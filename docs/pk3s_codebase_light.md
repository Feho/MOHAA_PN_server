# xyz_Airborne_Mod\global\AIR_aa_lib.scr

```scr
/*
======================================================
*** AIRborne; Anti-Aircraft Prefab Library for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------
======================================================
*/

/*
=============================================================
			NIGHTSKY THREAD
=============================================================
*/
goto_night local.fast:

	if (local.fast == NIL)
		local.fast = 0.001

	while(1)
	{
		local.fp_colour = $world.farplane_color

		if (local.fp_colour != ( 0.000 0.000 0.000 ) )
		{
			if (local.fp_colour[0] > 0.000)
				local.r = local.fp_colour[0] - local.fast
			else
				local.r = 0.000

			if (local.fp_colour[1] > 0.000)
				local.g = local.fp_colour[1] - local.fast
			else
				local.g = 0.000

			if (local.fp_colour[2] > 0.000)
				local.b = local.fp_colour[2] - local.fast
			else
				local.b = 0.000
		
			$world farplane_color ( local.r local.g local.b )
		}
		else
		{
			wait 1
		}

		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			if ($player[local.i].night_fastsk != 1)
			{
				$player[local.i] stufftext "set r_fastsky 1"
				$player[local.i].night_fastsk = 1
			}
		}

		waitframe
	}
end

/*
=============================================================
			AA Spot THREADS
=============================================================
*/
setup_spot local.origin local.end local.spot_scale local.numsegments local.alpha local.endalpha:

	if (local.spot_scale == NIL)
		local.spot_scale = 1

	// image that scale 50 equals scale 1
	local.scale = ( local.spot_scale * 50 )
	
	if (local.numsegments == NIL)
		local.numsegments = 40

	if (local.alpha == NIL)
		local.alpha = 0.6
	
	if (local.endalpha == NIL)
		local.endalpha = 0.4

	local.spotstart = spawn func_beam
	local.spotstart.origin = local.origin
	local.spotstart endpoint local.end
	local.spotstart alpha local.alpha
	local.spotstart endAlpha local.endalpha
	local.spotstart maxoffset 0
	local.spotstart numsegments local.numsegments
	local.spotstart scale local.scale
	local.spotstart color (1 1 1)
end local.spotstart

spot_behaviour_default local.time_on local.time_off:

	if (self == NULL)
		end

	while(1)
	{
		if (self.stop != 1)
		{
			self activate
		}
		self waitthread waittill_timeout_or_stop local.time_on
		self deactivate
		self waitthread waittill_timeout_or_stop local.time_off
		wait 1
	}
end

/*
=============================================================
			AA Explosion THREADS
=============================================================
*/
skyexplo local.array:

	for (local.i = 1; local.i <= local.array.size; local.i++)
	{
		local.skyexplo = spawn script_origin "targetname" local.array[local.i][2]
		local.skyexplo.origin = local.array[local.i][1]
		local.skyexplo notsolid
	}
end

skyexplo_default local.startdelay local.scale:

	if (self == NULL)
		end

	if (local.scale == NIL)
		local.scale = 2

	wait local.startdelay

	while(1)
	{
		wait (randomfloat(10) + 16)
		if (self.stop != 1)
		{
			self playsound arty_leadinmp
			wait 2
			self playsound air_exp
			exec global/model.scr self.origin "models/animate/fx_explosion_flak88.tik" local.scale
			radiusdamage (self.origin + (0 0 64)) 200 150
		}
	}
end

/*
=============================================================
			AA Fire THREADS
=============================================================
*/
/*
local.array = makeArray
( 240 -350 20 ) 
( 100 -50 0 )
( -1801 2560 -16 )
endArray
*/
add_projectile_targets local.array:

	if (local.array == NIL)
		end

	for (local.i = 1; local.i <= local.array.size; local.i++)
	{
		local.origin = local.array[local.i][1]

		local.targets[local.i] = spawn script_origin
		local.targets[local.i].origin = local.origin
		local.targets[local.i] notsolid
	}
end local.targets

set_burstfire local.mint local.maxt local.mind local.maxd:

	if (local.mint == NIL)
		local.mint = 1.0
	if (local.maxt == NIL)
		local.maxt = 4.5
	if (local.mind == NIL)
		local.mind = 0.2
	if (local.maxd == NIL)
		local.maxd = 0.8

	self burstfiresettings local.mint local.maxt local.mind local.maxd
end

create_projectilegen local.origin local.targetd local.startd local.firet local.setd local.endd:

	local.mg = spawn statweapons/mg42_gun.tik
	local.mg.origin = local.origin
	local.mg notsolid

	local.mg.targetdelay = local.targetd
	local.mg.startdelay = local.startd
	local.mg.firetime = local.firet
	local.mg.setdelay = local.setd
	local.mg.endtime = local.endd
end local.mg

projectilegen local.spots:

	if (self == NULL)
		end

	// Defaults
	local.targetdelay				= 3	//sec
	local.startdelay				= 10 	//sec
	local.firetime				= 7
	local.endtime				= 0	//sec
	local.setdelay				= 8	//sec

	if (self.targetdelay == NIL)
		self.targetdelay = local.targetdelay

	if (self.startdelay == NIL)
		self.startdelay = local.startdelay
	
	if (self.firetime == NIL)
		self.firetime = local.firetime
	
	if (self.endtime == NIL)
		self.endtime = local.endtime
	
	if (self.setdelay == NIL || self.setdelay == 0)	//avoids infinite loops
		self.setdelay = local.setdelay

	if (local.spots == NIL)
		{println "[ProjectileGen]: There are NO targets!!"
		end}


	waitframe
	waitframe

	self hide
	self notsolid
	self setPlayerUsable 0
	self bulletdamage 0

	wait self.startdelay

	local.set = 1
	while(1)
	{
		for (local.a=1;local.a <= local.spots.size && self.stop != 1;local.a++)
		{
			self setAimTarget local.spots[local.a]
			waitframe
			self startFiring
			self waitthread waittill_timeout_or_stop self.firetime
			self stopFiring
			self waitthread waittill_timeout_or_stop self.targetdelay
		}
		if (self.endtime != 0 && self.endtime != NIL && local.set == self.endtime)
		{
			self stopFiring
			self immediateremove	
			end
		}
		wait self.setdelay
		local.set++
	}
end

/*
=============================================================
			GLOBAL THREADS
=============================================================
*/
waittill_timeout_or_stop local.wait:

	local.time = 0
	while(local.time <= local.wait)
	{
		if (self.stop == 1)
			end

		local.time += 0.1
		wait 0.1
	}
end

/*
=============================================================
			SOUND THREADS
=============================================================
*/
soundz:

	local.master = spawn ScriptMaster
	local.master aliascache air_exp1 sound/weapons/explo/Explo_Bazooka1.wav soundparms 0.6 0.1 0.8 0.4 200 1100 "local" loaded maps "m dm moh obj train "
	local.master aliascache air_exp2 sound/weapons/explo/Explo_Bazooka2.wav soundparms 0.6 0.1 0.8 0.4 200 1100 "local" loaded maps "m dm moh obj train "
	local.master aliascache air_exp3 sound/weapons/explo/Explo_Bazooka3.wav soundparms 0.6 0.1 0.8 0.4 200 1100 "local" loaded maps "m dm moh obj train "
	local.master aliascache arty_leadinmp1 sound/weapons/explo/Exp_LeadIn_06.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
	local.master aliascache arty_leadinmp2 sound/weapons/explo/Exp_LeadIn_07.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
	local.master aliascache arty_leadinmp3 sound/weapons/explo/Exp_LeadIn_08.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
	local.master aliascache arty_leadinmp4 sound/weapons/explo/Exp_LeadIn_09.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
	local.master aliascache arty_leadinmp5 sound/weapons/explo/Exp_LeadIn_10.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
	local.master aliascache arty_leadinmp6 sound/weapons/explo/Exp_LeadIn_11.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
	local.master aliascache arty_leadinmp7 sound/weapons/explo/Exp_LeadIn_12.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
	local.master aliascache arty_leadinmp8 sound/weapons/explo/Exp_LeadIn_13.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
end
```

# xyz_Airborne_Mod\global\AIR_ammo.scr

```scr
/*
======================================================
*** AIRborne; Ammo Boxes for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------
--- INFO:

Models:
 	"models/items/item_rifle_ammobox.tik"
 	"models/items/item_mg_ammobox.tik"
 	"models/items/item_smg_ammobox.tik"
 	"models/items/item_grenade_ammobox.tik"
 	"models/items/item_heavy_ammobox.tik"
 	"models/items/item_pistol_ammobox.tik"

Execution:
 	local.array = makeArray
 	( X Y Z ) <weaponclass> <"model"> <amount> <respawntime>
 	endArray

 	exec global/AIR_ammo.scr local.array

-------------------
======================================================
*/
main local.ammo:

	if (local.ammo == NIL)
		end

	for (local.i = 1; local.i <= local.ammo.size; local.i++)
	{
		if (local.ammo[local.i].size != 5)
		{
			local.end = 1
		}
	}

	if (local.end == 1)
		end

	for (local.i = 1; local.i <= local.ammo.size; local.i++)
	{
		local.f[local.i] = spawn trigger_use 
		local.f[local.i].origin = local.ammo[local.i][1]
		local.f[local.i].box = spawn script_model model local.ammo[local.i][3]
		local.f[local.i].box.origin = local.f[local.i].origin
		local.f[local.i].box notsolid
		local.f[local.i] setsize ( -20 -20 -10 ) ( 20 20 10 )
		local.f[local.i].type = local.ammo[local.i][2]
		local.f[local.i].amount = local.ammo[local.i][4]
		local.f[local.i].respawn_time = local.ammo[local.i][5]
		local.f[local.i] wait 0.5
		local.f[local.i] setthread global/AIRborne_utils.scr::ammobox
	}
end
```

# xyz_Airborne_Mod\global\AIR_barbwire.scr

```scr
/*
======================================================
*** AIRborne; Global Barbwire Script for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------
======================================================
*/

// **************************************
// All you need to do is place barbwire models with the targetname $barbwire 
// and this script'll do the rest. Syntax:
//
// 		exec global/barbwire.scr::barbwire_setup <optional_hurt_value>
// **************************************
barbwire_setup local.hurt:

if ($barbwire == NIL || $barbwire == NULL)
{
	println "[BarbWire Script]: There are no barbwires in the map!!!"
	end
}
if (local.hurt == NIL)
	local.hurt = 5


while($barbwire != NIL || $barbwire != NULL)
{
	for ( local.f = 1; local.f <= $barbwire.size; local.f++ )
	{
		for(local.i=1;local.i<=$player.size;local.i++)
		{
			if ( $player[local.i] istouching $barbwire[local.f] == 1 )
			{
			$player[local.i] hurt local.hurt
			//println "Player is getting stinged by barbwire!"
			}
		}
	}
wait 1
}
end


// **************************************
// You can also use a different model with the $barbwire targetname.
// And you can also do it for 1 particular barbwire:
// 
//		$barbwire_targetname thread global/barbwire.scr::barbwire_single <optional_hurt_value>
// **************************************
barbwire_single local.hurt:

if (self == NIL || self == NULL)
{
	println "[BarbWire Script]: There is no barbwire in the map!"
	end
}

if (local.hurt == NIL)
	local.hurt = 5


while (self != NIL || self != NULL)
{
	for(local.i=1;local.i<=$player.size;local.i++)
	{
		if ( $player[local.i] istouching self == 1 )
		{
			$player[local.i] hurt local.hurt
			//println "Player is getting stinged by barbwire!"
		}
	}
wait 1
}
end


// **************************************
// Or 1 set of barbwires. Make sure the barbwire you want people to get hurt 
// have a #tag and targetname $barbwire: 
//
// 		exec global/barbwire.scr::barbwire_tags <"tag_value"> <optional_hurt_value>
// **************************************
barbwire_tags local.tag local.hurt:

if ($barbwire == NIL || $barbwire == NULL)
{
	println "[BarbWire Script]: There are no barbwires in the map!!!"
	end
}

if (local.tag == NIL || local.tag == "" )
{
	println "[Barbwire Script]: You MUST insert a tag value for the barbwire_tags thread!!"
	end
}


if (local.hurt == NIL)
	local.hurt = 5


while($barbwire != NIL || $barbwire != NULL)
{
	for ( local.f = 1; local.f <= $barbwire.size; local.f++ )
	{
		if ($barbwire[local.f].tag == local.tag)
		{
			for(local.i=1;local.i<=$player.size;local.i++)
			{
				if ( $player[local.i] istouching $barbwire[local.f] == 1 )
				{
					$player[local.i] hurt local.hurt
					//println "Player is getting stinged by barbwire!"
				}
			}
		}
	}
wait 1
}
end

```

# xyz_Airborne_Mod\global\AIR_clipping_lib.scr

```scr
/*
======================================================
*** AIRborne; Clipping Library for MoH:AA
======================================================
by Rindog (Modified & Bundled by Sor)
Version: v1.0
-----------------------------------
======================================================
*/

/*
==============================================================================
					LIBRARY INITIALIZATION
==============================================================================
*/
load_library:

	if (level.AIR_mapscript == NIL)
	{
		level.AIR_mapscript = waitexec global/strings.scr::to_lower (getcvar "mapname")
	}

	if(level.AIR_sb_library_loaded == 1)
	{
		println "[AIR Clip Library::Load]: The SpawnBlocks have already been loaded for this map!"
		end
	}

	switch(level.AIR_mapscript)
	{
		case "dm/mohdm1":
		case "dm/mohdm2":
		case "dm/mohdm3":
		case "dm/mohdm4":
		case "dm/mohdm5":
		case "dm/mohdm6":
		case "dm/mohdm7":
			local.map = waitthread get_mapname level.AIR_mapscript 3
			local.execute = ("clip_" + local.map)
		break
		case "obj/team1":
		case "obj/team2":
		case "obj/team3":
		case "obj/team4":
			local.map = waitthread get_mapname level.AIR_mapscript 4
			local.execute = ("clip_" + local.map)
		break
		case "m2l1":
		case "m4l0":
			local.map = level.AIR_mapscript
			local.execute = ("clip_" + local.map)
		break
		default:
			local.execute = "failure"
		break
	}

	local.load = waitthread local.execute

	if (local.load == "1")
	{
		waitthread enable_clips

		level.AIR_sb_library_loaded = 1
		println ("[AIR Clip Library::Load]: " + level.AIR_mapscript + "'s Clipping Library is successfully loaded!")
	}
	else
	{
		println ("[AIR Clip Library::Load]: An error has occured when loading this Clipping Library (" + level.AIR_mapscript + ")!")
	}

end

//=========================================================//
// Get Mapname
// -----------
// This helperthread is used to get the mapname
// without the folder prefix (eg: dm/ and obj/)
//
//=========================================================//
get_mapname local.name local.start:

	local.str = ""
	for (local.i = local.start; local.i < local.name.size; local.i++)
	{
		local.str += local.name[local.i]
	}

end local.str

failure:

	println "[AIR Clip Library::Load]: There isn't Clipping Library made yet for this map."

	local.fail = "0"

end local.fail

enable_clips:

	if (level.clip == NIL)
	{
		end
	}

	for (local.i = 1; local.i <= level.clip.size; local.i++)
	{
		level.clip[local.i] solid
		level.clip[local.i] nodamage
	}
end

disable_clips:

	if (level.clip == NIL)
	{
		end
	}

	for (local.i = 1; local.i <= level.clip.size; local.i++)
	{
		level.clip[local.i] notsolid
		level.clip[local.i] takedamage
	}

end

/*
==============================================================================
					SPAWNBLOCKER LIBRARY
==============================================================================
*/

clip_m2l1:


	level.clip[1] = spawn script_origin
	level.clip[1].origin = ( -3582.058 -624.326 1311.821 )
	level.clip[1] setsize ( -100 -200 -1600 ) ( 150 600 1000 )

	level.clip[2] = spawn script_origin
	level.clip[2].origin = ( -3414.011 -2055.133 1315.434 )
	level.clip[2] setsize ( -400 -400 -1600 ) ( 350 500 1000 )
 
	level.clip[3] = spawn script_origin
	level.clip[3].origin = ( -5015.759 -201.994 1288.256 )
	level.clip[3] setsize ( -1400 -300 -1600 ) ( 700 200 1000 )
 
	level.clip[4] = spawn script_origin
	level.clip[4].origin = ( -6904.262 -342.838 1406.032 )
	level.clip[4] setsize ( -200 -200 -1600 ) ( 500 200 1000 )
 
	level.clip[5] = spawn script_origin
	level.clip[5].origin = ( -7071.145 -1389.408 1089.221 )
	level.clip[5] setsize ( -600 -1800 -1600 ) ( 400 900 1000 )
 
	level.clip[6] = spawn script_origin
	level.clip[6].origin = ( -7134.296 -4432.615 977.659 )
	level.clip[6] setsize ( -550 -1800 -1600 ) ( 200 1400 1000 )
 
	level.clip[7] = spawn script_origin
	level.clip[7].origin = ( -4836.583 -6016.173 1402.236 )
	level.clip[7] setsize ( -2500 -800 -1600 ) ( 15000 800 1000 )
 
	level.clip[8] = spawn script_origin
	level.clip[8].origin = ( 8096.814 -3146.428 1599.350 )
	level.clip[8] setsize ( -800 -2200 -1600 ) ( 500 8100 1000 )
 
	level.clip[9] = spawn script_origin
	level.clip[9].origin = ( 6527.742 2838.087 795.339 )
	level.clip[9] setsize ( -825 -1670 -1600 ) ( 800 1250 1000 )
 
	level.clip[10] = spawn script_origin
	level.clip[10].origin = ( 5111.911 4897.256 1243.618 )
	level.clip[10] setsize ( -720 -800 -1600 ) ( 800 2700 1000 )
 
	level.clip[11] = spawn script_origin
	level.clip[11].origin = ( 3972.009 7134.234 985.869 )
	level.clip[11] setsize ( -380 -320 -400 ) ( 400 400 1000 )

	level.clip[12] = spawn script_origin
	level.clip[12].origin = ( -1766.838 5647.896 173.271 )
	level.clip[12] setsize ( -2000 -950 -1600 ) ( 1100 500 1000 )

	level.clip[13] = spawn script_origin
	level.clip[13].origin = ( -3910.912 4234.644 892.252 )
	level.clip[13] setsize ( -700 -850 -1600 ) ( 200 500 1000 )

	level.clip[14] = spawn script_origin
	level.clip[14].origin = ( -4223.814 2213.279 1271.029 )
	level.clip[14] setsize ( -300 -2000 -1600 ) ( 500 1300 1000 )

	level.clip[15] = spawn script_origin
	level.clip[15].origin = ( -3875.939 -385.249 1295.833 )
	level.clip[15] setsize ( -500 -500 -1600 ) ( 200 800 1000 )
 
	level.clip[16] = spawn script_origin
	level.clip[16].origin = ( -3553.437 -1169.850 1286.413 )
	level.clip[16] setsize ( -700 -500 -1600 ) ( 250 400 1000 )

	level.clip[17] = spawn script_origin
	level.clip[17].origin = ( 1530.674 5148.423 -16.888 )
	level.clip[17] setsize ( -2400 -550 -1600 ) ( 720 345 100 )

	level.clip[18] = spawn script_origin
	level.clip[18].origin = ( 3152.01 3558.89 590.76 ) 
	level.clip[18] setsize ( -30 -130 -1600 ) ( 30 30 400 )

	level.clip[19] = spawn script_origin
	level.clip[19].origin = ( 1792.940 -3933.547 722.345 )
	level.clip[19] setsize ( -1950 -250 -1600 ) ( 250 100 80 )
 
	level.clip[20] = spawn script_origin
	level.clip[20].origin = ( 6151.241 1068.254 649.416 )
	level.clip[20] setsize ( -190 -200 -1600 ) ( 350 300 1000 )

	local.load = "1"

end local.load


clip_m4l0:

	level.clip[1] = spawn script_origin
	level.clip[1].origin = ( 209.430 -5608.979 72.762 )
	level.clip[1] setsize ( -200 -200 -600 ) ( 200 200 100 )
 
	level.clip[2] = spawn script_origin
	level.clip[2].origin = ( -181.709 -5674.688 105.018 )
	level.clip[2] setsize ( -200 -100 -600 ) ( 200 100 100 )
 
	level.clip[3] = spawn script_origin
	level.clip[3].origin = ( 877.248 -5444.331 162.000 )
	level.clip[3] setsize ( -500 -200 -600 ) ( 200 100 100 )
 
	level.clip[4] = spawn script_origin
	level.clip[4].origin = ( 1749.977 -6078.780 175.184 )
	level.clip[4] setsize ( -500 -500 -600 ) ( 4800 100 200 )
 
	level.clip[5] = spawn script_origin
	level.clip[5].origin = ( 1294.244 -5650.369 106.775 )
	level.clip[5] setsize ( -300 -400 -600 ) ( 500 200 150 )
 
	level.clip[6] = spawn script_origin
	level.clip[6].origin = ( 2112.250 -5979.370 203.116 )
	level.clip[6] setsize ( -300 -200 -600 ) ( 200 100 150 )
 
	level.clip[7] = spawn script_origin
	level.clip[7].origin = ( 4790.444 2944.279 753.554 )
	level.clip[7] setsize ( -2000 -250 -600 ) ( 1800 100 200 )
 
	level.clip[8] = spawn script_origin
	level.clip[8].origin = ( -6110.160 -3138.398 339.057 )
	level.clip[8] setsize ( -100 -2300 -600 ) ( 100 2000 100 )
 
	level.clip[9] = spawn script_origin
	level.clip[9].origin = ( -5991.614 -2344.340 299.820 )
	level.clip[9] setsize ( -50 -1500 -600 ) ( 50 1000 100 )
 
	level.clip[10] = spawn script_origin
	level.clip[10].origin = ( -5896.960 -1451.976 200.354 )
	level.clip[10] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[11] = spawn script_origin
	level.clip[11].origin = ( -5803.128 -1283.466 201.911 )
	level.clip[11] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[12] = spawn script_origin
	level.clip[12].origin = ( -5619.226 -1120.161 234.033 )
	level.clip[12] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[13] = spawn script_origin
	level.clip[13].origin = ( -5727.858 -1188.235 185.555 )
	level.clip[13] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[14] = spawn script_origin
	level.clip[14].origin = ( -5832.033 -1361.134 249.120 )
	level.clip[14] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[15] = spawn script_origin
	level.clip[15].origin = ( -5425.065 -979.146 247.631 )
	level.clip[15] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[16] = spawn script_origin
	level.clip[16].origin = ( -5272.236 -1030.093 192.653 )
	level.clip[16] setsize ( -50 -50 -500 ) ( 50 50 100 )
 
	level.clip[17] = spawn script_origin
	level.clip[17].origin = ( -4164.031 -1407.976 226.382 )
	level.clip[17] setsize ( 0 -300 -500 ) ( 50 500 100 )
 
	level.clip[18] = spawn script_origin
	level.clip[18].origin = ( -4209.284 -1132.663 276.230 )
	level.clip[18] setsize ( -100 -50 -500 ) ( 50 50 100 )
 
	level.clip[19] = spawn script_origin
	level.clip[19].origin = ( -3438.287 -1564.000 388.993 )
	level.clip[19] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[20] = spawn script_origin
	level.clip[20].origin = ( -3256.144 -1378.829 398.290 )
	level.clip[20] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[21] = spawn script_origin
	level.clip[21].origin = ( -3136.196 -1285.274 524.548 )
	level.clip[21] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[22] = spawn script_origin
	level.clip[22].origin = ( -2994.523 -1143.734 520.844 )
	level.clip[22] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[23] = spawn script_origin
	level.clip[23].origin = ( -2796.414 -988.789 520.844 )
	level.clip[23] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[24] = spawn script_origin
	level.clip[24].origin = ( -2606.209 -887.218 520.844 )
	level.clip[24] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[25] = spawn script_origin
	level.clip[25].origin = ( -2414.413 -722.095 593.432 )
	level.clip[25] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[26] = spawn script_origin
	level.clip[26].origin = ( -2206.397 -576.486 593.432 )
	level.clip[26] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[27] = spawn script_origin
	level.clip[27].origin = ( -1875.474 -506.862 593.432 )
	level.clip[27] setsize ( -400 -250 -500 ) ( 500 100 100 )
 
	level.clip[28] = spawn script_origin
	level.clip[28].origin = ( -1170.994 -849.663 568.548 )
	level.clip[28] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[29] = spawn script_origin
	level.clip[29].origin = ( -981.599 -1019.641 568.548 )
	level.clip[29] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[30] = spawn script_origin
	level.clip[30].origin = ( -732.669 -1105.344 568.548 )
	level.clip[30] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[31] = spawn script_origin
	level.clip[31].origin = ( -489.801 -1217.897 568.548 )
	level.clip[31] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[32] = spawn script_origin
	level.clip[32].origin = ( -636.077 -1201.572 587.912 )
	level.clip[32] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[33] = spawn script_origin
	level.clip[33].origin = ( -374.059 -1392.707 676.243 )
	level.clip[33] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[34] = spawn script_origin
	level.clip[34].origin = ( -507.654 -1360.878 676.243 )
	level.clip[34] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[35] = spawn script_origin
	level.clip[35].origin = ( -242.150 -1637.830 616.582 )
	level.clip[35] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[36] = spawn script_origin
	level.clip[36].origin = ( -398.236 -1485.810 661.233 )
	level.clip[36] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[37] = spawn script_origin
	level.clip[37].origin = ( -1292.506 -693.251 496.216 )
	level.clip[37] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[38] = spawn script_origin
	level.clip[38].origin = ( -93.476 -1789.078 663.615 )
	level.clip[38] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[39] = spawn script_origin
	level.clip[39].origin = ( 61.230 -1948.717 676.570 )
	level.clip[39] setsize ( -100 -100 -500 ) ( 100 100 100 )
 
	level.clip[40] = spawn script_origin
	level.clip[40].origin = ( 149.645 -2933.336 611.402 )
	level.clip[40] setsize ( -100 -300 -800 ) ( 100 1000 100 )
 
	level.clip[41] = spawn script_origin
	level.clip[41].origin = ( 528.707 -3517.590 405.019 )
	level.clip[41] setsize ( -400 -450 -800 ) ( 500 500 0 )
 
	level.clip[42] = spawn script_origin
	level.clip[42].origin = ( 551.922 -3992.898 376.499 )
	level.clip[42] setsize ( -200 -50 -800 ) ( 200 50 100 )

	level.clip[43] = spawn script_origin
	level.clip[43].origin = ( -5735.508 -6304.886 51.504 )
	level.clip[43] setsize ( -100 -100 -200 ) ( 800 100 100 )
 
	level.clip[44] = spawn script_origin
	level.clip[44].origin = ( -6031.521 -6168.990 41.739 )
	level.clip[44] setsize ( -100 -200 -300 ) ( 200 300 100 )
 
	level.clip[45] = spawn script_origin
	level.clip[45].origin = ( -6278.473 -5761.178 17.365 )
	level.clip[45] setsize ( -100 -200 -300 ) ( 200 400 100 )

	level.clip[46] = spawn script_origin
	level.clip[46].origin = ( -5034.698 -5593.053 232.905 )
	level.clip[46] setsize ( -50 -600 -300 ) ( 50 1000 100 )
 
	level.clip[47] = spawn script_origin
	level.clip[47].origin = ( -4543.796 -4537.531 230.424 )
	level.clip[47] setsize ( -500 -50 -300 ) ( 400 50 100 )

	level.clip[48] = spawn script_origin
	level.clip[48].origin = ( -4022.958 -5479.355 257.325 )
	level.clip[48] setsize ( -50 -200 -300 ) ( 50 500 100 )
 
	level.clip[49] = spawn script_origin
	level.clip[49].origin = ( -4143.013 -4755.962 277.939 )
	level.clip[49] setsize ( -50 -200 -300 ) ( 100 200 100 )

	level.clip[50] = spawn script_origin
	level.clip[50].origin = ( 6600.417 -3166.769 1146.862 )
	level.clip[50] setsize ( -200 -3000 -1000 ) ( 100 6000 200 )
 
	level.clip[51] = spawn script_origin
	level.clip[51].origin = ( 6261.479 -284.989 795.625 )
	level.clip[51] setsize ( -500 -500 -600 ) ( 500 150 150 )
 
	level.clip[52] = spawn script_origin
	level.clip[52].origin = ( -3886.816 -6091.119 289.148 )
	level.clip[52] setsize ( -100 -800 -400 ) ( 50 400 100 )
 
	level.clip[53] = spawn script_origin
	level.clip[53].origin = ( -3801.010 -6302.915 250.802 )
	level.clip[53] setsize ( -50 -700 -400 ) ( 50 200 100 )
 
	level.clip[54] = spawn script_origin
	level.clip[54].origin = ( -3717.932 -6642.536 316.470 )
	level.clip[54] setsize ( -50 -400 -400 ) ( 50 200 100 )
 
	level.clip[55] = spawn script_origin
	level.clip[55].origin = ( -3208.383 -7377.196 235.780 )
	level.clip[55] setsize ( -500 -100 -400 ) ( 0 150 100 )
 
	level.clip[56] = spawn script_origin
	level.clip[56].origin = ( -3153.668 -7637.949 338.625 )
	level.clip[56] setsize ( -200 -100 -600 ) ( 800 150 100 )
 
	level.clip[57] = spawn script_origin
	level.clip[57].origin = ( -2933.435 -7328.668 77.601 )
	level.clip[57] setsize ( -300 -100 -600 ) ( 100 100 100 )

	level.clip[58] = spawn script_origin
	level.clip[58].origin = ( -3250.870 -7181.744 10.404 )
	level.clip[58] setsize ( -100 -100 -600 ) ( 200 50 100 )
 
	level.clip[59] = spawn script_origin
	level.clip[59].origin = ( -3256.439 -7098.428 60.061 )
	level.clip[59] setsize ( -100 -100 -600 ) ( 100 50 100 )
 
	level.clip[60] = spawn script_origin
	level.clip[60].origin = ( -1718.081 -7566.030 63.747 )
	level.clip[60] setsize ( -800 -100 -600 ) ( 1200 100 100 )
 
	level.clip[61] = spawn script_origin
	level.clip[61].origin = ( -403.755 -6884.892 285.878 )
	level.clip[61] setsize ( -50 -800 -600 ) ( 100 1200 100 )
 
	level.clip[62] = spawn script_origin
	level.clip[62].origin = ( -523.071 -7332.068 176.123 )
	level.clip[62] setsize ( -50 -150 -600 ) ( 100 150 100 )

	level.clip[63] = spawn script_origin
	level.clip[63].origin = ( -399.572 -6744.218 24.173 )
	level.clip[63] setsize ( 0 -400 -600 ) ( 50 1100 100 )
 
	level.clip[64] = spawn script_origin
	level.clip[64].origin = ( -495.510 -7275.749 94.706 )
	level.clip[64] setsize ( -50 -300 -600 ) ( 50 300 100 )
 
	level.clip[65] = spawn script_origin
	level.clip[65].origin = ( -566.126 -7429.731 141.714 )
	level.clip[65] setsize ( -30 -100 -600 ) ( 100 50 100 )

	level.clip[66] = spawn script_origin
	level.clip[66].origin = ( 1026.351 -2057.594 433.414 )
	level.clip[66] setsize ( -50 -1000 -600 ) ( 50 1500 100 )
 
	level.clip[67] = spawn script_origin
	level.clip[67].origin = ( 945.655 -370.511 576.192 )
	level.clip[67] setsize ( -50 -200 -600 ) ( 50 200 100 )
 
	level.clip[68] = spawn script_origin
	level.clip[68].origin = ( 751.677 149.713 540.931 )
	level.clip[68] setsize ( -50 -200 -600 ) ( 50 100 100 )
 
	level.clip[69] = spawn script_origin
	level.clip[69].origin = ( 831.096 -83.666 544.460 )
	level.clip[69] setsize ( -50 -200 -600 ) ( 50 100 100 )
 
	level.clip[70] = spawn script_origin
	level.clip[70].origin = ( 570.808 441.513 454.616 )
	level.clip[70] setsize ( -300 -200 -600 ) ( 100 50 100 )
 
	level.clip[71] = spawn script_origin
	level.clip[71].origin = ( 703.941 313.041 549.471 )
	level.clip[71] setsize ( -50 -50 -600 ) ( 50 50 100 )
 
	level.clip[72] = spawn script_origin
	level.clip[72].origin = ( 441.261 576.735 628.615 )
	level.clip[72] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[73] = spawn script_origin
	level.clip[73].origin = ( -31.950 738.557 561.886 )
	level.clip[73] setsize ( -250 -100 -600 ) ( 420 100 100 )
 
	level.clip[74] = spawn script_origin
	level.clip[74].origin = ( 571.597 554.402 514.134 )
	level.clip[74] setsize ( -50 -50 -600 ) ( 50 50 100 )
 
	level.clip[75] = spawn script_origin
	level.clip[75].origin = ( 39.425 881.935 629.408 )
	level.clip[75] setsize ( -150 -20 -600 ) ( 100 20 100 )
 
	level.clip[76] = spawn script_origin
	level.clip[76].origin = ( -389.073 691.638 531.953 )
	level.clip[76] setsize ( -50 -50 -600 ) ( 50 50 100 )
 
	level.clip[77] = spawn script_origin
	level.clip[77].origin = ( -502.536 574.544 440.229 )
	level.clip[77] setsize ( -50 -50 -600 ) ( 50 50 100 )
 
	level.clip[78] = spawn script_origin
	level.clip[78].origin = ( -895.872 657.062 268.595 )
	level.clip[78] setsize ( -300 -50 -600 ) ( 350 50 100 )
 
	level.clip[79] = spawn script_origin
	level.clip[79].origin = ( -5308.132 3381.947 188.334 )
	level.clip[79] setsize ( -50 -2000 -600 ) ( 120 2500 100 )
 
	level.clip[80] = spawn script_origin
	level.clip[80].origin = ( -5183.612 5426.396 125.313 )
	level.clip[80] setsize ( -50 -200 -600 ) ( 30 500 100 )
 
	level.clip[81] = spawn script_origin
	level.clip[81].origin = ( -1401.472 7327.912 209.350 )
	level.clip[81] setsize ( -50 -200 -600 ) ( 30 300 100 )
 
	level.clip[82] = spawn script_origin
	level.clip[82].origin = ( 670.761 4627.086 208.716 )
	level.clip[82] setsize ( -80 -1000 -600 ) ( 30 1100 100 )
 
	level.clip[83] = spawn script_origin
	level.clip[83].origin = ( -3258.043 1253.427 453.836 )
	level.clip[83] setsize ( -200 -50 -600 ) ( 750 50 100 )
 
	level.clip[84] = spawn script_origin
	level.clip[84].origin = ( -547.025 7142.214 318.343 )
	level.clip[84] setsize ( -50 -100 -600 ) ( 50 200 100 )

	level.clip[85] = spawn script_origin
	level.clip[85].origin = ( -1419.349 701.863 397.559 )
	level.clip[85] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[86] = spawn script_origin
	level.clip[86].origin = ( -1258.550 655.629 325.525 )
	level.clip[86] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[87] = spawn script_origin
	level.clip[87].origin = ( -1640.654 829.313 397.618 )
	level.clip[87] setsize ( -100 -100 -600 ) ( 100 60 100 )
 
	level.clip[88] = spawn script_origin
	level.clip[88].origin = ( -1913.282 934.938 495.690 )
	level.clip[88] setsize ( -100 -100 -600 ) ( 100 60 100 )
 
	level.clip[89] = spawn script_origin
	level.clip[89].origin = ( -2075.350 974.010 445.379 )
	level.clip[89] setsize ( -100 -100 -600 ) ( 100 60 100 )
 
	level.clip[90] = spawn script_origin
	level.clip[90].origin = ( -2277.372 1118.879 421.974 )
	level.clip[90] setsize ( -100 -100 -600 ) ( 100 60 100 )
 
	level.clip[91] = spawn script_origin
	level.clip[91].origin = ( -2134.363 1001.237 633.261 )
	level.clip[91] setsize ( -100 -100 -600 ) ( 100 60 100 )
 
	level.clip[92] = spawn script_origin
	level.clip[92].origin = ( -2450.242 1200.362 420.540 )
	level.clip[92] setsize ( -100 -100 -600 ) ( 100 60 100 )
 
	level.clip[93] = spawn script_origin
	level.clip[93].origin = ( -3594.434 1124.458 432.354 )
	level.clip[93] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[94] = spawn script_origin
	level.clip[94].origin = ( -3829.037 1078.604 509.757 )
	level.clip[94] setsize ( -100 -100 -600 ) ( 100 100 100 )

	level.clip[95] = spawn script_origin
	level.clip[95].origin = ( -4083.936 1055.161 462.858 )
	level.clip[95] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[96] = spawn script_origin
	level.clip[96].origin = ( -4294.938 1113.414 231.415 )
	level.clip[96] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[97] = spawn script_origin
	level.clip[97].origin = ( -4595.708 1166.811 209.496 )
	level.clip[97] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[98] = spawn script_origin
	level.clip[98].origin = ( -4399.319 1105.354 330.541 )
	level.clip[98] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[99] = spawn script_origin
	level.clip[99].origin = ( -4866.405 1369.460 239.193 )
	level.clip[99] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[100] = spawn script_origin
	level.clip[100].origin = ( -4730.062 1234.968 345.644 )
	level.clip[100] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[101] = spawn script_origin
	level.clip[101].origin = ( -5065.243 1599.407 450.188 )
	level.clip[101] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[102] = spawn script_origin
	level.clip[102].origin = ( -5063.204 6087.329 147.141 )
	level.clip[102] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[103] = spawn script_origin
	level.clip[103].origin = ( -5113.839 5901.521 236.801 )
	level.clip[103] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[104] = spawn script_origin
	level.clip[104].origin = ( -4820.318 6261.522 81.761 )
	level.clip[104] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[105] = spawn script_origin
	level.clip[105].origin = ( -4604.143 6382.255 81.761 )
	level.clip[105] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[106] = spawn script_origin
	level.clip[106].origin = ( -3283.021 6702.546 167.697 )
	level.clip[106] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[107] = spawn script_origin
	level.clip[107].origin = ( -3120.171 6701.873 167.697 )
	level.clip[107] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[108] = spawn script_origin
	level.clip[108].origin = ( -2924.132 6828.392 195.609 )
	level.clip[108] setsize ( -100 -100 -600 ) ( 100 100 100 )

	level.clip[109] = spawn script_origin
	level.clip[109].origin = ( -2805.843 6914.901 195.609 )
	level.clip[109] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[110] = spawn script_origin
	level.clip[110].origin = ( -2650.232 7019.757 195.609 )
	level.clip[110] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[111] = spawn script_origin
	level.clip[111].origin = ( -2395.789 7251.070 195.609 )
	level.clip[111] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[112] = spawn script_origin
	level.clip[112].origin = ( -2551.936 7149.940 195.609 )
	level.clip[112] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[113] = spawn script_origin
	level.clip[113].origin = ( -2163.236 7297.493 207.578 )
	level.clip[113] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[114] = spawn script_origin
	level.clip[114].origin = ( -1841.779 7389.645 215.372 )
	level.clip[114] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[115] = spawn script_origin
	level.clip[115].origin = ( -2005.179 7376.388 244.245 )
	level.clip[115] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[116] = spawn script_origin
	level.clip[116].origin = ( -1705.883 7397.991 272.653 )
	level.clip[116] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[117] = spawn script_origin
	level.clip[117].origin = ( -1492.429 7377.382 272.653 )
	level.clip[117] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[118] = spawn script_origin
	level.clip[118].origin = ( -388.071 7189.966 362.255 )
	level.clip[118] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[119] = spawn script_origin
	level.clip[119].origin = ( -128.132 7064.916 338.272 )
	level.clip[119] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[120] = spawn script_origin
	level.clip[120].origin = ( 242.152 6729.291 338.272 )
	level.clip[120] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[121] = spawn script_origin
	level.clip[121].origin = ( 95.361 6924.863 338.272 )
	level.clip[121] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[122] = spawn script_origin
	level.clip[122].origin = ( 148.291 6859.473 364.898 )
	level.clip[122] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[123] = spawn script_origin
	level.clip[123].origin = ( 326.004 6524.461 332.118 )
	level.clip[123] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[124] = spawn script_origin
	level.clip[124].origin = ( 449.178 6361.322 284.014 )
	level.clip[124] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[125] = spawn script_origin
	level.clip[125].origin = ( 374.367 6449.610 480.309 )
	level.clip[125] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[126] = spawn script_origin
	level.clip[126].origin = ( 522.102 6117.936 544.461 )
	level.clip[126] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[127] = spawn script_origin
	level.clip[127].origin = ( 580.246 5890.124 358.724 )
	level.clip[127] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[128] = spawn script_origin
	level.clip[128].origin = ( 605.606 3476.152 367.554 )
	level.clip[128] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[129] = spawn script_origin
	level.clip[129].origin = ( 367.515 3196.226 367.554 )
	level.clip[129] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[130] = spawn script_origin
	level.clip[130].origin = ( 474.919 3336.552 431.048 )
	level.clip[130] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[131] = spawn script_origin
	level.clip[131].origin = ( 238.250 2976.241 451.779 )
	level.clip[131] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[132] = spawn script_origin
	level.clip[132].origin = ( 156.445 2765.566 451.779 )
	level.clip[132] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[133] = spawn script_origin
	level.clip[133].origin = ( 155.997 2524.754 509.226 )
	level.clip[133] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[134] = spawn script_origin
	level.clip[134].origin = ( 303.179 2323.070 509.226 )
	level.clip[134] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[135] = spawn script_origin
	level.clip[135].origin = ( 399.667 2227.582 509.226 )
	level.clip[135] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[136] = spawn script_origin
	level.clip[136].origin = ( 638.863 2116.710 509.226 )
	level.clip[136] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[137] = spawn script_origin
	level.clip[137].origin = ( 843.747 2025.777 521.173 )
	level.clip[137] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[138] = spawn script_origin
	level.clip[138].origin = ( 1160.592 1994.179 521.173 )
	level.clip[138] setsize ( -200 -50 -600 ) ( 350 100 100 )
 
	level.clip[139] = spawn script_origin
	level.clip[139].origin = ( 1650.401 2101.068 610.214 )
	level.clip[139] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[140] = spawn script_origin
	level.clip[140].origin = ( 1940.737 2299.566 517.439 )
	level.clip[140] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[141] = spawn script_origin
	level.clip[141].origin = ( 1768.716 2200.957 667.468 )
	level.clip[141] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[142] = spawn script_origin
	level.clip[142].origin = ( 2227.972 2383.832 694.940 )
	level.clip[142] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[143] = spawn script_origin
	level.clip[143].origin = ( 2449.589 2486.209 694.940 )
	level.clip[143] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[144] = spawn script_origin
	level.clip[144].origin = ( 2620.760 2570.404 694.940 )
	level.clip[144] setsize ( -100 -100 -600 ) ( 100 100 100 )
 
	level.clip[145] = spawn script_origin
	level.clip[145].origin = ( 2838.664 2694.598 694.940 )
	level.clip[145] setsize ( -100 -100 -600 ) ( 100 100 100 )

	local.load = "1"

end local.load

```

# xyz_Airborne_Mod\global\AIR_gold.scr

```scr
/*
======================================================
*** AIRborne; Gold Perks for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------
======================================================
*/


//*********************************************************************
// Spawn Treasure mode Gold
// --------------------------
// local.info is an array and you can make 
// as many entries as you want.:
// 
// 	local.info = makeArray
// 	( origin1 ) ( angles1 ) "bonus1" //1 row for 1 goldbox
//
//  	endArray
//
// Then exec this thread with the local.info
// array:
//
//	thread global/AIR_gold.scr::treasure_spawn local.info
//
//*********************************************************************
treasure_spawn local.info:

	if (local.info == NIL)
		end

	if (level.AIR_goldcache != 1)
		thread soundcache

	//first check/parse some things...
	for (local.i = 1; local.i <= local.info.size; local.i++)
	{
		if (local.info[local.i][1] == NIL)
		{
			local.terminate = 1
			break
		}

		if (local.info[local.i][2] == NIL)
			local.info[local.i][2] = ( 0 0 0 )

		if (local.info[local.i][3] == NIL)
			local.info[local.i][3] = "health"
	}
	
	if (local.terminate == 1)
	{
		println "[AIR Gold::ERROR]: An error occurred when parsing the origin values of your array!!"
		end
	}

	// okay, now start spawning:
	for (local.a = 1; local.a <= local.info.size; local.a++)
	{
		if (level.AIR_goldboxs == NIL)
			local.f = 1
		else	
			local.f = ( level.AIR_goldboxs.size + 1 )

		level.AIR_goldboxs[local.f] = spawn trigger_use
		level.AIR_goldboxs[local.f].origin = local.info[local.a][1]
		level.AIR_goldboxs[local.f].bonus = local.info[local.a][3]
		level.AIR_goldboxs[local.f] setsize ( -35 -35 -20 ) ( 35 35 40 )
		level.AIR_goldboxs[local.f] setthread global/AIR_gold.scr::treasure_tr

		level.AIR_goldboxs[local.f].gold = spawn script_model model "static/corona_orange.tik" 
		level.AIR_goldboxs[local.f].gold.origin = local.info[local.a][1]
		level.AIR_goldboxs[local.f].gold.angles = local.info[local.a][2]
		level.AIR_goldboxs[local.f].gold rendereffects "+viewlensflare"
		level.AIR_goldboxs[local.f].gold light 0.9 0.7 0.0 0
		level.AIR_goldboxs[local.f].gold notsolid
		level.AIR_goldboxs[local.f].gold scale 0.4

		//level.AIR_goldboxs[local.f].gold thread blinky
		
	}

	level.AIR_maxgold = local.f

end

//*********************************************************************
// Treasure Gold - Setthread
// -------------------------
// This is the setthread of the trigger spawned in Treasure mode.
// Available bonusses are:
//
//	"health"	-	Gives 100 Health to the Finder
//	"ammo"	- 	Gives an amount of ammo to the weapon the 
//				Finder is currently holding
//	"armor"	-	Gives 80 armor to the Finder
//	"grenade"	-	Gives 6 grenades to the Finder
//	"weapon"	-	Gives a random weapon to the player (no
//				noob-weapons will be given ;) )
// 	"allweapon" - 	Gives player all weapons (except the noobies)
// 	"zooka"	- 	Gives player the bazooka
// 	"shotgun"	- 	Gives player the shotgun
//
//*********************************************************************
treasure_tr:

	local.p = parm.other

	local.p playsound pickup_explosives 
	self.gold rendereffects "-viewlensflare"
	self.gold remove

	self nottriggerable

	switch (self.bonus)
	{
		case "health":
			local.health_added = 100
			local.current_health = local.p.health
			local.health = local.current_health + local.health_added

			wait 0.1
			local.p healthonly local.health
			local.p playsound med_canteen
			local.p iprint "You've received 100 Health!" 1
		break
		case "ammo":
			// if my states aren't recording anything (meaning someone else is using my script)
			// then get the weapon the old fashion way ;)
			if (local.p.current_weapon == NIL && local.p.current_weaponclass == NIL && local.p.current_weapon_model == NIL)
			{
				local.p weaponcommand dual targetname ("w" + local.p.entnum)
				local.weapon = $("w" + local.p.entnum )

				if(local.weapon != NULL)
				{
					local.p.wpn = local.weapon.model
					local.weapon targetname ""
				}
				else
				{
					local.p.wpn = "models/weapons/unarmed.tik"
				}
				waitframe
				local.class = waitthread get_wpnclass local.p.wpn
			}
			else
			{
				local.class = local.p.current_weaponclass			
			}
			// aren't statefiles easy? :P
			if (local.class != none && local.class == grenade)
			{
				local.p ammo local.class 6
				local.p iprint "You got 6 more grenades!" 1
			}
			else if (local.class != none && local.class == heavy)
			{
				local.p ammo local.class 6
				local.p iprint "You received 6 heavy rounds" 1
			}
			else if (local.class != none && local.class == shotgun)
			{
				local.p ammo local.class 30
				local.p iprint "You received 30 shotgun rounds" 1
			}
			else if (local.class != none)
			{
				local.p ammo local.class 100
				local.p iprint "Your current weapon received 100 bullets!" 1
			}
		break
		case "armor":
			local.armor_added = 80
			local.current_health = local.p.health
			local.armor = local.current_health + local.armor_added

			wait 0.5
			local.p health local.armor
			local.p iprint "You've received 80 extra Armor!" 1
		break
		case "grenade":
			local.p ammo grenade 6
			local.p iprint "You got 6 more grenades!" 1
		break
		case "weapon":
			local.weapon = waitthread global/AIR_gold.scr::random_weapon
			local.picky = randomint(local.weapon.size)
			if (local.picky == 0)
				local.picky++

			local.p item local.weapon[local.picky][1]
			local.p iprint ("You have received the " + local.weapon[local.picky][2]) 1
		break
		case "allweapon":
			local.p item "models/weapons/m1_garand.tik"
			local.p item "models/weapons/kar98.tik"
			local.p item "models/weapons/kar98sniper.tik"
			local.p item "models/weapons/springfield.tik"
			local.p item "models/weapons/bar.tik"
			local.p item "models/weapons/mp44.tik"
			local.p item "models/weapons/thompsonsmg.tik"
			local.p item "models/weapons/mp40.tik"
			if (local.p.dmteam == "axis")
			{
				local.p item "models/weapons/colt45.tik"
			}
			local.p item "models/weapons/silencedpistol.tik"
			if (local.p.dmteam == "allies")
			{
				local.p item "models/weapons/p38.tik"
			}

			local.p iprint ("You have received All Weapons!!") 1
		break
		case "zooka":
			if (local.p.dmteam == "allies")
			{
				local.p item "models/weapons/bazooka.tik"
			}
			else
			{
				local.p item "models/weapons/panzerschreck.tik"
			}
			local.p ammo heavy 6
			local.p iprint ("You have received a Bazooka!!") 1
		break
		case "shotgun":
			local.p item "models/weapons/shotgun.tik"
			local.p ammo shotgun 30
			local.p iprint ("You have received a Shotgun!!") 1
		break
	}

	self remove
	thread global/AIR_gold.scr::treasure_changes

end

get_wpnclass local.wpn_model:

	switch(local.wpn_model)
	{
		case "models/weapons/m1_garand.tik":
		case "models/weapons/kar98.tik":
		case "models/weapons/kar98sniper.tik":
		case "models/weapons/springfield.tik":
			local.result = rifle
		break
		case "models/weapons/bar.tik":
		case "models/weapons/mp44.tik":
			local.result = mg
		break
		case "models/weapons/thompsonsmg.tik":
		case "models/weapons/mp40.tik":
			local.result = smg
		break
		case "models/weapons/bazooka.tik":
		case "models/weapons/panzerschreck.tik":
			local.result = heavy
		break
		case "models/weapons/shotgun.tik":
			local.result = shotgun
		break
		case "models/weapons/m2frag_grenade.tik":
		case "models/weapons/steilhandgranate.tik":
			local.result = grenade
		break
		case "models/weapons/colt45.tik":
		case "models/weapons/silencedpistol.tik":
		case "models/weapons/p38.tik":
			local.result = pistol
		break
		default:
			local.result = none
		break
	}

end local.result

treasure_changes:

	level.AIR_maxgold--

	if (level.AIR_maxgold == 0)
	{
		println "SECRET: All secret Gold Treasures have been found!!"
		iprintlnbold_noloc "SECRET: All secret Gold Treasures have been found!!"
	}

end

random_weapon:

	local.random_weapon = makeArray

		//model						//weapon name
		"models/weapons/m1_garand.tik"		"M1 Garand"
		"models/weapons/kar98.tik"			"Mauser KAR98 Rifle"
		"models/weapons/kar98sniper.tik"		"KAR98 Sniper Rifle"
		"models/weapons/springfield.tik"		"Springfield '03 Sniper Rifle"
		"models/weapons/bar.tik"			"BAR"
		"models/weapons/mp44.tik"			"StG44"
		"models/weapons/thompsonsmg.tik"		"Thompson SMG"
		"models/weapons/mp40.tik"			"MP40"
		"models/weapons/colt45.tik"			"Colt 45"
		"models/weapons/silencedpistol.tik"		"Silenced Pistol"
		"models/weapons/p38.tik"			"P38"

	endArray

end local.random_weapon

soundcache:

	local.master = spawn ScriptMaster
	local.master aliascache pickup_explosives1 sound/items/Item_BangaloreAssemble_01.wav soundparms 1.2 0.0 1.0 0.0 100 2000 item loaded maps "m dm obj train "
	local.master aliascache pickup_explosives2 sound/items/Item_BangaloreAssemble_02.wav soundparms 1.2 0.0 1.0 0.0 100 2000 item loaded maps "m dm obj train "
	local.master aliascache pickup_explosives3 sound/items/Item_BangaloreAssemble_03.wav soundparms 1.2 0.0 1.0 0.0 100 2000 item loaded maps "m dm obj train "

	level.AIR_goldcache = 1

end
```

# xyz_Airborne_Mod\global\AIR_library.scr

```scr
/*
======================================================
*** AIRborne; Map Location Library for MoH:AA
======================================================
by Sor
Version: v1.3.00
-----------------------------------
======================================================
*/

// TODO: team1, team2, team3 and team4/mohdm4
load_library:

	if (level.AIR_mapscript == NIL)
	{
		level.AIR_mapscript = waitexec global/strings.scr::to_lower (getcvar "mapname")
	}

	if(level.AIR_library_loaded == 1)
	{
		println "[AIR Library::Load]: A library has already been loaded for this map!"
		end
	}

	switch(level.AIR_mapscript)
	{
		case "dm/mohdm1":
		case "dm/mohdm2":
		case "dm/mohdm3":
		case "dm/mohdm4":
		case "dm/mohdm5":
		case "dm/mohdm6":
		case "dm/mohdm7":
			local.map = waitthread get_mapname level.AIR_mapscript 3
			local.execute = (local.map + "_lib")
		break
		case "obj/team1":
		case "obj/team2":
		case "obj/team3":
		case "obj/team4":
			local.map = waitthread get_mapname level.AIR_mapscript 4
			local.execute = (local.map + "_lib")
		break
		break
		case "m2l1":
		case "m2l3":
		case "m4l0":
		case "m4l3":
		case "m5l1b":
		case "m6l2a":
			local.map = level.AIR_mapscript
			local.execute = (local.map + "_lib")
		break
		default:
			local.execute = "failure"
		break
	}

	local.load = waitthread local.execute

	if (local.load == "1")
	{
		level.AIR_library_loaded = 1
		println ("[AIR Library::Load]: " + level.AIR_mapscript + "'s Map Location Library is successfully loaded!")
	}
	else
	{
		println ("[AIR Library::Load]: An error has popped up when loading this library (" + level.AIR_mapscript + ")!")
	}
end

//=========================================================//
// Get Mapname
// -----------
// This helperthread is used to get the mapname
// without the folder prefix (eg: dm/ and obj/)
//
//=========================================================//
get_mapname local.name local.start:

	local.str = ""
	for (local.i = local.start; local.i < local.name.size; local.i++)
	{
		local.str += local.name[local.i]
	}

end local.str

//=========================================================//
// Find player position
// ---------------------
// This script finds the place the given origin is at,
// according to the info_landmark method we recorded
// the places.
//
// local.origin = ( X Y Z ) Origin of player or object
//
//=========================================================//
findplayer local.origin local.abbr:

	if (level.AIR_library_loaded != 1)
		end

	//
	// Compare all landmarks with eachother and give the 
	// a score to each landmark. The landmark with the highest score
	// is most likely the location the player is at.
	// 
	for(local.i = 1; local.i <= level.AIR_landmark.size; local.i++)
	{
		local.landmarkscore[local.i] = 0

		for(local.n = level.AIR_landmark.size; local.n != 0; local.n--)
		{
			if(local.i != local.n)
				local.result = vector_closer level.AIR_landmark[local.i][1] level.AIR_landmark[local.n][1] local.origin
			else 
				local.result = 0

			if(local.result == 1)
				local.landmarkscore[local.i]++
		}
		wait 0.001
	}

	//
	// Now find to what landmark the highest landmarkscore belongs to.
	// I'm also doing this for the second highest score to resolve 
	// problems of returning NIL values because of the steps and stairs
	//
	local.shighest = 0
	local.highest = 0

	for (local.f = 1; local.f <= local.landmarkscore.size; local.f++)
	{
		if (local.highest < local.landmarkscore[local.f])
		{
			local.highest = local.landmarkscore[local.f]
			local.hi = local.f
		}
		
		if (local.shighest < local.landmarkscore[local.f] && local.landmarkscore[local.f] < local.highest)
		{
			local.shighest = local.landmarkscore[local.f]
			local.shi = local.f
		}

	}

	// Check if the player's origin is between the highest and lowest points of 
	// the landmark with the highest score. 
	if(local.origin[2] >= level.AIR_landmark[local.hi][3][1] && local.origin[2] <= level.AIR_landmark[local.hi][3][2])
	{
		local.p = local.hi
	}
	// If false, then he's on stairs so the landmark with the second highest score 
	// is the one he's at!
	else if (local.origin[2] >= level.AIR_landmark[local.shi][3][1] && local.origin[2] <= level.AIR_landmark[local.shi][3][2])
	{
		local.p = local.shi
	}
	// Rarely the case, probably a nasty stairway or the user didn't place his landmarks right,
	// or the player's out of bounds...
	else 
	{
		local.p = local.hi
	}

	if (level.AIR_landmark[local.p][2].size == 2)
	{
		if (local.abbr == 1)
			end level.AIR_landmark[local.p][2][2]
		else
			end level.AIR_landmark[local.p][2][1]
	}
	else
	{
		if (local.abbr == 1)
			end (waitthread get_abbr level.AIR_landmark[local.p][2])
		else
			end level.AIR_landmark[local.p][2]
	}
end

//=============================================
get_abbr local.string:
//=============================================

	local.split = waitthread global/strings.scr::split_line local.string 1 " "

	local.abbr = ""
	
	for (local.i = 1; local.i <= local.split[1].size; local.i++)
	{
		local.tempst = local.split[1][local.i]
		local.add = waitthread abbr_chooser local.tempst
		local.abbr += local.add
	}
end local.abbr

//=============================================
abbr_chooser local.tempst:

	if (local.tempst == "Flr" || local.tempst == "flr" || local.tempst == "Floor" || local.tempst == "floor" ||
		local.tempst == "The" || local.tempst == "the" || local.tempst == "Bldg" || local.tempst == "bldg" ||
		local.tempst == "Building" || local.tempst == "building" || local.tempst == "House" || local.tempst == "house" ||
		local.tempst == "Hs" || local.tempst == "hs" || local.tempst == "Room" || local.tempst == "room" ||
		local.tempst == "Rm" || local.tempst == "rm" || local.tempst == "Grand" || local.tempst == "grand")
	{
			local.result = ""
	}
	else if (local.tempst == "Grnd" || local.tempst == "grnd" || local.tempst == "Ground" || local.tempst == "ground")
	{
		local.result = "0"
	}
	else if (local.tempst == "1st" || local.tempst == "First" || local.tempst == "first")
	{
		local.result = "1"
	}
	else if (local.tempst == "2nd" || local.tempst == "Second" || local.tempst == "second")
	{
		local.result = "2"
	}
	else if (local.tempst == "3rd" || local.tempst == "Third" || local.tempst == "third")
	{
		local.result = "3"
	}
	else if (local.tempst == "4th" || local.tempst == "Fourth" || local.tempst == "fourth")
	{
		local.result = "4"
	}
	else if (local.tempst == "Northeast" || local.tempst == "Northeastern" || local.tempst == "northeast" ||
			local.tempst == "northeastern" || local.tempst == "NorthEast" || local.tempst == "NorthEastern")
	{
		local.result = "NE"
	}
	else if (local.tempst == "Southeast" || local.tempst == "Southeastern" || local.tempst == "southeast" ||
			local.tempst == "southeastern" || local.tempst == "SouthEast" || local.tempst == "SouthEastern")
	{
		local.result = "SE"
	}
	else if (local.tempst == "Southwest" || local.tempst == "Southwestern" || local.tempst == "southwest" ||
			local.tempst == "southwestern" || local.tempst == "SouthWest" || local.tempst == "SouthWestern")
	{
		local.result = "SW"
	}
	else if (local.tempst == "Northwest" || local.tempst == "Northwestern" || local.tempst == "northwest" ||
			local.tempst == "northwestern" || local.tempst == "NorthWest" || local.tempst == "NorthWestern")
	{
		local.result = "SW"
	}
	else
	{
		local.result = (waitthread global/strings.scr::to_upper local.tempst)[0]
	}
end local.result

//=============================================
failure:
//=============================================

	println "[AIR Library::Load]: There isn't a Map Location Library made yet for this map."

	local.fail = "0"

end local.fail

//=============================================
library_testtool local.abbr:
//=============================================

	waitthread load_library

	if (local.abbr == NIL)
		local.abbr = 0

	while(1)
	{
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			if ($player[local.i].status == "alive")
			{
				println (waitthread findplayer $player[local.i].origin local.abbr)
				wait 2
			}
		}

		wait 0.5
	}

end

//=============================================
show_records:
//=============================================

	waitthread load_library

	for (local.i = 1; local.i <= level.AIR_landmark.size; local.i++)
	{
		local.show = spawn script_model model "static/corona_reg.tik" "origin" level.AIR_landmark[local.i][1]
		local.show notsolid
	}
end

//=============================================
mohdm1_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin			//Name						// Z Min and Z Max
 	( 632 -580 218 ) 		("Lower Courtyard Bushes") 			(( 16.125 )::( 1200.875 ))
 	( 445 -724 218 ) 		("Lower Courtyard Bushes") 			(( 16.125 )::( 1200.875 ))
 	( -29 -940 218 ) 		("Lower Courtyard Bushes")  			(( 16.125 )::( 1200.875 ))
 	( -79 -693 218 ) 		("Lower Courtyard Bushes")  			(( 16.125 )::( 1200.875 ))
 	( -248 -822 218 ) 	("Lower Courtyard Bushes")  			(( 16.125 )::( 1200.875 ))
 	( 472 -577 218 ) 		("Lower Courtyard Bushes") 			(( 16.125 )::( 1200.875 ))
 	( -1250 41 217 ) 		("Southern Villa Alley")			(( 128.125 )::( 1200.875 ))
 	( -948 27 217 ) 		("Southern Villa Alley")			(( 96.125 )::( 1200.875 ))
 	( -875 -212 217 ) 	("Southern Villa Alley") 			(( 64.125 )::( 1200.875 ))
 	( -358 -340 120 ) 	("Lower Courtyard") 				(( 0.125 )::( 1200.875 ))
	( -122 -362 120 ) 	("Lower Courtyard") 				(( 0.125 )::( 1200.875 ))
 	( 196 -342 163 ) 		("Lower Courtyard") 				(( 16.125 )::( 1200.875 ))
 	( 231 -884 163 ) 		("Closed Gate") 					(( 0.125 )::( 227.675 ))
 	( -137 -78 163 ) 		("Lower Courtyard") 				(( 48.125 )::( 1200.875 ))
	( 215 262 163 ) 		("Lower Courtyard") 				(( 48.125 )::( 1200.875 ))
 	( 581 212 163 ) 		("Lower Courtyard") 				(( 48.125 )::( 1200.875 ))
 	( 539 -318 163 ) 		("Lower Courtyard") 				(( 0.125 )::( 1200.875 ))
 	( 831 -268 163 ) 		("Lower Courtyard") 				(( 0.125 )::( 1200.875 ))
 	( 949 -76 163 ) 		("Lower Courtyard") 				(( 0.125 )::( 1200.875 ))
 	( 1131 -523 426 ) 	("Lower Courtyard") 				(( 256.125 )::( 1200.875 ))
 	( 1085 -141 395 ) 	("Lower Courtyard") 				(( 256.125 )::( 1200.875 ))
 	( 1167 -196 395 ) 	("Lower Courtyard") 				(( 64.125 )::( 200.875 ))
 	( 1072 86 381 ) 		("Wine Cellar") 					(( 256.125 )::( 575.875 ))
 	( 1212 235 381 ) 		("Wine Cellar") 					(( 256.125 )::( 566.098 ))
 	( 987 290 486 ) 		("Wine Cellar") 					(( 384.125 )::( 575.875 ))
 	( 810 36 486 ) 		("Northern Villa Hall") 			(( 384.125 )::( 575.875 ))
 	( 807 159 486 ) 		("Northern Villa Hall") 			(( 385.125 )::( 575.875 ))
 	( 777 417 486 ) 		("Northern Villa Hall") 			(( 384.125 )::( 575.875 ))
 	( 804 737 486 ) 		("Northern Villa Hall") 			(( 384.125 )::( 575.875 ))
 	( 1061 745 461 ) 		("Northern Villa Back") 			(( 384.125 )::( 567.875 ))
 	( 1303 738 461 ) 		("Northern Villa Back") 			(( 384.125 )::( 567.875 ))
 	( 1504 581 461 ) 		("Northern Villa Balcony") 			(( 384.125 )::( 727.875 ))
	( 1530 808 622 ) 		("Northern Villa Balcony") 			(( 528.125 )::( 727.875 ))
 	( 637 479 486 ) 		("Villa Bridge") 					(( 384.125 )::( 700.875 ))
 	( 176 475 486 ) 		("Villa Bridge") 					(( 384.125 )::( 700.875 ))
 	( -206 476 486 ) 		("Villa Bridge") 					(( 384.125 )::( 700.875 ))
 	( -22 479 142 ) 		("Lower Courtyard") 				(( 48.125 )::( 318.743 ))
 	( -108 974 232 ) 		("Lower Courtyard") 				(( 48.125 )::( 1200.875 ))
 	( 315 920 232 ) 		("Lower Courtyard") 				(( 48.125 )::( 700.875 ))
 	( 487 513 152 ) 		("Lower Courtyard") 				(( 48.125 )::( 319.048 ))
 	( -1252 353 222 ) 	("Southern Villa Grnd Flr") 			(( 168.125 )::( 351.875 ))
 	( -1376 749 222 ) 	("Southern Villa Grnd Flr") 			(( 168.125 )::( 351.875 ))
 	( -920 795 222 ) 		("Southern Villa Grnd Flr") 			(( 168.125 )::( 351.875 ))
 	( -906 458 379 ) 		("Southern Villa Wooden Flr") 		(( 175.125 )::( 559.875 ))
 	( -806 242 449 ) 		("Southern Villa Wooden Flr") 		(( 328.125 )::( 559.875 ))
 	( -450 310 504 ) 		("Southern Villa Hall") 			(( 385.125 )::( 559.875 ))
 	( -336 466 504 ) 		("Southern Villa Hall") 			(( 384.125 )::( 559.875 ))
 	( -424 699 504 ) 		("Southern Villa Hall") 			(( 385.125 )::( 559.875 ))
	( -437 1013 483 ) 	("South Bridge") 					(( 384.125 )::( 1200.875 ))
 	( -445 1362 483 ) 	("South Bridge") 					(( 384.125 )::( 1200.875 ))
 	( -448 1705 483 ) 	("South Bridge") 					(( 384.125 )::( 1200.875 ))
 	( -445 2050 431 ) 	("South Bridge") 					(( 384.125 )::( 1200.875 ))
 	( -650 2301 507 ) 	("Upper Courtyard") 				(( 384.125 )::( 1200.875 ))
 	( -19 2311 507 ) 		("Upper Courtyard") 				(( 384.125 )::( 1200.875 ))
 	( 551 2342 507 ) 		("Upper Courtyard") 				(( 384.125 )::( 1200.875 ))
 	( 834 2523 507 ) 		("Upper Courtyard") 				(( 384.125 )::( 1200.875 ))
 	( 617 2715 507 ) 		("Upper Courtyard") 				(( 384.125 )::( 1200.875 ))
 	( 110 2880 442 ) 		("Wide Stairwell") 				(( 256.125 )::( 1200.875 ))
 	( 125 2275 238 ) 		("South Eastern Path") 				(( 128.125 )::( 335.875 ))
 	( 31 1832 238 ) 		("South Eastern Path") 				(( 128.125 )::( 1200.875 ))
 	( -467 1796 238 ) 	("South Eastern Path") 				(( 128.125 )::( 326.220 ))
 	( -998 1797 238 ) 	("South Eastern Path") 				(( 128.125 )::( 1200.875 ))
 	( -1205 1481 238 ) 	("South Eastern Path") 				(( 48.462 )::( 1200.875 ))
 	( -1109 1079 238 ) 	("South Eastern Path") 				(( 8.125 )::( 1200.875 ))
 	( -749 1063 185 ) 	("South Eastern Path")				(( 8.125 )::( 1200.875 ))
 	( -707 747 21 ) 		("Southern Villa Basement") 			(( -15.875 )::( 147.875 ))
 	( -673 497 55 ) 		("Southern Villa Basement") 			(( -15.875 )::( 148.851 ))
 	( 65 1559 180 ) 		("Centre Bldg Basement") 			(( 64.125 )::( 271.875 ))
 	( 197 1274 180 ) 		("Centre Bldg Basement") 			(( 48.125 )::( 255.875 ))
 	( -180 1329 102 ) 	("Centre Bldg Basement") 			(( 48.125 )::( 199.875 ))
 	( -231 1376 457 ) 	("Centre Bldg 1st Floor") 			(( 385.125 )::( 575.875 ))
 	( 162 1566 457 ) 		("Centre Bldg 1st Floor") 			(( 384.125 )::( 543.875 ))
 	( 538 1428 457 ) 		("Centre Bldg 1st Floor") 			(( 385.125 )::( 543.875 ))
 	( 1072 1411 457 ) 	("Centre Bldg 1st Floor") 			(( 384.125 )::( 535.875 ))
 	( 1249 1327 663 ) 	("Centre Bldg 2nd Floor Balcony") 		(( 608.125 )::( 759.875 ))
 	( 875 2001 535 ) 		("North Eastern Path") 				(( 328.125 )::( 1200.875 ))
 	( 1091 1764 535 ) 	("North Eastern Path") 				(( 312.125 )::( 1200.875 ))
 	( 1575 1626 535 ) 	("North Eastern Path") 				(( 300.283 )::( 1200.875 ))
 	( 1577 1165 535 ) 	("North Eastern Path") 				(( 229.528 )::( 1200.875 ))
 	( 1162 1054 433 ) 	("North Eastern Path") 				(( 139.202 )::( 1200.875 ))
 	( 1165 2063 580 )		("North Western Small House") 		(( 512.125 )::( 703.875 ))
 	( 1259 2710 465 ) 	("North Western House Grnd Flr") 		(( 385.125 )::( 575.875 ))
 	( 1461 3055 417 ) 	("North Western House Grnd Flr") 		(( 384.125 )::( 527.875 ))
 	( 1005 3094 670 ) 	("North Western House 1st Flr") 		(( 560.125 )::( 719.875 ))
 	( 1206 2604 765 ) 	("North Western House 2nd Flr") 		(( 672.125 )::( 871.875 ))

	endArray
	
	waitframe

	if (level.AIR_landmark.size == 85)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
mohdm2_lib:
//=============================================

	level.AIR_landmark = makeArray

	// Origin					//Name						// Z Min and Z Max
 	( -3028.494 -2434.034 134.492 ) 	("Main Street East") 				(( -61.304 )::( 831.875 ))
 	( -3120.233 -1765.413 134.492 ) 	("Main Street East") 				(( -60.873 )::( 831.875 ))
 	( -2978.025 -829.287 219.994 ) 	("Main Street Middle") 				(( 10.803 )::( 831.875 ))
 	( -2947.863 34.085 219.994 ) 		("Main Street Middle") 				(( 40.190 )::( 831.875 ))
 	( -3035.411 693.588 219.994 ) 	("Main Street West") 				(( -22.732 )::( 831.875 ))
 	( -2493.744 961.894 219.994 ) 	("Main Street West") 				(( -21.877 )::( 831.875 ))
 	( -2470.767 518.731 219.994 ) 	("Main Street West") 				(( 40.466 )::( 831.875 ))
 	( -2868.493 1435.898 462.297 ) 	("Barn") 						(( 183.007 )::( 831.875 ))
 	( -2848.451 1739.466 377.761 ) 	("Barn") 						(( 236.520 )::( 720.880 ))
 	( -2440.884 1658.880 377.761 ) 	("Barn") 						(( 216.125 )::( 608.880 ))
 	( -1906.910 1222.925 377.761 ) 	("Western Sector") 				(( 25.451 )::( 831.875 ))
 	( -1247.945 1221.342 377.761 ) 	("Western Sector") 				(( 22.694 )::( 831.875 ))
 	( -456.069 1219.991 377.761 ) 	("Western Sector") 				(( 44.021 )::( 831.875 ))
 	( 8.248 943.505 377.761 ) 		("Western Sector") 				(( 38.797 )::( 831.875 ))
 	( -130.200 500.430 377.761 ) 		("Western Sector") 				(( 38.206 )::( 1051.875 ))
 	( 432.972 86.589 377.761 ) 		("North Western Sector") 			(( -39.875 )::( 831.875 ))
 	( 554.787 -411.054 377.761 ) 		("North Western Sector") 			(( -63.875 )::( 831.875 ))
 	( 427.271 -1058.911 377.761 ) 	("North Western Sector") 			(( -51.984 )::( 831.875 ))
 	( 20.924 -1171.660 377.761 ) 		("North Western Sector") 			(( -1.164 )::( 831.875 ))
 	( -335.993 -1471.491 377.761 ) 	("Eastern Sector") 				(( -45.887 )::( 1535.875 ))
 	( -767.352 -1401.885 377.761 ) 	("Eastern Sector") 				(( -38.400 )::( 1535.875 ))
 	( -1386.420 -1315.693 377.761 ) 	("Centre Sector") 				(( -34.706 )::( 1051.875 ))
 	( -1444.000 -811.751 377.761 ) 	("Centre Sector") 				(( -31.875 )::( 1051.875 ))
 	( -1556.209 -170.933 377.761 ) 	("Centre Sector") 				(( -23.266 )::( 1051.875 ))
 	( -1579.920 356.893 377.761 ) 	("Centre Sector") 				(( 25.076 )::( 1051.875 ))
 	( -1325.308 746.099 377.761 ) 	("Centre Sector") 				(( 14.815 )::( 1051.875 ))
	( -897.977 -1989.834 377.761 ) 	("Centre Sector") 				(( -42.025 )::( 831.875 ))
	( -391.825 -2031.923 377.761 ) 	("North Eastern Ruins") 			(( -43.140 )::( 831.875 ))
 	( 70.741 -2110.040 377.761 ) 		("North Eastern Ruins") 			(( -24.716 )::( 831.875 ))
 	( -571.118 -2576.011 377.761 ) 	("North Eastern Sector") 			(( -63.875 )::( 831.875 ))
 	( -452.408 -3121.882 377.761 ) 	("North Eastern Sector") 			(( -55.363 )::( 831.875 ))
 	( -889.133 -3040.921 377.761 ) 	("North Eastern Sector") 			(( -43.565 )::( 831.875 ))
 	( -1351.616 -3083.231 377.761 ) 	("North Eastern Sector") 			(( -7.755 )::( 831.875 ))
 	( -1008.904 -3603.366 481.263 ) 	("Eastern Rubbled House") 			(( 119.712 )::( 831.875 ))
 	( -1353.086 -3638.973 231.169 ) 	("Eastern Rubbled House") 			(( -12.762 )::( 831.875 ))
 	( -1630.040 -3601.142 231.169 ) 	("Eastern Rubbled House") 			(( -11.613 )::( 831.875 ))
 	( -1767.856 -3122.543 103.895 ) 	("Eastern Spawn House") 			(( -15.875 )::( 175.875 ))
 	( -1120.212 -2498.750 314.505 ) 	("Eastern Sector") 				(( -63.875 )::( 831.875 ))
 	( -1672.371 -2573.236 314.505 ) 	("Eastern Sector") 				(( -121.185 )::( 831.875 ))
 	( -2388.985 -2605.417 314.505 ) 	("Eastern Sector") 				(( -115.019 )::( 831.875 ))
 	( -3025.689 -2846.037 314.505 ) 	("Eastern Sector") 				(( 70.029 )::( 831.875 ))
 	( -3564.016 -2630.407 314.505 ) 	("South Eastern Sector") 			(( 64.125 )::( 831.875 ))
 	( -3728.332 -2236.399 314.505 ) 	("South Eastern Sector") 			(( 64.125 )::( 831.875 ))
 	( -3474.144 -974.734 121.839 ) 	("Southeast Bldg") 				(( 8.125 )::( 203.875 ))
 	( -3412.651 -414.702 121.839 ) 	("Southwest Bldg Grnd Flr") 			(( 8.125 )::( 203.875 ))
 	( -3520.304 -297.066 330.925 ) 	("Southwest Bldg  1st Flr") 			(( 220.125 )::( 459.875 ))
 	( -3519.004 -465.615 624.743 ) 	("Southwest Bldg  2nd Flr") 			(( 476.125 )::( 831.875 ))
 	( -2343.000 -1976.000 93.000 ) 	("Centre Bldg Southeast Grnd Flr") 		(( 8.125 )::( 223.875 ))
 	( -2676.000 -1949.000 93.000 ) 	("Centre Bldg Southeast Grnd Flr") 		(( 8.125 )::( 223.875 ))
 	( -2540.000 -1970.000 315.000 ) 	("Centre Bldg Southeast 1st Flr") 		(( 240.125 )::( 463.875 ))
 	( -2267.000 -1883.000 315.000 ) 	("Centre Bldg Southeast 1st Flr") 		(( 240.125 )::( 463.875 ))
 	( -2277.000 -1512.000 315.000 ) 	("Centre Bldg Southeast 1st Flr") 		(( 240.125 )::( 463.875 ))
 	( -2323.000 -514.000 88.000 ) 	("Centre Bldg Southwest Grnd Flr") 		(( 16.125 )::( 223.875 ))
 	( -2354.000 -836.000 121.000 ) 	("Centre Bldg Southwest Grnd Flr") 		(( 28.837 )::( 223.875 ))
 	( -2306.000 -906.000 316.000 ) 	("Centre Bldg Southwest 1st Flr") 		(( 240.125 )::( 831.875 ))
 	( -2287.000 -432.000 316.000 ) 	("Centre Bldg Southwest 1st Flr") 		(( 240.125 )::( 463.875 ))
 	( -2329.000 -112.000 316.000 ) 	("Centre Bldg Southwest 1st Flr") 		(( 240.125 )::( 431.875 ))
 	( -2098.000 -33.000 315.000 ) 	("Centre Bldg Northwest 1st Flr") 		(( 240.125 )::( 463.875 ))
 	( -2100.000 -866.000 535.000 ) 	("Centre Bldg Northwest 2nd Flr") 		(( 480.125 )::( 831.875 ))
 	( -2097.000 -446.000 535.000 ) 	("Centre Bldg Northwest 2nd Flr") 		(( 480.125 )::( 831.875 ))
 	( -2034.000 -732.000 83.000 ) 	("Centre Bldg Northwest Grnd Flr") 		(( 16.125 )::( 193.274 ))
 	( -2028.000 -432.000 83.000 ) 	("Centre Bldg Northwest Grnd Flr") 		(( 16.125 )::( 223.875 ))
 	( -1979.000 -1088.000 83.000 ) 	("Centre Bldg Northeast Grnd Flr") 		(( 16.125 )::( 223.875 ))
 	( -2022.000 -1627.000 83.000 ) 	("Centre Bldg Northeast Grnd Flr") 		(( 16.125 )::( 223.875 ))
 	( -2018.000 -1172.000 333.000 ) 	("Centre Bldg Northeast 1st Flr") 		(( 240.125 )::( 463.875 ))
 	( -1920.000 -1492.000 333.000 ) 	("Centre Bldg Northeast 1st Flr") 		(( 240.125 )::( 831.875 ))
 	( -2078.000 -1593.000 581.000 ) 	("Centre Bldg Northeast 2nd Flr") 		(( 480.125 )::( 831.875 ))
 	( -2070.000 -1029.000 581.000 ) 	("Centre Bldg Northeast 2nd Flr") 		(( 480.125 )::( 831.875 ))
 	( -1557.673 -1900.629 116.996 ) 	("Corner Bldg Grnd Flr") 			(( 8.125 )::( 223.875 ))
 	( -1292.564 -1995.553 379.988 ) 	("Corner Bldg 1st Flr") 			(( 240.125 )::( 463.875 ))
 	( -1797.842 -1957.007 97.457 ) 	("Corner Bldg Grnd Flr") 			(( 8.125 )::( 223.875 ))
 	( -2131.850 -2589.651 193.200 ) 	("Eastern Sector") 				(( -120.457 )::( 831.875 ))
 	( -689.414 616.056 170.185 ) 		("Church Back") 					(( 40.125 )::( 239.875 ))
 	( -658.359 254.849 170.185 ) 		("Church Middle") 				(( 40.125 )::( 475.875 ))
 	( -684.886 -203.399 170.185 ) 	("Church Middle") 				(( 40.125 )::( 995.606 ))
 	( -1007.143 -360.621 170.185 ) 	("Church Middle") 				(( 40.125 )::( 690.672 ))
 	( -765.211 -688.736 170.185 ) 	("Church Front") 					(( 40.125 )::( 239.875 ))
 	( -760.109 -668.170 412.884 ) 	("Church Tower") 					(( 256.125 )::( 487.875 ))
 	( -681.896 -972.573 661.012 ) 	("Church Tower") 					(( 560.125 )::( 807.875 ))
 

	endArray

	waitframe

	if (level.AIR_landmark.size == 79)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
mohdm3_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin					//Name						// Z Min and Z Max
 	( -305.106 -408.132 108.165 ) 	("South Western Sector") 			(( -21.144 )::( 1623.875 ))
 	( 320.113 -418.663 108.165 ) 		("South Western Sector") 			(( -54.640 )::( 1623.875 ))
 	( 986.167 -554.406 108.165 ) 		("South Western Sector") 			(( -71.875 )::( 1623.875 ))
 	( 1050.904 -1182.805 108.165 ) 	("Western Sector") 				(( -71.875 )::( 1623.875 ))
 	( 1070.935 -1647.706 137.206 ) 	("South Western Sector") 			(( -49.911 )::( 1623.875 ))
 	( 1366.706 -2319.389 137.206 ) 	("South Western Sector") 			(( 3.857 )::( 1623.875 ))
 	( 1431.834 -2851.404 79.323 ) 	("Clock Tower Tunnel") 				(( 0.125 )::( 199.875 ))
 	( 1722.414 -3268.892 147.338 ) 	("Centre Sector") 				(( -0.490 )::( 1623.875 ))
 	( 2294.171 -3094.458 147.338 ) 	("Centre Sector") 				(( 1.255 )::( 1623.875 ))
 	( 2993.550 -2978.045 147.338 ) 	("Centre Sector") 				(( 1.802 )::( 1623.875 ))
 	( 3400.275 -3667.674 147.338 ) 	("Centre Sector") 				(( 0.125 )::( 1623.875 ))
 	( 3872.156 -3787.949 147.338 ) 	("North Eastern Sector") 			(( 3.566 )::( 1623.875 ))
 	( 4407.870 -4065.484 147.338 ) 	("North Eastern Sector") 			(( 1.017 )::( 1011.875 ))
 	( 5146.067 -3870.834 147.338 ) 	("Northern Sector") 				(( 1.649 )::( 1011.875 ))
 	( 5626.881 -3178.977 147.338 ) 	("Northern Sector") 				(( 0.833 )::( 1011.875 ))
 	( 5600.797 -2365.866 147.338 ) 	("Northern Sector") 				(( 0.678 )::( 1011.875 ))
	( 4883.881 -1844.802 147.338 ) 	("North Western Sector") 			(( 2.058 )::( 1011.875 ))
 	( 4049.802 -1814.419 147.338 ) 	("North Western Sector") 			(( 1.034 )::( 1623.875 ))
 	( 3254.375 -2058.885 147.338 ) 	("Centre Sector") 				(( 2.581 )::( 1623.875 ))
 	( 3116.497 -2546.811 128.350 ) 	("Centre Sector") 				(( 0.125 )::( 1623.875 ))
 	( 2568.325 -2088.285 59.981 ) 	("Manor Stairwell") 				(( 8.125 )::( 191.875 ))
 	( 2413.922 -2340.905 163.624 ) 	("Manor Stairwell") 				(( 120.125 )::( 423.875 ))
 	( 2158.324 -1708.652 20.099 ) 	("Manor Ground Flr Lounge") 			(( -55.875 )::( 127.875 ))
 	( 1871.913 -1165.915 34.550 ) 	("Manor Grand Entrance") 			(( -55.875 )::( 359.875 ))
 	( 2001.909 -1607.044 197.170 ) 	("Manor 1st Flr Dining Room") 		(( 144.125 )::( 307.947 ))
 	( 2614.663 -2313.940 288.831 ) 	("Manor 1st Flr Balcony Room") 		(( 208.125 )::( 423.875 ))
 	( 2712.823 -2643.866 288.831 ) 	("Manor 1st Flr Balcony") 			(( 208.125 )::( 1623.875 ))
 	( 2792.613 -2337.766 288.831 ) 	("Manor 1st Flr Balcony") 			(( 208.125 )::( 1623.875 ))
 	( 1888.693 -686.400 41.964 ) 		("Manor Backdoor") 				(( -55.875 )::( 119.875 ))
 	( 2253.316 -554.549 65.373 ) 		("Manor Backdoor Area") 			(( -63.875 )::( 1623.875 ))
 	( 2984.363 -1232.103 82.823 ) 	("Eastern Park Entrance") 			(( -29.307 )::( 1623.875 ))
 	( 3389.688 -1293.197 83.549 ) 	("Library") 					(( 16.125 )::( 215.875 ))
 	( 3879.958 -1168.021 83.549 ) 	("Library") 					(( 16.125 )::( 215.875 ))
 	( 2826.365 -832.061 29.143 ) 		("Park Path") 					(( -69.992 )::( 1623.875 ))
 	( 2835.747 -517.378 29.143 ) 		("Park Path") 					(( -87.875 )::( 1623.875 ))
 	( 2484.084 -239.758 29.143 ) 		("Park Path") 					(( -87.875 )::( 1623.875 ))
 	( 2157.632 -281.802 29.143 ) 		("Park Path") 					(( -76.519 )::( 1623.875 ))
 	( 1841.063 -277.086 58.478 ) 		("Western Park Entrance") 			(( -63.875 )::( 1623.875 ))
 	( 1409.070 -624.561 58.478 ) 		("Western Sector") 				(( -63.875 )::( 1623.875 ))
 	( 1343.035 -10.551 58.478 ) 		("Western Sector") 				(( -63.875 )::( 1623.875 ))
 	( 715.850 -79.190 58.478 ) 		("Western Sector") 				(( -63.875 )::( 1623.875 ))
 	( 999.818 273.052 13.640 ) 		("Allied Pub 1st Flr") 				(( -47.875 )::( 135.875 ))
 	( 763.140 329.462 13.640 ) 		("Allied Pub 1st Flr") 				(( -47.875 )::( 143.875 ))
 	( 629.994 493.674 222.387 ) 		("Allied Pub 2nd Flr") 				(( 162.125 )::( 361.875 ))
 	( 900.020 309.554 222.387 ) 		("Allied Pub 2nd Flr") 				(( 163.125 )::( 353.875 ))
 	( 1027.640 39.676 220.800 ) 		("Allied Pub Balcony") 				(( 164.125 )::( 322.230 ))
 	( 2225.726 -1189.172 154.943 ) 	("Manor Grand Entrance") 			(( 72.125 )::( 359.875 ))
 	( 3686.577 -3141.790 148.701 ) 	("Town Hall Grass Area") 			(( 8.125 )::( 1623.875 ))
 	( 3688.178 -2510.438 148.701 ) 	("Town Hall Grass Area") 			(( 8.125 )::( 1623.875 ))
 	( 3649.725 -2791.275 148.701 ) 	("Town Hall Grass Area") 			(( 8.125 )::( 1623.875 ))
	( 3660.785 -1547.313 264.706 ) 	("Library Front") 				(( 200.125 )::( 1623.875 ))
	( 3633.714 -1543.535 59.407 ) 	("Library Front") 				(( 8.125 )::( 187.875 ))
 	( 4917.579 -3286.617 107.890 ) 	("Bath House Grnd Flr") 			(( 48.125 )::( 247.875 ))
 	( 4629.272 -3275.676 154.561 ) 	("Bath House Grnd Flr") 			(( 48.125 )::( 487.875 ))
 	( 4646.904 -2784.904 341.862 ) 	("Bath House 1st Flr") 				(( 248.125 )::( 487.875 ))
 	( 4986.805 -3095.974 353.556 ) 	("Bath House 1st Flr") 				(( 278.125 )::( 479.875 ))
 	( 4890.841 -3479.007 353.556 ) 	("Bath House 1st Flr") 				(( 278.125 )::( 487.875 ))
 	( 4950.750 -2555.394 107.079 ) 	("Northern Sector") 				(( 8.125 )::( 1011.875 ))
 	( 5576.806 -3798.308 107.079 ) 	("Northern Sector") 				(( 8.125 )::( 1011.875 ))
 	( 3170.384 -1724.924 107.079 ) 	("Northern Western Sector") 			(( 8.125 )::( 1623.875 ))
 	( 655.207 -1702.698 67.542 ) 		("South Western Sector") 			(( -41.153 )::( 1623.875 ))
 	( 534.405 -1297.098 67.542 ) 		("South Western Sector") 			(( -58.880 )::( 1623.875 ))
 	( 4048.701 -1338.592 67.542 ) 	("Hidden Area") 					(( 8.125 )::( 391.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 63)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
mohdm5_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin					//Name						// Z Min and Z Max
 	( 2742 -4823 267 ) 			("Centre Bridge") 				(( 112.125 )::( 1663.875 ))
 	( 1604 -4806 250 )  			("Centre Bridge") 				(( 112.125 )::( 1663.875 ))
 	( 2201 -6611 227 )  			("Eastern Bridge") 				(( 112.125 )::( 1663.875 ))
 	( 2532 -6597 227 )  			("Eastern Bridge") 				(( 112.125 )::( 1663.875 ))
 	( 606 -2701 227 )  			("Western Bridge") 				(( 112.125 )::( 1663.875 ))
 	( 881 -2688 227 )  			("Western Bridge") 				(( 112.125 )::( 1663.875 ))
 	( 736 -2429 51 )  			("River West") 					(( -55.875 )::( 1663.875 ))
 	( 768 -3490 18 )  			("River West") 					(( -55.875 )::( 1663.875 ))
 	( 1618 -3809 18 )  			("River West") 					(( -55.875 )::( 1663.875 ))
 	( 2071 -3863 18 )  			("River Centre") 					(( -55.875 )::( 1663.875 ))
 	( 2089 -4514 18 )  			("River Centre") 					(( -55.875 )::( 1663.875 ))
 	( 2113 -4864 18 )  			("River Centre") 					(( -55.875 )::( 101.413 ))
 	( 2156 -5703 18 )  			("River East") 					(( -55.875 )::( 1663.875 ))
 	( 2377 -6861 18 )  			("River East") 					(( -55.875 )::( 1663.875 ))
	( 2682 -5194 286 )  			("Centre Sector") 				(( 133.235 )::( 1663.875 ))
	( 3161 -5016 286 )  			("Centre Sector") 				(( 155.165 )::( 1663.875 ))
 	( 2940 -5335 286 )  			("Centre Sector") 				(( 159.816 )::( 1663.875 ))
	( 3300 -4429 286 )  			("Centre Sector") 				(( 155.726 )::( 1663.875 ))
	( 3165 -3951 286 )  			("Centre Sector") 				(( 156.125 )::( 1663.875 ))
 	( 1645 -4459 192 )  			("Centre Sector") 				(( 100.125 )::( 1663.875 ))
 	( 1516 -4101 219 )  			("Centre Sector") 				(( 117.005 )::( 1663.875 ))
 	( 944 -4162 231 )  			("Centre Sector") 				(( 110.690 )::( 1663.875 ))
 	( 986 -5061 231 )  			("Centre Sector") 				(( 171.826 )::( 1663.875 ))
 	( 1277 -4842 231 ) 			("Centre Sector") 				(( 155.961 )::( 1663.875 ))
 	( 433 -4088 218 )  			("Centre Sector") 				(( 119.191 )::( 1663.875 ))
 	( 1562 -5168 218 )  			("Centre Sector") 				(( 128.954 )::( 1663.875 ))
 	( 1636 -5856 218 )  			("Centre Sector") 				(( 167.244 )::( 1663.875 ))
 	( 1291 -5689 218 )  			("Centre Sector") 				(( 169.561 )::( 1663.875 ))
 	( 1361 -5339 218 )  			("Centre Sector") 				(( 152.759 )::( 1663.875 ))
 	( 881 -5681 260 )  			("Centre Sector") 				(( 174.648 )::( 1663.875 ))
 	( 188 -5175 260 )  			("Centre Sector") 				(( 150.244 )::( 1663.875 ))
 	( 5028 -5880 263 )  			("North Sector") 					(( 161.396 )::( 1663.875 ))
 	( 4607 -5920 263 )  			("North Sector") 					(( 112.125 )::( 1663.875 ))
 	( 3994 -5740 263 )  			("North Sector") 					(( 157.440 )::( 1663.875 ))
 	( 3378 -5606 263 )  			("North Sector") 					(( 156.125 )::( 1663.875 ))
 	( 3451 -5330 263 )  			("North Sector") 					(( 156.125 )::( 1663.875 ))
 	( 3584 -4766 263 )  			("North Sector") 					(( 112.125 )::( 1663.875 ))
 	( 3613 -4260 263 )  			("North Sector") 					(( 156.125 )::( 1663.875 ))
 	( 3597 -3883 263 )  			("North Sector") 					(( 112.125 )::( 1663.875 ))
 	( 3958 -4708 263 )  			("North Sector") 					(( 112.125 )::( 1663.875 ))
 	( 4230 -4357 263 )  			("North Sector") 					(( 156.125 )::( 1663.875 ))
 	( 4820 -3754 263 )  			("North Sector") 					(( 169.582 )::( 1663.875 ))
 	( 4062 -5210 265 )  			("North Sector") 					(( 157.759 )::( 1663.875 ))
 	( -1301 -3590 301 )  			("South Sector") 					(( 169.712 )::( 1663.875 ))
 	( -903 -3625 301 )  			("South Sector") 					(( 186.573 )::( 1663.875 ))
 	( -432 -3734 301 )  			("South Sector") 					(( 167.532 )::( 1663.875 ))
 	( 7 -3665 301 )  				("South Sector") 					(( 112.125 )::( 1663.875 ))
 	( -310 -4573 301 )  			("South Sector") 					(( 135.866 )::( 1663.875 ))
 	( -838 -4633 301 )  			("South Sector") 					(( 155.492 )::( 1663.875 ))
 	( -751 -4130 301 )  			("South Sector") 					(( 187.441 )::( 1663.875 ))
 	( -1255 -5264 301 )  			("South Sector") 					(( 156.887 )::( 1663.875 ))
 	( -528 -5127 301 )  			("South Sector") 					(( 140.125 )::( 1663.875 ))
 	( -37 -4874 301 )  			("South Sector") 					(( 112.125 )::( 1663.875 ))
 	( -27 -5695 310 )  			("South Sector") 					(( 112.125 )::( 1663.875 ))
 	( -200 -4177 310 )  			("South Sector") 					(( 136.306 )::( 1663.875 ))
 	( 3931 -6827 310 )  			("East Sector") 					(( 191.801 )::( 1663.875 ))
 	( 3808 -6013 310 )  			("East Sector") 					(( 166.878 )::( 1663.875 ))
 	( 2763 -5838 310 )  			("East Sector") 					(( 153.154 )::( 1663.875 ))
 	( 3100 -5918 310 )  			("East Sector") 					(( 112.125 )::( 1663.875 ))
 	( 3202 -6506 310 )  			("East Sector") 					(( 144.185 )::( 1663.875 ))
 	( 2772 -6794 310 )  			("East Sector") 					(( 149.706 )::( 1663.875 ))
 	( 1441 -6147 310 )  			("East Sector") 					(( 187.991 )::( 1663.875 ))
 	( 807 -5977 310 ) 			("East Sector") 					(( 174.125 )::( 1663.875 ))
 	( 280 -5895 310 )  			("East Sector") 					(( 166.209 )::( 1663.875 ))
 	( 191 -6290 221 )  			("East Sector") 					(( 155.595 )::( 1663.875 ))
 	( 303 -6767 221 )  			("East Sector") 					(( 127.791 )::( 1663.875 ))
 	( 631 -6625 221 )  			("East Sector") 					(( 112.125 )::( 1663.875 ))
 	( 1261 -6082 278 )  			("East Sector") 					(( 185.968 )::( 1663.875 ))
 	( -438 -2424 354 )  			("West Sector") 					(( 167.867 )::( 1663.875 ))
 	( -180 -2817 354 )  			("West Sector") 					(( 159.411 )::( 1663.875 ))
 	( 352 -3273 354 )  			("West Sector") 					(( 134.125 )::( 1663.875 ))
 	( 356 -2704 260 )  			("West Sector") 					(( 112.125 )::( 1663.875 ))
 	( 2726 -2361 333 )  			("West Sector") 					(( 164.084 )::( 1663.875 ))
 	( 2704 -2772 333 )  			("West Sector") 					(( 112.125 )::( 1663.875 ))
 	( 2879 -3778 274 )  			("West Sector") 					(( 156.185 )::( 1663.875 ))
 	( 2748 -3319 274 )  			("West Sector") 					(( 156.125 )::( 1663.875 ))
 	( 2119 -2676 274 )  			("West Sector") 					(( 112.125 )::( 1663.875 ))
 	( 1336 -2676 274 )  			("West Sector") 					(( 112.125 )::( 1663.875 ))
 	( 1431 -3351 274 )  			("West Sector") 					(( 144.862 )::( 1663.875 ))
 	( 2358 -3284 274 )  			("West Sector") 					(( 151.157 )::( 1663.875 ))
 	( -1053 -6694 357 )  			("Southeast Sector") 				(( 182.092 )::( 1663.875 ))
 	( -1258 -5917 357 )  			("Southeast Sector") 				(( 193.712 )::( 1663.875 ))
 	( -314 -5950 357 )  			("Southeast Sector") 				(( 137.201 )::( 1663.875 ))
 	( -837 -6024 449 )  			("Southeast Sector") 				(( 294.768 )::( 1663.875 ))
 	( -148 -6563 335 )  			("Southeast Sector") 				(( 157.442 )::( 1663.875 ))
 	( -671 -2877 335 )  			("Southwest Sector") 				(( 171.139 )::( 1663.875 ))
 	( -1026 -3328 335 )  			("Southwest Sector") 				(( 170.322 )::( 1663.875 ))
 	( -518 -3242 335 )  			("Southwest Sector") 				(( 170.098 )::( 1663.875 ))
 	( -597 -2543 335 )  			("Southwest Sector") 				(( 169.650 )::( 1663.875 ))
 	( 3054 -2501 335 )  			("Northwest Sector") 				(( 169.208 )::( 1663.875 ))
 	( 4077 -3278 335 )  			("Northwest Sector") 				(( 170.779 )::( 1663.875 ))
 	( 3719 -3461 335 )  			("Northwest Sector") 				(( 175.198 )::( 1663.875 ))
 	( 3282 -3290 335 )  			("Northwest Sector") 				(( 169.494 )::( 1663.875 ))
 	( 3118 -2919 335 )  			("Northwest Sector") 				(( 162.123 )::( 1663.875 ))
 	( 4863 -6092 302 )  			("Northeast Sector") 				(( 156.125 )::( 1663.875 ))
 	( 4831 -6701 302 )  			("Northeast Sector") 				(( 185.880 )::( 1663.875 ))
 	( 4108 -6748 302 )  			("Northeast Sector") 				(( 176.904 )::( 1663.875 ))
 	( 4036 -6022 302 )  			("Northeast Sector") 				(( 156.125 )::( 1663.875 ))
 	( 4365 -5985 302 )  			("Northeast Sector") 				(( 155.444 )::( 1663.875 ))
 	( 4350 -6366 302 )  			("Northeast Sector") 				(( 112.125 )::( 1663.875 ))
 	( 4695 -6532 302 )  			("Northeast Sector") 				(( 169.635 )::( 1663.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 101)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded


//=============================================
mohdm6_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin					//Name						// Z Min and Z Max
 	( 1141.492 499.441 398.883 ) 		("North Bldg Roof") 				(( 304.125 )::( 1123.875 ))
 	( 1123.003 132.326 398.883 ) 		("North Bldg Roof") 				(( 304.125 )::( 1123.875 ))
 	( 1076.634 -275.392 398.883 ) 	("North Bldg Roof") 				(( 304.125 )::( 1123.875 ))
 	( 588.298 1.859 322.273 ) 		("Centre Bldg Roof")	 			(( 224.125 )::( 1123.875 ))
 	( 344.209 -231.746 322.273 ) 		("Centre Bldg Roof") 				(( 224.125 )::( 1123.875 ))
 	( 350.352 11.780 278.119 ) 		("Centre Bldg Roof Hut") 			(( 224.125 )::( 367.063 ))
 	( 338.765 1.697 77.405 ) 		("Centre Bldg 1st Flr") 			(( 32.125 )::( 207.875 ))
 	( 656.480 -42.678 77.405 ) 		("Centre Bldg 1st Flr") 			(( 32.125 )::( 207.875 ))
 	( 902.000 -152.000 77.405 ) 		("Centre Bldg 1st Flr") 			(( 32.125 )::( 207.875 ))
 	( 604.463 -425.319 -75.426 ) 		("Centre Bldg Boiler Room") 			(( -151.875 )::( 207.875 ))
 	( 409.481 -124.241 -75.426 ) 		("Centre Bldg Boiler Room") 			(( -151.875 )::( -0.125 ))
 	( 899.055 -136.748 -92.507 ) 		("Centre Bldg Boiler Room") 			(( -151.875 )::( -0.125 ))
 	( -43.483 -487.419 -92.507 ) 		("East Bldg Ground Flr") 			(( -151.875 )::( 7.875 ))
 	( -312.400 -766.850 -92.507 ) 	("East Bldg Ground Flr") 			(( -151.875 )::( 7.875 ))
 	( -48.780 -708.838 91.647 ) 		("East Bldg 1st Flr") 				(( 32.125 )::( 255.875 ))
 	( -219.442 -468.558 91.647 ) 		("East Bldg 1st Flr") 				(( 32.125 )::( 255.875 ))
 	( -652.792 -404.795 91.647 ) 		("East Bldg 1st Flr") 				(( 32.125 )::( 255.875 ))
 	( -386.948 -821.247 83.336 ) 		("East Bldg 1st Flr") 				(( 32.125 )::( 255.875 ))
 	( 111.970 -767.172 323.272 ) 		("East Bldg 2nd Flr") 				(( 272.125 )::( 479.875 ))
 	( -418.892 -728.195 323.272 ) 	("East Bldg 2nd Flr") 				(( 272.125 )::( 479.875 ))
 	( -1044.126 -771.084 323.272 )	("East Bldg 2nd Flr") 				(( 272.125 )::( 479.875 ))
 	( -551.022 -388.192 323.272 ) 	("East Bldg 2nd Flr") 				(( 272.125 )::( 479.875 ))
 	( -144.087 -426.163 323.272 ) 	("East Bldg 2nd Flr") 				(( 272.125 )::( 479.875 ))
 	( -1108.781 -246.501 323.272 ) 	("South Bldg 2nd Flr") 				(( 256.125 )::( 479.875 ))
 	( -911.492 126.723 323.272 ) 		("South Bldg 2nd Flr") 				(( 256.125 )::( 479.875 ))
 	( -1071.903 602.985 323.272 ) 	("South Bldg 2nd Flr") 				(( 256.125 )::( 479.875 ))
 	( -1472.704 334.766 216.921 ) 	("South Bldg Stairwell") 			(( 152.125 )::( 335.875 ))
 	( -1011.387 390.825 120.575 ) 	("South Bldg 1st Flr") 				(( 48.125 )::( 206.832 ))
 	( -618.520 432.303 140.287 ) 		("Ascended Alley ") 				(( 48.125 )::( 1123.875 ))
 	( -144.712 433.408 140.287 ) 		("Ascended Alley ") 				(( 48.125 )::( 263.444 ))
 	( 364.098 335.833 254.786 ) 		("Ascended Alley ") 				(( 160.125 )::( 1123.875 ))
 	( -1069.117 -46.297 566.406 ) 	("South Bldg 3rd Flr") 				(( 496.125 )::( 703.875 ))
 	( -1096.867 305.297 566.406 ) 	("South Bldg 3rd Flr") 				(( 496.125 )::( 703.875 ))
 	( -1056.492 827.175 566.406 ) 	("South Bldg 3rd Flr") 				(( 496.125 )::( 703.875 ))
 	( -356.713 681.363 564.797 ) 		("West Bldg South Side 3rd Flr") 		(( 512.125 )::( 735.875 ))
 	( 2.500 761.441 564.797 ) 		("West Bldg South Side 3rd Flr") 		(( 512.125 )::( 735.875 ))
 	( -21.593 709.464 309.391 ) 		("West Bldg South Side 2nd Flr") 		(( 272.125 )::( 495.875 ))
 	( -432.354 721.673 309.391 ) 		("West Bldg South Side 2nd Flr") 		(( 272.125 )::( 495.875 ))
 	( -9.384 696.567 82.784 ) 		("West Bldg South Side 1st Flr") 		(( 32.125 )::( 255.875 ))
 	( -428.936 655.204 82.784 ) 		("West Bldg South Side 1st Flr") 		(( 32.125 )::( 255.875 ))
 	( 549.864 1037.296 564.797 ) 		("West Bldg North Side 3rd Flr") 		(( 512.125 )::( 719.875 ))
 	( 799.086 731.554 564.797 ) 		("West Bldg North Side 3rd Flr") 		(( 512.125 )::( 719.875 ))
 	( 770.926 734.603 309.391 ) 		("West Bldg North Side 2nd Flr") 		(( 272.125 )::( 495.875 ))
 	( 479.764 1004.986 309.391 )	 	("West Bldg North Side 2nd Flr") 		(( 272.125 )::( 495.875 ))
 	( 838.910 766.328 82.784 ) 		("West Bldg North Side 1st Flr") 		(( 32.125 )::( 255.875 ))
 	( 498.483 995.927 82.784 ) 		("West Bldg North Side 1st Flr") 		(( 32.125 )::( 255.875 ))
 	( 353.583 477.143 471.883 ) 		("West Bldg 3rd Flr Stairwell") 		(( 408.125 )::( 631.875 ))
 	( 296.960 816.023 564.797 ) 		("West Bldg 3rd Flr Stairwell") 		(( 512.125 )::( 927.875 ))
 	( 333.193 828.747 342.969 ) 		("West Bldg 2nd Flr Stairwell") 		(( 272.125 )::( 491.481 ))
 	( 352.394 840.670 84.824 ) 		("West Bldg 1st Flr Stairwell") 		(( 32.125 )::( 255.875 ))
 	( 345.653 475.065 5.046 ) 		("West Bldg 1st Flr Stairwell") 		(( -79.875 )::( 139.658 ))
 	( 363.505 818.239 -113.599 ) 		("West Bldg Grnd Flr Stairwell") 		(( -151.875 )::( 15.875 ))
 	( 9.419 831.009 -113.599 ) 		("West Bldg Grnd Flr") 				(( -151.875 )::( -0.125 ))
 	( -314.569 641.227 -113.599 ) 	("West Bldg Grnd Flr") 				(( -151.875 )::( -0.125 ))
 	( 630.929 66.171 -104.829 ) 		("Centre Bldg Ground Flr") 			(( -151.875 )::( -0.125 ))
 	( 235.763 97.438 -104.829 ) 		("Centre Bldg Ground Flr") 			(( -151.875 )::( -0.125 ))
 	( -622.920 947.442 -65.605 ) 		("Courtyard") 					(( -151.875 )::( 1123.875 ))
 	( -637.201 416.769 -65.605 ) 		("Courtyard") 					(( -141.609 )::( 31.875 ))
 	( -579.086 -1.743 -65.605 ) 		("Courtyard") 					(( -151.757 )::( 1123.875 ))
 	( -86.582 -107.443 -65.605 ) 		("Courtyard") 					(( -147.875 )::( 1123.875 ))
 	( -248.903 159.419 -65.605 ) 		("Courtyard") 					(( -141.664 )::( 1123.875 ))
 	( 334.678 336.814 -65.605 ) 		("Courtyard") 					(( -149.219 )::( 143.875 ))
 	( -85.634 435.871 -65.605 ) 		("Courtyard") 					(( -136.882 )::( 31.875 ))
 	( 806.965 344.242 -65.605 ) 		("Courtyard") 					(( -137.383 )::( 1123.875 ))
 	( 870.270 60.572 -65.605 ) 		("Courtyard") 					(( -151.875 )::( 1123.875 ))
 	( 368.909 474.851 709.259 ) 		("West Bldg 4th Flr Stairwell") 		(( 648.125 )::( 927.875 ))
 	( 415.298 813.901 812.013 ) 		("West Bldg 4th Flr Stairwell") 		(( 736.125 )::( 927.875 ))
 	( -1364 29 851 ) 				("South Bldg Roof") 				(( 801.696 )::( 1123.875 ))
 	( -1367 -675 851 ) 			("South Bldg Roof") 				(( 800.172 )::( 1123.875 ))
 	( -980 -682 964 ) 			("South Bldg Roof") 				(( 897.190 )::( 1123.875 ))
 	( -935 177 933 ) 				("South Bldg Roof") 				(( 869.521 )::( 1123.875 ))
 	( -1003 538 984 ) 			("South Bldg Roof") 				(( 911.065 )::( 1123.875 ))
	( 1104 793 831 ) 				("West Bldg Roof") 				(( 710.822 )::( 1123.875 ))
 	( 372 619 962 ) 				("West Bldg Roof") 				(( 448.125 )::( 1123.875 ))
 	( 694 640 1055 ) 				("West Bldg Roof") 				(( 994.310 )::( 1123.875 ))
 	( -264 703 1055 ) 			("West Bldg Roof") 				(( 920.042 )::( 1123.875 ))
 	( -849 1294 823 ) 			("West Bldg Roof") 				(( 776.840 )::( 1123.875 ))
 	( -1027 225 758 ) 			("South Bldg 4th Flr") 				(( 720.125 )::( 901.015 ))
 	( -1188 627 758 ) 			("South Bldg 4th Flr") 				(( 720.125 )::( 885.683 ))
 	( -1098 843 758 ) 			("South Bldg 4th Flr") 				(( 720.125 )::( 875.875 ))
 	( -644 -375 689 ) 			("East Bldg Roof") 				(( 633.273 )::( 1123.875 ))
 	( -140 -368 676 ) 			("East Bldg Roof") 				(( 629.791 )::( 1123.875 ))
 	( 3 -735 741 ) 				("East Bldg Roof") 				(( 631.855 )::( 1123.875 ))
 	( 498 -448 676 ) 				("East Bldg Roof") 				(( 580.297 )::( 1123.875 ))
 	( 474 -670 676 ) 				("East Bldg Roof") 				(( 576.125 )::( 1123.875 ))
 	( 1062 -578 785 ) 			("East Bldg Roof") 				(( 722.912 )::( 1123.875 ))
 	( 1050 -829 785 ) 			("East Bldg Roof") 				(( 742.192 )::( 1123.875 ))
 	( 1392 -433 785 ) 			("North Bldg Roof") 				(( 734.988 )::( 1123.875 ))
 	( 1357 204 785 ) 				("North Bldg Roof") 				(( 713.012 )::( 1123.875 ))
 	( 1374 683 785 ) 				("North Bldg Roof") 				(( 723.497 )::( 1123.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 90) 
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
mohdm7_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin					//Name						// Z Min and Z Max

 	( 835 -1163 100 ) 			("Northeast Bldg 1st Flr") 			(( 40.125 )::( 255.875 ))
 	( 1382 -1136 100 ) 			("Northeast Bldg 1st Flr") 			(( 24.125 )::( 224.425 ))
 	( 1930 -1146 100 ) 			("Northeast Bldg 1st Flr")  			(( 24.125 )::( 231.573 ))
 	( 1625 -1148 -224 ) 			("Northeast Bldg Basement")  			(( -291.875 )::( 255.875 ))
 	( 1666 -1588 -238 )  			("Northeast Bldg Basement")  			(( -291.875 )::( -96.125 ))
 	( 1658 -806 -238 )  			("Northeast Bldg Basement")  			(( -291.875 )::( -96.125 ))
 	( 1422 -1160 -238 )  			("Northeast Bldg Basement")  			(( -291.875 )::( -96.125 ))
 	( 509 -766 -45 )  			("Northern Sector")  				(( -151.875 )::( 627.875 ))
 	( 504 -28 -45 )  				("Northern Sector")  				(( -151.875 )::( 627.875 ))
 	( 498 538 -45 )  				("Northern Sector")  				(( -151.875 )::( 627.875 ))
 	( 836 -690 -45 )  			("Northern Sector")  				(( -151.875 )::( 627.875 ))
 	( 1144 -83 44 )  				("Northern Sector")  				(( -59.875 )::( 627.875 ))
 	( 1416 526 110 )  			("Northern Sector")  				(( 24.125 )::( 627.875 ))
 	( 1442 -722 110 )  			("Northern Sector")  				(( 24.125 )::( 627.875 ))
 	( 1321 -918 108 )  			("Northern Sector")  				(( 52.125 )::( 627.875 ))
 	( 928 -914 108 )  			("Northern Sector")  				(( 52.125 )::( 627.875 ))
 	( 1231 338 -35 )  			("Northern Sector")  				(( -59.875 )::( 627.875 ))
 	( 411 1125 -79 )  			("Northwest Sector")  				(( -167.875 )::( 627.875 ))
 	( 913 1405 -79 )  			("Northwest Sector")  				(( -151.875 )::( 627.875 ))
 	( 29 1827 19 )  				("Northwest Sector")  				(( -49.870 )::( 627.875 ))
	( -688 1614 -23 )  			("Northwest Sector")  				(( -111.875 )::( 627.875 ))
	( -386 1495 -38 )  			("Northwest Sector")  				(( -117.512 )::( 627.875 ))
 	( 210 1784 -79 )  			("Northwest Bldg Grnd Flr")  			(( -135.875 )::( 31.875 ))
	( 274 1468 -79 )  			("Northwest Bldg Grnd Flr")  			(( -135.875 )::( 31.875 ))
 	( 201 1919 196 )  			("Northwest Bldg 1st Flr")  			(( 116.125 )::( 279.875 ))
 	( 548 1770 196 )  			("Northwest Bldg 1st Flr")  			(( 116.125 )::( 323.875 ))
 	( 216 1689 196 )  			("Northwest Bldg 1st Flr")  			(( 116.125 )::( 323.875 ))
 	( -509 1827 196 )  			("Western Bldg Roof")  				(( 96.125 )::( 627.875 ))
 	( -176 1839 196 )  			("Western Bldg Roof")  				(( 96.125 )::( 627.875 ))
 	( -197 1109 -55 )  			("Northwest Garden")  				(( -135.875 )::( 627.875 ))
 	( -731 1879 3 )  				("Western Pathway")  				(( -111.300 )::( 627.875 ))
 	( -800 2505 3 )  				("Western Pathway")  				(( -114.631 )::( 627.875 ))
 	( -1272 2507 3 )  			("Western Pathway")  				(( -107.875 )::( 627.875 ))
 	( -3525 3238 349 )  			("Mosque Roof")  					(( 276.125 )::( 627.875 ))
 	( -2942 3589 349 )  			("Mosque Roof")  					(( 284.125 )::( 831.875 ))
 	( -2197 3170 349 )  			("Mosque Roof")  					(( 276.125 )::( 627.875 ))
 	( -2631 2772 349 )  			("Mosque Roof")  					(( 276.125 )::( 831.875 ))
 	( -2635 1998 349 )  			("Mosque Roof")  					(( 284.125 )::( 831.875 ))
 	( -2647 1469 349 )  			("Mosque Roof")  					(( 284.125 )::( 831.875 ))
 	( -2036 1134 349 )  			("Mosque Roof")  					(( 284.125 )::( 627.875 ))
 	( -2965 1704 349 )  			("Mosque Roof")  					(( 284.125 )::( 831.875 ))
 	( -3187 1441 349 )  			("Mosque Roof")  					(( 284.125 )::( 831.875 ))
 	( -3233 2110 349 )  			("Mosque Roof")  					(( 284.125 )::( 831.875 ))
 	( -2338 1150 349 )  			("Mosque Roof")  					(( 284.125 )::( 627.875 ))
 	( -2678 870 349 )  			("Mosque Roof")  					(( 284.125 )::( 831.875 ))
 	( -2268 832 349 )  			("Mosque Roof")  					(( 284.125 )::( 627.875 ))
 	( -2954 2512 130 )  			("Mosque Courtyard")  				(( 64.125 )::( 831.875 ))
 	( -2957 3095 130 )  			("Mosque Courtyard")  				(( 64.125 )::( 831.875 ))
 	( -2930 2171 135 )  			("Mosque Courtyard")  				(( 72.125 )::( 263.875 ))
 	( -2598 2751 135 )  			("Mosque Courtyard")  				(( 72.125 )::( 263.875 ))
 	( -2063 1114 86 )  			("Mosque Grnd Flr")  				(( 0.125 )::( 223.875 ))
 	( -2183 800 86 )  			("Mosque Grnd Flr")  				(( 0.125 )::( 223.875 ))
 	( -2840 1162 86 )  			("Mosque Grnd Flr")  				(( 0.125 )::( 175.875 ))
 	( -2917 1592 86 )  			("Mosque Grnd Flr")  				(( 0.125 )::( 255.875 ))
 	( -2929 1915 146 )  			("Mosque Grnd Flr")  				(( 72.125 )::( 255.875 ))
 	( -3189 1955 146 )  			("Mosque Grnd Flr")  				(( 72.125 )::( 255.875 ))
 	( -3168 1188 48 )  			("Mosque Grnd Flr")  				(( 0.125 )::( 175.875 ))
 	( -3008 1016 48 )  			("Mosque Grnd Flr")  				(( 0.125 )::( 175.875 ))
 	( -3261 1026 142 )  			("Mosque Stairwell")  				(( 96.125 )::( 311.875 ))
 	( -3245 818 208 )  			("Mosque Stairwell")  				(( 168.125 )::( 352.928 ))
 	( -3179 1169 283 )  			("Mosque Radio Room")  				(( 264.125 )::( 419.875 ))
	( -2934 1442 299 ) 			("Mosque Radio Room")  				(( 284.125 )::( 416.435 ))
 	( -3484 872 104 )  			("Mosque Back")  					(( 0.125 )::( 627.875 ))
 	( -3822 901 104 )  			("Mosque Back")  					(( 0.125 )::( 627.875 ))
 	( -3856 1454 104 )  			("Mosque Back")  					(( 0.125 )::( 627.875 ))
 	( -3452 1967 56 )  			("Mosque Back")  					(( 0.125 )::( 627.875 ))
 	( -3494 418 -45 )  			("Mosque Back")  					(( -107.875 )::( 215.875 ))
 	( -3203 659 -34 )  			("Mosque Grnd Flr")  				(( -107.875 )::( 67.875 ))
 	( -2817 625 55 )  			("Mosque Grnd Flr")  				(( 0.125 )::( 175.875 ))
 	( -3141 414 -45 )  			("Mosque Hospital")  				(( -107.875 )::( 67.875 ))
 	( -3087 235 -45 )  			("Mosque Hospital")  				(( -107.875 )::( 67.875 ))
 	( -2982 -141 -45 )  			("Secret Passage")  				(( -115.875 )::( 59.875 ))
 	( -2824 -411 -57 )  			("Secret Passage")  				(( -91.875 )::( 87.875 ))
 	( -3083 -376 3 )  			("Secret Passage")  				(( -91.875 )::( 87.875 ))
 	( -2936 -642 -64 )  			("Southern Pathway")  				(( -105.875 )::( 627.875 ))
 	( -2479 -660 -64 )  			("Southern Pathway")  				(( -139.875 )::( 627.875 ))
 	( -1482 -644 -64 )  			("Southern Pathway")  				(( -155.875 )::( 627.875 ))
 	( -3069 -641 -64 )  			("Southern Pathway")  				(( -105.875 )::( 199.606 ))
 	( -1142 -633 -184 )  			("Centre Pathway")  				(( -230.360 )::( 627.875 ))
 	( -1070 -227 -38 )  			("Centre Pathway")  				(( -127.875 )::( 627.875 ))
 	( -1413 -39 -38 )  			("Centre Pathway")  				(( -129.871 )::( 627.875 ))
 	( -1435 552 -38 )  			("Centre Pathway")  				(( -127.875 )::( 627.875 ))
 	( -1100 580 -38 )  			("Centre Pathway")  				(( -117.172 )::( 627.875 ))
 	( -1147 1279 -38 )  			("Centre Pathway")  				(( -103.875 )::( 627.875 ))
 	( -929 1460 -38 )  			("Centre Pathway")  				(( -102.314 )::( 627.875 ))
 	( -2509 1193 60 )  			("Mosque Gardens")  				(( 0.125 )::( 627.875 ))
 	( -2404 1704 60 )  			("Mosque Gardens")  				(( 0.125 )::( 627.875 ))
 	( -2055 2505 60 )  			("Mosque Gardens")  				(( 0.125 )::( 627.875 ))
 	( -2071 3147 60 )  			("Mosque Gardens")  				(( 0.125 )::( 627.875 ))
 	( -1713 2875 60 )  			("Mosque Gardens")  				(( 0.125 )::( 627.875 ))
 	( -2085 1956 80 )  			("Mosque Gardens")  				(( 0.125 )::( 627.875 ))
 	( -2066 1425 80 )  			("Mosque Gardens")  				(( 0.125 )::( 627.875 ))
 	( -1452 2142 -27 )  			("Mosque Market")  				(( -107.875 )::( 171.875 ))
 	( -1442 1691 -27 )  			("Mosque Market")  				(( -107.875 )::( 171.875 ))
 	( -1790 1892 -27 )  			("Mosque Market")  				(( -111.875 )::( 627.875 ))
 	( -1740 2576 -27 )  			("Mosque Market")  				(( -111.875 )::( 627.875 ))
 	( -1512 2685 -27 )  			("Mosque Market")  				(( -107.875 )::( 627.875 ))
 	( 501 -1173 -211 )  			("Northeastern Pathway")  			(( -287.875 )::( 627.875 ))
 	( 88 -1172 -211 )  			("Northeastern Pathway")  			(( -293.331 )::( 627.875 ))
 	( -385 -1168 -211 )  			("Eastern Pathway")  				(( -287.875 )::( 627.875 ))
 	( -904 -1159 -211 )  			("Eastern Pathway")  				(( -283.875 )::( 627.875 ))
 	( -1228 -1499 -211 )  			("Eastern Pathway")  				(( -283.875 )::( 627.875 ))
 	( -1521 -1467 -211 )  			("Eastern Pathway")  				(( -287.875 )::( 627.875 ))
 	( -1561 -1320 -211 )  			("Eastern Bldg Grnd Flr")  			(( -283.875 )::( -104.125 ))
 	( -1584 -1092 -211 )  			("Eastern Bldg Grnd Flr")  			(( -283.875 )::( 111.875 ))
 	( -1701 -944 -108 )  			("Eastern Bldg Stairwell")  			(( -147.875 )::( 111.875 ))
 	( -1398 -954 -18 )  			("Eastern Bldg 1st Flr")  			(( -55.875 )::( 111.875 ))
 	( -1322 -1153 -18 )  			("Eastern Bldg 1st Flr")  			(( -55.875 )::( 111.875 ))
 	( -1660 -1330 -18 )  			("Eastern Bldg 1st Flr")  			(( -55.875 )::( 111.875 ))
 	( -1089 -951 -195 )  			("Eastern Pathway")  				(( -276.063 )::( 627.875 ))
 	( -874 -211 -64 )  			("Centre Bldg Grnd Flr")  			(( -111.875 )::( 71.875 ))
 	( -869 125 -64 )  			("Centre Bldg Grnd Flr")  			(( -111.875 )::( 71.875 ))
 	( -413 157 -172 )  			("Centre Bldg Grnd Flr")  			(( -199.875 )::( 71.875 ))
 	( -86 -157 -146 )  			("Centre Bldg Grnd Flr")  			(( -231.875 )::( 15.875 ))
 	( -91 -517 -146 )  			("Centre Bldg Grnd Flr")  			(( -199.875 )::( 15.875 ))
 	( -680 -328 -69 )  			("Centre Bldg Grnd Flr")  			(( -111.875 )::( 71.875 ))
 	( -293 -74 -146 )  			("Centre Bldg Grnd Flr")  			(( -199.875 )::( 15.875 ))
 	( -274 -865 102 )  			("Centre Bldg 1st Flr")  			(( 40.125 )::( 627.875 ))
 	( -85 -871 102 )  			("Centre Bldg 1st Flr")  			(( 40.125 )::( 627.875 ))
 	( -178 -172 102 )  			("Centre Bldg 1st Flr")  			(( 40.125 )::( 295.875 ))
 	( -50 -1556 216 )  			("Northeast Bldg Roof")  			(( 168.125 )::( 627.875 ))
 	( 411 -1549 216 )  			("Northeast Bldg Roof")  			(( 168.125 )::( 627.875 ))
 	( -3176 -658 327 )  			("Southern Balcony Room")  			(( 284.125 )::( 439.875 ))
 	( 147 538 -96 )  				("Northern Pathway")  				(( -205.445 )::( 627.875 ))
 	( 138 -137 -164 )  			("Northern Pathway")  				(( -248.193 )::( 627.875 ))
 	( 141 -814 -164 )  			("Northern Pathway")  				(( -284.622 )::( 627.875 ))
 	( -1589 1024 -34 )  			("Centre Passageway")  				(( -103.875 )::( 63.875 ))
 	( -1669 510 -34 )  			("Centre Passageway")  				(( -119.875 )::( 63.875 ))
 	( -1818 932 -34 )  			("Centre Passageway")  				(( -103.875 )::( 63.875 ))
	endArray

	waitframe

	if (level.AIR_landmark.size == 129)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded


//=============================================
team1_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin					//Name						// Z Min and Z Max
 	( -1030.047 5166.814 -1.514 ) 	("Allied Spawns") 				(( -155.958 )::( 2047.875 ))
 	( -213.678 5686.156 -45.661 ) 	("Allied Spawns") 				(( -173.884 )::( 2047.875 ))
 	( 843.906 5585.281 -45.661 ) 		("Allied Spawns") 				(( -207.549 )::( 2047.875 ))
 	( 1481.061 4869.556 -45.661 ) 	("Main Street") 					(( -227.263 )::( 2047.875 ))
 	( 2111.771 3746.285 -46.016 ) 	("Main Street") 					(( -254.021 )::( 2047.875 ))
 	( 3001.391 3680.630 -46.016 ) 	("Main Street") 					(( -260.935 )::( 2047.875 ))
 	( 3996.510 3683.813 -46.016 ) 	("Main Street") 					(( -275.322 )::( 2047.875 ))
 	( 4626.186 3274.440 -46.016 ) 	("Main Street") 					(( -297.101 )::( 2047.875 ))
	( 1758.416 4213.013 -141.081 ) 	("Main Street") 					(( -246.799 )::( 2047.875 ))
 	( 1106.707 4139.642 -31.706 ) 	("Allied Sniper Ruins") 			(( -154.581 )::( 2047.875 ))
 	( 1403.881 3903.751 -69.529 ) 	("Allied Sniper Ruins") 			(( -217.238 )::( 2047.875 ))
 	( 2488.851 4082.173 -95.545 ) 	("Ladder House Grnd Flr") 			(( -210.975 )::( -0.125 ))
 	( 2488.851 4082.173 90.220 ) 		("Ladder House 1st Flr") 			(( 19.125 )::( 235.175 ))
 	( 3119.384 4227.061 -137.431 ) 	("Tub House Ground Flr") 			(( -239.875 )::( -48.125 ))
 	( 3163.769 4325.357 31.619 ) 		("Tub House 1st Flr") 				(( -39.875 )::( 127.875 ))
 	( 2148.249 4608.283 -41.417 ) 	("Ladder House Gardens") 			(( -214.923 )::( 2047.875 ))
 	( 2766.960 4633.272 -41.417 ) 	("Ladder House Gardens") 			(( -226.487 )::( 2047.875 ))
 	( 3331.833 4643.088 -41.417 ) 	("Tub House Gardens") 				(( -227.016 )::( 2047.875 ))
 	( 3860.642 4204.016 -64.936 ) 	("North Western Ruins") 			(( -250.331 )::( 2047.875 ))
 	( 4453.810 4139.457 -64.936 ) 	("North Western Ruins") 			(( -313.342 )::( 2047.875 ))
	( 4982.978 3757.641 -176.927 ) 	("North Western Ruins") 			(( -318.007 )::( 2047.875 ))
 	( 2146.052 3152.739 -141.763 ) 	("Garage Ruins") 					(( -221.189 )::( 2047.875 ))
 	( 1622.584 3304.204 -69.489 ) 	("Garage Ruins") 					(( -217.102 )::( 2047.875 ))
 	( 3003.380 3152.209 -162.952 ) 	("Carpet House Grnd Flr") 			(( -247.875 )::( -80.125 ))
 	( 3030.028 3126.213 -29.092 ) 	("Carpet House 1st Flr") 			(( -71.875 )::( 2047.875 ))
 	( 3312.814 3068.354 -119.313 ) 	("Carpet House Passage") 			(( -252.724 )::( 2047.875 ))
 	( 3634.630 3043.302 -119.313 ) 	("Carpet House Passage") 			(( -261.006 )::( 2047.875 ))
 	( 3987.223 3127.337 -230.570 ) 	("Corner House Ground Flr") 			(( -255.875 )::( -72.125 ))
 	( 3987.223 3127.337 33.349 ) 		("Corner House 1st Flr") 			(( -63.875 )::( 2047.875 ))
 	( 5225.526 3167.732 -30.256 ) 	("Axis Sniper Bldg 1st Flr") 			(( -97.875 )::( 2047.875 ))
 	( 5233.139 3197.325 -220.029 ) 	("Axis Sniper Bldg Ground Flr") 		(( -289.875 )::( -106.125 ))
 	( 4665.381 2593.647 -220.029 ) 	("Bushy Passage") 				(( -287.875 )::( 2047.875 ))
 	( 4759.191 1763.353 -220.029 ) 	("Bushy Passage") 				(( -324.219 )::( 2047.875 ))
 	( 5042.126 1488.738 -268.074 ) 	("Bushy Passage") 				(( -369.174 )::( 2047.875 ))
 	( 5456.039 956.082 -268.074 ) 	("Bushy Passage") 				(( -409.191 )::( 2047.875 ))
 	( 5235.063 1148.762 -242.880 ) 	("Bushy Passage") 				(( -374.640 )::( 2047.875 ))
 	( 5397.734 293.606 -242.880 ) 	("Bushes opposite Church") 			(( -409.112 )::( 2047.875 ))
 	( 5450.739 -27.109 -242.880 ) 	("Bushes opposite Church") 			(( -400.322 )::( 2047.875 ))
 	( 4208.531 2318.992 -170.874 ) 	("Alley House 1 Ground Flr") 			(( -263.875 )::( -88.125 ))
 	( 4144.845 2673.206 -207.853 ) 	("Alley House 1 Ground Flr") 			(( -263.875 )::( -88.125 ))
 	( 4102.160 2646.744 0.306 ) 		("Alley House 1 First Flr") 			(( -79.875 )::( 363.932 ))
 	( 4100.261 2269.129 -15.690 ) 	("Alley House 1 First Flr") 			(( -79.875 )::( 2047.875 ))
 	( 4175.062 1607.225 -264.627 ) 	("Alley House 2 Ground Flr") 			(( -335.875 )::( -172.125 ))
 	( 4175.062 1607.225 -133.485 ) 	("Alley House 2 First Flr") 			(( -167.875 )::( -0.125 ))
 	( 4115.638 1149.772 -300.265 ) 	("Alley House 3 Ground Flr") 			(( -343.875 )::( 2047.875 ))
 	( 4082.384 1339.590 -75.556 ) 	("Alley House 3 First Flr") 			(( -159.875 )::( 2047.875 ))
 	( 4814.502 1225.693 -203.042 ) 	("Alley House 3 Ground Flr") 			(( -347.875 )::( 2047.875 ))
 	( 4562.525 1186.883 -203.042 ) 	("Alley House 3 Ground Flr") 			(( -352.460 )::( 2047.875 ))
 	( 3394.535 1319.302 -209.091 ) 	("Alley Ladder House Grnd Flr") 		(( -282.975 )::( -72.025 ))
 	( 3358.489 1237.294 0.071 ) 		("Alley Ladder House 1st Flr") 		(( -52.575 )::( 163.175 ))
 	( 3377.694 1152.061 -265.558 ) 	("Alley Ladder House Grnd Flr") 		(( -282.975 )::( -72.025 ))
 	( 3878.147 2678.016 -44.786 ) 	("The Alley") 					(( -239.842 )::( 2047.875 ))
 	( 3767.231 1910.654 -154.632 ) 	("The Alley") 					(( -288.028 )::( 2047.875 ))
 	( 3812.777 1132.506 -154.632 ) 	("The Alley") 					(( -344.012 )::( 2047.875 ))
 	( 3396.730 1831.549 -154.632 ) 	("Alley Ruins") 					(( -289.360 )::( 2047.875 ))
 	( 3614.711 2437.507 -53.469 ) 	("Alley Ruins") 					(( -182.645 )::( 2047.875 ))
 	( 3393.395 2294.398 -53.469 ) 	("Alley Ruins") 					(( -198.596 )::( 2047.875 ))
 	( 4207.442 2024.871 -136.911 ) 	("The Alley") 					(( -289.293 )::( 2047.875 ))
 	( 4501.567 2251.895 -136.911 ) 	("The Alley") 					(( -272.657 )::( 2047.875 ))
 	( 4303.140 2939.114 -136.911 ) 	("The Alley") 					(( -261.831 )::( 2047.875 ))
 	( 3011.647 1401.013 -112.170 ) 	("The Alley") 					(( -324.316 )::( 2047.875 ))
 	( 3618.102 752.631 -112.170 ) 	("Church Fields") 				(( -342.959 )::( 2047.875 ))
 	( 3276.461 693.970 -112.170 ) 	("Church Fields") 				(( -338.693 )::( 2047.875 ))
 	( 2799.240 851.432 -204.319 ) 	("Church Fields") 				(( -361.588 )::( 2047.875 ))
 	( 2118.249 692.987 -204.319 ) 	("Church Fields") 				(( -357.793 )::( 2047.875 ))
 	( 2810.111 -571.311 -253.435 ) 	("Church Fields") 				(( -445.304 )::( 2047.875 ))
 	( 3705.787 -45.270 -286.367 ) 	("Church Fields") 				(( -462.787 )::( 2047.875 ))
	( 4650.505 505.331 -127.120 ) 	("Church Fields") 				(( -450.805 )::( 2047.875 ))
 	( 4277.625 -498.184 -127.120 ) 	("Church Fields") 				(( -495.713 )::( 2047.875 ))
 	( 3020.520 -1289.707 -127.120 ) 	("Church Fields") 				(( -391.425 )::( 2047.875 ))
 	( 2273.585 -1597.962 -127.120 ) 	("Church Fields") 				(( -490.685 )::( 2047.875 ))
 	( 1716.871 -1181.201 -127.120 ) 	("Church Fields") 				(( -317.032 )::( 2047.875 ))
 	( 1041.473 -1753.478 -127.120 ) 	("Church Fields") 				(( -364.379 )::( 2047.875 ))
 	( 228.224 -1108.558 -127.120 ) 	("Church Fields") 				(( -472.689 )::( 2047.875 ))
 	( 258.966 -394.986 -127.120 ) 	("Church Fields") 				(( -333.679 )::( 2047.875 ))
 	( 290.188 133.454 -127.120 ) 		("Church Fields") 				(( -334.810 )::( 2047.875 ))
 	( 713.107 210.731 -127.120 ) 		("Church Fields") 				(( -310.452 )::( 2047.875 ))
 	( 1368.907 202.452 -127.120 ) 	("Church Fields") 				(( -305.556 )::( 2047.875 ))
 	( 1817.511 206.150 -127.120 ) 	("Church Fields") 				(( -305.875 )::( 2047.875 ))
 	( 2553.047 185.111 -127.120 ) 	("Church Fields") 				(( -364.942 )::( 2047.875 ))
 	( 3161.191 -207.275 -127.120 ) 	("Church Fields") 				(( -365.017 )::( 2047.875 ))
 	( 4043.349 803.846 -127.120 ) 	("Church Fields") 				(( -307.985 )::( 2047.875 ))
 	( 3716.092 -1024.490 -127.120 ) 	("Church Fields") 				(( -314.845 )::( 2047.875 ))
 	( 2353.328 -1051.926 -127.120 ) 	("Church Fields") 				(( -346.841 )::( 2047.875 ))
 	( 769.362 -326.906 -167.769 ) 	("Church Back Ruins") 				(( -279.875 )::( 2047.875 ))
 	( 1141.464 -362.547 -167.769 ) 	("Church Back Ruins") 				(( -279.875 )::( 2047.875 ))
 	( 1478.114 -375.143 -167.769 ) 	("Church Middle Area") 				(( -279.875 )::( 799.875 ))
 	( 1422.167 -737.444 -255.488 ) 	("Church Middle Area") 				(( -279.875 )::( 2047.875 ))
 	( 1438.051 -36.752 -255.488 ) 	("Church Middle Area") 				(( -279.875 )::( 126.324 ))
 	( 2036.238 -588.480 -210.504 ) 	("Church Front Area") 				(( -279.875 )::( 175.368 ))
 	( 1752.471 -180.286 -210.504 ) 	("Church Front Area") 				(( -279.875 )::( 186.015 ))
 	( 2381.868 -252.000 -136.546 ) 	("Church Front Area") 				(( -231.875 )::( 398.839 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 92)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded


//=============================================
team2_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin					//Name						// Z Min and Z Max


	endArray

	waitframe

	if (level.AIR_landmark.size == 92)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
m4l0_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin					//Name						// Z Min and Z Max
 	( -3158 -6690 44 ) 			("Pondside") 					(( -91.304 )::( 1727.875 ))
 	( -2351 -7120 39 ) 			("Pondside") 					(( -105.875 )::( 1727.875 ))
 	( -784 -7079 39 ) 			("Pondside") 					(( -105.875 )::( 1727.875 ))
 	( -886 -5972 39 ) 			("Pondside") 					(( -105.875 )::( 1727.875 ))
 	( -1818 -6118 -69 ) 			("Allied Pond") 					(( -249.875 )::( 1727.875 ))
 	( -3160 -5645 20 ) 			("Pondside") 					(( -87.642 )::( 1727.875 ))
 	( -1207 -2936 584 ) 			("Silo Farm") 					(( 404.611 )::( 1727.875 ))
 	( -919 -2085 624 ) 			("Silo Farm") 					(( 458.977 )::( 1727.875 ))
 	( -1672 -2072 624 ) 			("Silo Farm") 					(( 430.957 )::( 1727.875 ))
 	( -64 -2975 624 ) 			("Silo Farm") 					(( 481.529 )::( 1727.875 ))
 	( -4693 -2037 191 ) 			("Stable Farm") 					(( 72.846 )::( 1727.875 ))
 	( -5463 -3005 191 ) 			("Stable Farm") 					(( 68.125 )::( 1727.875 ))
 	( -3993 -2384 191 ) 			("Stable Farm") 					(( 70.902 )::( 1727.875 ))
 	( -3739 -3009 191 ) 			("Stable Farm") 					(( 74.125 )::( 1727.875 ))
 	( -2233 -1334 537 ) 			("South-Eastern Sector") 			(( 368.125 )::( 1727.875 ))
 	( -2134 -2756 472 ) 			("South-Eastern Sector") 			(( 281.970 )::( 1727.875 ))
 	( -2857 -3148 274 ) 			("South-Eastern Sector") 			(( 72.133 )::( 1727.875 ))
 	( -1907 -3617 313 ) 			("South-Eastern Sector") 			(( 188.119 )::( 1727.875 ))
 	( -939 -3899 476 ) 			("South-Eastern Sector") 			(( 156.686 )::( 1727.875 ))
 	( -5697 -5368 -51 ) 			("Eastern Sector") 				(( -327.875 )::( 1727.875 ))
 	( -5618 -4285 230 ) 			("Eastern Sector") 				(( -327.875 )::( 1727.875 ))
 	( -4793 -3929 230 ) 			("North-South Road") 				(( -327.875 )::( 1727.875 ))
 	( -4071 -3951 230 ) 			("North-South Road") 				(( -327.875 )::( 1727.875 ))
 	( -3093 -4529 136 ) 			("North-South Road") 				(( -327.875 )::( 1727.875 ))
 	( -2112 -4786 136 ) 			("North-South Road") 				(( -327.875 )::( 1727.875 ))
 	( -1293 -4797 136 ) 			("North-South Road") 				(( -327.875 )::( 1727.875 ))
 	( 392 -4808 50 ) 				("North-South Road") 				(( -327.875 )::( 1727.875 ))
 	( 1331 -4612 50 ) 			("North-South Road") 				(( -327.875 )::( 1727.875 ))
 	( 1713 -4203 50 ) 			("East-West Road") 				(( -327.875 )::( 1727.875 ))
 	( 1889 -3312 50 ) 			("East-West Road") 				(( -327.875 )::( 1727.875 ))
 	( 1923 -2567 50 ) 			("East-West Road") 				(( -327.875 )::( 1727.875 ))
 	( 1957 -1655 50 ) 			("East-West Road") 				(( -327.875 )::( 1727.875 ))
 	( 2011 -917 208 ) 			("East-West Road") 				(( -327.875 )::( 1727.875 ))
 	( 1915 -5 333 ) 				("East-West Road") 				(( -327.875 )::( 1727.875 ))
 	( 4830 -734 702 ) 			("North Hills") 					(( 468.275 )::( 1727.875 ))
 	( 4324 -2498 396 ) 			("North Hills") 					(( 171.910 )::( 1727.875 ))
 	( 3806 -440 635 ) 			("North Hills") 					(( 466.940 )::( 1727.875 ))
 	( 3523 -1870 507 ) 			("North Hills") 					(( 286.706 )::( 1727.875 ))
 	( 3700 -3824 629 ) 			("North Hills") 					(( 432.951 )::( 1727.875 ))
 	( 4107 -5679 279 ) 			("North Hills") 					(( 97.713 )::( 1727.875 ))
 	( 2749 -5431 205 ) 			("North Hills") 					(( -98.583 )::( 1727.875 ))
 	( 2583 -4036 205 ) 			("North Hills") 					(( -91.594 )::( 1727.875 ))
 	( 2986 -1619 437 ) 			("North Hills") 					(( 140.883 )::( 1727.875 ))
 	( 3092 -2722 487 ) 			("North Hills") 					(( 288.006 )::( 1727.875 ))
 	( 3183 -813 531 ) 			("North Hills") 					(( 326.213 )::( 1727.875 ))
 	( 3191 30 511 ) 				("North Hills") 					(( 294.885 )::( 1727.875 ))
 	( 2294 821 383 ) 				("Cottage Road") 					(( -327.875 )::( 1727.875 ))
 	( 3041 865 433 ) 				("Cottage Road") 					(( -327.875 )::( 1727.875 ))
 	( 3764 866 506 ) 				("Cottage Road") 					(( -327.875 )::( 1727.875 ))
 	( 4360 855 613 ) 				("Cottage Road") 					(( -327.875 )::( 1727.875 ))
 	( 5144 1407 595 ) 			("Cottage Garden") 				(( 488.125 )::( 1727.875 ))
 	( 5226 747 595 ) 				("Cottage Garden") 				(( 490.242 )::( 1727.875 ))
 	( 5942 1390 576 ) 			("Cottage 1st Flr") 				(( 536.125 )::( 843.875 ))
 	( 5598 1373 590 ) 			("Cottage 1st Flr") 				(( 536.125 )::( 671.875 ))
 	( 5552 1869 598 ) 			("Cottage 1st Flr") 				(( 536.125 )::( 687.875 ))
 	( 5007 1850 598 ) 			("Cottage 1st Flr") 				(( 536.125 )::( 675.875 ))
 	( 4832 2126 598 ) 			("Cottage 1st Flr") 				(( 536.125 )::( 675.875 ))
 	( 5157 2077 598 ) 			("Cottage 1st Flr") 				(( 536.125 )::( 675.875 ))
 	( 6162 1404 734 ) 			("Cottage 2nd Flr") 				(( 692.125 )::( 843.875 ))
 	( 5632 2017 778 ) 			("Cottage 2nd Flr") 				(( 692.125 )::( 962.875 ))
 	( 6149 1888 778 ) 			("Cottage 2nd Flr") 				(( 692.125 )::( 843.875 ))
 	( 5898 936 769 ) 				("Cottage 2nd Flr") 				(( 692.125 )::( 843.875 ))
 	( 6035 647 769 ) 				("Cottage 2nd Flr") 				(( 692.125 )::( 843.875 ))
 	( 1271 -2449 374 ) 			("East-West Road") 				(( 219.123 )::( 1727.875 ))
 	( 1418 -1655 418 ) 			("East-West Road") 				(( 272.927 )::( 1727.875 ))
 	( 1220 -702 418 ) 			("East-West Road") 				(( 301.366 )::( 1727.875 ))
 	( 1139 -47 517 ) 				("Cottage Sector") 				(( 275.977 )::( 1727.875 ))
 	( 1257 1650 517 ) 			("Cottage Sector") 				(( 353.975 )::( 1727.875 ))
 	( 1981 1443 517 ) 			("Cottage Sector") 				(( 344.990 )::( 1727.875 ))
 	( 2386 2002 517 ) 			("Cottage Sector") 				(( 369.977 )::( 1727.875 ))
 	( 3974 2143 576 ) 			("Cottage Sector") 				(( 438.040 )::( 1727.875 ))
 	( 4635 2427 576 ) 			("Cottage Sector") 				(( 472.873 )::( 1727.875 ))
 	( -1098 7098 232 ) 			("Axis Western Barn") 				(( 85.697 )::( 536.688 ))
 	( 322 4450 232 ) 				("Western Farm") 					(( 68.125 )::( 1727.875 ))
 	( 189 5382 210 ) 				("Western Farm") 					(( 68.125 )::( 1727.875 ))
 	( -842 6036 210 ) 			("Western Farm") 					(( 53.267 )::( 1727.875 ))
 	( -2047 6571 210 ) 			("Western Farm") 					(( -65.347 )::( 1727.875 ))
 	( -1726 7075 210 ) 			("Western Farm") 					(( 60.102 )::( 1727.875 ))
 	( -1166 5250 210 ) 			("Western Farm") 					(( -36.717 )::( 1727.875 ))
 	( -1378 6344 210 ) 			("Western Farm") 					(( 3.569 )::( 1727.875 ))
 	//( -297 6831 210 ) 			("Western Farm") 					(( 72.284 )::( 1727.875 ))
 	( -72 5989 210 ) 				("Western Farm") 					(( 68.125 )::( 1727.875 ))
 	( 678 799 621 ) 				("South-Western Sector") 			(( 346.173 )::( 1727.875 ))
 	( -845 1223 414 ) 			("South-Western Sector") 			(( 163.170 )::( 1727.875 ))
 	( -2095 1488 414 ) 			("South-Western Sector") 			(( 162.428 )::( 1727.875 ))
 	( -2093 2412 296 ) 			("South-Western Sector") 			(( 68.125 )::( 1727.875 ))
 	( -2066 3636 103 ) 			("South-Western Sector") 			(( -103.434 )::( 1727.875 ))
 	( -4615 5806 46 ) 			("South-Western Sector") 			(( -159.531 )::( 1727.875 ))
 	( -3937 2961 237 ) 			("South-Western Sector") 			(( -8.227 )::( 1727.875 ))
 	( -2871 2765 237 ) 			("South-Western Sector") 			(( 24.727 )::( 1727.875 ))
 	( -3220 5865 24 ) 			("Western Farm") 					(( -136.337 )::( 1727.875 ))
 	( -1924 5150 12 ) 			("Western Farm") 					(( -195.875 )::( 1727.875 ))
 	( -334 4268 241 ) 			("Western Farm") 					(( 62.125 )::( 1727.875 ))
 	( 1307 985 524 ) 				("South-Western Road") 				(( -327.875 )::( 1727.875 ))
 	( 97 1685 600 ) 				("South-Western Road") 				(( -327.875 )::( 1727.875 ))
 	( -544 3197 256 ) 			("South-Western Road") 				(( -327.875 )::( 1727.875 ))
 	( -958 4009 230 ) 			("South-Western Road") 				(( -327.875 )::( 1727.875 ))
 	( -1756 4372 35 ) 			("South-Western Road") 				(( -327.875 )::( 1727.875 ))
 	( -2775 4521 -24 ) 			("South-Western Road") 				(( -327.875 )::( 1727.875 ))
 	( -3994 5417 -24 ) 			("South-Western Road") 				(( -327.875 )::( 1727.875 ))
 	( -24 2759 348 ) 				("South-Western Sector") 			(( 194.645 )::( 1727.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 100)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
m5l1b_lib:
//=============================================

	level.AIR_landmark = makeArray
	
	// Origin					//Name						// Z Min and Z Max
 	( -2738 -3919 649 ) 			("Hotel Front Room") 				(( 560.125 )::( 751.875 ))
 	( -2788 -2588 419 ) 			("Hotel 1st Floor") 				(( 352.125 )::( 543.875 ))
 	( -3239 -2834 419 ) 			("Hotel 1st Floor") 				(( 352.125 )::( 543.875 ))
 	( -3150 -3162 419 ) 			("Hotel 1st Floor") 				(( 352.125 )::( 543.875 ))
 	( -2736 -3171 655 ) 			("Hotel 2nd Floor") 				(( 568.125 )::( 751.875 ))
 	( -3291 -2973 655 ) 			("Hotel 2nd Floor") 				(( 568.125 )::( 751.875 ))
 	( -3185 -2653 655 ) 			("Hotel 2nd Floor") 				(( 568.125 )::( 751.875 ))
 	( -2767 -2608 655 ) 			("Hotel 2nd Floor") 				(( 568.125 )::( 751.875 ))
 	( -755 -2417 545 ) 			("Bed House") 					(( 480.125 )::( 711.875 ))
 	( -959 -2169 551 ) 			("Bed House") 					(( 480.125 )::( 991.875 ))
 	( -994 -1805 603 ) 			("Bed House") 					(( 480.125 )::( 1599.875 ))
 	( -647 -1783 639 ) 			("Bed House") 					(( 506.900 )::( 711.875 ))
 	( -1696 -1238 533 ) 			("Sniper House") 					(( 480.125 )::( 639.875 ))
 	( -1908 -1344 533 ) 			("Sniper House") 					(( 480.125 )::( 639.875 ))
 	( -2011 -1087 533 ) 			("Sniper House") 					(( 480.125 )::( 1599.875 ))
 	( -2146 -2677 439 ) 			("Hotel Corner House") 				(( 360.125 )::( 531.875 ))
 	( -2135 -2447 439 ) 			("Hotel Corner House") 				(( 360.125 )::( 531.875 ))
 	( -1948 -2802 612 ) 			("Hotel Corner House") 				(( 540.125 )::( 767.875 ))
 	( -2147 -2684 612 ) 			("Hotel Corner House") 				(( 540.125 )::( 767.875 ))
 	( -2144 -2384 612 ) 			("Hotel Corner House") 				(( 540.125 )::( 767.875 ))
 	( -2475 -2560 412 ) 			("Hotel Path") 					(( 284.355 )::( 1599.875 ))
 	( -2454 -3212 412 ) 			("Hotel Path") 					(( 216.849 )::( 1599.875 ))
 	( -2423 -3686 332 ) 			("Hotel Path") 					(( 164.928 )::( 1599.875 ))
 	( -2443 -4242 243 ) 			("Hotel Path") 					(( 112.594 )::( 1599.875 ))
 	( -3788 -2245 424 ) 			("Hotel Path") 					(( 297.523 )::( 1599.875 ))
 	( -3423 -2054 500 ) 			("Hotel Path") 					(( 64.125 )::( 1599.875 ))
 	( -2924 -2099 500 ) 			("Hotel Path") 					(( 64.125 )::( 1599.875 ))
 	( -1567 -5323 248 ) 			("Eastern Sector") 				(( 89.531 )::( 1599.875 ))
 	( -2057 -5186 248 ) 			("Eastern Sector") 				(( 89.968 )::( 1599.875 ))
 	( -2177 -5578 248 ) 			("Eastern Sector") 				(( 141.724 )::( 1599.875 ))
 	( -2855 -4797 248 ) 			("Eastern Sector") 				(( 115.317 )::( 1599.875 ))
 	( -2427 -4776 248 ) 			("Eastern Sector") 				(( 91.630 )::( 1599.875 ))
 	( -2932 -4306 248 ) 			("Eastern Sector") 				(( 100.510 )::( 1599.875 ))
 	( -3395 -4192 324 ) 			("Eastern Sector") 				(( 150.589 )::( 1599.875 ))
 	( -3335 -3783 324 ) 			("Eastern Sector") 				(( 153.136 )::( 1599.875 ))
 	( -3712 -3526 340 ) 			("Eastern Sector") 				(( 185.483 )::( 1599.875 ))
 	( -3776 -3022 363 ) 			("Eastern Sector") 				(( 239.198 )::( 1599.875 ))
 	( -4128 -2791 443 ) 			("Eastern Sector") 				(( 272.382 )::( 1599.875 ))
 	( -4081 -2434 443 ) 			("Eastern Sector") 				(( 64.125 )::( 1599.875 ))
 	( -2553 -5340 197 ) 			("Eastern Corner House") 			(( 124.125 )::( 491.875 ))
 	( -3029 -5372 387 ) 			("Eastern Corner House") 			(( 304.125 )::( 703.875 ))
 	( -2832 -5133 387 ) 			("Eastern Corner House") 			(( 304.125 )::( 491.875 ))
 	( -2783 -5143 599 ) 			("Eastern Corner House") 			(( 508.125 )::( 703.875 ))
 	( -2680 -5406 599 ) 			("Eastern Corner House") 			(( 508.125 )::( 703.875 ))
 	( -2555 -2213 509 ) 			("Hotel Path") 					(( 64.125 )::( 1599.875 ))
 	( -2232 -2020 509 ) 			("Hotel Path") 					(( 64.125 )::( 1599.875 ))
 	( -1797 -1680 509 ) 			("Centre Sector") 				(( 64.125 )::( 1599.875 ))
 	( -1338 -1518 527 ) 			("Centre Sector") 				(( 64.125 )::( 1599.875 ))
 	( -898 -1207 527 ) 			("Centre Sector") 				(( 64.125 )::( 1599.875 ))
 	( -525 -658 554 ) 			("Centre Sector") 				(( 64.125 )::( 1599.875 ))
 	( -641 -1401 604 )			("Centre Sector") 				(( 380.019 )::( 1599.875 ))
 	( -1415 -933 604 ) 			("Centre Sector") 				(( 372.731 )::( 1599.875 ))
 	( -1563 -334 665 ) 			("Centre Sector") 				(( 64.125 )::( 1599.875 ))
 	( -1249 483 665 ) 			("Centre Sector") 				(( 64.125 )::( 1599.875 ))
 	( -1675 558 665 ) 			("Centre Sector") 				(( 349.653 )::( 1599.875 ))
 	( -640 587 601 ) 				("Centre Sector") 				(( 64.125 )::( 1599.875 ))
 	( -764 161 601 ) 				("Centre Sector") 				(( 416.256 )::( 1599.875 ))
 	( -1147 -66 601 ) 			("Centre Sector") 				(( 64.125 )::( 1599.875 ))
 	( -597 -236 426 ) 			("Centre Sector") 				(( 384.125 )::( 527.875 ))
 	( -553 1021 667 ) 			("Centre Sector") 				(( 477.642 )::( 1599.875 ))
 	( 134 274 667 ) 				("Lower Bridge House") 				(( 592.125 )::( 1599.875 ))
 	( -144 271 667 ) 				("Lower Bridge House") 				(( 592.125 )::( 1599.875 ))
 	( 15 684 667 ) 				("House Bridge") 					(( 592.125 )::( 1599.875 ))
 	( 3 1064 667 ) 				("Upper Bridge House") 				(( 592.125 )::( 799.875 ))
 	( 290 1207 737 ) 				("Upper Bridge House") 				(( 676.125 )::( 831.875 ))
 	( 453 1158 879 ) 				("Upper Bridge House") 				(( 796.125 )::( 991.875 ))
 	( 734 1241 879 ) 				("Upper Bridge House") 				(( 796.125 )::( 991.875 ))
 	( 934 805 513 ) 				("Shortcut House") 				(( 396.125 )::( 863.875 ))
 	( 1335 691 694 ) 				("Shortcut House") 				(( 624.125 )::( 863.875 ))
 	( 912 427 694 ) 				("Shortcut House") 				(( 624.125 )::( 1599.875 ))
 	( 1084 553 694 ) 				("Shortcut House") 				(( 624.125 )::( 863.875 ))
 	( 1572 656 771 ) 				("Shortcut House") 				(( 624.125 )::( 887.682 ))
 	( 1946 524 785 ) 				("Shortcut House") 				(( 656.125 )::( 903.875 ))
 	( 2179 732 785 ) 				("Shortcut House") 				(( 656.125 )::( 903.875 ))
 	( 298 641 490 ) 				("City Hall Path") 				(( 64.125 )::( 1599.875 ))
 	( 701 231 490 )	 			("City Hall Path") 				(( 64.125 )::( 1599.875 ))
 	( 840 -382 525 ) 				("City Hall Path") 				(( 64.125 )::( 1599.875 ))
 	( 1232 -932 525 ) 			("City Hall Path") 				(( 64.125 )::( 1599.875 ))
 	( 563 816 545 ) 				("City Hall Path") 				(( 422.851 )::( 1599.875 ))
 	( 1106 162 647 ) 				("City Hall Path") 				(( 487.548 )::( 1599.875 ))
 	( 1405 64 725 ) 				("Deformed House") 				(( 672.125 )::( 808.115 ))
 	( 1202 -394 632 ) 			("City Hall Path") 				(( 471.490 )::( 1599.875 ))
 	( 690 -1051 632 )				("City Hall Path") 				(( 484.455 )::( 1599.875 ))
 	( 1250 -1780 579 ) 			("City Hall Sector") 				(( 394.394 )::( 1599.875 ))
 	( 1751 -1548 700 ) 			("City Hall Sector") 				(( 444.369 )::( 1599.875 ))
 	( 1857 -371 764 ) 			("City Hall Sector") 				(( 561.699 )::( 1599.875 ))
 	( 1681 -1083 605 ) 			("City Hall Sector") 				(( 64.125 )::( 1599.875 ))
 	( 2431 -1036 605 ) 			("City Hall Sector") 				(( 384.125 )::( 1599.875 ))
 	( 2949 -1681 605 ) 			("City Hall Sector") 				(( 366.164 )::( 1599.875 ))
 	( 2358 -2194 662 ) 			("City Hall Sector") 				(( 462.411 )::( 1599.875 ))
 	( 3109 -1241 498 ) 			("City Hall Sector") 				(( 64.125 )::( 1599.875 ))
 	( 3852 -1300 510 ) 			("City Hall Sector") 				(( 384.125 )::( 1599.875 ))
 	( 4129 -881 510 ) 			("City Hall Sector") 				(( 384.125 )::( 1599.875 ))
 	( 4104 -52 510 ) 				("City Hall Sector") 				(( 64.125 )::( 1599.875 ))
 	( 3519 -296 510 ) 			("City Hall Sector") 				(( 384.125 )::( 1599.875 ))
 	( 2958 -238 510 ) 			("City Hall Sector") 				(( 384.125 )::( 1599.875 ))
 	( 2567 1 510 ) 				("City Hall Sector") 				(( 384.125 )::( 1599.875 ))
 	( 2147 64 791 ) 				("Axis Balustrade") 				(( 712.125 )::( 1599.875 ))
 	( 2609 -663 720 ) 			("City Hall Sector") 				(( 475.949 )::( 1599.875 ))
 	( 3823 334 617 ) 				("City Hall Sector") 				(( 414.382 )::( 1599.875 ))
 	( 2473 328 617 ) 				("City Hall Sector") 				(( 419.804 )::( 1599.875 ))
 	( 3199 452 537 ) 				("City Hall Entrance") 				(( 464.125 )::( 863.875 ))
 	( 3203 733 537 ) 				("City Hall Entrance")				(( 464.125 )::( 871.875 ))
 	( 3202 1000 685 ) 			("City Hall Entrance") 				(( 576.125 )::( 879.875 ))
 	( 3575 325 526 ) 				("City Hall 1st Floor") 			(( 464.125 )::( 655.875 ))
 	( 3718 648 526 ) 				("City Hall 1st Floor") 			(( 464.125 )::( 655.875 ))
 	( 3588 940 526 ) 				("City Hall 1st Floor") 			(( 464.125 )::( 655.875 ))
 	( 2874 333 526 ) 				("City Hall 1st Floor") 			(( 464.125 )::( 655.875 ))
 	( 2639 862 526 ) 				("City Hall 1st Floor") 			(( 464.125 )::( 655.875 ))
 	( 2544 601 526 ) 				("City Hall 1st Floor") 			(( 464.125 )::( 879.875 ))
 	( 2841 347 739 ) 				("City Hall 2nd Floor") 			(( 672.125 )::( 879.875 ))
 	( 2741 757 739 ) 				("City Hall 2nd Floor") 			(( 672.125 )::( 879.875 ))
 	( 3554 357 739 ) 				("City Hall 2nd Floor") 			(( 672.125 )::( 879.875 ))
 	( 3810 775 739 ) 				("City Hall 2nd Floor") 			(( 672.125 )::( 879.875 ))
 	( 3458 1462 518 )		 		("City Hall Garden") 				(( 364.078 )::( 1599.875 ))
 	( 3106 1790 518 ) 			("City Hall Garden") 				(( 291.075 )::( 1599.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 116)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
m6l2a_lib:
//=============================================

	level.AIR_landmark = makeArray

 	( -529 -3213 -99 ) 			("Wine Room") 				(( -239.875 )::( 91.875 ))
 	( -107 -3464 -3 ) 			("Wine Room") 				(( -119.875 )::( 91.875 ))
 	( -473 -3425 -3 ) 			("Wine Room") 				(( -119.875 )::( 91.875 ))
 	( -2329 -3575 81 ) 			("Western Pathway") 			(( -23.875 )::( 151.246 ))
 	( -2232 -3823 81 ) 			("Western Pathway") 			(( -39.875 )::( 1599.875 ))
 	( -2096 -4013 81 ) 			("Western Pathway") 			(( -47.875 )::( 1599.875 ))
 	( -2010 -4311 9 ) 			("Western Pathway") 			(( -103.875 )::( 1599.875 ))
 	( -1702 -4467 -69 ) 			("Western Pathway") 			(( -151.875 )::( 45.759 ))
 	( -1421 -4411 -41 ) 			("Western Pathway") 			(( -167.875 )::( 1599.875 ))
 	( -1203 -4064 -41 ) 			("Western Pathway") 			(( -167.875 )::( 1367.228 ))
 	( -1160 -4451 -41 ) 			("Western Pathway") 			(( -167.875 )::( 1599.875 ))
 	( -1588 -3583 75 ) 			("South Western Sector") 		(( -79.366 )::( 1599.875 ))
 	( -1327 -3715 12 ) 			("South Western Sector") 		(( -122.792 )::( 1599.875 ))
 	( -740 -3783 12 ) 			("South Western Sector") 		(( -127.875 )::( 1599.875 ))
 	( -228 -3768 12 ) 			("South Western Sector") 		(( -127.875 )::( 1599.875 ))
 	( -876 -3525 -11 )			("South Western Sector") 		(( -95.875 )::( 1599.875 ))
 	( -765 -3251 -11 ) 			("South Western Sector") 		(( -63.875 )::( 1599.875 ))
 	( -1102 -3744 -21 ) 			("South Western Sector") 		(( -127.875 )::( 1599.875 ))
 	( -1037 -3118 46 ) 			("Riverside") 				(( -47.875 )::( 1599.875 ))
 	( -1017 -2906 46 ) 			("Riverside") 				(( -63.875 )::( 1599.875 ))
 	( -836 -2990 -46 ) 			("Riverside") 				(( -159.875 )::( 1599.875 ))
 	( -551 -3116 -218 ) 			("Riverside") 				(( -239.875 )::( 1599.875 ))
 	( -1573 -2942 68 ) 			("Riverside Bridge") 			(( -63.875 )::( 1599.875 ))
 	( -1508 -2639 68 ) 			("Riverside Bridge") 			(( -67.029 )::( 1599.875 ))
 	( -1198 -2306 0 ) 			("Riverside Bridge") 			(( -119.382 )::( 1599.875 ))
 	( -1084 -2112 0 ) 			("Riverside Bridge") 			(( -127.875 )::( 1599.875 ))
 	( 124 -3167 -60 ) 			("Riverside") 				(( -151.875 )::( 1599.875 ))
 	( 120 -2937 -60 ) 			("Riverside") 				(( -151.875 )::( 1599.875 ))
 	( -67 -2712 -60 ) 			("Riverside") 				(( -151.875 )::( 1599.875 ))
 	( -256 -2596 -60 ) 			("Riverside") 				(( -151.875 )::( 1599.875 ))
 	( -518 -2457 -139 ) 			("Riverside") 				(( -199.026 )::( 1599.875 ))
 	( -421 -2208 -17 ) 			("Riverside") 				(( -123.073 )::( 1599.875 ))
 	( -269 -2088 -17 ) 			("Riverside") 				(( -87.875 )::( 87.875 ))
 	( -1420 -2102 -6 ) 			("Riverside Bridge") 			(( -109.616 )::( 1599.875 ))
 	( -1709 -2351 -6 ) 			("Riverside Bridge") 			(( -65.083 )::( 1599.875 ))
 	( -1861 -2662 -6 ) 			("Riverside Bridge") 			(( -55.875 )::( 1599.875 ))
 	( -2586 534 119 ) 			("German Camp") 				(( 8.125 )::( 1599.875 ))
 	( -3007 459 119 ) 			("German Camp")	 			(( 0.125 )::( 1599.875 ))
 	( -2876 -168 119 ) 			("German Camp") 				(( 0.125 )::( 1599.875 ))
 	( -2423 -330 119 ) 			("German Camp") 				(( 0.125 )::( 1599.875 ))
 	( -2440 -1075 119 ) 			("German Camp") 				(( 8.125 )::( 1599.875 ))
 	( -3638 -834 119 ) 			("German Camp") 				(( 0.125 )::( 1599.875 ))
 	( -4049 -357 119 ) 			("German Camp") 				(( 0.125 )::( 1599.875 ))
 	( -3409 -294 119 ) 			("German Camp") 				(( 0.125 )::( 1599.875 ))
 	( -3903 366 119 ) 			("German Camp") 				(( 0.125 )::( 1599.875 ))
 	( -3181 226 84 ) 				("German Camp") 				(( 0.125 )::( 1599.875 ))
 	( 1944 -3188 365 ) 			("Officer's Residence") 		(( 321.125 )::( 475.875 ))
 	( 1739 -3040 365 ) 			("Officer's Residence") 		(( 320.125 )::( 479.875 ))
 	( 1597 -3142 410 ) 			("Southern Sector") 			(( 320.125 )::( 1599.875 ))
 	( 1281 -3136 229 ) 			("Southern Sector") 			(( 112.125 )::( 1599.875 ))
 	( 1109 -2746 229 ) 			("Southern Sector") 			(( 112.125 )::( 1599.875 ))
 	( 591 -2491 229 ) 			("Southern Sector") 			(( 112.125 )::( 1599.875 ))
 	( 668 -2049 153 )			 	("Southern Sector") 			(( 112.125 )::( 295.875 ))
 	( 316 -2191 153 ) 			("Southern Sector") 			(( 112.125 )::( 1599.875 ))
 	( 313 -1596 211 ) 			("Southern Sector") 			(( 112.125 )::( 1599.875 ))
 	( 4 -1410 211 ) 				("Southern Sector") 			(( 112.125 )::( 1599.875 ))
 	( -46 -1097 218 ) 			("Axis Alarm House") 			(( 137.125 )::( 351.875 ))
 	( 84 -1038 218 ) 				("Axis Alarm House") 			(( 137.125 )::( 351.875 ))
 	( -2843 -2650 112 ) 			("Piano House 1st Flr") 		(( 9.125 )::( 207.875 ))
 	( -3025 -2459 112 ) 			("Piano House 1st Flr") 		(( 8.125 )::( 207.875 ))
 	( -3194 -2688 112 ) 			("Piano House 1st Flr") 		(( 8.125 )::( 191.875 ))
 	( -2858 -2475 112 )			("Piano House 1st Flr") 		(( 9.125 )::( 207.875 ))
 	( -3416 -2373 67 ) 			("Piano House 1st Flr") 		(( 9.125 )::( 175.875 ))
 	( -2929 -2066 67 ) 			("Piano House 1st Flr") 		(( 9.125 )::( 183.875 ))
 	( -3071 -2056 298 ) 			("Piano House 2nd Flr") 		(( 193.125 )::( 407.875 ))
 	( -3178 -1666 298 ) 			("Piano House 2nd Flr") 		(( 240.125 )::( 407.875 ))
 	( -2839 -2244 298 ) 			("Piano House 2nd Flr") 		(( 240.125 )::( 415.875 ))
 	( -2851 -1891 298 ) 			("Piano House 2nd Flr") 		(( 240.125 )::( 747.143 ))
 	( -2949 -1671 298 ) 			("Piano House 2nd Flr") 		(( 240.125 )::( 1599.875 ))
 	( -3178 -1527 298 ) 			("Piano House 2nd Flr") 		(( 240.125 )::( 1599.875 ))
 	( -2954 -2957 259 )			("Teleport House") 			(( 200.125 )::( 367.875 ))
 	( -2933 -3172 259 ) 			("Teleport House Balcony") 		(( 196.125 )::( 1599.875 ))
 	( -2722 -3092 259 ) 			("Teleport House Balcony") 		(( 196.125 )::( 1599.875 ))
 	( -2718 -2893 259 ) 			("Teleport House Balcony") 		(( 196.125 )::( 1599.875 ))
 	( -65 -431 217 ) 				("South Eastern Sector") 		(( 112.125 )::( 1599.875 ))
 	( -347 -681 156 ) 			("South Eastern Sector") 		(( 120.125 )::( 279.875 ))
 	( -230 -1079 219 ) 			("South Eastern Sector") 		(( 120.125 )::( 1599.875 ))
 	( -406 -1150 219 ) 			("South Eastern Sector") 		(( 112.125 )::( 1599.875 ))
 	( -476 -1425 219 ) 			("Eastern Sector") 			(( 112.125 )::( 1599.875 ))
 	( -1059 -1423 306 ) 			("Eastern Sector") 			(( 161.891 )::( 1599.875 ))
 	( -1521 -1387 306 ) 			("Eastern Sector") 			(( 112.125 )::( 1599.875 ))
 	( -1600 -778 262 ) 			("Eastern Sector") 			(( 71.299 )::( 1599.875 ))
 	( -1313 -709 194 ) 			("Eastern Sector") 			(( 73.259 )::( 1599.875 ))
 	( -1628 -310 194 ) 			("Eastern Sector") 			(( 48.125 )::( 1599.875 ))
 	( -2004 -298 194 ) 			("Eastern Sector") 			(( 27.073 )::( 1599.875 ))
 	( -1038 -1437 -22 ) 			("Eastern Sector") 			(( -127.875 )::( 101.487 ))
 	( -1009 -1840 -22 ) 			("Eastern Sector") 			(( -127.875 )::( 1599.875 ))
 	( -461 -1757 -22 ) 			("Eastern Sector") 			(( -119.875 )::( 1599.875 ))
 	( -561 -1603 127 ) 			("Eastern Sector") 			(( 24.125 )::( 1599.875 ))
 	( -4476 -4497 137 ) 			("Frozen Forest") 			(( 14.434 )::( 1599.875 ))
 	( -4347 -3289 137 ) 			("Frozen Forest") 			(( -0.392 )::( 1599.875 ))
 	( -2839 -3640 49 ) 			("Allied Alarm House") 			(( 9.125 )::( 159.875 ))
 	( -3634 -3233 87 ) 			("Northern Sector") 			(( 0.125 )::( 255.211 ))
 	( -3209 -3299 87 ) 			("Northern Sector") 			(( 0.125 )::( 1599.875 ))
 	( -2878 -3143 87 ) 			("Northern Sector") 			(( 8.125 )::( 187.875 ))
 	( -2617 -2810 87 ) 			("Northern Sector") 			(( 0.125 )::( 1599.875 ))
 	( -2624 -2347 87 ) 			("Northern Sector") 			(( 0.125 )::( 1599.875 ))
 	( -2652 -1771 87 ) 			("Northern Sector") 			(( 0.125 )::( 1599.875 ))
 	( -2762 -1372 87 ) 			("Northern Sector") 			(( 0.125 )::( 1599.875 ))
 	( -3647 -1325 87 )			("Northern Sector") 			(( 8.125 )::( 1599.875 ))
 	( -3149 -1352 87 ) 			("Northern Sector") 			(( 8.125 )::( 1599.875 ))
 	( -2393 -2580 59 ) 			("Northern Sector") 			(( 8.125 )::( 159.875 ))
 	( -2584 -3238 59 ) 			("Northern Sector") 			(( 0.125 )::( 1599.875 ))
 	( -2034 -3235 59 ) 			("Northern Sector") 			(( -24.022 )::( 1599.875 ))
 	( -2349 -3407 35 ) 			("Northern Sector") 			(( 0.125 )::( 167.875 ))
 	( 183 -3440 -67 ) 			("Southern Mansion 1st Flr") 		(( -126.875 )::( 39.875 ))
 	( 90 -3764 -47 ) 				("Southern Mansion 1st Flr") 		(( -126.875 )::( 39.875 ))
 	( 430 -3698 -47 ) 			("Southern Mansion 1st Flr") 		(( -127.875 )::( 63.875 ))
 	( 451 -3372 128 ) 			("Southern Mansion 2nd Flr") 		(( 64.125 )::( 207.875 ))
 	( 600 -3219 128 ) 			("Southern Mansion 2nd Flr") 		(( 65.125 )::( 231.875 ))
 	( 630 -3593 128 ) 			("Southern Mansion 2nd Flr") 		(( 64.125 )::( 231.875 ))
 	( 816 -3234 128 ) 			("Southern Mansion 2nd Flr") 		(( 65.125 )::( 231.875 ))
 	( 860 -3511 128 ) 			("Southern Mansion 2nd Flr") 		(( 64.125 )::( 207.875 ))
 	( 1289 -3398 193 ) 			("Southern Mansion 3rd Flr") 		(( 137.125 )::( 303.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 114)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
m2l1_lib:
//=============================================

	level.AIR_landmark = makeArray

 	( -445 -3653 541 ) 			("Southeast Sector") 			(( 483.658 )::( 2111.875 ))
 	( -671 -2897 541 ) 			("Southeast Sector") 			(( 448.125 )::( 2111.875 ))
 	( -855 -2271 541 ) 			("Southeast Sector") 			(( 450.865 )::( 2111.875 ))
 	( -1319 -1865 541 ) 			("Southeast Sector") 			(( 490.356 )::( 2111.875 ))
 	( -2115 -1794 541 ) 			("Southeast Sector") 			(( 483.197 )::( 2111.875 ))
 	( -2401 -1741 541 ) 			("Southeast Sector") 			(( 458.931 )::( 2111.875 ))
 	( -1488 -3709 622 ) 			("Southeast Sector") 			(( 584.125 )::( 2111.875 ))
 	( -1715 -2330 565 ) 			("Southeast Sector") 			(( 483.996 )::( 2111.875 ))
 	( -1680 -3330 596 ) 			("Southeast Sector") 			(( 470.297 )::( 2111.875 ))
 	( -5321 -3271 608 ) 			("Southeast Sector") 			(( 462.324 )::( 2111.875 ))
 	( -1687 -3507 649 ) 			("Entrance Bldg") 			(( 584.125 )::( 759.875 ))
 	( -1831 -3611 649 ) 			("Entrance Bldg") 			(( 584.125 )::( 759.875 ))
 	( -1595 -3698 649 ) 			("Entrance Bldg") 			(( 584.125 )::( 759.875 ))
 	( -2094 -3620 586 ) 			("Southeast Sector") 			(( 475.142 )::( 2111.875 ))
 	( -144 -3040 595 ) 			("East Sector") 				(( 448.125 )::( 2111.875 ))
 	( -310 -3754 685 ) 			("East Sector") 				(( 488.125 )::( 2111.875 ))
 	( -532 -2452 580 ) 			("East Sector") 				(( 448.125 )::( 2111.875 ))
 	( -599 -1932 580 ) 			("East Sector") 				(( 488.542 )::( 2111.875 ))
 	( 97 -1189 580 ) 				("East Sector") 				(( 450.727 )::( 2111.875 ))
 	( 523 -1185 580 ) 			("East Sector") 				(( 448.125 )::( 2111.875 ))
 	( 228 -2196 628 ) 			("East Sector") 				(( 448.125 )::( 2111.875 ))
 	( 1536 -2943 628 )			("East Sector") 				(( 448.125 )::( 2111.875 ))
 	( 1959 -2845 601 ) 			("East Sector") 				(( 476.726 )::( 2111.875 ))
 	( 1588 -2184 601 ) 			("East Sector") 				(( 483.492 )::( 2111.875 ))
 	( 923 -1516 601 ) 			("East Sector") 				(( 487.436 )::( 2111.875 ))
	( 3283 -2549 604 ) 			("Northeast Sector") 			(( 448.125 )::( 2111.875 ))
 	( 3350 -1901 604 ) 			("Northeast Sector") 			(( 490.261 )::( 2111.875 ))
 	( 3245 -1397 604 ) 			("Northeast Sector") 			(( 448.125 )::( 2111.875 ))
 	( 3349 -831 604 ) 			("Northeast Sector") 			(( 448.125 )::( 2111.875 ))
 	( 3455 -449 604 ) 			("Northeast Sector") 			(( 494.565 )::( 2111.875 ))
 	( 4176 -399 604 ) 			("Northeast Sector") 			(( 494.276 )::( 2111.875 ))
 	( 4757 -431 604 ) 			("Northeast Sector") 			(( 491.814 )::( 2111.875 ))
 	( 5386 -465 604 ) 			("Northeast Sector") 			(( 453.946 )::( 2111.875 ))
 	( 5814 -750 604 ) 			("Northeast Sector") 			(( 475.352 )::( 2111.875 ))
 	( 3852 -1339 604 ) 			("Northeast Sector") 			(( 448.125 )::( 2111.875 ))
 	( 5673 -1644 651 ) 			("Northeast Sector") 			(( 536.125 )::( 2111.875 ))
 	( -2338 -1574 581 ) 			("South Sector") 				(( 463.656 )::( 2111.875 ))
 	( -2099 -1589 581 ) 			("South Sector") 				(( 484.836 )::( 2111.875 ))
 	( -1079 -1690 581 ) 			("South Sector") 				(( 448.125 )::( 2111.875 ))
 	( -582 -1633 581 ) 			("South Sector") 				(( 477.119 )::( 2111.875 ))
 	( -572 -1063 581 ) 			("South Sector") 				(( 478.926 )::( 2111.875 ))
 	( -779 -162 581 ) 			("South Sector") 				(( 448.125 )::( 2111.875 ))
 	( -822 651 581 ) 				("South Sector") 				(( 480.446 )::( 2111.875 ))
 	( -711 1573 581 ) 			("South Sector") 				(( 448.125 )::( 2111.875 ))
 	( -852 2508 581 ) 			("South Sector") 				(( 484.181 )::( 2111.875 ))
 	( -911 3147 615 ) 			("South Sector") 				(( 473.741 )::( 2111.875 ))
 	( -1766 2167 605 ) 			("South Sector") 				(( 448.125 )::( 2111.875 ))
 	( -1570 63 605 ) 				("South Sector") 				(( 448.125 )::( 2111.875 ))
 	( -1825 -1146 618 ) 			("South Sector") 				(( 449.813 )::( 2111.875 ))
 	( 684 -804 640 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( -353 -713 640 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( -311 -161 640 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( -469 1027 640 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( -362 2286 640 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( -564 3124 640 )  			("Centre Sector") 			(( 473.244 )::( 2111.875 ))
 	( 105 1254 640 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( 890 1288 640 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( 1648 1511 640 )  			("Centre Sector") 			(( 489.679 )::( 2111.875 ))
 	( 1634 2559 558 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( 3608 2736 558 )  			("Centre Sector") 			(( 516.530 )::( 2111.875 ))
 	( 2590 1496 652 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( 3611 1400 652 )  			("Centre Sector") 			(( 484.125 )::( 2111.875 ))
 	( 3524 518 652 )  			("Centre Sector") 			(( 484.125 )::( 2111.875 ))
 	( 3060 -257 679 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( 2247 -374 586 )  			("Centre Sector") 			(( 448.125 )::( 733.966 ))
 	( 1707 99 625 )  				("Centre Sector") 			(( 482.508 )::( 2111.875 ))
 	( 428 352 631 )  				("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( 1250 819 631 )  			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( -441 1783 569 ) 			("Centre Sector") 			(( 448.125 )::( 2111.875 ))
 	( 2413 -695 568 )  			("East Sector") 				(( 448.125 )::( 781.948 ))
 	( 2948 -816 568 )  			("East Sector") 				(( 448.125 )::( 2111.875 ))
 	( 2915 -1476 568 )  			("East Sector") 				(( 448.125 )::( 2111.875 ))
 	( 3092 -2614 568 )  			("East Sector") 				(( 448.125 )::( 2111.875 ))
 	( 2179 -1650 665 )  			("East Sector") 				(( 487.044 )::( 2111.875 ))
 	( 2575 -2624 1052 )  			("East Building Roof") 			(( 888.125 )::( 2111.875 ))
 	( 2114 -1995 1052 )  			("East Building Roof") 			(( 888.125 )::( 2111.875 ))
 	( 1373 -1592 1052 )  			("East Building Roof") 			(( 888.125 )::( 2111.875 ))
 	( 1588 -544 1052 )  			("East Building Roof") 			(( 888.125 )::( 2111.875 ))
 	( 931 337 1052 )  			("East Building Roof") 			(( 888.125 )::( 2111.875 ))
 	( 174 1825 977 )  			("Centre Building Roof") 		(( 888.125 )::( 2111.875 ))
 	( 1270 1883 1028 )  			("Centre Building Roof") 		(( 888.125 )::( 2111.875 ))
 	( 227 2755 928 )  			("Centre Building Roof") 		(( 707.702 )::( 2111.875 ))
 	( 1249 2820 928 )  			("Centre Building Roof") 		(( 707.702 )::( 2111.875 ))
 	( 1941 3182 836 )  			("Centre Building Roof") 		(( 707.702 )::( 2111.875 ))
 	( 775 2553 1006 )  			("Centre Building Roof") 		(( 707.702 )::( 2111.875 ))
 	( 2198 2724 641 )  			("Centre Sector") 			(( 495.079 )::( 2111.875 ))
 	( 3049 6895 28 )  			("Complex 1st Flr") 			(( -31.875 )::( 447.875 ))
 	( 3869 7108 28 )  			("Complex 1st Flr") 			(( -31.875 )::( 127.875 ))
 	( 3722 7192 250 )  			("Complex 2nd Flr") 			(( 176.125 )::( 391.875 ))
 	( 4081 6934 228 )  			("Complex 2nd Flr") 			(( 176.125 )::( 447.875 ))
 	( 182 1586 502 ) 				("Centre Bldg Ground Flr") 		(( 448.125 )::( 607.875 ))
 	( 1398 1666 502 ) 			("Centre Bldg Ground Flr") 		(( 448.125 )::( 607.875 ))
 	( 1146 2177 502 ) 			("Centre Bldg Ground Flr") 		(( 448.125 )::( 607.875 ))
 	( 1376 2589 502 ) 			("Centre Bldg Ground Flr") 		(( 448.125 )::( 607.875 ))
 	( 662 3234 502 ) 				("Centre Bldg Ground Flr") 		(( 448.125 )::( 607.875 ))
 	( 1019 2549 502 ) 			("Centre Bldg Ground Flr") 		(( 448.125 )::( 607.875 ))
 	( 645 1926 502 ) 				("Centre Bldg Ground Flr") 		(( 448.125 )::( 607.875 ))
 	( -7 2320 654 ) 				("Centre Bldg 1st Flr") 		(( 624.125 )::( 783.875 ))
 	( 1333 2301 654 ) 			("Centre Bldg 1st Flr") 		(( 624.125 )::( 783.875 ))
 	( 1374 1714 654 ) 			("Centre Bldg 1st Flr") 		(( 624.125 )::( 783.875 ))
 	( 669 1598 654 ) 				("Centre Bldg 1st Flr") 		(( 624.125 )::( 783.875 ))
 	( 177 1872 654 ) 				("Centre Bldg 1st Flr") 		(( 624.125 )::( 783.875 ))
 	( 1051 2019 654 ) 			("Centre Bldg 1st Flr") 		(( 624.125 )::( 783.875 ))
 	( 380 2271 675 ) 				("Centre Bldg 1st Flr") 		(( 624.125 )::( 783.875 ))
 	( 179 5019 275 ) 				("West Sector") 				(( 83.237 )::( 2111.875 ))
 	( 680 6897 275 ) 				("West Sector") 				(( -47.875 )::( 2111.875 ))
 	( 1964 6148 275 ) 			("West Sector") 				(( -63.875 )::( 2111.875 ))
 	( 3185 4411 143 ) 			("West Sector") 				(( -63.875 )::( 2111.875 ))
 	( 3671 6057 143 ) 			("West Sector") 				(( -63.875 )::( 2111.875 ))
 	( 3066 6720 10 ) 				("West Sector") 				(( -31.875 )::( 2111.875 ))
 	( 3722 4182 52 ) 				("West Sector") 				(( -41.693 )::( 2111.875 ))
 	( 3295 3954 52 ) 				("West Sector") 				(( -63.875 )::( 2111.875 ))
 	( 5751 -112 572 ) 			("North Sector") 				(( 498.924 )::( 2111.875 ))
 	( 5049 -126 572 ) 			("North Sector") 				(( 448.125 )::( 2111.875 ))
 	( 4226 -220 572 ) 			("North Sector") 				(( 514.125 )::( 2111.875 ))
 	( 4002 295 572 ) 				("North Sector") 				(( 491.173 )::( 2111.875 ))
 	( 4030 1476 572 ) 			("North Sector") 				(( 480.786 )::( 2111.875 ))
 	( 4061 2668 572 ) 			("North Sector") 				(( 448.125 )::( 2111.875 ))
 	( 4904 2260 332 ) 			("North Sector") 				(( 189.358 )::( 2111.875 ))
 	( 5603 2238 591 ) 			("North Sector") 				(( 494.307 )::( 2111.875 ))
 	( 5207 2268 323 ) 			("North Sector") 				(( 187.389 )::( 2111.875 ))
      ( 3404 3681 69 ) 				("Northwest Sector") 			(( -63.875 )::( 2111.875 ))
 	( 3823 3966 69 ) 				("Northwest Sector") 			(( -53.915 )::( 2111.875 ))
 	( 4153 3032 179 ) 			("Northwest Sector") 			(( -7.289 )::( 2111.875 ))
 	( 4900 2444 255 ) 			("Northwest Sector") 			(( 155.798 )::( 2111.875 ))
 	( 5605 2454 561 ) 			("Northwest Sector") 			(( 490.834 )::( 2111.875 ))
 	( 4478 3555 146 ) 			("Northwest Sector") 			(( -63.875 )::( 2111.875 ))
 	( 4684 969 634 )				("North Sector") 				(( 490.133 )::( 2111.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 128) 
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
m2l3_lib:
//=============================================

	level.AIR_landmark = makeArray

 	( -1735 6492 -186 ) 		 	("Complex Chair Room") 			(( -255.875 )::( -72.125 ))
 	( -1719 6819 -186 ) 			("Complex Chair Room") 			(( -255.875 )::( -72.125 ))
 	( -1462 6887 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -1470 6558 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -1257 6420 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -880 6436 -186 ) 			("Complex 1st Flr")		  	(( -255.875 )::( -72.125 ))
 	( -486 6434 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( 62 6424 -186 ) 			 	("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( 521 6439 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( 949 6432 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( 1085 6174 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( 1088 5789 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -969 6176 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -972 5590 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -963 5273 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -665 6020 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -235 6017 -186 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -630 5860 -247 ) 			("Complex Stairs") 			(( -375.875 )::( -72.125 ))
 	( -508 6052 -400 ) 			("Complex Stairs") 			(( -463.875 )::( -272.125 ))
 	( 15 5312 -152 ) 			 	("Complex 131 Room") 			(( -255.875 )::( -72.125 ))
 	( -391 5042 -152 ) 			("Complex 131 Room") 			(( -255.875 )::( -72.125 ))
 	( -425 5640 -152 ) 			("Complex 131 Room") 			(( -255.875 )::( -72.125 ))
 	( -753 5366 -152 ) 			("Complex 131 Room") 			(( -255.875 )::( -72.125 ))
 	( -683 6816 -152 ) 			("Complex Battery Room") 		(( -255.875 )::( -72.125 ))
 	( -231 6812 -152 ) 			("Complex Battery Room") 		(( -255.875 )::( -72.125 ))
 	( -115 6944 -152 ) 			("Complex Battery Room") 		(( -255.875 )::( -72.125 ))
 	( -515 6671 -152 ) 			("Complex Battery Room") 		(( -255.875 )::( -72.125 ))
 	( 208 6767 -152 ) 			("Complex Electronics Room") 		(( -255.875 )::( -72.125 ))
 	( 417 6711 -152 ) 			("Complex Electronics Room") 		(( -255.875 )::( -72.125 ))
 	( 673 6979 -152 ) 			("Complex Electronics Room") 		(( -255.875 )::( -72.125 ))
 	( 1022 6758 -152 ) 			("Complex Electronics Room")		(( -255.875 )::( -72.125 ))
 	( 796 6158 -173 ) 			("Complex Kitchen") 			(( -255.875 )::( -72.125 ))
 	( 464 6127 -173 ) 			("Complex Kitchen") 			(( -255.875 )::( -72.125 ))
 	( 234 6143 -173 ) 			("Complex Kitchen") 			(( -255.875 )::( -72.125 ))
 	( 801 5345 -173 ) 			("Complex Typewriter Room") 		(( -255.875 )::( -72.125 ))
 	( 258 5315 -173 ) 			("Complex Typewriter Room") 		(( -255.875 )::( -72.125 ))
 	( 541 5541 -173 ) 			("Complex Typewriter Room") 		(( -255.875 )::( -72.125 ))
 	( 887 5739 -173 ) 			("Complex Typewriter Room") 		(( -255.875 )::( -72.125 ))
 	( 255 5903 -173 ) 			("Complex Typewriter Room") 		(( -255.875 )::( -72.125 ))
 	( 684 5869 -173 ) 			("Complex Typewriter Room") 		(( -255.875 )::( -72.125 ))
 	( -954 5912 -152 ) 			("Complex 1st Flr") 			(( -255.875 )::( -72.125 ))
 	( -154 6014 -444 ) 			("Complex Grnd Flr Hall") 		(( -511.875 )::( -272.125 ))
 	( 88 5881 -444 ) 			 	("Complex Grnd Flr Hall") 		(( -511.875 )::( -352.125 ))
 	( 166 6188 -444 ) 			("Complex Grnd Flr Hall") 		(( -511.875 )::( -352.125 ))
 	( 192 6462 -444 ) 			("Complex Grnd Flr Hall") 		(( -511.875 )::( -352.125 ))
 	( 177 5635 -444 ) 			("Complex Grnd Flr Hall") 		(( -511.875 )::( -352.125 ))
 	( 159 5261 -444 ) 		 	("Complex Grnd Flr Hall") 		(( -511.875 )::( -352.125 ))
 	( 160 4855 -444 ) 			("Complex Grnd Flr Hall") 		(( -511.875 )::( -352.125 ))
 	( -89 5390 -444 ) 			("Complex Grnd Flr Storage") 		(( -511.875 )::( -352.125 ))
 	( -100 4797 -444 ) 			("Complex Grnd Flr Storage") 		(( -511.875 )::( -352.125 ))
 	( -170 5691 -444 ) 			("Complex Grnd Flr Storage") 		(( -511.875 )::( -352.125 ))
 	( -401 5201 -444 ) 			("Complex Grnd Flr Storage") 		(( -511.875 )::( -352.125 ))
 	( -423 4766 -444 ) 			("Complex Grnd Flr Storage") 		(( -511.875 )::( -352.125 ))
 	( -509 5641 -444 ) 			("Complex Grnd Flr Storage") 		(( -511.875 )::( -352.125 ))
 	( 1217 3177 -444 ) 			("Complex Garage") 			(( -527.875 )::( 255.875 ))
 	( 329 3188 -444 ) 			("Complex Garage") 			(( -527.875 )::( 223.875 ))
 	( 693 3635 -444 ) 			("Complex Garage") 			(( -527.875 )::( 255.875 ))
 	( 647 4159 -444 ) 			("Complex Garage") 			(( -527.875 )::( 255.875 ))
 	( 1244 4545 -444 ) 			("Complex Garage") 			(( -527.875 )::( 255.875 ))
 	( 172 4619 -444 ) 			("Complex Garage") 			(( -527.875 )::( 255.875 ))
 	( -414 4610 -444 ) 			("Complex Garage") 			(( -527.875 )::( 255.875 ))
 	( -352 3983 -444 ) 			("Complex Garage") 			(( -527.875 )::( 223.875 ))
 	( 226 4253 -444 ) 			("Complex Garage") 			(( -527.875 )::( 255.875 ))
 	( 33 3570 -444 )  			("Complex Garage") 			(( -527.875 )::( 255.875 ))
 	( -281 3267 -444 ) 			("Complex Exitway") 			(( -511.875 )::( -352.125 ))
 	( -283 3649 -444 ) 			("Complex Exitway") 			(( -511.875 )::( -352.125 ))
 	( -501 3618 -444 ) 			("Complex Exitway") 			(( -511.875 )::( -352.125 ))
 	( -487 3222 -444 ) 			("Complex Exitway") 			(( -511.875 )::( -352.125 ))
 	( -2519 -808 -368 ) 			("Train Station") 			(( -447.875 )::( -240.125 ))
 	( -2534 -1373 -368 ) 			("Train Station") 			(( -447.875 )::( -240.125 ))
 	( -2007 -2045 -368 ) 			("Train Station") 			(( -511.875 )::( 1855.875 ))
 	( -2012 -1309 -368 ) 			("Train Station") 			(( -511.875 )::( 1855.875 ))
 	( -2025 -585 -368 ) 			("Train Station") 			(( -511.875 )::( 1855.875 ))
 	( -440 2931 -455 ) 			("Snow Sector") 				(( -506.931 )::( 1855.875 ))
 	( -11 2885 -455 ) 			("Snow Sector") 				(( -504.298 )::( 1855.875 ))
 	( -960 1629 -398 ) 			("Snow Sector") 				(( -461.179 )::( 1855.875 ))
 	( -186 1618 -398 ) 			("Snow Sector") 				(( -466.047 )::( 1855.875 ))
 	( -571 1205 -398 ) 			("Snow Sector") 				(( -468.902 )::( 1855.875 ))
 	( 276 682 -398 ) 			 	("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( -27 70 -398 ) 			 	("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( -61 -1347 -398 ) 			("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( 390 -1891 -398 ) 			("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( -680 -1698 -398 ) 			("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( -670 -603 -398 ) 			("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( -1545 -1503 -398 ) 			("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( -1527 -474 -398 ) 			("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( -1351 475 -398 ) 			("Snow Sector") 				(( -511.875 )::( 1855.875 ))
 	( -2421 93 -398 ) 			("Snow Sector") 				(( -511.875 )::( 1855.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 88)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

//=============================================
m4l3_lib:
//=============================================

	level.AIR_landmark = makeArray
 	( -5514 -2936 -30 ) 			("South Sector") 				(( -115.495 )::( 1023.875 ))
 	( -5045 -3012 -30 ) 			("South Sector") 				(( -177.955 )::( 1023.875 ))
 	( -4586 -2810 -30 ) 			("South Sector") 				(( -124.931 )::( 1023.875 ))
 	( -4737 -1937 -30 ) 			("South Sector") 				(( -135.875 )::( 1023.875 ))
 	( -3768 -1436 79 ) 			("South Sector") 				(( 3.643 )::( 1023.875 ))
 	( -4244 -1624 79 ) 			("South Sector") 				(( -58.839 )::( 1023.875 ))
 	( -5519 -1040 89 ) 			("South Sector") 				(( -33.982 )::( 1023.875 ))
 	( -6196 -960 156 ) 			("South Sector") 				(( 15.505 )::( 1023.875 ))
 	( -5080 -1115 49 ) 			("South Sector") 				(( -87.972 )::( 1023.875 ))
 	( -4627 -380 79 ) 			("Encampment") 				(( -60.951 )::( 1023.875 ))
 	( -6216 -694 157 ) 			("Encampment") 				(( 22.460 )::( 1023.875 ))
 	( -5199 -211 64 ) 			("Encampment") 				(( -78.584 )::( 1023.875 ))
 	( -4453 863 109 ) 			("Encampment") 				(( 6.979 )::( 1023.875 ))
 	( -4141 1226 109 ) 			("Encampment") 				(( -6.293 )::( 1023.875 ))
 	( -4116 2049 109 ) 			("Encampment") 				(( 2.125 )::( 1023.875 ))
 	( -4090 2940 109 ) 			("Encampment") 				(( -6.005 )::( 1023.875 ))
 	( -5959 2948 109 ) 			("Encampment") 				(( -4.071 )::( 1023.875 ))
 	( -3887 2965 92 ) 			("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( -3883 2037 92 ) 			("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( -3943 1240 92 ) 			("West Sector") 				(( -0.399 )::( 1023.875 ))
 	( -3039 1575 92 ) 			("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( -1760 1710 92 ) 			("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( -733 1744 92 ) 				("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( -166 1921 92 ) 				("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( -1377 2020 92 ) 			("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( -2505 1930 92 ) 			("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( 37 2615 99 ) 				("West Sector") 				(( 2.125 )::( 1023.875 ))
 	( 401 2592 99 ) 				("Northwest Sector") 			(( 2.125 )::( 1023.875 ))
 	( 642 1702 99 ) 				("Northwest Sector") 			(( 2.125 )::( 1023.875 ))
 	( 1256 1183 99 ) 				("Northwest Sector") 			(( 41.756 )::( 1023.875 ))
 	( 1776 1411 128 ) 			("Northwest Sector") 			(( -44.648 )::( 1023.875 ))
 	( 1051 933 129 ) 				("North Sector") 				(( -13.450 )::( 1023.875 ))
 	( 993 55 129 ) 				("North Sector") 				(( -45.875 )::( 1023.875 ))
 	( 1078 -757 129 ) 			("North Sector") 				(( -46.138 )::( 1023.875 ))
 	( 1439 -1371 90 ) 			("North Sector") 				(( -66.380 )::( 1023.875 ))
 	( 1810 953 139 ) 				("North Sector") 				(( -38.411 )::( 1023.875 ))
 	( -831 -2011 152 ) 			("Northeast Sector") 			(( -7.102 )::( 1023.875 ))
 	( 627 -1656 105 ) 			("Northeast Sector") 			(( -65.813 )::( 1023.875 ))
 	( 1389 -1608 48 ) 			("Northeast Sector") 			(( -85.081 )::( 1023.875 ))
 	( -158 -2481 128 ) 			("Northeast Sector") 			(( 1.443 )::( 1023.875 ))
 	( -6059 -3094 26 ) 			("Southeast Sector") 			(( -86.900 )::( 1023.875 ))
 	( -5565 -3082 -37 ) 			("Southeast Sector") 			(( -141.328 )::( 1023.875 ))
 	( -4936 -3129 -37 ) 			("Southeast Sector") 			(( -190.814 )::( 1023.875 ))
 	( -4462 -2985 -37 ) 			("Southeast Sector") 			(( -164.022 )::( 1023.875 ))
 	( -4256 -2238 15 ) 			("Southeast Sector") 			(( -76.473 )::( 1023.875 ))
 	( -3922 -1807 74 ) 			("Southeast Sector") 			(( -29.767 )::( 1023.875 ))
 	( -3523 -2269 74 ) 			("Southeast Sector") 			(( -10.253 )::( 1023.875 ))
 	( -2998 -2689 74 ) 			("Southeast Sector") 			(( -6.538 )::( 1023.875 ))
 	( -2991 -3227 -42 ) 			("Southeast Sector") 			(( -258.088 )::( 1023.875 ))
 	( -2951 -3590 -204 ) 			("Southeast Sector") 			(( -316.500 )::( 1023.875 ))
 	( -3071 -4242 -192 ) 			("Southeast Sector") 			(( -308.387 )::( 1023.875 ))
 	( -3161 -4687 -192 ) 			("Southeast Sector") 			(( -308.265 )::( 1023.875 ))
 	( -3431 -5241 -192 ) 			("Southeast Sector") 			(( -308.879 )::( 1023.875 ))
 	( -3681 -5837 -192 ) 			("Southeast Sector") 			(( -306.448 )::( 1023.875 ))
 	( -2728 -2864 58 ) 			("East Sector") 				(( -24.915 )::( 1023.875 ))
 	( -2783 -3396 -205 ) 			("East Sector") 				(( -283.140 )::( 1023.875 ))
 	( -2750 -4204 -205 ) 			("East Sector") 				(( -317.994 )::( 1023.875 ))
 	( -2947 -4971 -251 ) 			("East Sector") 				(( -322.322 )::( 1023.875 ))
 	( -3270 -5690 -251 ) 			("East Sector") 				(( -315.212 )::( 1023.875 ))
 	( -2048 -2804 60 ) 			("East Sector") 				(( 9.532 )::( 1023.875 ))
 	( -1581 -2891 60 ) 			("East Sector") 				(( 7.491 )::( 1023.875 ))
 	( -2494 -2424 139 ) 			("Centre Sector") 			(( 17.911 )::( 1023.875 ))
 	( -3037 -1951 139 ) 			("Centre Sector") 			(( -11.696 )::( 1023.875 ))
 	( -3358 -1362 139 ) 			("Centre Sector") 			(( 16.840 )::( 1023.875 ))
 	( -4239 -641 139 ) 			("Centre Sector") 			(( -3.177 )::( 1023.875 ))
 	( -4166 11 139 ) 				("Centre Sector") 			(( -16.622 )::( 1023.875 ))
 	( -4129 837 139 ) 			("Centre Sector") 			(( 1.586 )::( 1023.875 ))
 	( -3507 1350 139 ) 			("Centre Sector") 			(( 2.125 )::( 1023.875 ))
 	( -2467 1395 139 ) 			("Centre Sector") 			(( 2.125 )::( 1023.875 ))
 	( -1327 1472 139 ) 			("Centre Sector") 			(( -25.624 )::( 1023.875 ))
 	( -261 1420 139 ) 			("Centre Sector") 			(( -32.315 )::( 1023.875 ))
 	( 540 981 139 ) 				("Centre Sector") 			(( -31.477 )::( 1023.875 ))
 	( 741 103 139 ) 				("Centre Sector") 			(( -45.875 )::( 1023.875 ))
 	( 777 -974 139 ) 				("Centre Sector") 			(( -59.891 )::( 1023.875 ))
 	( 626 -1513 139 ) 			("Centre Sector") 			(( -64.423 )::( 1023.875 ))
 	( -72 -225 0 ) 				("Centre Sector") 			(( -44.267 )::( 1023.875 ))
 	( -615 596 139 ) 				("Centre Sector") 			(( -209.973 )::( 1023.875 ))
 	( -1478 413 139 ) 			("Centre Sector") 			(( -13.875 )::( 1023.875 ))
 	( -3577 175 139 ) 			("Centre Sector") 			(( 2.125 )::( 1023.875 ))
 	( -2907 -1066 139 ) 			("Centre Sector") 			(( -13.875 )::( 1023.875 ))
 	( -1979 -1997 139 ) 			("Centre Sector") 			(( -17.544 )::( 1023.875 ))
 	( -1434 -2462 139 ) 			("Centre Sector") 			(( 10.125 )::( 1023.875 ))
 	( -1660 -1759 139 ) 			("Centre Sector") 			(( -39.875 )::( 1023.875 ))
 	( -1404 -567 40 ) 			("Centre Sector") 			(( -39.875 )::( 1023.875 ))
 	( -1563 -431 40 ) 			("Centre Sector") 			(( -39.875 )::( 1023.875 ))
 	( -2449 190 40 ) 				("Centre Sector") 			(( 0.718 )::( 1023.875 ))
 	( -1169 67 48 ) 				("Centre Sector") 			(( -39.875 )::( 1023.875 ))
 	( -372 -756 48 ) 				("Centre Sector") 			(( 0.125 )::( 1023.875 ))
 	( -649 -779 48 ) 				("North Bldg Ground Flr") 		(( 0.125 )::( 384.138 ))
 	( -715 -1550 48 ) 			("North Bldg Ground Flr")		(( 0.125 )::( 191.875 ))
 	( -943 61 48 ) 				("North Bldg Ground Flr") 		(( 0.125 )::( 159.875 ))
 	( -500 -336 48 ) 				("North Bldg Ground Flr") 		(( 0.125 )::( 191.875 ))
 	( -982 -197 48 ) 				("North Bldg Ground Flr") 		(( 0.125 )::( 191.875 ))
 	( -1085 -762 156 ) 			("North Bldg Stairwell") 		(( 128.125 )::( 415.875 ))
 	( -826 -506 280 ) 			("North Bldg 1st Flr") 			(( 200.125 )::( 415.875 ))
 	( -1072 -140 280 ) 			("North Bldg 1st Flr") 			(( 208.125 )::( 383.875 ))
 	( -87 -245 280 ) 				("North Bldg 1st Flr") 			(( 208.125 )::( 383.875 ))
 	( -563 104 280 ) 				("North Bldg 1st Flr") 			(( 209.125 )::( 383.875 ))
 	( -1088 -1185 280 ) 			("North Bldg 1st Flr") 			(( 208.125 )::( 383.875 ))
 	( -550 -1551 280 ) 			("North Bldg 1st Flr") 			(( 208.125 )::( 383.875 ))
 	( 17 -1425 280 ) 				("North Bldg 1st Flr") 			(( 208.125 )::( 375.875 ))
 	( 300 -1503 280 ) 			("North Bldg 1st Flr") 			(( 208.125 )::( 383.875 ))
 	( 298 -1229 280 ) 			("North Bldg 1st Flr") 			(( 208.125 )::( 383.875 ))
 	( -1410 -818 61 ) 			("Centre Bldg Ground Flr") 		(( 0.125 )::( 175.875 ))
 	( -1585 -1413 61 )			("Centre Bldg Treasury") 		(( 0.125 )::( 175.875 ))
 	( -1438 -1212 61 ) 			("Centre Bldg Treasury") 		(( 0.125 )::( 175.875 ))
 	( -1741 -1464 61 ) 			("Centre Bldg Ground Flr") 		(( 0.125 )::( 175.875 ))
	( -2225 -1520 61 ) 			("Centre Bldg Ground Flr") 		(( 0.125 )::( 511.875 ))
 	( -2471 -1090 61 ) 			("Centre Bldg Stairwell") 		(( 136.125 )::( 447.875 ))
 	( -2503 -1140 242 ) 			("Centre Bldg 1st Flr") 		(( 200.125 )::( 447.875 ))
 	( -1700 -145 242 ) 			("Centre Bldg 1st Flr") 		(( 200.125 )::( 383.875 ))
 	( -1762 -520 242 ) 			("Centre Bldg 1st Flr") 		(( 200.125 )::( 375.875 ))
 	( -1711 -942 242 ) 			("Centre Bldg 1st Flr") 		(( 200.125 )::( 399.875 ))
 	( -1674 -1353 242 ) 			("Centre Bldg 1st Flr") 		(( 200.125 )::( 391.875 ))
 	( -1636 -1096 479 ) 			("Centre Bldg Attic") 			(( 408.125 )::( 575.875 ))
 	( -2648 187 60 ) 				("South Bldg Ground Flr") 		(( 16.125 )::( 175.875 ))
 	( -3119 332 60 ) 				("South Bldg Ground Flr") 		(( 16.125 )::( 175.875 ))
 	( -3005 569 60 ) 				("South Bldg Ground Flr") 		(( 16.125 )::( 363.875 ))
 	( -2800 -112 60 ) 			("South Bldg Ground Flr") 		(( 16.125 )::( 191.875 ))
 	( -1852 -31 48 ) 				("South Bldg Ground Flr") 		(( -31.875 )::( 151.875 ))
 	( -1743 -472 48 ) 			("South Bldg Ground Flr") 		(( -31.875 )::( 175.875 ))
 	( -2757 231 -116 ) 			("South Bldg Basement") 		(( -191.875 )::( -8.125 ))
 	( -3039 455 -116 ) 			("South Bldg Basement") 		(( -191.875 )::( -8.125 ))
 	( -2894 566 287 ) 			("South Bldg 1st Flr") 			(( 216.125 )::( 383.875 ))
 	( -2811 115 287 ) 			("South Bldg 1st Flr") 			(( 216.125 )::( 399.875 ))
 	( -2771 -239 287 ) 			("South Bldg 1st Flr") 			(( 216.125 )::( 399.875 ))
 	( -3131 330 287 ) 			("South Bldg 1st Flr") 			(( 216.125 )::( 399.875 ))
 	( -3108 -246 287 ) 			("South Bldg 1st Flr") 			(( 216.125 )::( 383.875 ))
 	( -2941 -55 287 ) 			("South Bldg 1st Flr") 			(( 216.125 )::( 399.875 ))

	endArray

	waitframe

	if (level.AIR_landmark.size == 129)
		local.loaded = "1"
	else
		local.loaded = "0"

end local.loaded

```

# xyz_Airborne_Mod\global\AIR_Multi_UsePlane.scr

```scr
/*
======================================================
*** AIRborne; Flying Airplane Script for MoH:AA
======================================================
by Sor
Version: v1.2 (Multi-seats & Use-to-Exit)
-----------------------------------

======================================================
*/

// ==========================================================================================================================	//
setup local.trigger_origin local.tag local.model local.speed local.accel local.path1 local.path2 local.path3: //local.plane_origin local.plane_angles 
// ==========================================================================================================================	//

	/////////////////
	// RESOLVE NILs
	/////////////////

	// Parse path entries
	if (local.path1 == NULL || local.path1 == NIL)
	{
		println "[AIR Multi-UsePlane::spawn]: Invalid plane path (Make sure it's an targetname array)!"
		end
	}

	if (local.trigger_origin == NIL)
	{
		println "[AIR Multi-UsePlane::spawn]: Invalid trigger origin!"
		end
	}

	if (local.model == NIL || local.model == "")
	{
		local.model = "vehicles/c47fly.tik"
	}

	if (local.speed == NIL)
	{
		local.speed = 950
	}
	if (local.accel == NIL)
	{
		local.accel = 200
	}

	/////////////////
	// Set correct array entry
	/////////////////
	if (level.AIR_MUsePlane == NIL)
		local.i = 1
	else
		local.i = level.AIR_MUsePlane.size + 1
	


	/////////////////
	// SPAWN TRIGGER
	/////////////////
	level.AIR_MUsePlane[local.i] = spawn trigger_multiple
	level.AIR_MUsePlane[local.i].origin = local.trigger_origin
	level.AIR_MUsePlane[local.i] setsize ( -30 -30 -30 ) ( 30 30 30 )
	level.AIR_MUsePlane[local.i] setthread global/AIR_Multi_UsePlane.scr::triggered
	if (local.tag != NIL && local.tag != "")
	{
		level.AIR_MUsePlane[local.i].tag = local.tag
	}
	
	// Set flying properties
	level.AIR_MUsePlane[local.i].flyspeed = local.speed
	level.AIR_MUsePlane[local.i].accel = local.accel


	/////////////////
	// SETUP PATHS
	/////////////////
	level.AIR_MUsePlane[local.i].path[1] = local.path1
	if (local.path2 != NIL)
	{
		level.AIR_MUsePlane[local.i].path[2] = local.path2
	}
	if (local.path3 != NIL)
	{
		level.AIR_MUsePlane[local.i].path[3] = local.path3
	}

	/////////////////
	//spawn plane icon
	/////////////////
	level.AIR_MUsePlane[local.i].icon = spawn script_model model local.model
	level.AIR_MUsePlane[local.i].icon.origin = local.trigger_origin
	if (local.model == "vehicles/c47fly.tik")
	{
		level.AIR_MUsePlane[local.i].icon scale 0.06
	}
	else 
	{
		level.AIR_MUsePlane[local.i].icon scale 0.1
	}
	level.AIR_MUsePlane[local.i].icon notsolid
	level.AIR_MUsePlane[local.i].icon thread spin

	/////////////////
	// Spawn orb
	/////////////////
	level.AIR_MUsePlane[local.i].icon1 = spawn script_model model "static/corona_util.tik"
	level.AIR_MUsePlane[local.i].icon1.origin = local.trigger_origin - ( 0 0 30 )
	level.AIR_MUsePlane[local.i].icon1 light 1 1 1 0

	/////////////////
	//spawn plane
	/////////////////
	level.AIR_MUsePlane[local.i].plane = spawn script_model model local.model
	level.AIR_MUsePlane[local.i].plane.origin = local.path1.origin //local.plane_origin
	level.AIR_MUsePlane[local.i].plane.angles = local.path1.angles //local.plane_angles
	level.AIR_MUsePlane[local.i].plane notsolid

	/////////////////
	//spawn helper script_origin
	/////////////////
	level.AIR_MUsePlane[local.i].helper = spawn script_origin
	level.AIR_MUsePlane[local.i].helper.origin = level.AIR_MUsePlane[local.i].plane.origin
	level.AIR_MUsePlane[local.i].helper glue level.AIR_MUsePlane[local.i].plane

	/////////////////
	//spawn seats:
	/////////////////
	local.origin_dev[1] = ( 60 90 70 )
	local.origin_dev[2] = ( -80 80 70 )
	local.origin_dev[3] = ( -190 75 70 )
	local.origin_dev[4] = ( 60 -90 70 )
	local.origin_dev[5] = ( -80 -80 70 )
	local.origin_dev[6] = ( -190 -75 70 )

	for (local.a = 1; local.a <= 6; local.a++)
	{
		level.AIR_MUsePlane[local.i].seat[local.a] = spawn script_origin
		level.AIR_MUsePlane[local.i].seat[local.a].origin = level.AIR_MUsePlane[local.i].plane.origin + local.origin_dev[local.a]
		level.AIR_MUsePlane[local.i].seat[local.a] bind level.AIR_MUsePlane[local.i].helper
		level.AIR_MUsePlane[local.i].seat[local.a] notsolid
	}

	level.AIR_MUsePlane[local.i].seats_taken = 0
	level.AIR_MUsePlane[local.i] thread global/AIR_Multi_UsePlane.scr::wait_for_departure

end

// ==================================================	//
// This controls the players in the plane. 		//
// --------------------------------------------------	//
triggered:								//
// ==================================================	//

	local.player = parm.other

	if (self.seats_taken == 6 || self.leaving_in == 0)
	{
		local.player iprint "Plane is about to take off, wait to catch the next one!"
		wait 2
		end
	}
	if (local.player.in_plane == 1 || local.player.in_seat == 1)
	{
		end
	}

	//glue player to his seat
	for (local.f = 1; local.f <= self.seat.size; local.f++)
	{
		if (self.seat[local.f].taken != 1 && local.player.in_seat != 1)
		{
			local.player.origin = self.seat[local.f].origin
			local.player bind self.seat[local.f]

			self.seat[local.f].taken = 1
			local.player.in_seat = 1
			local.seat = self.seat[local.f]
			break
		}
	}

	self.seats_taken++

	//apply player properties
	local.player waitthread flight_properties
	local.team = local.player.dmteam 

	if (self.leaving_in == NIL || self.leaving_in < 5)
	{
		self.leaving_in = 5
	}
	
	// Don't leave until all seats are taken or until we waited long enough
	self.icon1 light 0 1 0 80
	while(self.seats_taken < 6 && self.seats_taken != 0 && self.leaving_in > 0)
	{
		local.player iprint ("The plane will take off in " + self.leaving_in + " seconds.") 1

		// We must display the "taking off" message every second, but
		// that doesn't mean we can't do a few checks to prevent bugs 
		// and errors
		local.time = 0
		while (local.time < 1.00)
		{
			if ( !(isAlive local.player) || local.player.dmteam != local.team )
			{
				local.seat.taken = NIL
				self.seats_taken--
				local.player unbind
				local.player thread jump_properties
				if (self.seats_taken == 0)
				{
					self.icon1 light 1 1 1 0
					self.leaving_in = NIL
				}
				end
			}
			if ( local.player == NIL || local.player == NULL)
			{
				self.seats_taken--
				local.seat.taken = NIL
				if (self.seats_taken == 0)
				{
					self.icon1 light 1 1 1 0
					self.leaving_in = NIL
				}
				end
			}
			if (self.seats_taken == 6 && self.leaving_in <= 0)
			{
				break
			}
			local.time += 0.05
			waitframe
		}

		self.leaving_in -= 1
		wait 0.2
	}
	
	//gates closed
	self.leaving_in = 0
	self nottriggerable
	self.icon1 light 1 0 0 80
	self.icon1 solid

	//wait for plane to leave
	while(self.in_flight != 1)
	{
		wait 0.5
	}

	
	//wait 2
	//while the plane is flying...
	local.player iprint ("Press USE to jump out of the plane")

	while(self.in_flight == 1)
	{
		//let player leave whenever he wants
		if (local.player.useheld == 1)
		{
			local.player waitthread jump_properties
			local.player unbind
			local.player thread jump
			end
		}

		if (local.player.dmteam != local.team)
		{
			local.player unbind
			local.player waitthread jump_properties
			end
		}
		if !(isAlive local.player)
		{
			local.player unbind
			local.player waitthread jump_properties
			end
		}
		if (local.player == NIL || local.player == NULL)
		{
			end
		}
		wait 0.1
	}

	//the plane has reached its destination
	wait 0.1

	//if there's still someone left
	if (local.player.in_seat == 1)
	{
		local.player iprint "End of the line!" 1
		local.player unbind
		local.player waitthread kill_properties
	}

end

// ==================================================	//
// This controls the plane itself. 				//
// --------------------------------------------------	//
wait_for_departure:						//
// ==================================================	//

	self.plane hide

	local.path = self waitthread global/AIR_Multi_UsePlane.scr::choose_path

	self.plane.origin = local.path.origin
	self.plane.angles = local.path.angles

	// reset seats
	self thread relocate_seats

	// Get original origin
	local.orig_pos = self.plane.origin
	local.orig_angles = self.plane.angles

	while(self.leaving_in != 0)
	{
		wait 1
	}
	
	self.plane show
	self.plane loopsound fly_snd
	self.plane flypath local.path self.flyspeed self.accel //950 200
	self.in_flight = 1

	self.plane waitmove

	wait 0.3
	self.in_flight = 0
	self.leaving_in = NIL
	self.seats_taken = 0
	self.plane hide
	self.plane stoploopsound

	// Unoccupy the seats
	for (local.f = 1; local.f <= self.seat.size; local.f++)
	{
		if (self.seat[local.f].taken == 1)
		{
			self.seat[local.f].taken = 0
		}
	}

	//wait till all remaining players are dead
	wait 1

	//reset plane
	self.plane.origin = local.orig_pos
	self.plane.angles = local.orig_angles

	waitframe

	//prepare for new departure
	self triggerable
	self.icon1 light 1 1 1 0
	self.icon1 notsolid
	self thread global/AIR_Multi_UsePlane.scr::wait_for_departure

end

// --------------------------------------------------	//
choose_path:							//
// --------------------------------------------------	//

	if (self.path.size > 1)
	{
		switch ((randomint self.path.size)+1)
		{
			case 1:
				end self.path[1]
			break
			case 2:
				end self.path[2]
			break	
			case 3:	
				end self.path[3]
			break
		}
	}
	else if (self.path.size == 1)
	{
		end self.path[1]
	}

end NIL

// --------------------------------------------------	//
jump:									//
// --------------------------------------------------	//

	local.player = self
	local.player.ejecting = 1
	local.vec = local.player.velocity
	local.velocity_get = -120 //-300

	local.player forcelegsstate STAND
	local.player forcetorsostate STAND

	local.chute = spawn script_model
	local.chute model "models/static/parachute_white_canvas.tik"
	local.chute.origin = ( local.player gettagposition "Bip01 Spine2" )
	local.chute notsolid 
	local.chute attach local.player "Bip01 Spine2" 0 ( 0 0 0 )

	//waitframe
	//waitframe
	local.time = 0
	while( local.player.ejecting == 1 )
	{
		if (local.player.useheld && local.velocity_get > -300)
		{
			local.velocity_get -= 5.0
			local.rn = randomint (20)
			if (local.rn == 10)
			{
				local.player iprint "Loosening parachute..."
			}
		}

		if ( local.player.health > 0)
		{
			local.vec[0] = local.player.velocity[0]
			local.vec[1] = local.player.velocity[1]
			local.vec[2] = local.velocity_get

			local.player.velocity = local.vec
		}
		else
		{
			local.player.ejecting = 0
			local.player.in_para_drop = NIL
			local.chute remove
			end
		}

		if (local.player.dmteam == "spectator")
		{
			local.player.ejecting = 0
			local.player.in_para_drop = NIL
			local.chute remove
			end
		}

		if (local.player == NIL || local.player == NULL)
		{
			local.player.ejecting = NIL
			local.player.in_para_drop = NIL
			local.chute remove
			end
		}
		
		// takes a while before the states find out this player is "falling"
		if( ( local.player getposition ) == "standing" && local.time > 0.30)
		{
			local.player.ejecting = 0
		}
		local.time += 0.05
		waitframe
	}

	local.player.in_para_drop = NIL
	local.player forcelegsstate CROUCH_IDLE
	local.chute detach local.player
	wait .1
	local.player forcelegsstate STAND

	local.chute speed 50
	local.chute movedown 400
	local.chute waitmove
	local.chute remove

end

///////////////////////////////////////
// properties				 //
///////////////////////////////////////

// --------------------------	//
flight_properties:

	self hide
	self notsolid
	self physics_off
	self nodamage
	self.in_plane = 1

end

// --------------------------	//
jump_properties:

	self show
	self solid
	self physics_on
	self takedamage
	self.in_seat = NIL
	self.in_plane = NIL

end

// --------------------------	//
kill_properties:

	self show
	self solid
	self physics_on
	self takedamage
	self.in_seat = NIL
	self.in_plane = NIL
	waitframe
	self kill

end

// --------------------------------------------------	//
spin:									//
// --------------------------------------------------	//

	local.an[0] = 3
	local.an[1] = 4
	local.an[2] = 5

	local.in[0] = 0
	local.in[1] = 0
	local.in[2] = 0

	while(self)
	{
		if (local.turn != 1)
		{
			local.an[0] ++
			local.an[1] ++
			local.an[2] ++
		}
		if (local.turn == 1)
		{
			local.an[0] --
			local.an[1] --
			local.an[2] --
		}
		if (local.an[2] == 10)
		{
			local.turn = 1
		}
		if (local.an[0] == 3)
		{
			local.turn = 0
		}

		for(local.p = 0; local.p <= 10; local.p++)
		{
		
			waitframe

			local.in[0] += local.an[0]
			local.in[1] += local.an[1]
			local.in[2] += local.an[2]

			self.angles = ( local.in[0] local.in[1] local.in[2] )
		}
	}
end

// --------------------------	//
relocate_seats:

	local.origin_dev[1] = ( 60 90 70 )
	local.origin_dev[2] = ( -80 80 70 )
	local.origin_dev[3] = ( -190 75 70 )
	local.origin_dev[4] = ( 60 -90 70 )
	local.origin_dev[5] = ( -80 -80 70 )
	local.origin_dev[6] = ( -190 -75 70 )

	for (local.a = 1; local.a <= 6; local.a++)
	{
		self.seat[local.a].origin = self.plane.origin + local.origin_dev[local.a]
	}
end
```

# xyz_Airborne_Mod\global\AIR_ParaDrop.scr

```scr
/*
======================================================
*** AIRborne; Global Paradrop Script for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/

// --------------------------------------------------------------------	//
create_drop local.origin local.angles local.dest local.team local.tag:
// --------------------------------------------------------------------	//

	// 
	// Check all the inserted values...
	//
	if ( local.team != "axis" && local.team != "allies" )
	{
		println "[AIR Paradrop::Spawn]: Invalid team!"
		end
	}
	if (local.origin == NIL)
	{
		println "[AIR Paradrop::Spawn]: Invalid origin values!"
		end	
	}
	if (local.angles == NIL)
	{
		println "[AIR Paradrop::Spawn]: Invalid angles values!"
		end
	}
	if (local.dest == NIL)
	{
		println "[AIR Paradrop::Spawn]: Invalid destination origin values!"
		end
	}

	// 
	// Set certain values according to the entered Team
	//
	if (local.team == "axis" )
	{
		local.model = "models/vehicles/fockwulf.tik"
		local.guy = "models/player/german_waffenss_shutze.tik"
		local.plane_scale = 0.1
		local.other_angles = ( 0 0 0 )
	}
	else if (local.team == "allies")
	{
		local.model = "models/vehicles/c47fly.tik"
		local.guy = "models/player/allied_airborne.tik"
		local.plane_scale = 0.06
		local.other_angles = ( 0 0 0 )
	}	

	// 
	// Handle Array
	//
	if (level.AIR_paradrop == NIL)
	{
		local.i = 1
	}
	else if (level.AIR_paradrop != NIL)
	{
		local.i = level.AIR_paradrop.size + 1
	}
	
	//Spawn Plane Icon
	level.AIR_paradrop[local.i][1] = spawn script_model
	level.AIR_paradrop[local.i][1] model local.model
	level.AIR_paradrop[local.i][1].origin = local.origin
	level.AIR_paradrop[local.i][1].angles = local.angles
	level.AIR_paradrop[local.i][1].scale = local.plane_scale
	level.AIR_paradrop[local.i][1] notsolid
	level.AIR_paradrop[local.i][1] ghost

	//Spawn Chute Icon
	level.AIR_paradrop[local.i][2] = spawn script_model
	level.AIR_paradrop[local.i][2] model "models/static/parachute.tik"
	level.AIR_paradrop[local.i][2].origin = local.origin - ( 0 0 30 )
	level.AIR_paradrop[local.i][2].angles = local.other_angles
	level.AIR_paradrop[local.i][2].scale = .2
	level.AIR_paradrop[local.i][2] notsolid
	level.AIR_paradrop[local.i][2] ghost

	//Spawn Player Icon
	level.AIR_paradrop[local.i][3] = spawn script_model
	level.AIR_paradrop[local.i][3] model local.guy
	level.AIR_paradrop[local.i][3].origin = local.origin - ( 0 0 60 )
	level.AIR_paradrop[local.i][3].angles = local.other_angles
	level.AIR_paradrop[local.i][3].scale = .3
	level.AIR_paradrop[local.i][3] notsolid
	level.AIR_paradrop[local.i][3] ghost
	level.AIR_paradrop[local.i][3] rotatey 360

	//Spawn Trigger
	level.AIR_paradrop[local.i][4] = spawn trigger_multiple
	level.AIR_paradrop[local.i][4].origin = local.origin - ( 0 0 60 )
	level.AIR_paradrop[local.i][4] setsize ( -40 -40 -10 ) ( 40 40 10 ) 
	level.AIR_paradrop[local.i][4] setthread drop

	// Add destination value to array
	level.AIR_paradrop[local.i][5] = local.dest

	if (local.tag != NIL)
	{
		level.AIR_paradrop[local.i][6] = local.tag
	}
end
	
// --------------------------------------------------------------------	//
drop:
// --------------------------------------------------------------------	//

	self waittill trigger
	local.player = parm.other

	if (local.player.in_para_drop != 0 && local.player.in_para_drop != NIL )
	{
		end
	}

	for (local.a = 1; local.a <= level.AIR_paradrop.size; local.a++)
	{
 		if (level.AIR_paradrop[local.a][4] == self)
		{
			local.index = local.a
			local.player tele level.AIR_paradrop[local.a][5]
		}
	}
	if (local.index == NIL)
	{
		end
	}

	local.player.in_para_drop = local.index
	local.player.ejecting = 1
	local.vec = local.player.velocity
	local.velocity_get = -120 //-250

	local.player forcelegsstate STAND
	local.player forcetorsostate STAND

	local.chute = spawn script_model
	local.chute model "models/static/parachute_white_canvas.tik"
	local.chute.origin = ( local.player gettagposition "Bip01 Spine2" )
	local.chute notsolid 
	local.chute attach local.player "Bip01 Spine2" 0 ( 0 0 0 )

	//waitframe
	//waitframe
	local.time = 0
	while( local.player.ejecting == 1 )
	{
		if (local.player.useheld && local.velocity_get > -300)
		{
			local.velocity_get -= 5.0
			local.rn = randomint (20)
			if (local.rn == 10)
			{
				local.player iprint "Loosening parachute..."
			}
		}

		if ( local.player.health > 0)
		{
			local.vec[0] = local.player.velocity[0]
			local.vec[1] = local.player.velocity[1]
			local.vec[2] = local.velocity_get

			local.player.velocity = local.vec
		}
		else
		{
			local.player.ejecting = 0
			local.player.in_para_drop = NIL
			local.chute remove
			end
		}

		if (local.player.dmteam == "spectator")
		{
			local.player.ejecting = 0
			local.player.in_para_drop = NIL
			local.chute remove
			end
		}

		if (local.player == NIL || local.player == NULL)
		{
			local.player.ejecting = NIL
			local.player.in_para_drop = NIL
			local.chute remove
			end
		}
		
		// takes a while before the states find out this player is "falling"
		if( ( local.player getposition ) == "standing" && local.time > 0.30)
		{
			local.player.ejecting = 0
		}
		local.time += 0.05
		waitframe
	}

	local.player.in_para_drop = NIL
	local.player forcelegsstate CROUCH_IDLE
	local.chute detach local.player
	wait .1
	local.player forcelegsstate STAND

	local.chute speed 50
	local.chute movedown 400
	local.chute waitmove
	local.chute remove

end

// --------------------------------------------------------------------	//
disable_drop local.tag:
// --------------------------------------------------------------------	//

	if (level.AIR_paradrop == NIL)
	{
		println "[AIR Paradrop::disable]: The level.AIR_paradrop array doesn't exist!"
		end
	}

	local.hidden = 0

	for (local.b = 1; local.b <= level.AIR_paradrop.size; local.b++)
	{
		if (local.tag != NIL)
		{
			if (level.AIR_paradrop[local.b][6] != NIL && level.AIR_paradrop[local.b][6] == local.tag)
			{
				local.hidden++
				level.AIR_paradrop[local.b][1] hide
				level.AIR_paradrop[local.b][2] hide
				level.AIR_paradrop[local.b][3] hide
				level.AIR_paradrop[local.b][4] hide
				level.AIR_paradrop[local.b][4] nottriggerable
			}
		}
		else if (local.tag == NIL)
		{
			level.AIR_paradrop[local.b][1] hide
			level.AIR_paradrop[local.b][2] hide
			level.AIR_paradrop[local.b][3] hide
			level.AIR_paradrop[local.b][4] hide
			level.AIR_paradrop[local.b][4] nottriggerable
		}
		wait 0.01
	}

	if (local.hidden != 0)
	{
		println ("[AIR Paradrop::disable]: " + local.hidden + " Paradrop triggers hidden and disabled!")
	}
	else if (local.hidden == 0)
	{	
		println ("[AIR Paradrop::disable]: " + local.b + " Paradrop triggers hidden and disabled!")
	}

end


// --------------------------------------------------------------------	//
enable_drop local.tag:
// --------------------------------------------------------------------	//

	if (level.AIR_paradrop == NIL)
	{
		println "[AIR Paradrop::enable]: The level.AIR_paradrop array doesn't exist!"
		end
	}

	local.shown = 0

	for (local.b = 1; local.b <= level.AIR_paradrop.size; local.b++)
	{
		if (local.tag != NIL)
		{
			if (level.AIR_paradrop[local.b][6] != NIL && level.AIR_paradrop[local.b][6] == local.tag)
			{
				local.shown++
				level.AIR_paradrop[local.b][1] show
				level.AIR_paradrop[local.b][2] show
				level.AIR_paradrop[local.b][3] show
				level.AIR_paradrop[local.b][4] show
				level.AIR_paradrop[local.b][4] triggerable
			}
		}
		else if (local.tag == NIL)
		{
			level.AIR_paradrop[local.b][1] show
			level.AIR_paradrop[local.b][2] show
			level.AIR_paradrop[local.b][3] show
			level.AIR_paradrop[local.b][4] show
			level.AIR_paradrop[local.b][4] triggerable
		}
		wait 0.01
	}

	if (local.shown != 0)
	{
		println ("[AIR Paradrop::enable]: " + local.shown + " Paradrop triggers shown and enabled!")
	}
	else if (local.shown == 0)
	{	
		println ("[AIR Paradrop::enable]: " + local.b + " Paradrop triggers shown and enabled!")
	}

end

// -------------------------------- //
del local.tag: 
// -------------------------------- //

	if (level.AIR_paradrop == NIL)
	{
		println "[AIR Paradrop::delete]: The level.AIR_paradrop array doesn't exist or already has been deleted!"
		end
	}

	local.asize = level.AIR_paradrop.size

	for (local.b = 1; local.b <= local.asize; local.b++)
	{
		if (local.tag != NIL)
		{
			if (level.AIR_paradrop[local.b][6] != NIL && level.AIR_paradrop[local.b][6] == local.tag)
			{
				level.AIR_paradrop[local.b][1] delete
				level.AIR_paradrop[local.b][2] delete
				level.AIR_paradrop[local.b][3] delete
				level.AIR_paradrop[local.b][4] delete
				level.AIR_paradrop[local.b][5] = NIL
				level.AIR_paradrop[local.b][6] = NIL

				level.AIR_paradrop[local.b] = NIL
			}
		}
		else if (local.tag == NIL)
		{
			level.AIR_paradrop[local.b][1] delete
			level.AIR_paradrop[local.b][2] delete
			level.AIR_paradrop[local.b][3] delete
			level.AIR_paradrop[local.b][4] delete
			level.AIR_paradrop[local.b][5] = NIL
			level.AIR_paradrop[local.b][6] = NIL

			level.AIR_paradrop[local.b] = NIL
		}

		wait 0.01
	}

	//level.AIR_paradrop delete

	local.newsize = local.asize - level.AIR_paradrop.size

	if (local.newsize == 0)
	{
		println "[AIR Paradrop::delete]: No Paradrop Triggers have been removed."
		end
	}

	println ("[AIR Paradrop::delete]: " + local.newsize + " Paradrop Triggers of the " + local.asize + " have been removed!")

end
```

# xyz_Airborne_Mod\global\AIR_randomexplo.scr

```scr
/*
======================================================
*** AIRborne; Global Explosion Script for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/

// ---------------------------------------
// USE:
// exec global/randomexplo.scr::boom <origin> <"targetname"> <type> <minwait> <maxwait> <dmg_radius> <damage> <quaketime> <quakesize> <quakeradius>
//
// - Origin:( X Y Z )
// - Targetname: Targetname of script_origin
// - type: "ground" or "water" (default: "ground")
// - minwait: value in seconds (default: 13)
// - maxwait: value >= min wait in seconds (default: 23)
// - Damage: value in health points (default: 256)
// - Radius: value in Game Units (default: 384)
// - Quake Time: value in seconds: Duration of quake. (default: 0)
// - Quake Magnitude: Used to set the jitter angles. Example ( 5 2 1 ). (default: ( 0 0 0 ))
// - Quake Radius: value in Game Units. (default: 0)
// ---------------------------------------
boom local.origin local.tn local.type local.minw local.maxw local.rad local.dmg local.eqt local.eqs local.eqr:

	if (local.origin == NIL)
	{
		println "[RandomExplo]: Please define the origin!!!"
		end
	}

	if (local.type == NIL || local.type == "")
		local.type = "ground"

	if (local.minw == NIL || local.minw == 0)
		local.minw = 13

	if (local.maxw == NIL || local.maxw == 0)
		local.maxw = 23
	
	if (local.rad == NIL)
		local.rad = 384
	
	if (local.dmg == NIL)
		local.dmg = 256

	if (local.eqt == NIL)
		local.eqt = 0
	
	if (local.eqs == NIL )
		local.eqs = ( 0 0 0 ) 

	if (local.eqr == NIL)
		local.eqr = 0

	if (local.tn == NIL)
		local.tn = ""

	waitframe
	waitframe

	local.or = spawn script_origin "targetname" local.tn
	local.or.origin = local.origin
	local.or.status = "on"


	if (local.type == "ground" )
	{
		local.exp = spawn models/animate/fx_mortar_dirt.tik
		local.exp.origin = local.origin
	}
	if (local.type == "water")
	{
		local.exp = spawn models/animate/fx_mortar_water.tik
		local.exp.origin = local.origin 
	}

	//************************************************
	// Spawning the Quake - using viewjitter
	// It replaces the earthquake, now the shake is only noticeable in a
	// defined radius and it gets weaker the more you reach the end of the radius
	//************************************************

	local.jitter = spawn func_viewjitter "targetname" "viewjitter" 
	local.jitter.origin = local.origin
	local.jitter jitteramount local.eqs
	local.jitter duration local.eqt
	local.jitter radius local.eqr

	while(local.or.status == "on")
	{
		wait (randomfloat local.minw + local.maxw)
		local.or playsound arty_leadinmp
		wait 1

		local.exp anim start
		radiusdamage local.or local.dmg local.rad
		waitframe

		//************************************************
		// You can only activate the jitter through script
		// Now the jitter function gets activated for $world
		// meaning the current map.
		//************************************************

		local.jitter doActivate $world
	}

	local.exp delete
	local.jitter delete
	local.or delete

end


//----------------------------------------------------------------------
cache:

local.master = spawn ScriptMaster

local.master aliascache arty_leadinmp1 sound/weapons/explo/Exp_LeadIn_06.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "dm obj "
local.master aliascache arty_leadinmp2 sound/weapons/explo/Exp_LeadIn_07.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "dm obj "
local.master aliascache arty_leadinmp3 sound/weapons/explo/Exp_LeadIn_08.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "dm obj "
local.master aliascache arty_leadinmp4 sound/weapons/explo/Exp_LeadIn_09.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "dm obj "
local.master aliascache arty_leadinmp5 sound/weapons/explo/Exp_LeadIn_10.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "dm obj "
local.master aliascache arty_leadinmp6 sound/weapons/explo/Exp_LeadIn_11.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "dm obj "
local.master aliascache arty_leadinmp7 sound/weapons/explo/Exp_LeadIn_12.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "dm obj "
local.master aliascache arty_leadinmp8 sound/weapons/explo/Exp_LeadIn_13.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "dm obj "

local.master aliascache arty_exp_water1 sound/weapons/explo/exp_water_01.wav soundparms 1.0 0.2 0.8 0.4 1000 8000 auto loaded maps "dm obj "
local.master aliascache arty_exp_water2 sound/weapons/explo/exp_water_02.wav soundparms 1.0 0.2 0.8 0.4 1000 8000 auto loaded maps "dm obj "
local.master aliascache arty_exp_water3 sound/weapons/explo/exp_water_03.wav soundparms 1.0 0.2 0.8 0.4 1000 8000 auto loaded maps "dm obj "
end
```

# xyz_Airborne_Mod\global\AIR_SoundTrig.scr

```scr
/*
======================================================
*** AIRborne; Global Soundtrigger Script for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/
sound local.origin local.alias local.team local.wait local.min local.max:

	if (local.alias == NIL)
		end

	if (local.origin == NIL)
		end

	if (local.min == NIL)
		local.min = ( -60 -60 -60)

	if (local.max == NIL)
		local.max = ( 60 60 60)

	local.sound_trigger = spawn trigger_multiple
	local.sound_trigger.origin = local.origin
	local.sound_trigger setsize local.min local.max
	local.sound_trigger setthread x_sound
	local.sound_trigger wait local.wait
	local.sound_trigger delay 0
	local.sound_trigger.sound_alias = local.alias
	local.sound_trigger.team = local.team

end

x_sound:

	local.player = parm.other
	if (local.player.dmteam == self.team || self.team == NIL)
	{
		self playsound self.sound_alias
	}

end
```

# xyz_Airborne_Mod\global\AIR_spawnblock_lib.scr

```scr
/*
======================================================
*** AIRborne; SpawnBlocking Library for MoH:AA
======================================================
by Rindog (Modified & Bundled by Sor)
Version: v1.0
-----------------------------------

======================================================
*/

/*
==============================================================================
					LIBRARY INITIALIZATION
==============================================================================
*/
load_library:

	if (level.AIR_mapscript == NIL)
	{
		level.AIR_mapscript = waitexec global/strings.scr::to_lower (getcvar "mapname")
	}

	if(level.AIR_sb_library_loaded == 1)
	{
		println "[AIR SpawnBlock::Load]: The SpawnBlocks have already been loaded for this map!"
		end
	}

	switch(level.AIR_mapscript)
	{
		case "dm/mohdm1":
		case "dm/mohdm2":
		case "dm/mohdm3":
		case "dm/mohdm4":
		case "dm/mohdm5":
		case "dm/mohdm6":
		case "dm/mohdm7":
			local.map = waitthread get_mapname level.AIR_mapscript 3
			local.execute = ("lib_" + local.map)
		break
		case "obj/team1":
		case "obj/team2":
		case "obj/team3":
		case "obj/team4":
			local.map = waitthread get_mapname level.AIR_mapscript 4
			local.execute = ("lib_" + local.map)
		break
		default:
			local.execute = "failure"
		break
	}

	local.load = waitthread local.execute

	if (local.load == "1")
	{
		level.AIR_sb_library_loaded = 1
		println ("[AIR SpawnBlock::Load]: " + level.AIR_mapscript + "'s SpawnBlocking Library is successfully loaded!")
	}
	else
	{
		println ("[AIR SpawnBlock::Load]: An error has occured when loading this SpawnBlocking Library (" + level.AIR_mapscript + ")!")
	}

end

//=========================================================//
// Get Mapname
// -----------
// This helperthread is used to get the mapname
// without the folder prefix (eg: dm/ and obj/)
//
//=========================================================//
get_mapname local.name local.start:

	local.str = ""
	for (local.i = local.start; local.i < local.name.size; local.i++)
	{
		local.str += local.name[local.i]
	}

end local.str

failure:

	println "[AIR SpawnBlock::Load]: There isn't SpawnBlocking Library made yet for this map."

	local.fail = "0"

end local.fail

show_spawns local.team local.number local.name:

	if (local.team == "allies")
	{
		local.model = "player/allied_airborne.tik"
		local.light = ( 0.4 0.4 1.0 )
	}
	else if (local.team == "axis")
	{
		local.model = "player/german_waffenss_shutze.tik"
		local.light = ( 1.0 0.4 0.4 )
	}
	else
	{
		end
	}

	if (local.number == NIL)
		local.number = 15

	if (local.name == NIL && local.team == "allies")
		local.name = "A"
	else if (local.name == NIL && local.team == "axis")
		local.name = "X"

	for (local.i = 1; local.i <= local.number; local.i++)
	{
		local.spawn = $(local.name + local.i)
		local.dummy = spawn script_model model local.model
		local.dummy.origin = local.spawn.origin
		local.dummy.angle = local.spawn.angle
		local.dummy light local.light[0] local.light[1] local.light[2] 60
		local.dummy notsolid
	}

end

/*
==============================================================================
					SPAWNBLOCKER SETUP
==============================================================================
*/
spawn_block_trigger local.origin:

 	local.trig = spawn trigger_multiple
 	local.trig.origin = local.origin
	local.trig setsize ( -4 -4 -4 ) ( 4 4 4 )
 	local.trig wait 0.2
 	local.trig delay 0.0
 	local.trig setthread spawn_block_trigger_thread
 	local.trig.dummy = spawn fx/dummy.tik
 	local.trig.dummy.origin = local.origin
 	local.trig.dummy setsize ( -1 -1 -1 ) ( 1 1 1 )
 	local.trig.dummy solid

end

spawn_block_trigger_thread:

	local.player = parm.other
	self.dummy notsolid
	while (local.player istouching self)
	{
 		wait .1
	}
	wait 1
	self.dummy solid

end

/*
==============================================================================
					SPAWNBLOCKER LIBRARY
==============================================================================
*/
lib_mohdm1:

	waitthread spawn_block_trigger ( 1192 1568 392 ) 
	waitthread spawn_block_trigger ( 1232 1568 392 ) 
	waitthread spawn_block_trigger ( -216 1232 384 ) 
	waitthread spawn_block_trigger ( -264 1232 384 ) 
	waitthread spawn_block_trigger ( 608 1528 384 ) 
	waitthread spawn_block_trigger ( 912 1336 384 ) 
	waitthread spawn_block_trigger ( 1352 2528 672 ) 
	waitthread spawn_block_trigger ( 1376 2712 672 ) 
	waitthread spawn_block_trigger ( -1208 1112 24 ) 
	waitthread spawn_block_trigger ( -288 1240 48 ) 
	waitthread spawn_block_trigger ( -216 1432 48 ) 
	waitthread spawn_block_trigger ( 1512 2744 392 ) 
	waitthread spawn_block_trigger ( 1512 2680 392 ) 
	waitthread spawn_block_trigger ( 1448 2176 512 ) 
	waitthread spawn_block_trigger ( 1448 2216 512 ) 
	waitthread spawn_block_trigger ( 1176 672 384 ) 
	waitthread spawn_block_trigger ( 1128 640 384 ) 
	waitthread spawn_block_trigger ( 784 792 384 ) 
	waitthread spawn_block_trigger ( 848 792 384 ) 
	waitthread spawn_block_trigger ( -808 376 328 ) 
	waitthread spawn_block_trigger ( -1024 664 168 ) 
	waitthread spawn_block_trigger ( -1056 664 168 ) 
	waitthread spawn_block_trigger ( -1504 480 176 ) 
	waitthread spawn_block_trigger ( -1264 -16 136 ) 
	waitthread spawn_block_trigger ( -928 96 104 ) 
	waitthread spawn_block_trigger ( -848 -344 48 ) 
	waitthread spawn_block_trigger ( 896 -584 0 ) 
	waitthread spawn_block_trigger ( 992 -48 0 ) 
	waitthread spawn_block_trigger ( 1104 -544 256 ) 
	waitthread spawn_block_trigger ( -776 376 328 ) 
	waitthread spawn_block_trigger ( -704 352 -8 ) 
	waitthread spawn_block_trigger ( -864 352 -16 ) 
	waitthread spawn_block_trigger ( -1504 304 176 ) 
	waitthread spawn_block_trigger ( -1176 1064 24 ) 
	waitthread spawn_block_trigger ( -816 -392 48 ) 
	waitthread spawn_block_trigger ( 976 -528 0 ) 
	waitthread spawn_block_trigger ( 992 -104 0 ) 
	waitthread spawn_block_trigger ( 1144 -552 256 ) 
	waitthread spawn_block_trigger ( 912 -96 0 ) 
	waitthread spawn_block_trigger ( -968 96 104 ) 
	waitthread spawn_block_trigger ( -1272 32 136 ) 
	waitthread spawn_block_trigger ( 912 -56 0 ) 
	waitthread spawn_block_trigger ( -648 312 328 )
	waitthread spawn_block_trigger ( -832 352 -16 )
	waitthread spawn_block_trigger ( 976 184 392 )
	waitthread spawn_block_trigger ( 1068 -552 256 )
	waitthread spawn_block_trigger ( 1104 676 384 )
	waitthread spawn_block_trigger ( -672 352 -8 )
	waitthread spawn_block_trigger ( -264 1416 48 )
	waitthread spawn_block_trigger ( 580 1572 384 )
	waitthread spawn_block_trigger ( 816 792 384 )
	waitthread spawn_block_trigger ( 1668 916 232 )
	waitthread spawn_block_trigger ( 1504 2604 396 )
	waitthread spawn_block_trigger ( 48 2960 256 )
	waitthread spawn_block_trigger ( -1264 1864 112 )
	waitthread spawn_block_trigger ( -1296 88 136 )
	waitthread spawn_block_trigger ( -324 1236 384 )
	waitthread spawn_block_trigger ( 1176 1336 384 )
	waitthread spawn_block_trigger ( 976 -592 0 )
	waitthread spawn_block_trigger ( -924 -292 48 )

	local.loaded = "1"

end local.loaded

lib_mohdm2:

	waitthread spawn_block_trigger ( -3352 520 40 ) 
	waitthread spawn_block_trigger ( 208 -2368 0 ) 
	waitthread spawn_block_trigger ( -1648 -3648 16 ) 
	waitthread spawn_block_trigger ( -1888 -3064 -8 ) 
	waitthread spawn_block_trigger ( -2016 -1776 8 ) 
	waitthread spawn_block_trigger ( -3928 -2688 72 ) 
	waitthread spawn_block_trigger ( -2512 -1768 16 ) 
	waitthread spawn_block_trigger ( -2192 -1816 248 ) 
	waitthread spawn_block_trigger ( -2472 -432 24 ) 
	waitthread spawn_block_trigger ( 728 272 -24 ) 
	waitthread spawn_block_trigger ( -904 744 48 ) 
	waitthread spawn_block_trigger ( -2208 784 248 ) 
	waitthread spawn_block_trigger ( -2192 -352 248 ) 
	waitthread spawn_block_trigger ( -3544 -1184 16 ) 
	waitthread spawn_block_trigger ( -3352 568 40 ) 
	waitthread spawn_block_trigger ( -3928 -2624 72 ) 
	waitthread spawn_block_trigger ( -1888 -3136 -8 ) 
	waitthread spawn_block_trigger ( -1888 -3208 -8 ) 
	waitthread spawn_block_trigger ( -1888 -3272 -8 ) 
	waitthread spawn_block_trigger ( -3360 -1184 16 ) 
	waitthread spawn_block_trigger ( -848 496 48 ) 
	waitthread spawn_block_trigger ( -544 480 48 ) 
	waitthread spawn_block_trigger ( 792 216 -24 ) 
	waitthread spawn_block_trigger ( 280 -2256 0 ) 
	waitthread spawn_block_trigger ( -2192 -1776 248 )
	waitthread spawn_block_trigger ( -3928 -2240 96 )
	waitthread spawn_block_trigger ( -2116 -1700 496 )
	waitthread spawn_block_trigger ( -648 -480 104 )
	waitthread spawn_block_trigger ( 264 -2336 0 )
	waitthread spawn_block_trigger ( -1912 -1776 16 )
	waitthread spawn_block_trigger ( 784 272 -24 )
	waitthread spawn_block_trigger ( -3352 480 40 )
	waitthread spawn_block_trigger ( -1872 -3016 -8 )
	waitthread spawn_block_trigger ( -3320 896 64 )
	waitthread spawn_block_trigger ( -3352 616 40 )
	waitthread spawn_block_trigger ( -2200 784 248 )
	waitthread spawn_block_trigger ( -2192 -352 248 )
	waitthread spawn_block_trigger ( -2864 -2912 80 )
	waitthread spawn_block_trigger ( -544 736 64 )
	waitthread spawn_block_trigger ( 264 928 64 )
	waitthread spawn_block_trigger ( -1888 -3344 -8 )
	waitthread spawn_block_trigger ( -2112 -1776 16 )

	local.loaded = "1"

end local.loaded

lib_mohdm3:

	waitthread spawn_block_trigger ( -456 -576 8 ) 
	waitthread spawn_block_trigger ( 4448 -4288 24 ) 
	waitthread spawn_block_trigger ( 432 -16 -32 ) 
	waitthread spawn_block_trigger ( 1576 -1392 -48 ) 
	waitthread spawn_block_trigger ( 504 176 -32 ) 
	waitthread spawn_block_trigger ( 1256 352 -48 ) 
	waitthread spawn_block_trigger ( 2096 -440 -48 ) 
	waitthread spawn_block_trigger ( 472 -1256 -48 ) 
	waitthread spawn_block_trigger ( 1688 -2560 24 ) 
	waitthread spawn_block_trigger ( 1768 -904 -48 ) 
	waitthread spawn_block_trigger ( 1720 -1864 160 ) 
	waitthread spawn_block_trigger ( 1888 -1800 -40 ) 
	waitthread spawn_block_trigger ( 440 -144 -32 ) 
	waitthread spawn_block_trigger ( -448 -328 16 ) 
	waitthread spawn_block_trigger ( 5984 -2552 32 ) 
	waitthread spawn_block_trigger ( 4728 -3560 56 ) 
	waitthread spawn_block_trigger ( 3920 -1408 32 ) 
	waitthread spawn_block_trigger ( 2752 -2096 24 ) 
	waitthread spawn_block_trigger ( 2392 -2000 24 ) 
	waitthread spawn_block_trigger ( 2792 -2224 216 ) 
	waitthread spawn_block_trigger ( 2880 -3840 32 ) 
	waitthread spawn_block_trigger ( 3520 -2288 32 ) 
	waitthread spawn_block_trigger ( 3672 -968 32 ) 
	waitthread spawn_block_trigger ( 4544 -1512 24 ) 
	waitthread spawn_block_trigger ( 4232 -4264 16 ) 
	waitthread spawn_block_trigger ( -472 -384 0 )
	waitthread spawn_block_trigger ( 504 216 -32 )
	waitthread spawn_block_trigger ( 672 -1680 -40 )
	waitthread spawn_block_trigger ( 2552 -2376 24 )
	waitthread spawn_block_trigger ( 3944 -832 24 )
	waitthread spawn_block_trigger ( 4544 -3432 64 )
	waitthread spawn_block_trigger ( 5992 -3024 24 )
	waitthread spawn_block_trigger ( 4624 -1480 24 )
	waitthread spawn_block_trigger ( 3296 -1408 32 )
	waitthread spawn_block_trigger ( 2392 -400 -48 )
	waitthread spawn_block_trigger ( 3928 -4192 24 )

	local.loaded = "1"

end local.loaded

lib_mohdm4:

	waitthread spawn_block_trigger ( 632 3040 920 ) 
	waitthread spawn_block_trigger ( 48 672 64 ) 
	waitthread spawn_block_trigger ( 1576 3112 248 ) 
	waitthread spawn_block_trigger ( 694 1592 28 ) 
	waitthread spawn_block_trigger ( 336 3136 28 ) 
	waitthread spawn_block_trigger ( -812 2452 248 ) 
	waitthread spawn_block_trigger ( -324 3756 658 ) 
	waitthread spawn_block_trigger ( -1256 2824 452 ) 
	waitthread spawn_block_trigger ( 672 2580 674 ) 
	waitthread spawn_block_trigger ( 592 3080 926 ) 
	waitthread spawn_block_trigger ( 816 -1136 486 ) 
	waitthread spawn_block_trigger ( -502 -1384 256 ) 
	waitthread spawn_block_trigger ( -794 -2032 256 ) 
	waitthread spawn_block_trigger ( 848 -2192 244 ) 
	waitthread spawn_block_trigger ( 848 -2384 244 ) 
	waitthread spawn_block_trigger ( -1040 -1132 256 ) 
	waitthread spawn_block_trigger ( -1040 2256 482 ) 
	waitthread spawn_block_trigger ( -528 2032 252 ) 
	waitthread spawn_block_trigger ( 624 2580 280 ) 
	waitthread spawn_block_trigger ( -1340 2492 332 ) 
	waitthread spawn_block_trigger ( -1656 3108 192 ) 
	waitthread spawn_block_trigger ( 1252 1296 80 ) 
	waitthread spawn_block_trigger ( -68 4188 24 ) 
	waitthread spawn_block_trigger ( 784 4588 248 ) 
	waitthread spawn_block_trigger ( -1488 4076 248 ) 
	waitthread spawn_block_trigger ( -1508 884 256 ) 
	waitthread spawn_block_trigger ( -1372 1092 252 ) 
	waitthread spawn_block_trigger ( -1328 2292 252 ) 
	waitthread spawn_block_trigger ( -896 4608 248 ) 
	waitthread spawn_block_trigger ( 468 4336 332 ) 
	waitthread spawn_block_trigger ( 1292 3368 248 ) 
	waitthread spawn_block_trigger ( 1284 -804 192 ) 
	waitthread spawn_block_trigger ( 80 -3024 244 ) 
	waitthread spawn_block_trigger ( -356 1468 736 )
	waitthread spawn_block_trigger ( -2 -34 50 )
	waitthread spawn_block_trigger ( -1030 2348 482 )
	waitthread spawn_block_trigger ( 616 3140 926 )
	waitthread spawn_block_trigger ( -1040 -1168 256 )
	waitthread spawn_block_trigger ( 672 2580 280 )
	waitthread spawn_block_trigger ( -802 3868 544 )
	waitthread spawn_block_trigger ( -1712 3106 194 )
	waitthread spawn_block_trigger ( -1488 4116 248 )
	waitthread spawn_block_trigger ( -1104 3504 456 )
	waitthread spawn_block_trigger ( 1240 1352 80 )
	waitthread spawn_block_trigger ( -486 -1896 256 )
	waitthread spawn_block_trigger ( -832 -2032 256 )
	waitthread spawn_block_trigger ( -1326 880 256 )
	waitthread spawn_block_trigger ( 1284 -770 194 )
	waitthread spawn_block_trigger ( 802 -1064 486 )
	waitthread spawn_block_trigger ( 328 2694 28 )
	waitthread spawn_block_trigger ( -780 2484 248 )
	waitthread spawn_block_trigger ( -688 3568 658 )
	waitthread spawn_block_trigger ( 864 2978 248 )
	waitthread spawn_block_trigger ( 766 4702 248 )
	waitthread spawn_block_trigger ( 128 -2944 240 )
	waitthread spawn_block_trigger ( 872 -1304 256 )
	waitthread spawn_block_trigger ( -1256 2736 448 )
	waitthread spawn_block_trigger ( 1552 1168 256 )
	waitthread spawn_block_trigger ( -488 2008 256 )
	waitthread spawn_block_trigger ( -1358 2254 252 )
	waitthread spawn_block_trigger ( 816 -2480 244 )
	waitthread spawn_block_trigger ( 648 2896 708 )
	waitthread spawn_block_trigger ( 1384 824 70 )
	waitthread spawn_block_trigger ( -1016 1064 736 )
	waitthread spawn_block_trigger ( -632 1064 736 )

	local.loaded = "1"

end local.loaded

lib_mohdm5:

	waitthread spawn_block_trigger ( -1320 -3736 192 ) 
	waitthread spawn_block_trigger ( 4296 -4296 184 ) 
	waitthread spawn_block_trigger ( 5056 -4608 120 ) 
	waitthread spawn_block_trigger ( 5056 -4672 120 ) 
	waitthread spawn_block_trigger ( 4960 -4576 120 ) 
	waitthread spawn_block_trigger ( 4960 -4736 120 ) 
	waitthread spawn_block_trigger ( 5032 -3768 192 ) 
	waitthread spawn_block_trigger ( 5016 -5648 192 ) 
	waitthread spawn_block_trigger ( 4448 -5112 176 ) 
	waitthread spawn_block_trigger ( -1312 -6424 208 ) 
	waitthread spawn_block_trigger ( -1320 -3832 192 ) 
	waitthread spawn_block_trigger ( -1312 -6320 208 ) 
	waitthread spawn_block_trigger ( -1232 -5560 184 ) 
	waitthread spawn_block_trigger ( -1104 -4528 168 ) 
	waitthread spawn_block_trigger ( -664 -5408 160 ) 
	waitthread spawn_block_trigger ( 856 -4824 184 ) 
	waitthread spawn_block_trigger ( 5032 -3848 192 ) 
	waitthread spawn_block_trigger ( 5016 -5568 192 ) 
	waitthread spawn_block_trigger ( -1312 -4824 120 ) 
	waitthread spawn_block_trigger ( -1312 -4952 120 ) 
	waitthread spawn_block_trigger ( -1096 -4376 208 ) 
	waitthread spawn_block_trigger ( -1144 -2432 192 ) 
	waitthread spawn_block_trigger ( -1240 -2544 192 ) 
	waitthread spawn_block_trigger ( -1192 -6656 208 ) 
	waitthread spawn_block_trigger ( -1280 -5400 184 ) 
	waitthread spawn_block_trigger ( -1152 -4784 120 ) 
	waitthread spawn_block_trigger ( -1176 -5016 120 ) 
	waitthread spawn_block_trigger ( 4944 -6648 208 ) 
	waitthread spawn_block_trigger ( 5016 -6400 192 ) 
	waitthread spawn_block_trigger ( 5024 -5232 192 ) 
	waitthread spawn_block_trigger ( 4880 -4792 120 ) 
	waitthread spawn_block_trigger ( 4832 -4536 120 ) 
	waitthread spawn_block_trigger ( 4904 -3496 192 ) 
	waitthread spawn_block_trigger ( 4816 -3792 192 ) 
	waitthread spawn_block_trigger ( 4320 -6760 200 )
	waitthread spawn_block_trigger ( 3968 -2424 200 )
	waitthread spawn_block_trigger ( -944 -2376 192 )
	waitthread spawn_block_trigger ( 2624 -4048 168 )
	waitthread spawn_block_trigger ( 5040 -5392 192 )
	waitthread spawn_block_trigger ( -1304 -3552 192 )
	waitthread spawn_block_trigger ( 4352 -3424 192 )
	waitthread spawn_block_trigger ( 2432 -2376 176 )
	waitthread spawn_block_trigger ( 880 -4688 184 )
	waitthread spawn_block_trigger ( -1288 -4888 192 )
	waitthread spawn_block_trigger ( -816 -6368 208 )
	waitthread spawn_block_trigger ( 2688 -5968 168 )
	waitthread spawn_block_trigger ( -320 -6824 192 )

	local.loaded = "1"

end local.loaded

lib_mohdm6:

	waitthread spawn_block_trigger ( 240 -136 -136 ) 
	waitthread spawn_block_trigger ( -408 -808 48 ) 
	waitthread spawn_block_trigger ( -420 -845 288 ) 
	waitthread spawn_block_trigger ( -632 -610 288 ) 
	waitthread spawn_block_trigger ( -400 792 -136 ) 
	waitthread spawn_block_trigger ( 418 807 -136 ) 
	waitthread spawn_block_trigger ( 244 984 48 ) 
	waitthread spawn_block_trigger ( 236 984 288 ) 
	waitthread spawn_block_trigger ( -432 911 288 ) 
	waitthread spawn_block_trigger ( -432 911 48 ) 
	waitthread spawn_block_trigger ( -408 991 528 ) 
	waitthread spawn_block_trigger ( -312 896 48 ) 
	waitthread spawn_block_trigger ( -312 896 528 ) 
	waitthread spawn_block_trigger ( -280 904 288 ) 
	waitthread spawn_block_trigger ( 248 944 528 ) 
	waitthread spawn_block_trigger ( -1152 -72 512 ) 
	waitthread spawn_block_trigger ( -964 -192 262 ) 
	waitthread spawn_block_trigger ( -484 -610 48 ) 
	waitthread spawn_block_trigger ( 240 -72 -136 ) 
	waitthread spawn_block_trigger ( -400 -720 48 ) 
	waitthread spawn_block_trigger ( -420 -773 288 ) 
	waitthread spawn_block_trigger ( -664 -586 288 ) 
	waitthread spawn_block_trigger ( -400 856 -136 ) 
	waitthread spawn_block_trigger ( 418 871 -136 ) 
	waitthread spawn_block_trigger ( 244 1008 48 ) 
	waitthread spawn_block_trigger ( 236 1008 288 ) 
	waitthread spawn_block_trigger ( -432 935 288 ) 
	waitthread spawn_block_trigger ( -432 935 48 ) 
	waitthread spawn_block_trigger ( -488 991 528 ) 
	waitthread spawn_block_trigger ( -312 960 48 ) 
	waitthread spawn_block_trigger ( -312 984 528 ) 
	waitthread spawn_block_trigger ( -280 968 288 ) 
	waitthread spawn_block_trigger ( 248 1040 528 ) 
	waitthread spawn_block_trigger ( -1152 8 512 ) 
	waitthread spawn_block_trigger ( -964 -168 262 ) 
	waitthread spawn_block_trigger ( -484 -530 48 ) 
	waitthread spawn_block_trigger ( -1136 784 512 ) 
	waitthread spawn_block_trigger ( -1136 848 512 ) 
	waitthread spawn_block_trigger ( -336 -556 -147 ) 
	waitthread spawn_block_trigger ( -336 -492 -147 ) 
	waitthread spawn_block_trigger ( -704 800 -147 ) 
	waitthread spawn_block_trigger ( -624 816 -147 ) 
	waitthread spawn_block_trigger ( 912 -48 -136 ) 
	waitthread spawn_block_trigger ( 848 -48 -136 ) 
	waitthread spawn_block_trigger ( 1072 608 314 ) 
	waitthread spawn_block_trigger ( 1008 608 314 ) 
	waitthread spawn_block_trigger ( -650 -614 48 ) 
	waitthread spawn_block_trigger ( -586 -614 48 ) 
	waitthread spawn_block_trigger ( -1136 785 260 ) 
	waitthread spawn_block_trigger ( -1136 849 260 ) 
	waitthread spawn_block_trigger ( 240 -104 -136 )
	waitthread spawn_block_trigger ( -408 -768 48 )
	waitthread spawn_block_trigger ( -422 -809 288 )
	waitthread spawn_block_trigger ( -632 -578 288 )
	waitthread spawn_block_trigger ( -400 824 -136 )
	waitthread spawn_block_trigger ( 418 839 -136 )
	waitthread spawn_block_trigger ( 244 992 48 )
	waitthread spawn_block_trigger ( 236 992 288 )
	waitthread spawn_block_trigger ( -432 919 288 )
	waitthread spawn_block_trigger ( -432 919 48 )
	waitthread spawn_block_trigger ( -448 991 528 )
	waitthread spawn_block_trigger ( -312 928 48 )
	waitthread spawn_block_trigger ( -312 936 528 )
	waitthread spawn_block_trigger ( -280 936 288 )
	waitthread spawn_block_trigger ( 248 992 528 )
	waitthread spawn_block_trigger ( -1152 -32 512 )
	waitthread spawn_block_trigger ( -964 -184 262 )
	waitthread spawn_block_trigger ( -484 -570 48 )
	waitthread spawn_block_trigger ( -1136 816 512 )
	waitthread spawn_block_trigger ( -336 -524 -147 )
	waitthread spawn_block_trigger ( -664 808 -147 )
	waitthread spawn_block_trigger ( 880 -48 -136 )
	waitthread spawn_block_trigger ( 1040 608 314 )
	waitthread spawn_block_trigger ( -618 -614 48 )
	waitthread spawn_block_trigger ( -1136 817 260 )

	local.loaded = "1"

end local.loaded

lib_mohdm7:

	waitthread spawn_block_trigger ( -2240 -936 -136 ) 
	waitthread spawn_block_trigger ( -2304 -936 -136 ) 
	waitthread spawn_block_trigger ( 816 -1056 -280 ) 
	waitthread spawn_block_trigger ( 896 -1056 -280 ) 
	waitthread spawn_block_trigger ( -1424 1240 -96 ) 
	waitthread spawn_block_trigger ( -1504 1240 -96 ) 
	waitthread spawn_block_trigger ( -3504 3184 288 ) 
	waitthread spawn_block_trigger ( -3504 3152 288 ) 
	waitthread spawn_block_trigger ( 1392 -96 24 ) 
	waitthread spawn_block_trigger ( 1464 -96 24 ) 
	waitthread spawn_block_trigger ( -2448 1656 8 ) 
	waitthread spawn_block_trigger ( -2448 1736 8 ) 
	waitthread spawn_block_trigger ( -1112 1432 -88 ) 
	waitthread spawn_block_trigger ( -1176 1432 -88 ) 
	waitthread spawn_block_trigger ( -3104 1296 8 ) 
	waitthread spawn_block_trigger ( -3024 1296 8 ) 
	waitthread spawn_block_trigger ( -3808 2064 8 ) 
	waitthread spawn_block_trigger ( -3840 2064 8 ) 
	waitthread spawn_block_trigger ( -2016 3216 8 ) 
	waitthread spawn_block_trigger ( -2080 3152 8 ) 
	waitthread spawn_block_trigger ( -2908 784 288 ) 
	waitthread spawn_block_trigger ( -2908 864 288 ) 
	waitthread spawn_block_trigger ( -3176 1232 272 ) 
	waitthread spawn_block_trigger ( -3176 1152 272 ) 
	waitthread spawn_block_trigger ( 592 1680 124 ) 
	waitthread spawn_block_trigger ( 592 1608 124 ) 
	waitthread spawn_block_trigger ( 1904 -1092 32 ) 
	waitthread spawn_block_trigger ( 1904 -1164 32 ) 
	waitthread spawn_block_trigger ( 1684 -912 -284 ) 
	waitthread spawn_block_trigger ( 1612 -912 -284 ) 
	waitthread spawn_block_trigger ( 512 -936 -144 ) 
	waitthread spawn_block_trigger ( 584 -936 -144 ) 
	waitthread spawn_block_trigger ( -3024 482 -94 ) 
	waitthread spawn_block_trigger ( -2938 388 -94 ) 
	waitthread spawn_block_trigger ( -1598 -1430 -270 ) 
	waitthread spawn_block_trigger ( -1598 -1502 -270 ) 
	waitthread spawn_block_trigger ( -1144 1432 -88 )
	waitthread spawn_block_trigger ( 1428 -96 24 )
	waitthread spawn_block_trigger ( -1464 1240 -96 )
	waitthread spawn_block_trigger ( -2272 -936 -136 )
	waitthread spawn_block_trigger ( 856 -1056 -280 )
	waitthread spawn_block_trigger ( -2448 1696 8 )
	waitthread spawn_block_trigger ( -3064 1296 8 )
	waitthread spawn_block_trigger ( -3776 2064 8 )
	waitthread spawn_block_trigger ( -2048 3184 8 )
	waitthread spawn_block_trigger ( -2908 824 288 )
	waitthread spawn_block_trigger ( -3176 1192 272 )
	waitthread spawn_block_trigger ( -3176 1192 272 )
	waitthread spawn_block_trigger ( 592 1644 124 )
	waitthread spawn_block_trigger ( -3504 3216 288 )
	waitthread spawn_block_trigger ( 1904 -1128 32 )
	waitthread spawn_block_trigger ( 548 -936 -144 )
	waitthread spawn_block_trigger ( 1648 -912 -284 )
	waitthread spawn_block_trigger ( -2978 424 -94 )
	waitthread spawn_block_trigger ( -1598 -1466 -270 )

	local.loaded = "1"

end local.loaded

lib_team1:

	waitthread spawn_block_trigger ( -1080 4976 -136 ) 
	waitthread spawn_block_trigger ( -984 5192 -144 ) 
	waitthread spawn_block_trigger ( -896 5424 -152 ) 
	waitthread spawn_block_trigger ( -1128 5200 -136 ) 
	waitthread spawn_block_trigger ( -1104 5328 -152 ) 
	waitthread spawn_block_trigger ( -944 5136 -144 ) 
	waitthread spawn_block_trigger ( -1000 4944 -144 ) 
	waitthread spawn_block_trigger ( -1048 5232 -144 ) 
	waitthread spawn_block_trigger ( -816 5144 -152 ) 
	waitthread spawn_block_trigger ( -1008 5424 -152 ) 
	waitthread spawn_block_trigger ( -1232 5168 -136 ) 
	waitthread spawn_block_trigger ( -912 5040 -128 ) 
	waitthread spawn_block_trigger ( 2304 512 -310 ) 
	waitthread spawn_block_trigger ( 3680 1888 -274 ) 
	waitthread spawn_block_trigger ( 2752 576 -308 ) 
	waitthread spawn_block_trigger ( 3072 1408 -306 ) 
	waitthread spawn_block_trigger ( 3072 832 -318 ) 
	waitthread spawn_block_trigger ( 1056 -1632 -320 ) 
	waitthread spawn_block_trigger ( 1760 -292 -264 ) 
	waitthread spawn_block_trigger ( 992 -1504 -312 ) 
	waitthread spawn_block_trigger ( 2848 -1632 -360 ) 
	waitthread spawn_block_trigger ( 2528 -1312 -344 ) 
	waitthread spawn_block_trigger ( 1888 -480 -268 ) 
	waitthread spawn_block_trigger ( 3456 640 -312 ) 
	waitthread spawn_block_trigger ( 3840 1216 -306 ) 
	waitthread spawn_block_trigger ( 3888 1744 -312 ) 
	waitthread spawn_block_trigger ( -1048 5096 -136 ) 
	waitthread spawn_block_trigger ( -800 5240 -144 ) 
	waitthread spawn_block_trigger ( -816 5344 -144 ) 
	waitthread spawn_block_trigger ( -984 5312 -144 ) 
	waitthread spawn_block_trigger ( 3560 640 -312 ) 
	waitthread spawn_block_trigger ( 2432 448 -310 ) 
	waitthread spawn_block_trigger ( 2464 -1184 -336 ) 
	waitthread spawn_block_trigger ( 1472 -1024 -312 ) 
	waitthread spawn_block_trigger ( -1160 5112 -136 ) 
	waitthread spawn_block_trigger ( -920 5264 -144 ) 

	local.loaded = "1"

end local.loaded

lib_team2:

	waitthread spawn_block_trigger ( -528 944 -440 ) 
	waitthread spawn_block_trigger ( -8 32 16 ) 
	waitthread spawn_block_trigger ( 922 496 8 ) 
	waitthread spawn_block_trigger ( 3072 2416 8 ) 
	waitthread spawn_block_trigger ( 1744 2832 8 ) 
	waitthread spawn_block_trigger ( 1312 2240 -432 ) 
	waitthread spawn_block_trigger ( 1208 2248 8 ) 
	waitthread spawn_block_trigger ( 1216 536 -434 ) 
	waitthread spawn_block_trigger ( 1808 2504 -504 ) 
	waitthread spawn_block_trigger ( 3112 2608 0 ) 
	waitthread spawn_block_trigger ( 2736 816 -504 ) 
	waitthread spawn_block_trigger ( -1688 743 -448 ) 
	waitthread spawn_block_trigger ( -1728 976 -392 ) 
	waitthread spawn_block_trigger ( -1712 559 -448 ) 
	waitthread spawn_block_trigger ( -1584 399 -416 ) 
	waitthread spawn_block_trigger ( -1392 335 -416 ) 
	waitthread spawn_block_trigger ( -1200 399 -416 ) 
	waitthread spawn_block_trigger ( -1456 719 -416 ) 
	waitthread spawn_block_trigger ( -1456 559 -416 ) 
	waitthread spawn_block_trigger ( -1264 591 -416 ) 
	waitthread spawn_block_trigger ( -1264 751 -416 ) 
	waitthread spawn_block_trigger ( 3312 2256 -504 ) 
	waitthread spawn_block_trigger ( 1392 864 0 ) 
	waitthread spawn_block_trigger ( 462 14 -232 ) 
	waitthread spawn_block_trigger ( 632 550 4 ) 
	waitthread spawn_block_trigger ( 744 0 -232 ) 
	waitthread spawn_block_trigger ( 1391 1998 -508 ) 
	waitthread spawn_block_trigger ( -536 256 -440 ) 
	waitthread spawn_block_trigger ( -184 256 -440 ) 
	waitthread spawn_block_trigger ( -472 1320 -440 ) 
	waitthread spawn_block_trigger ( -472 2088 -440 ) 
	waitthread spawn_block_trigger ( -528 1520 -440 ) 
	waitthread spawn_block_trigger ( 1164 1344 -194 )
	waitthread spawn_block_trigger ( 487 788 -210 )
	waitthread spawn_block_trigger ( 1304 1768 -440 )
	waitthread spawn_block_trigger ( 2792 824 -508 )
	waitthread spawn_block_trigger ( 1456 464 4 )
	waitthread spawn_block_trigger ( 2912 2576 4 )
	waitthread spawn_block_trigger ( 1124 1984 4 )
	waitthread spawn_block_trigger ( 900 1928 24 )
	waitthread spawn_block_trigger ( -1680 368 -424 )
	waitthread spawn_block_trigger ( 912 1520 4 )
	waitthread spawn_block_trigger ( 688 1536 4 )
	waitthread spawn_block_trigger ( 444 1352 4 )
	waitthread spawn_block_trigger ( 208 1008 4 )
	waitthread spawn_block_trigger ( 348 576 -230 )

	local.loaded = "1"

end local.loaded

lib_team3:

	waitthread spawn_block_trigger ( -1224 1336 416 ) 
	waitthread spawn_block_trigger ( -1184 -544 256 ) 
	waitthread spawn_block_trigger ( -1088 -544 256 ) 
	waitthread spawn_block_trigger ( 1424 -160 256 ) 
	waitthread spawn_block_trigger ( 1586 -160 256 ) 
	waitthread spawn_block_trigger ( -1000 -536 256 ) 
	waitthread spawn_block_trigger ( 1506 -168 256 ) 
	waitthread spawn_block_trigger ( 104 752 384 ) 
	waitthread spawn_block_trigger ( 296 1176 256 ) 
	waitthread spawn_block_trigger ( 528 1176 256 ) 
	waitthread spawn_block_trigger ( 576 1176 256 ) 
	waitthread spawn_block_trigger ( 112 1552 328 ) 
	waitthread spawn_block_trigger ( 1624 272 64 ) 
	waitthread spawn_block_trigger ( 1768 -448 64 ) 
	waitthread spawn_block_trigger ( 1684 232 -128 ) 
	waitthread spawn_block_trigger ( -664 -5080 -448 ) 
	waitthread spawn_block_trigger ( -676 -5144 -452 ) 
	waitthread spawn_block_trigger ( -732 -5044 -448 ) 
	waitthread spawn_block_trigger ( -604 -5164 -448 ) 
	waitthread spawn_block_trigger ( -612 -4908 -452 ) 
	waitthread spawn_block_trigger ( -532 -5028 -452 ) 
	waitthread spawn_block_trigger ( -460 -4936 -452 ) 
	waitthread spawn_block_trigger ( -340 -5180 -452 ) 
	waitthread spawn_block_trigger ( -228 -5072 -452 ) 
	waitthread spawn_block_trigger ( -128 -5172 -452 ) 
	waitthread spawn_block_trigger ( -20 -5072 -452 ) 
	waitthread spawn_block_trigger ( 76 -5168 -452 ) 
	waitthread spawn_block_trigger ( 156 -5068 -452 ) 
	waitthread spawn_block_trigger ( 260 -5168 -452 ) 
	waitthread spawn_block_trigger ( 332 -5060 -452 ) 
	waitthread spawn_block_trigger ( 580 -5096 -452 ) 
	waitthread spawn_block_trigger ( 508 -5012 -448 ) 
	waitthread spawn_block_trigger ( 572 -5196 -448 ) 
	waitthread spawn_block_trigger ( 2128 -5170 -448 ) 
	waitthread spawn_block_trigger ( 2060 -5154 -452 ) 
	waitthread spawn_block_trigger ( 2128 -5062 -448 ) 
	waitthread spawn_block_trigger ( 2206 -5034 -448 ) 
	waitthread spawn_block_trigger ( 732 -5144 -452 ) 
	waitthread spawn_block_trigger ( 812 -5044 -452 ) 
	waitthread spawn_block_trigger ( 916 -5144 -452 ) 
	waitthread spawn_block_trigger ( 1068 -5036 -452 ) 
	waitthread spawn_block_trigger ( 1148 -5132 -452 ) 
	waitthread spawn_block_trigger ( 1324 -5180 -452 ) 
	waitthread spawn_block_trigger ( 1468 -5148 -452 ) 
	waitthread spawn_block_trigger ( 1548 -5052 -452 ) 
	waitthread spawn_block_trigger ( 1644 -5148 -452 ) 
	waitthread spawn_block_trigger ( 1740 -5036 -452 ) 
	waitthread spawn_block_trigger ( 532 -2356 -312 ) 
	waitthread spawn_block_trigger ( 588 -2308 -312 ) 
	waitthread spawn_block_trigger ( 644 -2268 -312 ) 
	waitthread spawn_block_trigger ( 2244 -2200 -312 ) 
	waitthread spawn_block_trigger ( 2268 -2156 -312 ) 
	waitthread spawn_block_trigger ( 1632 0 -128 ) 
	waitthread spawn_block_trigger ( 1644 112 -128 ) 
	waitthread spawn_block_trigger ( 1744 -264 64 ) 
	waitthread spawn_block_trigger ( 1658 -162 256 ) 
	waitthread spawn_block_trigger ( -928 -544 256 ) 
	waitthread spawn_block_trigger ( 360 1176 256 ) 
	waitthread spawn_block_trigger ( 632 1176 256 ) 
	waitthread spawn_block_trigger ( 224 1176 256 ) 
	waitthread spawn_block_trigger ( 160 1616 328 ) 
	waitthread spawn_block_trigger ( 208 880 384 ) 
	waitthread spawn_block_trigger ( 320 896 384 ) 
	waitthread spawn_block_trigger ( 400 872 384 ) 
	waitthread spawn_block_trigger ( 504 864 384 ) 
	waitthread spawn_block_trigger ( 608 848 384 ) 
	waitthread spawn_block_trigger ( -168 904 360 ) 
	waitthread spawn_block_trigger ( -280 888 360 ) 
	waitthread spawn_block_trigger ( -504 672 360 ) 
	waitthread spawn_block_trigger ( 848 640 384 ) 
	waitthread spawn_block_trigger ( 952 624 384 ) 
	waitthread spawn_block_trigger ( 2316 -2116 -312 ) 
	waitthread spawn_block_trigger ( 476 -2372 -304 ) 
	waitthread spawn_block_trigger ( 3064 2048 344 ) 
	waitthread spawn_block_trigger ( 3112 1984 368 ) 
	waitthread spawn_block_trigger ( 3152 1912 384 ) 
	waitthread spawn_block_trigger ( 3152 1808 384 ) 
	waitthread spawn_block_trigger ( 3144 2120 320 ) 
	waitthread spawn_block_trigger ( 3192 2056 352 ) 
	waitthread spawn_block_trigger ( 3232 1984 376 ) 
	waitthread spawn_block_trigger ( 3232 1880 384 ) 
	waitthread spawn_block_trigger ( 2976 1568 384 ) 
	waitthread spawn_block_trigger ( 3104 1664 384 ) 
	waitthread spawn_block_trigger ( 3024 1680 384 ) 
	waitthread spawn_block_trigger ( 2000 1360 432 ) 
	waitthread spawn_block_trigger ( 1920 1376 432 ) 
	waitthread spawn_block_trigger ( -1208 1272 416 ) 
	waitthread spawn_block_trigger ( -1208 1192 416 ) 
	waitthread spawn_block_trigger ( -1224 1112 416 ) 
	waitthread spawn_block_trigger ( -552 1480 336 ) 
	waitthread spawn_block_trigger ( -400 1408 336 ) 
	waitthread spawn_block_trigger ( -352 1312 336 ) 
	waitthread spawn_block_trigger ( -1056 -208 256 ) 
	waitthread spawn_block_trigger ( -1056 -304 256 ) 
	waitthread spawn_block_trigger ( -1048 -392 256 ) 
	waitthread spawn_block_trigger ( 1840 270 256 ) 
	waitthread spawn_block_trigger ( 1832 350 256 ) 
	waitthread spawn_block_trigger ( 1838 198 256 ) 
	waitthread spawn_block_trigger ( 2188 -2212 -312 ) 
	waitthread spawn_block_trigger ( 2324 -2164 -312 ) 
	waitthread spawn_block_trigger ( 596 -2356 -312 ) 
	waitthread spawn_block_trigger ( 644 -2316 -312 ) 

	local.loaded = "1"

end local.loaded

lib_team4:

	waitthread spawn_block_trigger ( -2474 3050 264 ) 
	waitthread spawn_block_trigger ( -880 -2064 248 ) 
	waitthread spawn_block_trigger ( -880 -2256 248 ) 
	waitthread spawn_block_trigger ( -880 -2480 248 ) 
	waitthread spawn_block_trigger ( -720 -2608 248 ) 
	waitthread spawn_block_trigger ( -560 -2680 248 ) 
	waitthread spawn_block_trigger ( -688 -2192 248 ) 
	waitthread spawn_block_trigger ( -688 -2384 248 ) 
	waitthread spawn_block_trigger ( -144 -2928 248 ) 
	waitthread spawn_block_trigger ( -496 -2544 248 ) 
	waitthread spawn_block_trigger ( -88 -2608 248 ) 
	waitthread spawn_block_trigger ( -240 -2480 248 ) 
	waitthread spawn_block_trigger ( -48 -2352 248 ) 
	waitthread spawn_block_trigger ( 80 -2160 248 ) 
	waitthread spawn_block_trigger ( -240 -2064 248 ) 
	waitthread spawn_block_trigger ( 16 -2000 248 ) 
	waitthread spawn_block_trigger ( 336 -2128 248 ) 
	waitthread spawn_block_trigger ( -2466 2888 264 ) 
	waitthread spawn_block_trigger ( -2188 3056 254 ) 
	waitthread spawn_block_trigger ( -2546 3250 254 ) 
	waitthread spawn_block_trigger ( -2274 3154 262 ) 
	waitthread spawn_block_trigger ( -1936 3184 214 ) 
	waitthread spawn_block_trigger ( -2354 3010 254 ) 
	waitthread spawn_block_trigger ( -2370 3130 262 ) 
	waitthread spawn_block_trigger ( -1904 2992 206 ) 
	waitthread spawn_block_trigger ( -1776 3088 206 ) 
	waitthread spawn_block_trigger ( -2064 3184 238 ) 
	waitthread spawn_block_trigger ( -1976 2920 222 ) 
	waitthread spawn_block_trigger ( -2092 2916 238 ) 
	waitthread spawn_block_trigger ( -3212 3138 338 ) 
	waitthread spawn_block_trigger ( -2466 3184 262 ) 
	waitthread spawn_block_trigger ( -2564 2968 270 ) 
	waitthread spawn_block_trigger ( -3286 3218 338 ) 
	waitthread spawn_block_trigger ( -111 -1390 248 ) 
	waitthread spawn_block_trigger ( -18 -1261 248 ) 
	waitthread spawn_block_trigger ( 86 -1454 248 ) 

	local.loaded = "1"

end local.loaded
```

# xyz_Airborne_Mod\global\AIR_Spawner.scr

```scr
/*
======================================================
*** AIRborne; Global Spawner Script for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/

// -------------------------------------------------------------------------------- //
spawn local.origin local.angles local.model local.solid local.scale local.tag:	//
// -------------------------------------------------------------------------------- //

	if (local.origin == NIL)
	{
		println "[AIR Spawner::Spawn]: Invalid Origin!"
		end
	}

	if (local.model == NIL)
	{
		println "[AIR Spawner::Spawn]: Invalid Model!"
		end	
	}

	if (local.angles == NIL)
	{
		local.angles = ( 0 0 0 )
	}

	if (local.tag != NIL)
	{
		local.tag = ""
	}

	// Initialization
	if (level.AIR_spawner == NIL)
	{
		local.i = 1

		println " "
		println "[AIR Spawner::Spawn]: level.AIR_spawner initialized!!"
		println " "
	}
	else
	{
		local.i = level.AIR_spawner.size + 1
	}

	level.AIR_spawner[local.i] = spawn script_model "targetname" local.tag
	level.AIR_spawner[local.i] model local.model
	level.AIR_spawner[local.i].origin = local.origin
	level.AIR_spawner[local.i].angles = local.angles

	if (local.solid == 0)
	{
		level.AIR_spawner[local.i] notsolid
	}
	else if (local.solid == 1)
	{
		level.AIR_spawner[local.i] solid
	}

	if (local.scale != NIL)
	{
		level.AIR_spawner[local.i].scale = local.scale 
	}

	if (local.tag != NIL)
		level.AIR_spawner[local.i].tag = local.tag

	//println ("[AIR Spawner::Spawn]: Object " + local.i + " has been spawned!")

end

// -------------------------------- //
report: 
// -------------------------------- //

	if (level.AIR_spawner != NIL)
	{
		println "************************************************************************"
		println "[AIR Spawner::Info]: Version 1.1; by Sor"
		println "----------------------------------------------"
		println ("[AIR Spawner::Info]: " + level.AIR_spawner.size + " objects have been spawned!")
		println "************************************************************************"
	}

end
```

# xyz_Airborne_Mod\global\AIR_TeleModel.scr

```scr
/*
======================================================
*** AIRborne; Global TeleportModel Script for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/

telemodel local.origin local.model local.scale local.targetname:

	if (local.origin == NIL)
	{
		println "[AIR TeleModel::Spawn]: Invalid origin!"
		end
	}
	if (local.model == NIL || local.model == "")
	{
		println "[AIR TeleModel::Spawn]: Invalid model!"
		end
	}
	if (local.targetname == NIL || local.targetname == "")
	{
		local.targetname = ""
	}

	if (local.scale == NIL)
		local.scale = 1

	local.portlight = spawn script_model "targetname" local.targetname
	local.portlight model local.model
	local.portlight.origin = local.origin
	local.portlight.scale = local.scale

end local.portlight
```

# xyz_Airborne_Mod\global\AIR_TeleTrig.scr

```scr
/*
======================================================
*** AIRborne; Global TeleportTrigger Script for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/

// --------------------------------------------------------------------------------------	//
teleport local.origin local.dest local.team local.kind local.tag local.neg local.pos:
// --------------------------------------------------------------------------------------	//

	// Checking stuff....
	if (local.origin == NIL)
		{println "[AIR TeleGen::Spawn]: Invalid Origin!"
		end}

	if (local.dest == NIL)
		{println "[AIR TeleGen::Spawn]: Invalid destination!"
		end}

	if (local.neg == NIL)
		local.neg = ( -40 -40 -20)

	if (local.pos == NIL)
		local.pos = ( 40 40 20 )

	if (local.tag == NIL)
		local.tag = ""

	if (level.AIR_teletrig == NIL)
		local.i = 1
	else
		local.i = level.AIR_teletrig.size + 1

	if (local.kind == 1 || local.kind == NIL)
	{
		level.AIR_teletrig[local.i] = spawn trigger_use "targetname" local.tag
	}
	else if (local.kind == 2)
	{
		level.AIR_teletrig[local.i] = spawn trigger_multiple "targetname" local.tag
	}
	level.AIR_teletrig[local.i].origin = local.origin
	level.AIR_teletrig[local.i].team = local.team
	level.AIR_teletrig[local.i].destination = local.dest
	level.AIR_teletrig[local.i] setsize local.neg local.pos
	level.AIR_teletrig[local.i] setthread tele_man
	level.AIR_teletrig[local.i] wait 1

	if (self != NULL)
	{
		level.AIR_teletrig[local.i].telemodel = self
	}

end

tele_man:

	local.player = parm.other

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		if ( (vector_within self.destination $player[local.i].origin 20) == 1)
		{
			local.player iprint "There's someone at the exit point of the trigger!" 1
			end
		}
	}


	if (self.team != NIL)
	{
		if (local.player.dmteam == self.team)
		{
			self nottriggerable
			local.player tele self.destination
		}
		if (local.player.dmteam != self.team)
		{
			end
		}
	}
	if (self.team == NIL)
	{
		self nottriggerable
		local.player tele self.destination
	}

	self triggerable

end

```

# xyz_Airborne_Mod\global\AIR_tower.scr

```scr
/*
======================================================
*** AIRborne; Guard Tower SETUP Script for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/

main local.origin local.mg:

	// Create the Tower Platform
	local.cratelid = spawn script_model "targetname" "cratelid1"
	local.cratelid model "static/cratelid2.tik"
	local.cratelid.origin = local.origin 
	local.cratelid.angles = ( 0 0 180 ) 
	local.cratelid scale 6
	local.cratelid solid
	local.cratelid nodamage

	local.cratelid2 = spawn script_model "targetname" "cratelid2"
	local.cratelid2 model "static/cratelid2.tik"
	local.cratelid2.origin = local.origin 
	local.cratelid2.angles = ( 0 0 182 ) 
	local.cratelid2 scale 6
	local.cratelid2 solid
	local.cratelid2 nodamage

	// Create the Tower Structure
	local.deviations = makeArray
	( -95 -100 0 ) ( -95 -100 -400 )
	( -95 100 0 ) ( -95 100 -400 )
	( 85 -100 0 ) ( 85 -100 -400 )
	( 85 100 0 ) ( 85 100 -400 )
	( 85 -100 0 ) ( -95 -100 -400 )
	( -95 -100 0 ) ( 85 -100 -400 )
	( -95 100 0 ) ( 85 100 -400 )
	( 85 100 0 ) ( -95 100 -400 )
	( 85 100 0 ) ( 85 -100 -400 )
	( 85 -100 0 ) ( 85 100 -400 )
	( 85 100 -200 ) ( -95 -100 -200 )
	( 85 -100 -200 ) ( -95 100 -200 )
	( 85 -100 -200 ) ( -95 -100 -200 )
	( -95 -100 -200 ) ( -95 100 -200 )
	( 85 100 -200 ) ( -95 100 -200 )
 	( 85 100 -200 ) ( 85 -100 -200 )
	( -95 100 0 ) ( -95 -100 0 )
	( 85 100 0 ) ( 85 -100 0 )
	( -95 -100 0 ) ( 85 -100 0 )
	( -95 100 0 ) ( 85 100 0 )
	endArray

	for (local.i = 1; local.i <= local.deviations.size; local.i++)
	{
		local.o = spawn func_beam "origin" ($cratelid1.origin + local.deviations[local.i][1]) "endpoint" ($cratelid1.origin + local.deviations[local.i][2]) "targetname" "tower" 
		local.o shader "textures/barrel/blackbarrel.jpg"
		local.o maxoffset 0
		local.o scale 4
		local.o activate
	}

	// Create the Platform Sandbags
	local.sandbags = makeArray
	( -65 -90 0 ) ( 0 90 0 ) "static/sandbag_link_topcap.tik"
	( 0 -90 0 ) ( 0 90 0 ) "static/sandbag_link_main.tik"
	( 70 -95 0 ) ( 0 -90 0 ) "static/sandbag_link_rightbend.tik"
	( 70 -50 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 25 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 95 0 ) ( 0 90 0 ) "static/sandbag_link_leftbend.tik"
	( 0 90 0 ) ( 0 -90 0 ) "static/sandbag_link_main.tik"
	( -70 90 0 ) ( 0 -270 0 ) "static/sandbag_link_topcap.tik"
      endArray

	for (local.i = 1; local.i <= local.sandbags.size; local.i++)
	{
		local.s = spawn script_model model local.sandbags[local.i][3] "targetname" "tower_sandbags"
		local.s.origin = $cratelid1.origin + local.sandbags[local.i][1]
		local.s.angles = local.sandbags[local.i][2]
		local.s solid
		local.s nodamage
	}

	// Create some stable Support
	local.support = makeArray
	( 0 80 -50 )
	( 0 -80 -50 )
	( 0 0 -50 )
	endArray

	for (local.i = 1; local.i <= local.support.size; local.i++)
	{
		local.t = spawn script_model model "static/planningtable.tik" "targetname" "tower_support"
		local.t.origin = ($cratelid1.origin + local.support[local.i][1])
		local.t.angles = ( 0 -90 0 ) 
		local.t setsize ( -64 -96 0 ) ( 64 96 50 )
		local.t hide
		local.t solid
		local.t nodamage
	}

	// Platform correction
	$cratelid1.origin += ( 20 0 0 )
	$cratelid2.origin += ( -30 0 0 )

	// Create MG
	if (local.mg == 1)
	{
		local.mg42 = spawn "models/statweapons/mg42_gun.tik"
		local.mg42.origin = $cratelid1.origin + ( 35 0 70 )
		local.mg42.angles = ( 0 0 0 )
		local.mg42 maxyawoffset 75

		local.mg42b = spawn script_model model "statweapons/mg42_bipod.tik"
		local.mg42b.origin = local.mg42.origin
		local.mg42b.angles = local.mg42.angles
		local.mg42b solid
	}

end

/****
Setthread for teleporting onto the tower.
Not required to use this.

Your trigger must have the following property:
.destination = ( X Y Z )
*/
tele_tower:

	local.p = parm.other
	self nottriggerable

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		if ($player[local.i] != local.p && (vector_within self.destination $player[local.i].origin 10) == 1)
		{
			local.block = 1
			break
		}
		else if ($player[local.i] != local.p && self.destination == $player[local.i].origin)
		{
			local.block = 1
			break
		}
	}

	if (local.block == 1)
		local.p iprint "You cannot teleport onto the tower at this time. Another player is obstructing the destination spot!"
	else
		local.p tele self.destination

	wait 0.2
	self triggerable
end
```

# xyz_Airborne_Mod\global\AIR_tower2.scr

```scr
/*
======================================================
*** AIRborne; Guard Tower 2 SETUP Script for MoH:AA
======================================================
by Sor 
Version: v1.1 (No top)
-----------------------------------

======================================================
*/

main local.origin:

	// Create the Tower Platform
	local.cratelid = spawn script_model "targetname" "cratelid1"
	local.cratelid model "static/cratelid2.tik"
	local.cratelid.origin = local.origin 
	local.cratelid.angles = ( 0 0 180 ) 
	local.cratelid scale 6
	local.cratelid solid
	local.cratelid nodamage

	local.cratelid2 = spawn script_model "targetname" "cratelid2"
	local.cratelid2 model "static/cratelid2.tik"
	local.cratelid2.origin = local.origin 
	local.cratelid2.angles = ( 0 0 182 ) 
	local.cratelid2 scale 6
	local.cratelid2 solid
	local.cratelid2 nodamage

	// Create the Tower Structure
	local.deviations = makeArray
	( -95 -100 0 ) ( -95 -100 -400 )
	( -95 100 0 ) ( -95 100 -400 )
	( 85 -100 0 ) ( 85 -100 -400 )
	( 85 100 0 ) ( 85 100 -400 )
	( 85 -100 0 ) ( -95 -100 -400 )
	( -95 -100 0 ) ( 85 -100 -400 )
	( -95 100 0 ) ( 85 100 -400 )
	( 85 100 0 ) ( -95 100 -400 )
	( 85 100 0 ) ( 85 -100 -400 )
	( 85 -100 0 ) ( 85 100 -400 )
	( 85 100 -200 ) ( -95 -100 -200 )
	( 85 -100 -200 ) ( -95 100 -200 )
	( 85 -100 -200 ) ( -95 -100 -200 )
	( -95 -100 -200 ) ( -95 100 -200 )
	( 85 100 -200 ) ( -95 100 -200 )
 	( 85 100 -200 ) ( 85 -100 -200 )
	( -95 100 0 ) ( -95 -100 0 )
	( 85 100 0 ) ( 85 -100 0 )
	( -95 -100 0 ) ( 85 -100 0 )
	( -95 100 0 ) ( 85 100 0 )
	endArray

	for (local.i = 1; local.i <= local.deviations.size; local.i++)
	{
		local.o = spawn func_beam "origin" ($cratelid1.origin + local.deviations[local.i][1]) "endpoint" ($cratelid1.origin + local.deviations[local.i][2]) "targetname" "tower" 
		local.o shader "textures/barrel/blackbarrel.jpg"
		local.o maxoffset 0
		local.o scale 4
		local.o activate
	}

	// Create some stable Support
	local.support = makeArray
	( 0 80 -50 )
	( 0 -80 -50 )
	( 0 0 -50 )
	endArray

	for (local.i = 1; local.i <= local.support.size; local.i++)
	{
		local.t = spawn script_model model "static/planningtable.tik" "targetname" "tower_support"
		local.t.origin = ($cratelid1.origin + local.support[local.i][1])
		local.t.angles = ( 0 -90 0 ) 
		local.t setsize ( -64 -96 0 ) ( 64 96 50 )
		local.t hide
		local.t solid
		local.t nodamage
	}

	// Platform correction
	$cratelid1.origin += ( 20 0 0 )
	$cratelid2.origin += ( -30 0 0 )

end

/****
Setthread for teleporting onto the tower.
Not required to use this.

Your trigger must have the following property:
.destination = ( X Y Z )
*/
tele_tower:

	local.p = parm.other
	self nottriggerable

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		if ($player[local.i] != local.p && (vector_within self.destination $player[local.i].origin 10) == 1)
		{
			local.block = 1
			break
		}
		else if ($player[local.i] != local.p && self.destination == $player[local.i].origin)
		{
			local.block = 1
			break
		}
	}

	if (local.block == 1)
		local.p iprint "You cannot teleport onto the tower at this time. Another player is obstructing the destination spot!"
	else
		local.p tele self.destination

	wait 0.2
	self triggerable
end
```

# xyz_Airborne_Mod\global\AIR_view.scr

```scr
/*
======================================================
*** AIRborne; Realism Script for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/

main:

if (level.view_run != 1)
{
	local.master = spawn ScriptMaster
	local.master aliascache inhale sound/characters/gasmask1.wav soundparms 1.0 0.0 1.0 0.0 320 2200 dialog loaded maps "m dm obj train "
	local.master aliascache exhale sound/characters/gasmask2.wav soundparms 1.0 0.0 1.0 0.0 320 2200 dialog loaded maps "m dm obj train "
	level waittill spawn
	thread dm_view
}

end

dm_view:

	if (level.view_run != 1)
	{
		level.view_run = 1
		level.view_p = 0
		level.view_y = 0
		level.view_p_mid = 0
		level.view_y_mid = 0
		level.view_p_high = 0
		level.view_y_high = 0
		level.view_toggle_p = -0.001
		level.view_toggle_y = -0.001
	}
	else
	{
		end
	}

	local.pitch_max = 0.015  //0.015
	local.pitch_jitter = 0.0006 //0.0006
	local.yaw_max = 0.018 
	local.yaw_jitter = 0.0003 //0.0003

	local.AIR_realism = waitthread global/AIR/AIR_Control.scr::get_setting "realism"
	if (local.AIR_realism == 1)
	{
		println "[AIR Realism::view]: Realistic View enabled!"
	}
	
	while (local.AIR_realism == 1)
	{

		local.AIR_realism = level.AIR["realism"]

		if (level.AIR_wintermap == 1 && local.already_cold != 1)
		{
			thread breathe_winter local.AIR_realism
			local.already_cold = 1
		}
	
		waitframe //0.1 //maybe increase
		if(level.view_p > local.pitch_max)
		{
			level.view_toggle_p = -local.pitch_jitter
		}
		else if(level.view_p < -local.pitch_max)
		{
			level.view_toggle_p = local.pitch_jitter
		}

		if(level.view_y > local.yaw_max)
		{
			level.view_toggle_y = -local.yaw_jitter
		}
		else if(level.view_y < -local.yaw_max)
		{
			level.view_toggle_y = local.yaw_jitter
		}

		level.view_p += level.view_toggle_p
		level.view_y += level.view_toggle_y

		level.view_p_mid += level.view_toggle_p * 1.5
		level.view_y_mid += level.view_toggle_y * 1.5

		level.view_p_high += level.view_toggle_p * 2.5
		level.view_y_high += level.view_toggle_y * 2.5

		for (local.p = 1; local.p <= $player.size ;local.p++)
		{
			if ($player[local.p].usingScope == 1 && $player[local.p].useheld == 1)
			{
				if ($player[local.p].holding != 1)
				{
					$player[local.p] thread hold_breath
				}
			}
			else if($player[local.p].health > 50)
			{
				$player[local.p].viewangles =  $player[local.p].viewangles + (level.view_p level.view_y  0)
			}
			else if($player[local.p].health <= 50 && $player[local.p].health > 15)
			{
				$player[local.p].viewangles =  $player[local.p].viewangles + (level.view_p_mid level.view_y_mid  0)
			}
			else if($player[local.p].health <= 15)
			{
				$player[local.p].viewangles =  $player[local.p].viewangles + (level.view_p_high level.view_y_high  0)
			}
		}		 
	}

	level.view_run = 0
	println "[AIR Realism::view]: Realistic View Disabled!"

end

//=======================
breathe_winter:

	local.AIR_realism = waitthread global/AIR/AIR_Control.scr::get_setting "realism"

	while (level.AIR_wintermap == 1 && local.AIR_realism == 1)
	{
		local.AIR_realism = level.AIR["realism"]

		if ($player.size > 0) 
		{
			for(local.i = 1; local.i <= $player.size; local.i++)
			{
				if ($player[local.i].status == "alive" && $player[local.i].dmteam != "spectator")
				{
					$player[local.i] attachmodel models/emitters/breath_steam_emitter.tik "Bip01 Head" 1 1
					wait ((randomfloat 1) + 3.5)
				}
			}
		}
		wait 1.3
	}
end

hold_breath:

	self.holding = 1
	self thread inhale

	while ( self.status == "alive" && (self.useheld) && self.usingScope)
	{
		wait 0.2
	}

	if (self.status == "alive")
	{
		self thread exhale
	}

	self.holding = 0

end

inhale:

	self loopsound inhale
	wait 0.85
	self stoploopsound

end

exhale:

	self loopsound exhale
	wait 4.5
	self stoploopsound

end

```

# xyz_Airborne_Mod\global\AIR_weather.scr

```scr
// AIR Weather
// by Sor

//===============================================
weather_settings:

	level.rain_width = "0.4"
	level.rain_min_dist = 512

	level.startedrainsound1 = 1
	level.startedrainsound2 = 1

	level.farplane = $world.farplane
	level.farplane_color = $world.farplane_color

	if ($weatherF == NULL)
		level.weatherFs = 0
	else
		level.weatherFs = $weatherF.size

	if (level.weatherFs > 0)
		level.weatherF = exec global/makearray.scr $weatherF

	if ($weatherR == NULL)
		level.weatherRs = 0
	else
		level.weatherRs = $weatherR.size

	if (level.weatherRs > 0)
	{
		level.weatherR = exec global/makearray.scr $weatherR
		level.weatherR model "fx/dummy.tik"
	}

	if ($weatherI == NULL)
		level.weatherIs = 0
	else
		level.weatherIs = $weatherI.size

	if (level.weatherIs > 0)
		level.weatherI = exec global/makearray.scr $weatherI

	if ($weatherW == NULL)
		level.weatherWs = 0
	else
		level.weatherWs = $weatherW.size

	if (level.weatherWs > 0)
	{
		level.weatherW = exec global/makearray.scr $weatherW
		level.weatherW model "fx/dummy.tik"
	}

	if ($wind == NULL)
		level.winds = 0
	else
		level.winds = $wind.size

	if (level.winds > 0)
		level.wind = exec global/makearray.scr $wind


	level waittill spawn

	
	if (level.windtime == NIL)
		level.windtime = 15

	if (level.shuttertime == NIL)
		level.shuttertime = 0.8

	if (level.rainvolume == NIL)
		level.rainvolume = -1

	if (level.raindensity == NIL)
		level.raindensity = -1

	if (level.thundertime == NIL)
		level.thundertime = 20


	if (game.medic != NIL)
		thread medicchanger
	else
		thread weatherchanger

	thread weatherpattern

	level.AIR_weather_settings = 1

end


//===============================================
init_rain:

	if (level.AIR_weather_settings != 1)
		waitthread weather_settings

	if (level.interiors != 0 || level.interiors != NIL)
	{
		for (local.i=1;local.i<level.interiors+1;local.i++)
		{
			level.interior[local.i] thread rainin
		}
	}

	if (level.exteriors != 0 || level.exteriors != NIL)
	{
		for (local.i=1;local.i<level.exteriors+1;local.i++)
		{
			level.exterior[local.i] thread rainout
		}
	}

	//save all rain settings
	local.rain_speed = level.rain_speed
	local.rain_speed_vary = level.rain_speed_vary 
	local.rain_length = level.rain_length
	local.rain_width = level.rain_width
	local.rain_density = level.rain_density 
	local.rain_slant = level.rain_slant
	local.rain_min_dist = level.rain_min_dist
	local.rain_numshaders = level.rain_numshaders 
	local.rain_shader = level.rain_shader

	// Give rain sounds to players:
	thread rainsound
	

	level.raindest = 0.0
	local.raintime = level.time
	local.msec = 0

	while(level.rain_off != 1)
	{	
		if (level.rain < level.raindest)
		{
			waitthread weatherloop
			level.rain = level.rain + 0.1
		}
		else
		if (level.rain > level.raindest)
		{
			waitthread weatherloop
			level.rain = level.rain - 0.1
		}
		else
		if (level.time > local.raintime)
		{
			waitthread weatherloop
			local.raintime = level.time + 2
		}

		local.msec++
		wait 0.1
	}

end



//===============================================
weatherpattern:

	if (level.AIR_weather_settings != 1)
		waitthread weather_settings

	while(1)
	{
		if (level.weatherpattern == 0)
		{
			local.windtime = 15
			local.shuttertime = 0.8
			local.rainvolume = -1
			local.raindensity = -1
			local.thundertime = 20
		}
		else if (level.weatherpattern == 1)
		{
			local.windtime = 5
			local.shuttertime = 0.3
			local.rainvolume = 0.2
			local.raindensity = 0.8
			local.thundertime = 8
		}
		else if (level.weatherpattern == 2)
		{
			local.windtime = 3
			local.shuttertime = 0.2
			local.rainvolume = 0.4
			local.raindensity = 3
			local.thundertime = 6
		}
		else if (level.weatherpattern == 3)
		{
			local.windtime = 1.5
			local.shuttertime = 0.1
			local.rainvolume = 1
			local.raindensity = 10
			local.thundertime = 4
		}

		// local.trans = 0.15
		local.trans = 0.07
		level.windtime = (local.windtime * local.trans + (level.windtime * (1 - local.trans)))
		level.shuttertime = (local.shuttertime * local.trans + (level.shuttertime * (1 - local.trans)))
		level.raindensity = (local.raindensity * local.trans + (level.raindensity * (1 - local.trans)))
		level.rainvolume = (local.rainvolume * local.trans + (level.rainvolume * (1 - local.trans)))
		level.thundertime = (local.thundertime * local.trans + (level.thundertime * (1 - local.trans)))

		if ((level.raindensity > 0.4) && (level.rainvolume < 0.1))
		{
			level.rainvolume = 0.1
		}

		wait 1
	}

end

//===============================================
weatherchanger:

	if (level.AIR_weather_settings != 1)
		waitthread weather_settings

	level.weatherpattern = 0
	wait 4
	while(1)
	{
		local.pattern_nr = randomint(3)
		local.wait_nr = randomint(60)

		if (local.pattern_nr == 0)
			local.pattern_nr++

		if (local.wait_nr == 0)
			local.wait_nr = 15


		level.weatherpattern = local.pattern_nr
		wait local.wait_nr
	}

end

//===============================================
medicchanger:

	if (level.AIR_weather_settings != 1)
		waitthread weather_settings

	level.weatherpattern = 0
	wait 5
	while(1)
	{
		level.weatherpattern = 1
		wait 10
		level.weatherpattern = 2
		wait 15
		level.weatherpattern = 3

		wait 20
		level.weatherpattern = 2
		wait 5
		level.weatherpattern = 0
		wait 15
	}

end


//===============================================
thunder:

	if (level.AIR_weather_settings != 1)
		waitthread weather_settings

	while(1)
	{
		wait (level.thundertime + randomint( (level.thundertime * 1.5) ))
		local.num = (randomint (3) + 1)

		if (game.medic == NIL)
		{
			for (local.f = 1; local.f <= $player.size; local.f++)
			{
				$player[local.f] playsound thunder
			}
		}

		switch (local.num)
		{
			case 1:
				waitthread flash
				wait 0.2
				waitthread unflash
				wait 1
				waitthread flash
				wait 0.1
				waitthread unflash
				wait 0.1
				waitthread flash
				wait 0.1
				waitthread unflash
				wait (1 + (randomfloat(2)))
			break
			case 2:
				waitthread flash
				wait 0.1
				waitthread unflash
				wait 0.1
				waitthread flash
				wait 0.1
				waitthread unflash
				wait 1
				waitthread flash
				wait 0.2
				waitthread unflash
				wait (1 + (randomfloat(2)))
			break
			case 3:
				waitthread flash
				wait 0.1
				waitthread unflash
				wait 0.1
				waitthread flash
				wait 0.2
				waitthread unflash
				wait 0.5
				waitthread flash
				wait 0.1
				waitthread unflash
				wait (1 + (randomfloat(2)))
			break
		}
	}

end

//===============================================
flash:

	for (local.f = 1; local.f <= $player.size; local.f++)
	{
 		$player[local.i] stufftext "r_fastsky 1"
	}
	$world farplane_color (0.9 0.9 0.9)

	if (level.weatherFs != 0)
	{
		for (local.i=1;local.i<level.weatherFs+1;local.i++)
		{
			level.weatherF[local.i] show
		}
	}

end

//===============================================
unflash:

	for (local.f = 1; local.f <= $player.size; local.f++)
	{
 		$player[local.i] stufftext "r_fastsky 0"
	}
	$world farplane_color level.farplane_color

	if (level.weatherFs != 0)
	{
		for (local.i=1;local.i<level.weatherFs+1;local.i++)
		{
			level.weatherF[local.i] hide
		}
	}
end


//========================================================
// Weather Loop; modified by Sor
// -----------------------------
// This makes certain weather functions play their 
// respective sounds and it passes the correct sound
// properties to them (volume, distance etc) 
//
// I edited to start only when the playersound objects
// have spawned and I added some NIL checks.
//
//========================================================
weatherloop:

	if (level.AIR_weather_settings != 1)
		waitthread weather_settings

	// -------------
	// In case the map gets loaded in an empty server
	// it basically stops this script until the $playersounds
	// are spawned:
	// -------------
	if (level.playersound_spawned != 1)
	{
		end
	}

	if (level.raindensity < 0)
	{
		level.rain_density = 0
	}
	else if (level.raindensity < 1)
	{
		level.rain_density = level.raindensity * 10
	}
	else if (level.raindensity < 10)
	{
		level.rain_density = level.raindensity
	}
	else
	{
		level.rain_density = 0.003
	}

	level.rain_density = level.raindensity // WTF Mackey? 

	if (level.raindensity < 5)
		local.raindensity = 50
	else
		local.raindensity = (50 + ((level.raindensity - 5) * 8))

	level.rain_slant = local.raindensity

	local.rainvolume = level.rainvolume - 0.3
	local.rainvolume = local.rainvolume - level.rain

	if (local.rainvolume > 0)
	{
		$playersound loopsound rain_ext (local.rainvolume + 0.2) "levelwide"
	}
	else
	{
		$playersound loopsound rain_ext 0
	}
	
	if (level.rainvolume > 0.4)
		local.rainvolume = (0.4 - (level.rainvolume - 0.4))
	else
		local.rainvolume = level.rainvolume
	
	local.rainvolume = local.rainvolume - level.rain

	if (local.rainvolume < 0.0)
	{
		$playersound2 loopsound rain_puddle 0
	}
	else
	{
		$playersound2 loopsound rain_puddle (local.rainvolume + 0.2) "levelwide"
	}

	local.rainvolume = level.rainvolume - (1.0 - level.rain)

	if (local.rainvolume < 0.0)
	{
		$playersound3 loopsound rain_int 0 
	}
	else
	{
		$playersound3 loopsound rain_int (local.rainvolume + 0.2) "levelwide"
	}

	if (level.weatherRs != NIL && level.weatherRs != 0)
	{
		for (local.i=1;local.i<level.weatherRs+1;local.i++)
		{
			if (level.rainvolume < 0)
			{
				level.weatherR[local.i] stoploopsound
			}
			else
			{
				level.weatherR[local.i] loopsound rain_roof (level.rainvolume + 0.2) 
			}
		}
	}

	if (level.weatherWs != NIL && level.weatherWs != 0)
	{
		for (local.i=1;local.i<level.weatherWs+1;local.i++)
		{
			if (level.rainvolume < 0)
			{
				level.weatherW[local.i] stoploopsound
			}
			else
			{
				level.weatherW[local.i] loopsound rain_window (level.rainvolume + 0.2)
			}
		}
	}

	if (level.winds != NIL && level.winds != 0)
	{
		for (local.i=1;local.i<level.winds+1;local.i++)
		{
			if (level.rainvolume < 0)
			{
				level.wind[local.i] stoploopsound
			}
			else if (level.rainvolume > 0.5)
			{
				level.wind[local.i] loopsound "sound/environment/wind_weak.wav" (level.rainvolume + 0.2) 192
			}
			else
			{
				level.wind[local.i] loopsound "sound/environment/wind_strong.wav" level.rainvolume 192
			}
		}
	}

end

//===============================================
// Spawn Rainsounds for players;
// - MP version
//===============================================
rainsound:

	if (level.AIR_weather_settings != 1)
		waitthread weather_settings

	level.rain = 0.0

	while(1)
	{
		if ($player.size > 0)
		{
			for (local.f = 1; local.f <= $player.size; local.f++)
			{
				//pick someone
				spawn script_model "targetname" "playersound"
				$playersound.origin = $player[local.f].origin
				$playersound model "fx/dummy.tik"
				$playersound notsolid

				spawn script_model "targetname" "playersound2"
				$playersound2.origin = $player[local.f].origin
				$playersound2 model "fx/dummy.tik"
				$playersound2 notsolid

				spawn script_model "targetname" "playersound3"
				$playersound3.origin = $player[local.f].origin
				$playersound3 model "fx/dummy.tik"
				$playersound3 notsolid

				level.playersound_spawned = 1

				// end because we got someone, the sounds these objects
				// play are levelwide
				end
			}
		}
		wait 0.5
	}
end

//========================================================
// Treebranch Movement; modified by Sor
// ------------------------------------
//
// I wanted to make them more noticeable and
// controllable. The wind is a very nice feature
// we can use in MoHAA which wasn't used. 
//
// Let's use it now!
//
//========================================================
treemovement:

	if (level.AIR_weather_settings != 1)
		waitthread weather_settings

	local.independant = level.windcontrol

	while(local.independant != 1)
	{
		local.independant = level.windcontrol

		local.num = (level.raindensity + 1.5) / 2.5
		setcvar "r_static_shadermultiplier1" local.num
		wait 1
	}

	while(local.independant == 1)
	{
		local.independant = level.windcontrol
		local.num = level.treewind

		if (local.num == 0 || local.num == NIL)
		{
			local.num = (level.raindensity + 1.5) / 2.5
		}
		setcvar "r_static_shadermultiplier1" local.num
		wait 1
	}

	// if independant is back 1, rerun script
	thread treemovement	

end

//===============================================
rainin:
	while(1)
	{
		self waittill trigger
		level.raindest = 1.0
		wait 0.1
	}
end

//===============================================
rainout:
	while(1)
	{
		self waittill trigger
		level.raindest = 0.0
		wait 0.1
	}
end

//=========================================================================
// CUSTOM Snowing Mechanism for AA; by jv
// --------------------------------------
// 
// This generates snow in maps with no func_rain. Unfortunately, you
// need a custom tik file to see the snow :(
//
// Initially meant for AA, since you can script-spawn rain in SH/BT;
// but you can use it in SH/Bt as well since this does not snow 
// through walls and roofs!
//
// USE: thread global/AIR/AIR_weather.scr::snow_players <amount_flakes>
//
//==========================================================================
snow_players local.amount:

	if (local.amount == NIL)
		local.amount = 25

	if (local.amount > 50)
	{
		println ("[AIR Weather::Snowing]: Amount of flakes is set to : " + local.amount + " which will cause serious lag!")
		println "[AIR Weather::Snowing]: Reducing amount to 25!"
		local.amount = 25
	}

	while ((getcvar sc_nosnow) != "1")
	{
		if ($player.size > 0)
		{
			for (local.i = 1; local.i <= $player.size; local.i++)
			{
				if ($player[local.i].isSnowing != 1)
				{
					$player[local.i] thread snowing local.amount
					$player[local.i].isSnowing = 1
				}
			}
		}
		wait 7 //shouldn't be too often
	}

end

//===============================================
// This script is made by the scripting god, jv
//===============================================
snowing local.amount:

	for(local.i = 1; local.i <= local.amount; local.i++)
	{
		local.ent[local.i] = spawn emitters/snowdrip.tik //<- by jv
		//local.ent[local.i] scale 1.5
	}
	
	while(self != NIL && isAlive self && local.terminate != 1 && (getcvar sc_nosnow) != "1")
	{
		local.flatvelocity = self.velocity
		local.flatvelocity[2] = 0
		
		local.tmp_origin = self.origin + local.flatvelocity * 4.0 // was 3
		local.tmp_origin[2] = self.origin[2] + 400 //level.snowheight
		
		local.i = 0
		for(local.x = -2; local.x <= 2; local.x++)
		{
			for(local.y = -2; local.y <= 2; local.y++)
			{
				local.i++
				local.ent[local.i].origin = local.tmp_origin + (local.x local.y 0) * 250.0 // was 150
			}	
		}
		wait 0.5 // was waitframe but caused lag
	}
	
	local.num = local.ent.size
	for(local.i = 1; local.i <= local.num; local.i++)
	{
		local.ent[local.i] commanddelay 0.05 remove
	}

end

//=========================================================================
// CUSTOM Raining Mechanism for AA;
// by jv & modified by Sor
// --------------------------------
// 
// This generates light rain in maps with no func_rain. Unfortunately, you
// need a custom tik file to see the rain drops :(
//
// Initially meant for AA, since you can script-spawn rain in SH/BT;
// but you can use it in SH/Bt as well since this does not rain 
// through walls and roofs!
//
// USE: thread global/AIR/AIR_weather.scr::rain_players <amount_drops> <type_rain>
//
// For type use 1 for smill light drops and 2 for big heavy rain drops
//
//==========================================================================
rain_players local.amount local.type:

	if (local.type != 1 && local.type != 2)
		local.type = 1

	if (local.amount == NIL)
		local.amount = 25

	if (local.amount > 50)
	{
		println ("[AIR Weather::Raining]: Amount of drops is set to : " + local.amount + " which will cause serious lag!")
		println "[AIR Weather::Raining]: Reducing amount to 25!"
		local.amount = 25
	}

	while ((getcvar sc_norain) != "1")
	{
		if ($player.size > 0)
		{
			for (local.i = 1; local.i <= $player.size; local.i++)
			{
				if ($player[local.i].isRaining != 1)
				{
					$player[local.i] thread custom_rain local.amount local.type
					$player[local.i].isRaining = 1
				}
			}
		}
		wait 7 //shouldn't be too often
	}

end


//===================================================================
// This script is based on the snow-script by the scripting god, jv
//===================================================================
custom_rain local.amount local.type:

	for(local.i = 1; local.i <= local.amount; local.i++)
	{
		if (local.type == 1)
			local.ent[local.i] = spawn emitters/drip.tik
		else
			local.ent[local.i] = spawn emitters/heavydrip.tik
	}
	
	while(self != NIL && isAlive self && local.terminate != 1 && (getcvar sc_nosnow) != "1")
	{
		local.flatvelocity = self.velocity
		local.flatvelocity[2] = 0
		
		local.tmp_origin = self.origin + local.flatvelocity * 4.0 // was 3
		local.tmp_origin[2] = self.origin[2] + 400 //level.snowheight
		
		local.i = 0
		for(local.x = -2; local.x <= 2; local.x++)
		{
			for(local.y = -2; local.y <= 2; local.y++)
			{
				local.i++
				local.ent[local.i].origin = local.tmp_origin + (local.x local.y 0) * 250.0 // was 150
			}	
		}
		wait 0.5 // was waitframe but caused lag
	}
	
	local.num = local.ent.size
	for(local.i = 1; local.i <= local.num; local.i++)
	{
		local.ent[local.i] commanddelay 0.05 remove
	}

end

// ____________________________________________
//
// AIR Lightning Beams; by Sor
// ---------------------------
// 
// USE:
// thread global/AIR/AIR_weather.scr::lightning <origin> <angles> <"targetname"> <time> <scale> <numsegments> <minoffset> <maxoffset>
// 
// CLARIFICATION:
// - <origin>: ( X Y Z ) Where do you want the beam?
// - <angles>: ( X Y Z ) Beam's angles; NOTE ( -90 0 0) makes the beam upright, else he'll be horizontal!
// - <"targetname">: ( String ) Give the beam a targetname so you can delete/control him afterwards 
// - <time>: ( Integer ) Time between Lightning beams (default 5)
// - <scale>: ( Float ) Scale of the Lightning beams (default 1)
// - <numsegments>: ( Integer ) Number of beams (default 20)
// - <minoffset>: ( Float ) Minimum distance it deviates
// - <maxoffset>: ( Float ) Maximum distance it deviates
// ____________________________________________
//

// --------------------------------------------------------------------------------------------------------	//
lightning local.origin local.angles1 local.tname local.time local.ascale local.num local.min local.max:
// --------------------------------------------------------------------------------------------------------	//

	if (local.origin == NIL)
	{
		println "[AIR Weather::Lightning]: Invalid origin!"
		end
	}
	if (local.angles1 == NIL)
	{
		//println "[AIR Weather::Lightning]: Invalid angles!"
		//end
		local.angles1 = ( -90 0 0 )
	}
	if (local.tname == NIL)
	{
		println "[AIR Weather::Lightning]: Invalid targetname!"
		end
	}
	if (local.ascale == NIL)
		local.ascale = 1

	if (local.num == NIL)
		local.num = 20

	if (local.min == NIL)
		local.min = 10

	if (local.max == NIL)
		local.max = 35

	if (local.time == NIL || local.time <= 0.5)
		local.time = 5


	if (level.AIR_lightning == NIL)
	{
		local.i = 1
		waitthread cache
	}
	else
	{
		local.i = level.AIR_lightning.size + 1
	}
	level.AIR_lightning[local.i] = spawn func_beam "targetname" local.tname
	level.AIR_lightning[local.i].origin = local.origin
	level.AIR_lightning[local.i].angles = local.angles1 //( -90 0 0 )
	level.AIR_lightning[local.i] scale local.ascale
	level.AIR_lightning[local.i] minoffset local.min
	level.AIR_lightning[local.i] maxoffset local.max
	level.AIR_lightning[local.i] color ( 1 1 1 )
	level.AIR_lightning[local.i] numsegments local.num
	level.AIR_lightning[local.i] overlap 5
	level.AIR_lightning[local.i] endalpha 0.1

	level.AIR_lightning[local.i] thread doLightning local.time

end

doLightning local.time:
	wait 1

	while(self.stop != 1) 
	{
		if (self == NIL || self == NULL)
		{
			end
		}
		self activate
		self playsound thunder
		self volumedamage 20000
		wait 0.5
		self deactivate
		self volumedamage 0
		wait local.time
	}

	// In case the lightning is on
	self deactivate
	self volumedamage 0
	self stopsound

	while(self.stop != 0)
	{
		if (self == NIL || self == NULL)
		{
			end
		}
		wait 5
	}

	if (self.stop == 0)
	{
		self thread doLightning local.time
	} 
	
end


cache:
local.master = spawn ScriptMaster
local.master alias thunder1 sound/amb/Amb_Thunder_01.wav soundparms 1.0 0.0 1.0 0.0 3000 6000 auto streamed maps "dm obj "
local.master alias thunder2 sound/amb/Amb_Thunder_02.wav soundparms 1.0 0.0 1.0 0.0 3000 6000 auto streamed maps "dm obj "
local.master alias thunder3 sound/amb/Amb_Thunder_03.wav soundparms 1.0 0.0 1.0 0.0 3000 6000 auto streamed maps "dm obj "
end


```

# xyz_Airborne_Mod\global\AIR\AIR_AntiCamp.scr

```scr
/*
======================================================
*** AIRborne; Anti-Camping Script for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
camper_buster:

	if (self == NULL)
		end

	if (self.camp_check == 1)
	{
		//println "camp_check is already on"
		end
	}
	else
	{
		self.camp_check = 1
	}

	//Update settings:
	local.camper = waitthread global/AIR/AIR_Control.scr::get_setting "camper"
	local.origin = self.origin 
	local.team = self.dmteam

	local.camped_for = 0

	while (local.camper == 1 && self.status == "alive" && self.dmteam != "spectator")
	{
		//Update settings:
		local.camper = level.AIR["camper"]
		local.camper_radius = level.AIR["camper_radius"] 
		local.camper_time = level.AIR["camper_time"] 
		local.camper_punish = level.AIR["camper_punish"]
		local.camper_message = level.AIR["camper_message"]
		local.camper_sound = level.AIR["camper_sound"]

		//Update radius
		local.inradius = vector_within local.origin self.origin local.camper_radius
		if !(local.inradius)
		{
			local.camped_for = 0
			local.origin = self.origin 
		}
		
		if ( self == NIL || self == NULL )
		{
			end
		}
		if ( self.dmteam == "specatator" || self.dmteam != local.team )
		{
			self.camp_check = 0
			end
		}

		if ( self.usingTurret != 1 && self.camping != 1)
		{
			local.warning = local.camper_time - 6
			if (local.camped_for == local.warning)
			{
				if (local.camper_sound == 1)
				{
					self stoploopsound
					self playsound streamed_dfr_scripted_M3L1_016a 
				}
				if (local.camper_message == 1)
				{
					self iprint "Someone seems to be setting up his tent..."
				}
			}

			if (local.camped_for >= local.camper_time)
			{
				if (level.AIR_library_loaded == 1)
				{
					local.add = ("[" + (waitthread global/AIR/AIR_library.scr::findplayer self.origin 1) + "]")
					self.camping_spot = local.add
				}
				else
				{
					local.add = ""
				}

				if (local.camper_sound == 1)
				{
					self stoploopsound
					self playsound streamed_dfr_scripted_M3L1_016a 
				}

				/////////////////////////////
				////////PUNISHMENT 1/////////
				/////////////////////////////
				if (local.camper_punish == 1)
				{
					self.camping = 1
					if (local.camper_message == 1)
					{
						self iprint "YOU ARE CAMPING!!"
						iprintln_noloc ("A camper has been spotted! " + local.add)
					}
					while (local.inradius && self.health > 0 && self)
					{
						self hurt 5
						self iprint "I will keep poking you until you move or until you die!"
						
						//Update radius
						local.inradius = vector_within local.origin self.origin local.camper_radius
						wait 1
					}
					if (self && self.health <= 0)
					{
						if (local.camper_message == 1)
						{
							self iprint "Oh well, you should have listened to reason!"
						}

						self.camping_spot = NIL
						self.camping = 0
						self.camp_check = 0
						end
					}
					else if (self && self.health > 0)
					{
						if (local.camper_message == 1)
						{
							self iprint "Wise choice..."
						}

						self.camping_spot = NIL
						self.camping = 0
					}
					else
					{
						end
					}
				}
				/////////////////////////////
				////////PUNISHMENT 2/////////
				/////////////////////////////
				if (local.camper_punish == 2)
				{
					self.camping = 1
					if (local.camper_message == 1)
					{
						self iprint "YOU ARE CAMPING!!"
						iprintln_noloc ("A camper has been spotted! " + local.add)
					}

					wait 4
					self spectator
					wait 1
					
					if (local.camper_message == 1)
					{
						self iprint "Oh well, you should have listened to reason!"
					}
					self.camping_spot = NIL
					self.camp_check = 0
					self.camping = 0
					end
				}
				/////////////////////////////
				////////PUNISHMENT 3/////////
				/////////////////////////////
				if (local.camper_punish == 3)
				{
					self.camping = 1
					if (local.camper_message == 1)
					{
						self iprint "YOU ARE CAMPING!!"
						iprintln_noloc ("A camper has been spotted! " + local.add)
					}

					wait 4
					self kill
					wait 1

					if (local.camper_message == 1)
					{
						self iprint "Oh well, you should have listened to reason!"
					}
					self.camping_spot = NIL
					self.camp_check = 0
					self.camping = 0
					end
				}
				/////////////////////////////
				////////PUNISHMENT 4/////////
				/////////////////////////////
				if (local.camper_punish == 4)
				{
					self.camping = 1
					if (local.camper_message == 1)
					{
						self iprint "YOU ARE CAMPING!!"
						self dmmessage 0 ("I'm setting up my tent because I'm a BIG DIRTY CAMPER!! " + local.add)
					}
					self iprint "We are currently leading a ZERO-TOLERANCE policy for campers!"
					wait 2
					self iprint "This means you will be kicked off our server."
					wait 2
					self thread kick_server
					waitframe

					self iprint "One..."
					wait 1
					self iprint "Two..."
					wait 1
					self iprint "THREE!"
					wait 1

					if (local.camper_message == 1)
					{
						iprintln "Because of our ZERO-TOLERANCE Policy, a camper has been kicked!"
					}
					//self.camp_check = 0
					//self.camping = 0
					end
				}
			}
		}
		//increase time
		wait 1
		if (local.inradius)
		{
			local.camped_for++
		}
	}

	//self.camping = 0
	self.camp_check = 0

end

kick_team:

	self spectator
	wait 1

end

kick_server:

	wait 3

	//hmm, he doesn't like to leave
	if(self)
	{
		self stufftext "disconnect"
		wait 1
	}

	//damnit, go away!!
	if(self)
	{
		self delete 	//bye bye
	}

end
```

# xyz_Airborne_Mod\global\AIR\AIR_Control.scr

```scr
/*
======================================================
*** AIRborne; Control Centre for MoH:AA
======================================================
by Sor
Version: v2.0.2
-----------------------------------

======================================================
*/

// TODO: Help command which prints all help text in the console
// TODO: Finish library
init:

	level.AIR_global_init = 1

	println "[AIR Init::STARTED]: Starting AIR System initialization, standby..."

	// load all settings if necessary
	waitthread global/AIR/AIR_Settings.scr::main_settings
	waitthread global/AIR/AIR_Settings.scr::script_settings
	waitthread global/AIR/AIR_Settings.scr::map_settings

	thread clear_hud

	if (level.AIR == NIL)
	{
		println "[AIR Init::Fatal Error]: The AIR settings weren't properly loaded!!"
		end
	}
	else
	{
		println "[AIR Init]: Settings have loaded successfully."
	}

	if ( (getcvar "AIR_sv") != "" )
	{
		println "[AIR Init::Backup_to_level]: Backup cvar returns latest values to level.AIR var..."
		waitthread return_fromcvar
	}

	//*********************//
	level waittill prespawn
	//*********************//

	// register user's cmds & initialize the Command-Service
	if ( level.AIR["cmd"] == 1)
	{
 		local.cmds = waitthread global/AIR/AIR_Settings.scr::register_user_cmds
		for (local.i = 1; local.i <= local.cmds.size; local.i++)
		{
			if (local.cmds[local.i][4] == NIL)
				waitthread register_cmd local.cmds[local.i][1] local.cmds[local.i][2] local.cmds[local.i][3]
			else
				waitthread register_cmd local.cmds[local.i][1] local.cmds[local.i][2] local.cmds[local.i][3] local.cmds[local.i][4]
		}
		thread cmd_handler
	}

	// register all spectator messages
	if ( level.AIR["spec_messages"] == 1 )
	{
		local.msgs = waitthread global/AIR/AIR_Settings.scr::add_user_specmsg
		for (local.i = 1; local.i <= local.msgs.size; local.i++)
		{
			if (local.msgs[local.i][2] == NIL)
				local.msgs[local.i][2] = 0

			waitthread global/AIR/AIR_messages.scr::add_message local.msgs[local.i][1] local.msgs[local.i][2] local.msgs[local.i][3]
		}
		
		println "[AIR Init]: Registered all SPECTATOR messages!"

		exec global/AIR/AIR_messages.scr
	}

	// register all global messages
	if ( level.AIR["gmessages"] == 1 )
	{
		local.gmsg = waitthread global/AIR/AIR_Settings.scr::add_user_globalmsg
		for (local.c = 1; local.c <= local.gmsg.size; local.c++)
		{
			if (local.gmsg[local.c][2] == NIL)
				local.gmsg[local.c][2] = 0

			waitthread global/AIR/AIR_gmessages.scr::add_message local.gmsg[local.c][1] local.gmsg[local.c][2] 
		}
		
		println "[AIR Init]: Registered all GLOBAL messages!"

		exec global/AIR/AIR_gmessages.scr
	}

	if ( level.AIR["RANK_system"] == 1)
		exec global/rank/ranking.scr

	//******************//
	level waittill spawn
	//******************//

	level.dmrespawning = 1

	if ( level.AIR["weapon_limiter"] == 1)
	{
		thread global/limits.txt::banned
		thread global/limits.txt::limited
		thread global/limits.txt::bonuses
	}

	if (level.AIR_mapscript == NIL)
		level.AIR_mapscript = waitexec global/strings.scr::to_lower (getcvar "mapname")

	if ( level.AIR["realism"] == 1)
	{
		exec global/AIR_view.scr
	}

	if ( level.AIR["SP_soundfix"] == 1)
		exec global/SPFIX_/soundfix.scr::init

	if ( level.AIR["balance"] == 1)
		exec global/AIR/AIR_TeamBalance.scr

	if ( level.AIR["LOC_library"] == 1)
	{
		thread global/AIR/AIR_library.scr::load_library
	}

	if ( level.AIR["spawn_protect"] == 1)
		println "[AIR Spawn Protect]: Spawn protection enabled!"

	if ( level.AIR["nextmap_display"] == 1)
	{
		println "[AIR Nextmap]: Nextmap Display enabled!"
		println "[AIR Init::FINISHED]: Initialization completed!"
		exec global/AIR/AIR_nextmap.scr
	}
	else
	{
		println "[AIR Init::FINISHED]: Initialization completed!"
	}


	while(1)
	{
		huddraw_font 122 "facfont-20"
		huddraw_align 122 "left" "bottom"
		huddraw_rect 122 5 -15 100 100
		huddraw_string 122 ("AIRborne Mod " + level.AIR["version"])
		huddraw_color 122 0.400 0.400 1.000
		huddraw_alpha 122 1.000

		huddraw_font 123 facfont-20
		huddraw_align 123 left bottom
		huddraw_rect 123 300 -15 100 100
		huddraw_string 123 "[62.182.59.38:12204]"
		huddraw_color 123 1.000 1.000 1.000
		huddraw_alpha 123 1.000

		huddraw_font 124 facfont-20
		huddraw_align 124 left bottom
		huddraw_rect 124 430 -15 100 100
		huddraw_string 124 "[www.mohaairborne.co.cc]"
		huddraw_color 124 1.000 1.000 1.000
		huddraw_alpha 124 1.000

		huddraw_font 125 facfont-20
		huddraw_align 125 left bottom
		huddraw_rect 125 610 -15 100 100
		huddraw_string 125 "[airborneserver@live.com]"
		huddraw_color 125 1.000 1.000 1.000
		huddraw_alpha 125 1.000

		wait 1.5
	}
end

clear_hud:

	for (local.i = 0; local.i <= 255; local.i++)
	{
		huddraw_alpha local.i 0.0
	}

	//make sure
	for (local.i = 40; local.i <= 150; local.i++)
	{
		huddraw_alpha local.i 0.0
	}
end

///////////////////////////////////////////////////////////////////////////////////
// Add setting to Cvar
// --------------------
// PURPOSE: Used to save settings of internal variables in an persistent cvar.
// USE: waitthread global/AIR/AIR_Control.scr::add_tocvar <"setting"> <value>
//
// CLARIFICATION:
// - "setting": Find all applicable settings in the /AIR/AIR_Settings.scr Script
// - value: Find all applicable values in the /AIR/AIR_Settings.scr Script
//
///////////////////////////////////////////////////////////////////////////////////
add_tocvar local.option local.value:

	if ( (getcvar "AIR_sv") != "")
		group.method = "add"
	else
		group.method = "start"

	if (group.method == "add")
	{
		local.reg_value = waitthread get_fromcvar local.option
		println local.reg_value
		if (local.reg_value == local.value)
		{
			end
		}
		else if (local.reg_value != NIL)
		{
			local.cib =  waitexec global/strings.scr::split_line (getcvar "AIR_sv") 1 " "
	
			for (local.i = 1; local.i <= local.cib[1].size && local.stop != 1; local.i++)
			{
				if (local.cib[1][local.i] == local.option)
				{
					local.tobe_replaced = (local.option + " " + local.cib[1][(local.i + 1)] + " ; ")
					local.stop = 1
				}
			}

			local.replaced_with = (local.option + " " + local.value + " ; ")
			local.newcvar = waitexec global/strings.scr::Replace (getcvar "AIR_sv") local.tobe_replaced local.replaced_with
			setcvar "AIR_sv" local.newcvar
			end
		}
		else
		{
			local.cvar = (getcvar "AIR_sv")
			local.newcvar = local.cvar + (local.option + " " + local.value + " ; ")
			setcvar "AIR_sv" local.newcvar
			end
		}
	}
	else
	{
		setcvar "AIR_sv" (local.option + " " + local.value + " ; ")
	}
end

///////////////////////////////////////////////////////////////////////////////////
// Get value from Cvar
// --------------------
// PURPOSE: Retrieves a saved value for an internal variable  in the persistant cvar.
// USE: waitthread global/AIR/AIR_Control.scr::get_fromcvar <"setting">
//
// CLARIFICATION:
// - "setting": Find all applicable settings in the /AIR/AIR_Settings.scr Script
//
///////////////////////////////////////////////////////////////////////////////////
get_fromcvar local.option:

	if ( (getcvar "AIR_sv") == "")
		end

	local.cib =  waitexec global/strings.scr::split_line (getcvar "AIR_sv") 1 " "

	for (local.i = 1; local.i <= local.cib[1].size; local.i++)
	{
		if (local.cib[1][local.i] == local.option)
		{
			local.v = local.cib[1][(local.i + 1)]
			local.value = waitexec global/AIR/AIR_Control.scr::correct_type local.option local.v
			local.checked_value = waitexec global/AIR/AIR_Control.scr::check_value local.option local.value
			if (local.checked_value == 1)
			{
				end local.value
			}
			else
			{
				end NIL
			}
		}
	}
end

/////////////////////////////////////////////////////////////////
// Record Values to Cvar
// --------------------
// PURPOSE: Saves all necessary values of internal variables
// USE: waitthread global/AIR/AIR_Control.scr::record_tocvar
//
/////////////////////////////////////////////////////////////////
record_tocvar:

	if (level.AIR == NIL)
		end

	setcvar "AIR_sv" ""

	local.o = makeArray
	"gmessages"
	"spec_messages"
	"camper_message"
	"camper_sound"
	"cmd"
	"camper"
	"camper_punish"
	"balance"
	"camper_radius"
	"balance_time"
	"camper_time"
	"weapon_limiter"
	"music"
	"realism"
	"LOC_library"
	"nextmap_display"
	"spawn_protect"
	"RANK_system"
	"SP_soundfix"
	"spawn_protect_sec"
	endArray

	local.string = ""

	for (local.i = 1; local.i <= local.o.size; local.i++)
	{
		local.t = local.o[local.i][1]
		local.string += (local.t + " " + level.AIR[local.t] + " ; ")
	}

	setcvar "AIR_sv" local.string

end

////////////////////////////////////////////////////////////////////////////
// Return Values to Cvar
// --------------------
// PURPOSE: Returns all saved values to the cvar to their level. variables
// USE: waitthread global/AIR/AIR_Control.scr::return_fromcvar
//
////////////////////////////////////////////////////////////////////////////
return_fromcvar:

	if ( (getcvar "AIR_sv") == "")
		end

	local.cib =  waitexec global/strings.scr::split_line (getcvar "AIR_sv") 1 " "
	
	for (local.i = 1; local.i <= local.cib[1].size; local.i++)
	{
		if (local.cib[1][local.i] == ";")
		{
			local.option = local.cib[1][(local.i - 2)]
			local.v = local.cib[1][(local.i - 1)]
			local.value = waitexec global/AIR/AIR_Control.scr::correct_type local.option local.v
			local.checked_value = waitexec global/AIR/AIR_Control.scr::check_value local.option local.value

			if (local.checked_value == 1)
			{
				if (level.AIR[local.option] == local.value)
				{
					local.tobe_replaced = (local.option + " " + local.v + " ; ")
					local.replaced_with = ""

					local.newcvar = waitexec global/strings.scr::Replace (getcvar "AIR_sv") local.tobe_replaced local.replaced_with
					setcvar "AIR_sv" local.newcvar
				}
				else
				{
					level.AIR[local.option] = local.value
				}
			}
		}
	}
end


//////////////////////////////////////////////////////////////////////////////////////////////////
// Apply Settings
// --------------
// PURPOSE: Used to apply settings to internal variables used in running scripts.
// USE: waitthread global/AIR/AIR_Control.scr::apply_setting <"setting"> <value>
//
// CLARIFICATION:
// - "setting": Find all applicable settings in the /AIR/AIR_Settings.scr Script
// - value: Find all applicable values in the /AIR/AIR_Settings.scr Script
//
// NOTE: This should only be used by the Server Command-Service
//
//////////////////////////////////////////////////////////////////////////////////////////////////
apply_setting local.setting local.value:

	if (level.AIR == NIL)
	{
		waitthread global/AIR/AIR_Settings.scr::main_settings
		waitthread global/AIR/AIR_Settings.scr::script_settings
		waitthread global/AIR/AIR_Settings.scr::map_settings
	}

	if (local.setting == NIL || local.setting == "")
	{
		end
	}

	if (level.AIR[local.setting] == NIL)
	{
		println "[AIR Control::apply_setting]: Setting does not exist!"
		end
	}

	//make sure we got an the correct type (integer/float):
	local.value = waitthread correct_type local.setting local.value

	//make sure we got a correct value
	local.check = waitthread check_value local.setting local.value

	if (local.check == NIL)
	{
		println "[AIR Control::apply_setting]: Invalid value!!"
		end
	}

	level.AIR[local.setting] = local.value

	println ("[AIR Control::apply_setting]: " + local.setting + " successfully set to " + local.value + "!")

	thread add_tocvar local.setting local.value
end

//////////////////////////////////////////////////////////////////////////////////////////////////
// Get Settings
// ------------
// PURPOSE: Used by internal scripts to get the most updated setting.
// USE: waitthread global/AIR/AIR_Control.scr::get_setting <"setting">
//
// CLARIFICATION:
// - "setting": Find all applicable settings in the /AIR/AIR_Settings.scr Script
//
//
// NOTE: This should only be used by the Server Command-Service
//
//////////////////////////////////////////////////////////////////////////////////////////////////
get_setting local.setting:

	if (level.AIR == NIL)
	{
		waitthread global/AIR/AIR_Settings.scr::main_settings
		waitthread global/AIR/AIR_Settings.scr::script_settings
		waitthread global/AIR/AIR_Settings.scr::map_settings
	}

	if (local.setting == NIL || local.setting == "")
	{
		end NIL
	}

	if (level.AIR[local.setting] == NIL)
	{
		println "[AIR Control::get_settings]: Setting does not exist!"
		end NIL
	}
	else if (level.AIR[local.setting] != NIL)
	{
		end level.AIR[local.setting]
	}
end NIL

//////////////////////////////////////////////////////////////////////////////////////////////////
// Get Map Settings
// -----------------
// PURPOSE: Used by internal scripts to get the most updated mod and mode settings for maps
// USE: waitthread global/AIR/AIR_Control.scr::get_msetting <"setting">
//
// CLARIFICATION:
// - "setting": Find all applicable settings in the /AIR/AIR_Settings.scr Script
//
//
// NOTE: This should only be used by the Server Command-Service
//
//////////////////////////////////////////////////////////////////////////////////////////////////
get_msetting local.setting:

	if (level.AIR_maps == NIL)
	{
		waitthread global/AIR/AIR_Settings.scr::map_settings
	}

	if (local.setting == NIL || local.setting == "")
	{
		end NIL
	}

	if (level.AIR_maps[local.setting] == NIL)
	{
		println "[AIR Control::get_msettings]: Setting does not exist!"
		end NIL
	}

	else if (level.AIR_maps[local.setting] != NIL)
	{
		end level.AIR_maps[local.setting]
	}
end NIL

/////////////////////////////////////////////////////////////////////////
// Check Value
// ------------
// Check if the correct value is being applied to a setting!
// 
/////////////////////////////////////////////////////////////////////////
check_value local.setting local.value:

	switch (local.setting)
	{
		case "gmessages":
		case "spec_messages":
		case "camper_message":
		case "camper_sound":
		case "cmd":
		case "camper":
		case "balance":
		case "weapon_limiter":
		case "music":
		case "realism":
		case "LOC_library":
		case "nextmap_display":
		case "spawn_protect":
		case "RANK_system":
		case "SP_soundfix":
			if (local.value != 0 && local.value != 1)
			{
				end NIL
			}
		break
		case "balance_time":
		case "camper_time":
		case "spawn_protect_sec":
			if (local.value < 0.05)
			{
				end NIL
			}
		break
		case "camper_radius":
			if (local.value < 20)
			{
				end NIL
			}
		break
		case "camper_punish":
			if (local.value != 0 && local.value != 1 && local.value != 2 && local.value != 3 && local.value != 4)
			{
				end NIL
			}
		break
	}

end 1

/////////////////////////////////////////////////////////////////////////
// Check Type
// ------------
// Check if the correct value-type is being applied to a setting!
// 
/////////////////////////////////////////////////////////////////////////
correct_type local.setting local.value:

	switch (local.setting)
	{
		case "gmessages":
		case "spec_messages":
		case "camper_message":
		case "camper_sound":
		case "cmd":
		case "camper":
		case "camper_punish":
		case "balance":
		case "weapon_limiter":
		case "music":
		case "realism":
		case "LOC_library":
		case "nextmap_display":
		case "spawn_protect":
		case "RANK_system":
		case "SP_soundfix":
			local.correct = int (local.value)
			end local.correct
		break
		case "camper_radius":
		case "balance_time":
		case "camper_time":
		case "spawn_protect_sec":
			local.correct = float (local.value)
			end local.correct
		break
	}

end


//////////////////////////////////////////////////////////////////////////////////////////////////
// Register Commands
// -----------------
// PURPOSE: By registering a command, you can use it to activate a specified script in the 
//		console. More user-friendly info -> AIR_Settings.scr
//
// USE: waitthread global/AIR/AIR_Control.scr::register_cmd <"cmd"> <"script"> <"wait"> <"feedback">
//
// CLARIFICATION:
// - "cmd": 	Name of the command
// - script: 	Filename of script, you can also specify a thread within the script. (NO STRING)
// - "wait": 	Must the game use waitthread/waitexec? 1 yes, 0 no
// - "feedback": 	OPTIONAL: This gets printed in the console when this command is activated.
//
//////////////////////////////////////////////////////////////////////////////////////////////////
register_cmd local.cmd local.file local.wait local.feedback:

	if (local.cmd == NIL || local.cmd == "")
	{
		println "[AIR Control::register_cmd]: Invalid command string!"
		end
	}

	if (local.file == NIL || local.file == "")
	{
		println "[AIR Control::register_cmd]: Invalid scriptfile string!"
		end
	}

	if (local.wait == NIL)
	{
		local.wait = "0"
	}


	if (level.AIR_reg == NIL)
		local.i = 1
	else
		local.i = level.AIR_reg.size + 1

	level.AIR_reg[local.i][1] = local.cmd
	level.AIR_reg[local.i][2] = local.file
	level.AIR_reg[local.i][3] = local.wait
	if (local.feedback != NIL)
	{
		level.AIR_reg[local.i][4] = local.feedback
	}

	println ("[AIR Control::register_cmd]: " + local.cmd + " successfully registered!")

end


//////////////////////////////////////////////////////////////////////////////////////////////////
// UnRegister Commands
// -------------------
// PURPOSE: To unregister registered commands
//
// USE: waitthread global/AIR/AIR_Control.scr::unregister_cmd <"cmd">
//
// CLARIFICATION:
// - "cmd": Use the same string for cmd like the one you used to register
//
// Unfound commands will result in an error
//
//////////////////////////////////////////////////////////////////////////////////////////////////
unregister_cmd local.cmd:
	
	if (level.AIR_reg == NIL)
	{
		println "[AIR Control::Unregister_cmd]: Register is empty, cannot unregister specified command!"
		end
	}

	if (local.cmd == NIL || local.cmd == "")
	{
		println "[AIR Control::Unregister_cmd]: Invalid command string!"
		end
	}

	for (local.b = 1; local.b <= level.AIR_reg.size; local.b++)
	{
			if (level.AIR_reg[local.b][1] == local.cmd)
			{
				level.AIR_reg[local.b] = NIL
				local.unregistered = 1
			}
	}

	if (local.unregistered == 1)
	{
		println ("[AIR Control::Unregister_cmd]: " + local.cmd + " successfully unregistered!")
	}
	else
	{
		println ("[AIR Control::Unregister_cmd]: " + local.cmd + " not found in the register!")
	}

end


//////////////////////////////////////////////////////////////////////////////////////////////////
// Dump All Commands
// -----------------
// PURPOSE: Dump all registered commands in the console!
//
// USE: waitthread global/AIR/AIR_Control.scr::dumpall_cmd
//
//////////////////////////////////////////////////////////////////////////////////////////////////
dumpall_cmd:

	if (level.AIR_reg == NIL)
	{
		println "[AIR Control::dumpall_cmd]: Register is empty, cannot dump information!"
		end
	}	

	println "****************"
	println "[AIR Control::Dumpall_cmd]: Dumping all Register contents into the console!"
	println "****************"	
	println " "
	println " "

	for (local.e = 1; local.e <= level.AIR_reg.size; local.e++)
	{
		println "---------------------------------------------------------------------"
		println "Dumping Entry " local.e
		println "Command: " level.AIR_reg[local.e][1]
		//println "Scriptfile: " level.AIR_reg[local.e][2]
		if (level.AIR_reg[local.e][3] == "1")
		{
			println "Type waitexec"
		}
		else
		{
			println "Type exec"
		}
		if (level.AIR_reg[local.e][4] != NIL)
		{
			println "Console Feedback: " level.AIR_reg[local.e][4]
		}
	}

	println "---------------------------------------------------------------------"
	println " "
	println " "
	println "****************"
	println "[AIR Control::Dumpall_cmd]: Dumping Completed!"
	println "****************"	

end

//////////////////////////////////////////////////////////////////////////////////////////////////
// Dump One Command
// ----------------
// PURPOSE: Dump all info about the specified command into the console
//
// USE: waitthread global/AIR/AIR_Control.scr::dumpone_cmd <"cmd">
//
//////////////////////////////////////////////////////////////////////////////////////////////////
dumpone_cmd local.cmd:

	if (level.AIR_reg == NIL)
	{
		println "[AIR Control::dumpone_cmd]: Register is empty, cannot dump information!"
		end
	}

	if (local.cmd == NIL || local.cmd == "")
	{
		println "[AIR Control::dumpone_cmd]: Invalid command string!"
		end
	}


	for (local.a = 1; local.a <= level.AIR_reg.size; local.a++)
	{
		if (level.AIR_reg[local.a][1] == local.cmd)
		{
			println "---------------------------------------------------------------------"
			println "Dumping Entry " local.a
			println "Command: " level.AIR_reg[local.a][1]
			//println "Scriptfile: " level.AIR_reg[local.a][2]
			if (level.AIR_reg[local.a][3] == "1")
			{
				println "Type waitexec"
			}
			else
			{
				println "Type exec"
			}
			if (level.AIR_reg[local.a][4] != NIL)
			{
				println "Console Feedback: " level.AIR_reg[local.a][4]
			}
			println "---------------------------------------------------------------------"
			local.dumped = 1
		}
	}

	if (local.dumped == 1)
	{
		println ("[AIR Control::dumpone_cmd]: " + local.cmd + " successfully dumped!")
	}
	else
	{
		println ("[AIR Control::dumpone_cmd]: " + local.cmd + " not found in the register!")
	}
		
end

//////////////////////////////////////////////////////////////////////////////////////////////////
// Clear Register
// --------------
// PURPOSE: Clear all entries from the register!
//
// USE: waitthread global/AIR/AIR_Control.scr::clear_cmd <backup>
//
//////////////////////////////////////////////////////////////////////////////////////////////////
clear_cmd local.bu:

	if (level.AIR_reg == NIL)
	{
		println "[AIR Control::clear_cmd]: Register is empty, cannot erase information!"
		end
	}

	if (local.bu == 1)
	{
		if (level.AIR_rereg == NIL)
		{
			level.AIR_rereg = level.AIR_reg
		}
		else
		{
			local.c = level.AIR_rereg.size
			for (local.i = 1; local.i <= level.AIR_reg.size; local.i++)
			{
				level.AIR_rereg[(local.c + local.i)] = level.AIR_reg[local.i]
			}
		}

		waitframe
	}
		
	level.AIR_reg = NIL

	println "[AIR Control::clear_cmd]: Register successfully cleared!"

end

//////////////////////////////////////////////////////////////////////////////////////////////////
// Clear Register Entry
// ---------------------
// PURPOSE: Clear one entry from the register!
//
// USE: waitthread global/AIR/AIR_Control.scr::clear_one_cmd <"cmd"> <backup>
//
//////////////////////////////////////////////////////////////////////////////////////////////////
clear_one_cmd local.cmd local.bu:

	if (level.AIR_reg == NIL)
	{
		println "[AIR Control::clear_one_cmd]: Register is empty, cannot erase information!"
		end
	}

	for (local.i = 1; local.i <= level.AIR_reg.size; local.i++)
	{
		if (level.AIR_reg[local.i][1] == local.cmd)
		{
			if (local.bu == 1)
			{
				if (level.AIR_rereg == NIL)
					local.c = 1
				else
					local.c = ( level.AIR_rereg.size + 1 )
				
				level.AIR_rereg[local.c] = level.AIR_reg[local.i]
				waitframe
			}
			
			level.AIR_reg[local.i] = NIL
			local.clear = 1
			break
		}
	}

	if (local.clear == 1)
	{
		println ("[AIR Control::clear_cmd]: Entry " + local.cmd + " successfully cleared!")
	}

end


//////////////////////////////////////////////////////////////////////////////////////////////////
// Reregister Cleared Entry
// -------------------------
// PURPOSE: Reregister an entry you cleared earlier. This only works if the backup option
// 		was turned on when you cleared it.
//
// USE: waitthread global/AIR/AIR_Control.scr::reregister_one <"cmd">
//
//////////////////////////////////////////////////////////////////////////////////////////////////
reregister_one local.cmd:

	if (level.AIR_rereg == NIL)
	{
		println "[AIR Control::reregister_one]: Backup Register is empty!"
		println "[AIR Control::reregister_one]: Are you sure you turned on the backup option when you cleared the specified entry?"
		end
	}

	for (local.i = 1; local.i <= level.AIR_rereg.size; local.i++)
	{
		if (level.AIR_rereg[local.i][1] == local.cmd)
		{
			local.match = 1
			if (level.AIR_rereg[local.i].size == 3)
			 	waitthread global/AIR/AIR_Control.scr::register_cmd level.AIR_rereg[local.i][1] level.AIR_rereg[local.i][2] level.AIR_rereg[local.i][3]
			else if (level.AIR_rereg[local.i].size == 4)
				waitthread global/AIR/AIR_Control.scr::register_cmd level.AIR_rereg[local.i][1] level.AIR_rereg[local.i][2] level.AIR_rereg[local.i][3] level.AIR_rereg[local.i][4]
		
			level.AIR_rereg[local.i] = NIL
			break
		}
	}

	if (local.match == 1)
	{
		println ("[AIR Control::clear_cmd]: Entry " + local.cmd + " successfully reregistered!")
	}

end

///////////////////////////////////////////////////////////////////////////////
// Restart Function
// ------------------
// PURPOSE: Restarts the current map.
//
// USE: thread global/AIR/AIR_Control.scr::safe_restart_function
//
//////////////////////////////////////////////////////////////////////////////
safe_restart_function:

	level.global_maprestart["delay"] = 0.1
	level.global_maprestart["display"] = 0
	exec global/win.scr::maprestart
end

mytest:

	setcvar "g_gametype" "4"
	wait 1
	teamwin "axis"
end

// ********************************************************************************************	//
//																//
//		     			   AIR Command Script - Don't Change					//
//																//
// ********************************************************************************************	//

// --------------------------------------------------------	//
cmd_handler:
// --------------------------------------------------------	//

setcvar "AIR_cmd" ""
//waitthread global/AIR/AIR_Settings.scr::register_user_cmds

level waittill spawn
wait 3
println "[AIR Cmd::Command_Service]: Server Command-Service initialized and running!"

local.cmd_h = waitthread get_setting "cmd"

while(local.cmd_h == 1)
{

	local.AIR_cmd = getcvar("AIR_cmd")
	local.cmd_h = level.AIR["cmd"]

	if (local.AIR_cmd != "")
	{
		// Parse Command information
		local.command = waitexec global/strings.scr::split_line local.AIR_cmd 1 " "

		// Convert Command to lower case characters - just in case
		local.command[1][1] = waitexec global/strings.scr::to_lower local.command[1][1]

		if (local.command != NIL)
		{
			///////////////////////////////////
			// Parsing command
			// ----------
			// Stock commands first
			///////////////////////////////////

			switch (local.command[1][1])
			{
			case "balance":
				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				
					if (local.integer == 1 && level.balance_running != 1)
					{
						exec global/AIR/AIR_TeamBalance.scr
					}
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::TeamBalance]: Invalid value! Turn TeamBalance 1 (on) or 0 (off)!"
				}
			break
			case "balance_time":

				local.num = float(local.command[1][2])
				if (local.num > 0.05)
				{
					setcvar "AIR_cmd" ""
					local.integer = float(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::TeamBalance_Time]: Invalid value! TeamBalance-check time can't be negative or less than a frame(0.05)!"
				}
			break
			case "gmessages":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer

					if (local.integer == 1 && level.gmessages_running != 1)
					{
						exec global/AIR/AIR_gmessages.scr
					}
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Global_Messages]: Invalid value! Turn Global Messages 1 (on) or 0 (off)!"
				}
			break
			case "spec_messages":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer

					if (local.integer == 1 && level.smessages_running != 1)
					{
						exec global/AIR/AIR_messages.scr
					}
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Spec_Messages]: Invalid value! Turn Spectator Messages 1 (on) or 0 (off)!"
				}
			break
			case "camper":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Anti-Camper]: Invalid value! Turn the Anti-Camper Scanner 1 (on) or 0 (off)!"
				}
			break
			case "camper_time":

				local.num = float(local.command[1][2])
				if (local.num >= 8)
				{
					setcvar "AIR_cmd" ""
					local.integer = float(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Anti-Camper_Time]: Invalid value! The Anti-Camper time value can't be less than 8 seconds!!"
				}
			break
			case "camper_radius":

				local.num = float(local.command[1][2])
				if (local.num > 20.00)
				{
					setcvar "AIR_cmd" ""
					local.integer = float(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Anti-Camper_Radius]: Invalid value! The Anti-Camper Radius value can't be negative or less than 20!"
				}
			break
			case "camper_punish":

				if (local.command[1][2] == "0" || local.command[1][2] == "1" || local.command[1][2] == "2" || local.command[1][2] == "3" || local.command[1][2] == "4")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Anti-Camper_Punish]: Invalid value! The Anti-Camper Punishment value must be one of the following:"
					println "------------------------------------------------------------------------------------------------------------"
					println "[AIR Cmd::Anti-Camper_Punish]: 1 = Deals 10 damage each second and make player say he's a camper"
					println "[AIR Cmd::Anti-Camper_Punish]: 2 = Kill player and make player say he's a camper"
					println "[AIR Cmd::Anti-Camper_Punish]: 3 = Kick player into spectator and make player say he's a camper"
					println "[AIR Cmd::Anti-Camper_Punish]: 4 = Kicks player off the server before letting everyone know he's a camper"
				}
			break
			case "camper_message":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Anti-Camper_Message]: Invalid value! Turn the Anti-Camper Message 1 (on) or 0 (off)!"
				}
			break
			case "camper_sound":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Anti-Camper_Sound]: Invalid value! Turn the Anti-Camper Sound-Inform 1 (on) or 0 (off)!"
				}
			break
			case "cmd":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
					println "[AIR Cmd::Command_Service]: NOTE that you cannot insert any more values if the Server Command-Service is turned off. You can only turn it back on!"
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Command_Service]: Invalid value! Turn the Server Command-Service 1 (on) or 0 (off)!"
					println "[AIR Cmd::Command_Service]: NOTE that you cannot insert any more values if turned off. You can only turn it back on!"
				}
			break
			case "music":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Music]: Invalid value! Turn Spectator Music 1 (on) or 0 (off)!"
				}
			break
			case "music_mode":

				if (local.command[1][2] == "sequenced" || local.command[1][2] == "random")
				{
					setcvar "AIR_cmd" ""
					waitthread apply_setting local.command[1][1] local.command[1][2]
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Music Mode]: Invalid! The Spectator Music Mode can only be random or sequenced!"
				}
			break
			case "weapon_limiter":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Weapon Limiter]: Invalid value! Turn the Weapon Limiter 1 (on) or 0 (off)!"
				}
			break
			case "realism":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer

					if (local.integer == 1 && level.view_run != 1)
					{
						exec global/AIR_view.scr
					}
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Realism]: Invalid value! Turn the Realism Mod 1 (on) or 0 (off)!"
				}
			break
			case "nextmap_display":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer

					if (local.integer == 1 && level.nextmap_running != 1)
					{
						exec global/AIR/AIR_nextmap.scr
					}
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Nextmap]: Invalid value! Turn the Nextmap Display 1 (on) or 0 (off)!"
				}
			break
			case "nextmap_rect":

				if (local.command[1][2] != NIL || local.command[1][3] != NIL )
				{
					setcvar "AIR_cmd" ""
					waitthread global/AIR/AIR_nextmap.scr::new_rect local.command[1][2] local.command[1][3]
				}
				else
				{
					setcvar "AIR_cmd" ""
				}
			break
			case "spawn_protect":

				if (local.command[1][2] == "1" || local.command[1][2] == "0")
				{
					setcvar "AIR_cmd" ""
					local.integer = int(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Spawn Protect]: Invalid value! Turn the Spawn Protection 1 (on) or 0 (off)!"
				}
			break
			case "spawn_protect_sec":

				local.num = float(local.command[1][2])
				if (local.num >= 1)
				{
					setcvar "AIR_cmd" ""
					local.integer = float(local.command[1][2])
					waitthread apply_setting local.command[1][1] local.integer
				}
				else
				{
					setcvar "AIR_cmd" ""
					println "[AIR Cmd::Spawn Protect Time]: Invalid value! The Spawn Protect time value can't be less than 1 second!!"
				}
			break
			default:
				////////////////////////////////////////////////
				// This part of the parser scans and executes //
				// custom registered commands!		    //
				// ---------					    //
				// Remember that variables will be inserted   //
				// as strings, so adjust your scripts to	    //
				// evaluate string types (eg "1")		    //
				////////////////////////////////////////////////
				if (level.AIR_reg != NIL)
				{
					for (local.f = 1; local.f <= level.AIR_reg.size; local.f++)
					{
						if (level.AIR_reg[local.f][1] == local.command[1][1])
						{
							local.found = 1
							if (level.AIR_reg[local.f][3] == "1")
							{
								if (local.command[1].size == 1)
									waitexec level.AIR_reg[local.f][2] 
								else if (local.command[1].size == 2)
									waitexec level.AIR_reg[local.f][2] local.command[1][2] 
								else if (local.command[1].size == 3)
									waitexec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] 
								else if (local.command[1].size == 4)
									waitexec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] 
								else if (local.command[1].size == 5)
									waitexec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] local.command[1][5]
								else if (local.command[1].size == 6)
									waitexec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] local.command[1][5] local.command[1][6]
								else if (local.command[1].size == 7)
									waitexec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] local.command[1][5] local.command[1][6] local.command[1][7]
								else if (local.command[1].size == 8)
									waitexec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] local.command[1][5] local.command[1][6] local.command[1][7] local.command[1][8]
							}
							else
							{
								if (local.command[1].size == 1)
									exec level.AIR_reg[local.f][2] 
								else if (local.command[1].size == 2)
									exec level.AIR_reg[local.f][2] local.command[1][2] 
								else if (local.command[1].size == 3)
									exec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] 
								else if (local.command[1].size == 4)
									exec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] 
								else if (local.command[1].size == 5)
									exec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] local.command[1][5]
								else if (local.command[1].size == 6)
									exec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] local.command[1][5] local.command[1][6]
								else if (local.command[1].size == 7)
									exec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] local.command[1][5] local.command[1][6] local.command[1][7]
								else if (local.command[1].size == 8)
									exec level.AIR_reg[local.f][2] local.command[1][2] local.command[1][3] local.command[1][4] local.command[1][5] local.command[1][6] local.command[1][7] local.command[1][8]
							}
							if (level.AIR_reg[local.f][4] != NIL)
							{
								println level.AIR_reg[local.f][4]
							}
						}
					}
					if (local.found != 1)
					{
						println "[AIR Cmd::Command_Parser]: Invalid command!!"
					}
				}
				else 
				{
					println "[AIR Cmd::Command_Parser]: Invalid command!!"
				}
				setcvar "AIR_cmd" ""
			break
			}
			////////////////////////
			//////END Default///////
			////////////////////////
		}		
	}
	wait 1
}

while(local.cmd_h != 1)
{
	local.AIR_cmd = getcvar("AIR_cmd")
	local.cmd_h = waitthread get_setting "cmd"

	if (local.AIR_cmd != "")
	{
		// Parse Command information
		local.command = waitexec global/strings.scr::split_line local.AIR_cmd 1 " "

		// Convert Command to lower case characters - just in case
		local.command[1][1] = waitexec global/strings.scr::to_lower local.command[1][1]
		switch (local.command[1][1])
		{
			case "cmd":
				if (local.command[1][2] == "1")
				{
					setcvar "AIR_cmd" ""
					level.AIR["cmd"] = int(local.command[1][2])
				}
				else
				{
					println "[AIR Cmd::Command_Service]: You can only turn the Server Command-Service back on (1)"
				}
			break
			default:
				setcvar "AIR_cmd" ""
				println "[AIR Cmd::Command_Service]: You can only turn the Server Command-Service back on (1)"
			break
		}
	}
	wait 5
}

	println "[AIR Cmd::Command_Service]: Booting Server Command-Service back up!"
	thread cmd_handler

end
```

# xyz_Airborne_Mod\global\AIR\AIR_gmessages.scr

```scr
/*
======================================================
*** AIRborne; Global Messenger Service for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/

//----------------------------------------------------------------------//
message:											//
//----------------------------------------------------------------------//

	level waittill spawn

	if (level.AIR_gmessage == NIL)
	{
		println "[AIR GMessage-Service::Main]: No messages found. Shutting down!"
		end
	}

	if (level.gmessages_running == 1)
		end

	level.gmessages_running = 1

	local.gmessage = waitthread global/AIR/AIR_Control.scr::get_setting "gmessages"
	println "[AIR GMessage-Service::Main]: Global Messaging-Service running!"

	wait 3

	while(local.gmessage == 1)
	{
		local.gmessage = level.AIR["gmessages"]
		for (local.i = 1; local.i <= level.AIR_gmessage.size; local.i++)
		{
			for (local.o = 1; local.o <= $player.size; local.o++)
			{	
				if ($player[local.o].dmteam != "spectator")
				{ 
					$player[local.o] iprint level.AIR_gmessage[local.i][0] 0
				}
			}

			if (level.AIR_gmessage[local.i][1] != NIL && level.AIR_gmessage[local.i][1] != 0)
			{
				wait level.AIR_gmessage[local.i][1]
			}
		}

		wait 15
	}

	println "[AIR GMessage-Service::Main]: Global Messaging-Service deactivated!"
	level.gmessages_running = 0

end

//----------------------------------------------------------------------//
//*** Add messages with optional wait before the next message, 		//
//*** to the message array.								//
//----------------------------------------------------------------------//
add_message local.string local.wait:						//
//----------------------------------------------------------------------//


	if (local.string == NIL || local.string == "")
	{
		println "[AIR GMessage-Service::Add]: Please insert a (valid) string!!"
		end
	}

	if (local.bold == NIL)
		local.bold = 0


	if (level.AIR_gmessage == NIL)
	{
		level.AIR_gmessage[1][0] = local.string
		level.AIR_gmessage[1][1] = local.wait

		println "[AIR GMessage-Service::Add]: The level.AIR_gmessage array has been initialized!"

		end
	}

	local.i = level.AIR_gmessage.size + 1
	level.AIR_gmessage[local.i][0] = local.string
	level.AIR_gmessage[local.i][1] = local.wait

	println "[AIR GMessage-Service::Add]: Added entry number " local.i

end	

//----------------------------------------------------------------------//
//*** Clears the entire array 							//
//----------------------------------------------------------------------//
clean_message:										//
//----------------------------------------------------------------------//

	if (level.AIR_gmessage == NIL)
	{
		println "[AIR GMessage-Service::Clean]: Array is empty, there's nothing to clean!!"
		end
	}

	println "[AIR GMessage-Service::Clean]: Clearing the level.AIR_gmessage array"

	for (local.i = 1; local.i <= level.AIR_gmessage.size; local.i++)
	{
		level.AIR_gmessage[local.i] = NIL
	}

	//final cleanage - just to be sure
	level.AIR_gmessage = NIL 

	println "[AIR GMessage-Service::Clean]: ...Done! The array is completely cleared!"

end

```

# xyz_Airborne_Mod\global\AIR\AIR_messages.scr

```scr
/*
======================================================
*** AIRborne; Spectator Messenger Service for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/

//----------------------------------------------------------------------//
message:											//
//----------------------------------------------------------------------//

	//waitthread global/AIR/AIR_Settings.scr::add_user_specmsg
	if (level.AIR_message == NIL)
	{
		println "[AIR Message-Service::Main]: No messages found. Shutting down!"
		end
	}

	if (level.smessages_running == 1)
		end

	local.spec_message = waitthread global/AIR/AIR_Control.scr::get_setting "spec_messages"
	println "[AIR Message-Service::Main]: Spectator Messaging-Service running!"

	while(local.spec_message == 1)
	{
		local.spec_message = level.AIR["spec_messages"]
		level.smessages_running = 1
		for (local.i = 1; local.i <= $player.size; local.i++)
		{	
			if ($player[local.i].dmteam == "spectator" && $player[local.i].message != 1)
			{
				$player[local.i] thread start
			}
		}
	wait 3
	}

	println "[AIR Message-Service::Main]: Spectator Messaging-Service deactivated!"
	level.smessages_running = 0

end

//----------------------------------------------------------------------//
//*** Iprints the messages for all applicable spectators			//
start:											//
//----------------------------------------------------------------------//

	if (level.AIR_message == NIL)
	{
		println "[AIR Message-Service::print]: Array is empty, cannot print anything!!"
		
		// Disable Main loop and ongoing messages
		waitthread global/AIR/AIR_Control.scr::apply_setting "spec_messages" 0
		end
	}

	self.message = 1

	wait 5

	for (local.i = 1; local.i <= level.AIR_message.size; local.i++)
	{

		local.spec_message = level.AIR["spec_messages"]
		if (local.spec_message == 0)
		{
			self.message = 0
			end
		}

		if (self.dmteam == "spectator" && self.message == 1)
		{
			self iprint level.AIR_message[local.i][0] level.AIR_message[local.i][1]
			if (level.AIR_message[local.i][2] != NIL)
			{
				wait level.AIR_message[local.i][2]
			}
		}
		else if (self.dmteam != "spectator")
		{
			self.message = 0
			end
		}
	}
	wait 15

	self.message = 0

end

//----------------------------------------------------------------------//
//*** Add messages with optional boldness and optional wait 		//
//*** before the next message, to the message array.				//
//----------------------------------------------------------------------//
add_message local.string local.bold local.wait:					//
//----------------------------------------------------------------------//


	if (local.string == NIL || local.string == "")
	{
		println "[AIR Message-Service::Add]: Please insert a (valid) string!!"
		end
	}

	if (local.bold == NIL)
		local.bold = 0


	if (level.AIR_message == NIL)
	{
		level.AIR_message[1][0] = local.string
		level.AIR_message[1][1] = local.bold
		if (local.wait != NIL)
		{
			level.AIR_message[1][2] = local.wait
		}

		println "[AIR Message-Service::Add]: The level.AIR_message array has been initialized!"

		end
	}

	local.i = level.AIR_message.size + 1
	level.AIR_message[local.i][0] = local.string
	level.AIR_message[local.i][1] = local.bold
	if (local.wait != NIL)
	{
		level.AIR_message[local.i][2] = local.wait
	}

	println "[AIR Message-Service::Add]: Added entry number " local.i

end

//----------------------------------------------------------------------//
//*** Clears the entire array 							//
//----------------------------------------------------------------------//
clean_message:										//
//----------------------------------------------------------------------//

	if (level.AIR_message == NIL)
	{
		println "[AIR Message-Service::Clean]: Array is empty, there's nothing to clean!!"
		end
	}

	println "[AIR Message-Service::Clean]: Clearing the level.air_message array"

	for (local.i = 1; local.i <= level.AIR_message.size; local.i++)
	{
		level.AIR_message[local.i] = NIL
	}

	//final cleanage - just to be sure
	level.AIR_message = NIL 

	println "[AIR Message-Service::Clean]: ...Done! The array is completely cleared!"

end

```

# xyz_Airborne_Mod\global\AIR\AIR_music.scr

```scr
/*
======================================================
*** AIRborne; Spectator Music Script for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/
main:

	if (level.AIR["music"] == 1)
	{
		if (level.playlist == NIL)
			waitthread music_array

		if (self.music == 1)
			end
		else
			self.music = 1

		// just in case
		self stufftext "stopmp3"

		wait 1

		while(self.dmteam == spectator && level.AIR["music"] == 1 && self.music == 1)
		{
			local.mode = waitthread global/AIR/AIR_Control.scr::get_setting "music_mode"
			if (local.mode == "random" && group.wait != 1)
			{
				local.picky = randomint (level.playlist.size)
				if (local.picky == 0)
					local.picky++

				self stufftext level.playlist[local.picky][1]
				group.wait = 1

				local.wait = waitthread get_seconds level.playlist[local.picky][2] level.playlist[local.picky][3]
				local.cwait = (local.wait + 1)

				self iprint ("Playing MP3 Track: " + level.playlist[local.picky][4] + " (Duration: " + level.playlist[local.picky][2] + ":" + level.playlist[local.picky][3] + ")") 1
				thread waittill_musicdone local.cwait
			}
			if (local.mode == "sequenced" && group.wait != 1)
			{
				if (group.ct == NIL)
				{
					group.ct = 1
				}
				else
				{
					group.ct++
					if (group.ct > level.playlist.size)
					{
						group.ct = 1
					}
				}
				
				self stufftext level.playlist[group.ct][1]
				group.wait = 1				

				local.wait = waitthread get_seconds level.playlist[group.ct][2] level.playlist[group.ct][3]
				local.cwait = (local.wait + 1)

				self iprint ("Playing MP3 Track: " + level.playlist[group.ct][4] + " (Duration: " + level.playlist[group.ct][2] + ":" + level.playlist[group.ct][3] + ")") 1
				thread waittill_musicdone local.cwait
			}
			wait 0.5
		}
		self stufftext "stopmp3"
		self.music = 0
	}

end

waittill_musicdone local.cwait:

	wait local.cwait
	group.wait = 0
end


music_array:

	level.playlist = makeArray
	
	// STUFFTEXT COMMAND						//minutes	//seconds	//Title of track
	("playmp3 main/sound/music/medicdance.mp3") 		2 		56		"Medic Dance"
	("playmp3 main/sound/music/mus_01a_suspense.mp3") 	3 		24		"01a Suspense"
	("playmp3 main/sound/music/mus_02b_suspense.mp3") 	0 		38		"02b Suspense"
	("playmp3 main/sound/music/mus_02f_suspense.mp3") 	1	 	35		"02f Suspense"
	("playmp3 main/sound/music/mus_03b_success.mp3") 	0 		32		"03b Success"
	("playmp3 main/sound/music/mus_03c_suspense.mp3") 	0 		28		"03c Suspense"
	("playmp3 main/sound/music/mus_04a_suspense.mp3") 	4 		10		"04a Suspense"
	("playmp3 main/sound/music/mus_04b_suspense.mp3") 	0 		20		"04b Suspense"
	("playmp3 main/sound/music/mus_04f_suspense.mp3") 	1 		43		"04f Suspense"
	("playmp3 main/sound/music/mus_06a_mystery.mp3") 	3 		39		"06a Mystery"
	("playmp3 main/sound/music/mus_09a_action.mp3") 	3 		17		"09a Action"
	("playmp3 main/sound/music/mus_10a_action.mp3") 	4 		16		"10a Action"
	("playmp3 main/sound/music/mus_10b_suspense.mp3") 	0 		35		"10b Suspense"
	("playmp3 main/sound/music/mus_11a_surprise.mp3") 	3 		20		"11a Surprise"
	("playmp3 main/sound/music/mus_11b_action.mp3") 	2 		06		"11b Action"
	("playmp3 main/sound/music/mus_14a_action.mp3") 	3 		58		"14a Action"
	("playmp3 main/sound/music/mus_15a_mystery.mp3") 	3 		17		"15a Mystery"
	("playmp3 main/sound/music/mus_16a_mystery.mp3") 	3 		23		"16a Mystery"
	("playmp3 main/sound/music/mus_17a_mystery.mp3") 	4 		42		"17a Mystery"
	("playmp3 main/sound/music/mus_17b_mystery.mp3") 	0 		59		"17b Mystery"
	("playmp3 main/sound/music/mus_17c_failure.mp3") 	0 		21		"17c Failure"
	("playmp3 main/sound/music/mus_17d_failure.mp3") 	0 		35		"17d Failure"
	("playmp3 main/sound/music/mus_17d_mystery.mp3") 	2 		02		"17d Mystery"
	("playmp3 main/sound/music/mus_18a_action.mp3") 	4 		13		"18a Action"
	("playmp3 main/sound/music/mus_aircraftfacility.mp3") 3 		28		"Aircraft Facility"
	("playmp3 main/sound/music/mus_berlin.mp3") 		3 		06		"Berlin"
	("playmp3 main/sound/music/mus_MainTheme.mp3") 		4 		01		"MoHAA Main Theme"
	("playmp3 main/sound/music/mus_MainTheme_01d.mp3") 	2 		49		"MainTheme_01d"
	("playmp3 main/sound/music/mus_NorthAfrica_01a.mp3") 	3 		17		"North Africa 01a"
	("playmp3 main/sound/music/mus_NorthAfrica_01d.mp3") 	1 		59		"North Africa 01d"
	("playmp3 main/sound/music/mus_Schmerzen_01a.mp3") 	3 		34		"Schmerzen 01a"
	("playmp3 main/sound/music/mus_Schmerzen_01f.mp3") 	1 		12		"Schmerzen 01f"
	("playmp3 main/sound/music/mus_Schmerzen_01g.mp3") 	2 		05		"Schmerzen 01g"
	("playmp3 main/sound/music/mus_SniperTown_01a.mp3") 	3 		18		"Sniper Town 01a"
	("playmp3 main/sound/music/mus_SniperTown_01b.mp3") 	1 		09		"Sniper Town 01b"
	("playmp3 main/sound/music/mus_SniperTown_01f.mp3") 	1 		45		"Sniper Town 01f"
	("playmp3 main/sound/music/mus_TigerTank_01a.mp3") 	3		22		"Tiger Tank 01a"

	endArray

end

//----------------------------
// Too lazy to calculate it myself 
// when entering them in the array
// ... lol
get_seconds local.minutes local.seconds:

	local.int = int (local.minutes)
	local.deca_hexa = (local.int * 60)
	
	local.result = ( local.deca_hexa + local.seconds )

end local.result


```

# xyz_Airborne_Mod\global\AIR\AIR_nextmap.scr

```scr
/*
======================================================
*** AIRborne; Nextmap Display Script for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/
start:

	local.maplist = (getcvar "sv_maplist")
	local.map = waitexec global/strings.scr::split_line local.maplist 1 " "

	if (level.AIR_mapscript == NIL)
	{
		level.AIR_mapscript = waitexec global/strings.scr::to_lower (getcvar "mapname")
	}

	for (local.i = 1; local.i <= local.map[1].size; local.i++)
	{
		if (local.map[1][local.i] == level.AIR_mapscript)
		{
			local.f = (local.i + 1)
			if (local.f > local.map[1].size)
				local.f = 1

			local.match = 1
			level.AIR_nextmap = local.map[1][local.f]
			waitthread hud_nxtmap local.map[1][local.f]
			end
		}	
	}

	if (local.match != 1)
	{
		println "[AIR Nextmap::ERROR]: The current running map isn't in the maplist??"
	}
end


//************************************************************
// Displays current Nextmap on the screen
//************************************************************
hud_nxtmap local.next_map:

	local.display_map = waitthread mapname local.next_map

	// Dynamically calculate the width of the underlay box
	if ( level.AIR["nextmap_underlay"] == 1 )
	{
		local.add = 0
		for (local.i = 0; local.i < local.display_map.size; local.i++)
		{
			if (local.display_map[local.i] == "W" || local.display_map[local.i] == "w" )
				local.add += 8

			if (local.display_map[local.i] == "m" ||  local.display_map[local.i] == "M" )
			{
				if (local.next_map == local.display_map)
					local.add += 9
				else
					local.add += 12
			}
		}

		local.w = ( 100 + ( 7 * local.display_map.size ) + local.add )
	}

	while (level.AIR["nextmap_display"] == 1)
	{
		level.nextmap_running = 1

		local.rect_num = ((10 + local.display_map.size ) * -7)
		local.x = level.AIR["nextmap_rect"][1] + local.rect_num 
		local.y = level.AIR["nextmap_rect"][2]

      	huddraw_font 119 "verdana-14"
		huddraw_align 119 "right" "top"
      	huddraw_rect 119 local.x local.y 70 10
		huddraw_string 119 ("Next Map: " + local.display_map)
      	huddraw_color 119 0.69 0.69 0.00
     	 	huddraw_alpha 119 1.0

      	huddraw_font 120 "verdana-14"
		huddraw_align 120 "right" "top"
		if (local.next_map[0] == "m" || local.next_map[0] == "M")
		{
			local.string = ("[SP Map: " + local.next_map + "]")
      		huddraw_rect 120 ( level.AIR["nextmap_rect"][1] + (local.string.size * -7)) (local.y + 18) 70 10
			huddraw_string 120 local.string
		}
		else
		{
			huddraw_rect 120 ( level.AIR["nextmap_rect"][1] - 80) (local.y + 18) 70 10
			huddraw_string 120 ("[Stock Map]")
		}
      	huddraw_color 120 0.69 0.69 0.00
     	 	huddraw_alpha 120 1.0

		if ( level.AIR["nextmap_underlay"] == 1 )
		{
			huddraw_alpha 118 .60
			huddraw_align 118 "right" "top"
			huddraw_rect 118 (local.x - (local.w / 10)) (local.y - 5) local.w 42
			huddraw_shader 118 "textures/mohmenu/black"
		}
		else
		{
			huddraw_alpha 118 0.0
		}

		wait 1
	}

	level.nextmap_running = 0
	huddraw_alpha 119 0.0
	huddraw_alpha 118 0.0
	huddraw_alpha 120 0.0

end


//************************************************************
// Checks if a Full mapname is defined for the next map
// if not then it returns the bsp name.
//************************************************************
mapname local.next_map:

	local.list = waitthread nextmap_list
	for (local.e = 1; local.e <= local.list.size; local.e++)
	{
		if (local.list[local.e][1] == local.next_map)
		{
			local.result = local.list[local.e][2]
		}
	}

	if (local.result == NIL)
	{
		local.result = local.next_map
	} 
end local.result


//*****************************************
// Array with the Full mapnames
//*****************************************
nextmap_list:

	local.AIR_maplist = makeArray

	//bsp name			//map name
	"dm/mohdm1"			"Southern France"
	"dm/mohdm2"			"Destroyed Village"
	"dm/mohdm3" 		"Remagen"
	"dm/mohdm4" 		"The Crossroads"
	"dm/mohdm5" 		"Snowy Park"
	"dm/mohdm6" 		"Stalingrad"
	"dm/mohdm7" 		"Algiers"
	"obj/obj_team1" 		"The Hunt"
	"obj/obj_team2" 		"V2 Rocket"
	"obj/obj_team3" 		"Omaha Beach"
	"obj/obj_team4" 		"The Bridge"
	"m1l1" 	  		"Rangers Lead the Way"
	"m1l2a" 	  		"The Rescue Mission"
	"m1l2b" 	  		"The Motorpool"
	"m1l3a" 	  		"The Desert"
	"m1l3b" 	  		"The Airfield"
	"m1l3c" 	  		"The Lighthouse"
	"m2l1" 	  		"The Kriegsmarine"
	"m2l2a" 	  		"Naxos Prototype"
	"m2l2b" 	  		"Inside the U-529"
	"m2l2c"	  		"Cover Blown"
	"m2l3" 	  		"Escape Trondheim"
	"m3l1a" 	  		"Omaha Beach Landing"
	"m3l1b" 	  		"Omaha Beach Bunker"
	"m3l2" 	  		"Battle in Bocage"
	"m3l3" 	  		"Nebelwerfer Hunt"
	"m4l0"			"The Farm House"
	"m4l1" 	  		"Bocage at Night"
	"m4l2" 	  		"The Railway Station"
	"m4l3" 	  		"The Command Post"
	"m5l1a" 	  		"City Hall Outskirts"
	"m5l1b" 	  		"City Hall"
	"m5l2a" 	  		"King Tiger 1"
	"m5l2b" 	  		"King Tiger 2"
	"m5l3" 	  		"Bridge of Brest"
	"m6l1a" 	  		"Siegfried Forest 1"
	"m6l1b" 	  		"Siegfried Forest 2"
	"m6l1c" 	  		"Die Sturmgewehr"
	"m6l2a"	  		"Communications Blackout"
	"m6l2b" 	  		"Schmerzen Express"
	"m6l3a" 	  		"Fort Schmerzen 1"
	"m6l3b" 	  		"Fort Schmerzen 2"
	"m6l3c"	  		"Fort Schmerzen 3"
	"m6l3d" 	  		"Fort Schmerzen 4"
	"m6l3e" 	  		"Fort Schmerzen 5"
	endArray

end local.AIR_maplist


new_rect local.x local.y:

	local.nx = int (local.x)
	local.ny = int (local.y)

	level.AIR["nextmap_rect"] = (( local.nx)::( local.ny))
end
```

# xyz_Airborne_Mod\global\AIR\AIR_Settings.scr

```scr
/*
======================================================
*** AIRborne; Global Settings Script for MoH:AA
======================================================
by Sor
Version: v1.4
-----------------------------------

======================================================
*/

//// ******************************************************************** ////
//// ******************************************************************** ////
////												  ////
////				     AIR Settings Script				  ////
////				   -----------------------				  ////
////												  ////
////			Use integer values unless stated otherwise!		  ////
////												  ////
//// ******************************************************************** ////
//// ******************************************************************** ////
script_settings:

// -------------------------------------------------------- //
// Settings for Team Balance						//
// -------------------------						//
// "balance": Turn Team Balance on (1) or off (0)		//
// "balance_time": Time between the check for team		//
//			 imbalances; cannot be negative or less	//
//			 than a frame (0.05)				//
// -------------------------------------------------------- //

	level.AIR["balance"] = 1
	level.AIR["balance_time"] = 8

// -------------------------------------------------------- //
// Settings for Server Messages					//
// ----------------------------					//
// "gmessages": Turn the global server messages on (1) or	//
//		    off (0) (messages for playing clients) 	//
// "spec_messages": Turn the Spectator Server Messages on 1 //
//  			  or off 0.						//
// -------------------------------------------------------- //

	level.AIR["gmessages"] = 1
	level.AIR["spec_messages"] = 1

// -------------------------------------------------------------------------- //
// Settings for Anti-Camper									//
// ------------------------									//
// "camper": Turn the Anti-Camper mod on (1) or off (0)				//
//													//
// "camper-time": Amount of time a player can sit still before 			//
//			counter-measures are taken; this cannot be negative and 	//
//			less than a frame (0.05)						//
//													//
// "camper_radius": Radius within the player stays to become a camper and 	//
//			  get punished; cannot be less than 20!				//
//			    										//
// "camper_punish": 1 = Deals 10 damage each second (+)				//
//			  2 = Kick player to spectator (+)					//
//			  3 = Kill player(+)							//
//			  4 = Kicks player off the server before letting everyone 	//
//				know he's a camper!						//
//			  (+) if camper_message is on, it also makes the player say	//
//				he's a camper.							//
//													//
// "camper_display": Display the number (or location abbreviation) of campers	//
// 													//
// "camper-message": Turn this on with 1 or off with 0.				//
//			   This setting will: - make the player say he's a camper	//
//						    - tells the player why he's punished	//	
//						    - tell he's going to be punished if	//
//							doesn't move.				//
//													//
// "camper_sound": Dialogue sound will be played telling the player he will	//
//			 die if he doesn't move; 1 = on, 0 = off				//
//													//
// -------------------------------------------------------------------------- //

	level.AIR["camper"] = 1
	level.AIR["camper_time"] = 55
	level.AIR["camper_radius"] = 80

	level.AIR["camper_punish"] = 1

	level.AIR["camper_message"] = 1
	level.AIR["camper_sound"] = 1	


// ----------------------------------------------------------

	level.AIR["music"] = 0
	level.AIR["music_mode"] = "random"

// ----------------------------------------------------------

	level.AIR["weapon_limiter"] = 1
	level.AIR["realism"] = 0
	level.AIR["LOC_library"] = 1

	level.AIR["nextmap_display"] = 1
	level.AIR["nextmap_rect"] = (( -10)::( 60))
      level.AIR["nextmap_underlay"] = 0

	level.AIR["spawn_protect"] = 1
	level.AIR["spawn_protect_sec"] = 5.5
	
	// other ranking settings seperate
	level.AIR["RANK_system"] = 0
end

// ----------------------------------------------------------
// Map rotation options

map_settings:

	level.AIR["SP_soundfix"] = 1

	// supported mods&modes: Take out the ones you don't want to 
	// be chosen if you picked random
	level.AIR_maps["m2l1"] = "random"::"para"
	level.AIR_maps["m2l1_mods"] = "para"::"planes" 
	level.AIR_maps["m2l1_modes"] = "tdm"::"obj"::"cnh"::"ctf"

	level.AIR_maps["m2l3"] = "random"
	level.AIR_maps["m2l3_modes"] = "tdm"::"obj"::"cnh"::"ctf"

	level.AIR_maps["m4l0"] = "random"::"planes"
	level.AIR_maps["m4l0_mods"] = "para"::"planes"
	level.AIR_maps["m4l0_modes"] = "tdm"::"cnh"::"ctf"

	level.AIR_maps["m4l3"] = "random"::"planes"
	level.AIR_maps["m4l3_mods"] = "allpara"::"planes"
	level.AIR_maps["m4l3_modes"] = "tdm"::"ctf" //"tdm"::"tow"::"ctf"

	level.AIR_maps["m5l1b"] = "random"::"para"
	level.AIR_maps["m5l1b_mods"] = "para"
	level.AIR_maps["m5l1b_modes"] = "tdm"::"ktf"::"ctf"

	level.AIR_maps["m6l2a"] = "random"::"para"
	level.AIR_maps["m6l2a_mods"] = "para"
	level.AIR_maps["m6l2a_modes"] = "tdm"::"obj"::"ktf"::"ctf"
end

// -------------------------------------------------------------------------- //
// Settings for Server Command-Service							//
// -----------------------------------							//
// Turn the server-command Service on (1) or off (0)					//
// If on, this allows you to change any of the above set values in game,	//
// directly from your server!									//
//													//
// Use the following syntax:									//
// rcon AIR_cmd "<your_command> <your_value>"						//
//													//
// your_command: Being any command between the level.AIR[" "]			//
// your_value: The value you want to set; 						//
//		   you will be informed if the value is invalid.			//
//													//
// You can also turn this service off and back on any time you like		//
// -------------------------------------------------------------------------- //
main_settings:

	level.AIR["cmd"] = 1 
	level.AIR["version"] = "v2.2.62"

end


// ********************************************************************************************************	//
// ********************************************************************************************************	//
// Register Your Own Custom Commands												//
// ---------------------------------												//
// PURPOSE: If you added a custom script and like to control it or change some dynamic parts, you		//
// 		can add your own command and use it in the console with up to 3 variables!				//
//																		//
// USE: <"cmd"> <script> <"wait"> <"feedback">											//
//																		//
// CLARIFICATION:																//
// - "cmd": 	Name of the command												//
// - script: 	Filename of script, you can also specify a thread within the script. (NO STRING)		//
// - "wait": 	Must the game use waitthread/waitexec? 1 yes, 0 no							//
// - "feedback": 	OPTIONAL: This gets printed in the console when this command is activated.			//
//																		//
// CONSOLE: Like I said before you can set up to 3 variables. No need to preset this anywhere. The command	//
// 		parser automatically knows when he needs to add a variable to an exec, it is not required.	//
//																		//
//		Syntax: rcon AIR_cmd "<cmd> <var1> <var2> <var3>"								//
//																		//
//		- cmd: This is the commandname you registered earlier								//
//		- var X: This is your optional variable(s) which will be passed on to the preset script when 	//
//			   it is executed. (!) NOTE that these variables will be strings!! Adjust your if/...	//
//			   statements to strings (eg: "1" or "hello")!!!							//
//																		//
// Do this for each message on a new line after the "makeArray" and before the "endArray"				//
//																		//
// ********************************************************************************************************	//
// ********************************************************************************************************	//
register_user_cmds:
	
	local.c = makeArray
	// cmd		//script								//wait
	"dumpall" 		global/AIR/AIR_Control.scr::dumpall_cmd 			"1"
	"dumpone" 		global/AIR/AIR_Control.scr::dumpone_cmd 			"1" 
	"clear" 		global/AIR/AIR_Control.scr::clear_cmd 			"1"
	"unregister" 	global/AIR/AIR_Control.scr::unregister_cmd 		"1"
	"restart"		global/AIR/AIR_Control.scr::safe_restart_function	"0"
	"teamwin"		global/AIR/AIR_Control.scr::mytest				"0"

	endArray

end local.c

// ********************************************************************************************************	//
// ********************************************************************************************************	//
// Add Spectator Messages														//
// ----------------------														//
// PURPOSE: If you wish, you can add messages here which will be displayed to spectators between a 20 sec.	//
// 		wait. Please note that the "spec_message" setting must be turned on. If it's off, nothing		//
//		will be displayed. If it's on and nothing is added, it will shut down.					//
//																		//
// USE: <"message"> <bold> <wait>													//
//																		//
// CLARIFICATION:																//
// "message": The string containing your message.										//
// bold: (Integer) optional bold(white text) setting, if unset, it won't be bold(yellow text).			//
// wait: (Integer) optional wait value, this'll be the wait between this message and the next you add. 	//
// Do this for each message on a new line after the "makeArray" and before the "endArray"				//
//																		//
// ********************************************************************************************************	//
// ********************************************************************************************************	//

add_user_specmsg:

	local.msg = makeArray

	// Message											//bold 	//wait
	"Welcome to the Airborne Server!!" 							1		0
	"Enjoy your stay and behave!!" 							1 		6
	"General Info:" 										1		0
	"Server's IP: 91.194.59.38:12204"							0		0
	"Website: www.mohaairborne.co.cc"							0		0
	"Admin Contact: airborneserver@live.com" 						0 		6
	"BUGS/FEEDBACK; please report right away!!!"					1		7
	"New clientside parachute!! Get it from our site!!" 				1 		30

	endArray

end local.msg

// ********************************************************************************************************	//
// ********************************************************************************************************	//
// Add Global Messages															//
// --------------------															//
// PURPOSE: If you wish, you can add messages here which will be displayed to ALL SPAWNED players between 	//
// 		a 20 sec wait. Please note that the "spec_message" setting must be turned on. If it's off, 	//
//		nothing will be displayed. If it's on and nothing is added, it will shut down.			//
//																		//
// USE: <"message"> <bold> <wait>													//
//																		//
// CLARIFICATION:																//
// "message": The string containing your message.										//
// bold: (Integer) optional bold(white text) setting, if unset, it won't be bold(yellow text).			//
// wait: (Integer) optional wait value, this'll be the wait between this message and the next you add. 	//
// Do this for each message on a new line after the "makeArray" and before the "endArray"				//
//																		//
// PERK:																	//
// There's a special, dynamic word you can use in your message: "level".						//
// When you use it, the global messenger script will replace this word with the name of the current map!!	//
//																		//
// ********************************************************************************************************	//
// ********************************************************************************************************	//
add_user_globalmsg:

	local.msg = makeArray

	// Message											//wait
	"You're playing on the Airborne Server."						3
	"Enjoy your stay and play fair!"							8
	"Report bugs/feedback at once please: airborneserver@live.com"		10
	"To see the NEW parachute... "							2
	"download the xyz_New_parachute.pk3 file"						2
	"at www.mohaairborne.co.cc"								15
	" "												100
	
	endArray

end local.msg
```

# xyz_Airborne_Mod\global\AIR\AIR_sp.scr

```scr
/*
======================================================
*** AIRborne; Spawn Protection Script for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
main:

	if(self == NULL)
		end

	self nodamage

	local.team = self.dmteam

	local.wait = level.AIR["spawn_protect_sec"]
	self iprint "---Protection on!"

	while(local.wait >= 0.000)
	{
		if (self.dmteam != local.team || self.status != "alive")
		{
			break
		}
		
		local.wait -= 0.1
		wait 0.1
	}

	if (self)
	{
		self iprint "---Protection off!"
		self takedamage
	}
end
```

# xyz_Airborne_Mod\global\AIR\AIR_TeamBalance.scr

```scr
/*
======================================================
*** AIRborne; Team-Balance Script for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/

// --------------------------------	//
main:
// --------------------------------	//

	if (level.balance_running == 1)
		end

	println "[AIR TeamBalance]: Team Balance running!"

	local.balance = waitthread global/AIR/AIR_Control.scr::get_setting "balance"

	while(local.balance == 1)
	{
		level.balance_running = 1
		local.balance = level.AIR["balance"]
		local.wait = level.AIR["balance_time"]

		wait local.wait

		if($player.size > 1 )
		{
			local.team["allies"] = 0
			local.team["axis"]= 0
				
			for(local.i = 1; local.i <= $player.size; local.i++)
			{
				if($player[local.i].dmteam != "spectator")
				{
					local.team[$player[local.i].dmteam]++
				}
			}

			waitframe

			if(local.team["allies"] !=  local.team["axis"]) 
			{
				if(local.team["allies"] - local.team["axis"] > 1 || local.team["allies"] - local.team["axis"] < -1) 
				{
					if(local.team["allies"] > local.team["axis"])
					{
						local.guy = waitthread pick_random_player "allies" 
						local.guy waitthread swap_team
					}
					else
					{
						local.guy = waitthread pick_random_player "axis" 
						local.guy waitthread swap_team
					}
				}
			}
		}
	}

	level.balance_running = 0
	println "[AIR TeamBalance]: Team Balance deactivated!"
	
end

//------------------------------------
pick_random_player local.team:

	local.got_him = 0

	local.waiting = 0

	while(local.got_him == 0)
	{		
		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			if($player[local.i].dmteam == local.team && !(isalive $player[local.i]))
			{
				local.got_him = 1
				end $player[local.i]
			}

			//no one seems to be dying...
			if (local.waiting >= 30)
			{
				if($player[local.i].dmteam == local.team)
				{
					local.got_him = 1
					end $player[local.i]
				}
			}
		}
		local.waiting++
		wait 1
	}
end

//------------------------------------	
swap_team:
	wait 1
	local.team = self.dmteam
	self auto_join_team
	wait 1.5
	if (self.dmteam != local.team)
	{
		self iprint "You were randomly picked to swap teams to even them out" 1
	}
end

```

# xyz_Airborne_Mod\global\AIRborne_prefabs.scr

```scr
/*
======================================================
*** AIRborne; OBJ Prefab Scripts for MoH:AA
======================================================
by Sor
Version: v1.1.15
-----------------------------------

======================================================
*/


/*****
==============================================
		  Creation Prefabs		    
----------------------------------------------
 Contents:
 ---------
 /General Creation/
 create_model
 create_pulsexp
 create_triggeruse
 create_triggershoot

 /Specific Creation/ 
 create_kingtiger
 create_sherman
 create_opelgreen
 create_opelcanopy
 create_opel
 create_tiger
 create_tiger_desert
 create_flak
 create_post
 create_ammodepot

==============================================
*/
//------------------------------------------------------------------
create_model local.mdl local.origin local.angles local.solid:

	local.o = spawn script_model 
	local.o model local.mdl
	local.o.origin = local.origin
	local.o.angles = local.angles
	if (local.solid == 1)
	{
		local.o solid
	}
	else if (local.solid == 0)
	{
		local.o notsolid
	}

end local.o

//------------------------------------------------------------------
create_pulsexp local.o local.a:

	local.pulse = spawn script_model 
	local.pulse model "items/pulse_explosive.tik"
	local.pulse.origin = local.o
	local.pulse.angles = local.a 
	local.pulse notsolid

end local.pulse


//------------------------------------------------------------------
create_triggeruse local.o local.t:

	local.trigg = spawn trigger_use "targetname" local.t
	local.trigg.origin = local.o
	local.trigg setsize ( -40 -40 -40 ) ( 40 40 40 )

end local.trigg

//------------------------------------------------------------------
create_triggershoot local.o local.t local.bbox:

	local.trigg = spawn trigger_multiple "spawnflags" "128" "targetname" local.t 
	local.trigg.origin = local.o
	if (local.bbox != NIL)
	{
		local.trigg setsize (local.bbox[0] + ( -5 -5 -5 )) (local.bbox[1] + ( 5 5 5 ))
	}
	else
	{
		local.trigg setsize ( -40 -40 -10 ) ( 40 40 40 )
	}
end local.trigg

//------------------------------------------------------------------
create_kingtiger local.o local.a:

	local.kt = spawn vehicle model "vehicles/kingtank.tik"
	local.kt.origin = local.o
	local.kt.angles = local.a
	local.kt solid
	local.kt undrivable
	local.kt lock

end local.kt

//------------------------------------------------------------------
create_sherman local.o local.a:

	local.sh = spawn vehicle model "vehicles/shermantank.tik"
	local.sh.origin = local.o
	local.sh.angles = local.a
	local.sh solid
	local.sh undrivable
	local.sh lock

end local.sh

//------------------------------------------------------------------
create_opelgreen local.o local.a:

	local.og = spawn script_model model "vehicles/opeltruckgreen.tik"
	local.og.origin = local.o
	local.og.angles = local.a
	local.og anim idlenolights
	local.og anim stop_wheels

end local.og

//------------------------------------------------------------------
create_opelcanopy local.o local.a:

	local.og = spawn script_model model "vehicles/opeltruckgreen_canopy.tik"
	local.og.origin = local.o
	local.og.angles = local.a
	local.og anim idlenolights

end local.og

//------------------------------------------------------------------
create_opel local.o local.a:

	local.ot = spawn script_model model "vehicles/opeltruck.tik"
	local.ot.origin = local.o
	local.ot.angles = local.a
	local.ot anim idlenolights
	local.ot anim stop_wheels

end local.ot

//------------------------------------------------------------------
create_tiger local.o local.a:

	local.d = spawn vehicle model "vehicles/tigertank.tik"
	local.d.origin = local.o
	local.d.angles = local.a
	local.d solid
	local.d undrivable
	local.d lock

end local.d

//------------------------------------------------------------------
create_tiger_desert local.o local.a:

	local.d = spawn vehicle model "vehicles/tigertankdsrt.tik"
	local.d.origin = local.o
	local.d.angles = local.a
	local.d solid
	local.d undrivable
	local.d lock

end local.d


//------------------------------------------------------------------
create_flak local.o local.a:

	local.base = spawn script_model model "statweapons/flak88base.tik" 
	local.base.origin = local.o
	local.base solid

	local.turret = spawn script_model model "statweapons/flak88turret.tik"  
	local.turret.origin = local.o + ( 0 0 60 )
	local.turret.angles = local.a
	local.turret notsolid

end local.turret

//------------------------------------------------------------------
create_post local.o local.a:

	// -------------------
	// Create Sandbags
	// -------------------
	local.sandbags = makeArray
	( -65 -90 0 ) ( 0 90 0 ) "static/sandbag_link_topcap.tik"
	( 0 -90 0 ) ( 0 90 0 ) "static/sandbag_link_main.tik"
	( 70 -95 0 ) ( 0 -90 0 ) "static/sandbag_link_rightbend.tik"
	( 70 -50 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 25 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 95 0 ) ( 0 90 0 ) "static/sandbag_link_leftbend.tik"
	( 0 90 0 ) ( 0 -90 0 ) "static/sandbag_link_main.tik"
	( -70 90 0 ) ( 0 -270 0 ) "static/sandbag_link_topcap.tik"
      endArray

	for (local.i = 1; local.i <= local.sandbags.size; local.i++)
	{
		local.s = spawn script_model model local.sandbags[local.i][3]
		local.s.origin = local.o + local.sandbags[local.i][1]
		local.s.angles = local.sandbags[local.i][2]
		local.s solid
		local.s nodamage
	}

	// -------------------
	// Create Flag
	// -------------------
	local.b = spawn func_beam 
	local.b.origin = local.o
	local.b endpoint (local.o + ( 0 0 300 ))
	local.b shader "textures/barrel/blackbarrel.jpg"
	local.b maxoffset 0
	local.b scale 2
	local.b activate

	local.c = spawn script_model model "static/static_kriegsflag.tik"
	local.c.origin = local.b.origin + ( 0 50 250 )
	local.c notsolid

	// -------------------
	// Create Ammoboxes
	// -------------------
	local.d = spawn script_model model "static/indycrate.tik"
	local.d.origin = local.b.origin + ( 20 40 0 )
	local.d.angles = ( 0 35 0 )
	local.d solid
	local.d nodamage

	// Ammo Boxes
	local.f[1] = spawn trigger_use 
	local.f[1].origin = local.d.origin + ( 0 20 45 )
	local.f[1].box = spawn script_model model "models/items/item_mg_ammobox.tik"
	local.f[1].box.origin = local.f[1].origin
	local.f[1].box notsolid
	local.f[1] setsize ( -20 -20 -10 ) ( 20 20 10 )
	local.f[1].type = mg
	local.f[1].amount = 30
	local.f[1].respawn_time = 10
	local.f[1] wait 0.5
	local.f[1] setthread global/AIRborne_utils.scr::ammobox
	

	local.f[2] = spawn trigger_use 
	local.f[2].origin = local.d.origin + ( 0 0 45 )
	local.f[2].box = spawn script_model model "models/items/item_smg_ammobox.tik"
	local.f[2].box.origin = local.f[2].origin
	local.f[2].box notsolid
	local.f[2] setsize ( -20 -20 -10 ) ( 20 20 10 )
	local.f[2].type = smg
	local.f[2].amount = 30
	local.f[2].respawn_time = 10
	local.f[2] wait 0.5
	local.f[2] setthread global/AIRborne_utils.scr::ammobox

	// -------------------
	// Create MG42 Turret
	// -------------------
	local.mg42 = spawn "models/statweapons/mg42_gun.tik"
	local.mg42.origin = local.o + ( 55 -10 70 )
	local.mg42.angles = ( 0 0 0 )
	local.mg42 maxyawoffset 75

	local.mg42b = spawn script_model model "statweapons/mg42_bipod.tik"
	local.mg42b.origin = local.mg42.origin
	local.mg42b.angles = local.mg42.angles
	local.mg42b solid

	// to blow up:
	local.t[1] = local.b	//beam
	local.t[2] = local.c	//flag
	local.t[3] = local.f	//ammo boxes
	local.t[4] = local.mg42 //mg42

end local.t

//------------------------------------------------------------------
create_ammodepot local.o local.a:

	// -------------------
	// Create Sandbags
	// -------------------
	local.sandbags = makeArray
	( -65 -90 0 ) ( 0 90 0 ) "static/sandbag_link_topcap.tik"
	( 0 -90 0 ) ( 0 90 0 ) "static/sandbag_link_main.tik"
	( 70 -95 0 ) ( 0 -90 0 ) "static/sandbag_link_rightbend.tik"
	( 70 -50 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 25 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 95 0 ) ( 0 90 0 ) "static/sandbag_link_leftbend.tik"
	( 0 90 0 ) ( 0 -90 0 ) "static/sandbag_link_main.tik"
	( -70 90 0 ) ( 0 -270 0 ) "static/sandbag_link_topcap.tik"
      endArray

	for (local.i = 1; local.i <= local.sandbags.size; local.i++)
	{
		local.s = spawn script_model model local.sandbags[local.i][3]
		local.s.origin = local.o + local.sandbags[local.i][1]
		local.s.angles = local.sandbags[local.i][2]
		local.s solid
		local.s nodamage
	}

	// -------------------
	// Create Flag
	// -------------------
	local.b = spawn func_beam 
	local.b.origin = local.o
	local.b endpoint (local.o + ( 0 0 300 ))
	local.b shader "textures/barrel/blackbarrel.jpg"
	local.b maxoffset 0
	local.b scale 2
	local.b activate

	local.c = spawn script_model model "static/static_naziflag2.tik"
	local.c.origin = local.b.origin + ( 0 40 250 )
	local.c notsolid

	// -------------------
	// Create AmmoDepot Crates
	// -------------------
	local.d = spawn script_model model "static/indycrate.tik"
	local.d.origin = local.b.origin + ( 40 40 0 )
	local.d solid
	local.d nodamage

	local.crates = makeArray
	( 30 -25 6 ) "static/exp_crate1.tik"
	( 40 -60 6 ) "static/heat_crate.tik"
	( 40 -60 45 ) "static/fragcrate1.tik"
	( -20 -70 6 ) "static/bunkerbench.tik" ( 0 -90 0 )
	endArray
	
	for (local.i = 1; local.i <= local.crates.size; local.i++)
	{
		local.cr = spawn script_model model local.crates[local.i][2]
		local.cr.origin = local.o + local.crates[local.i][1]
		if (local.crates[local.i][3] != NIL)
			local.cr.angles = local.crates[local.i][3]

		local.cr solid
	}

	// -------------------
	// Create Destructible crates
	// -------------------
	local.mdl = makeArray
	( 30 60 45 ) "static/30cal_crate.tik"
	( 50 30 45 ) "static/45cal_crate.tik"
	endArray

	for (local.i = 1; local.i <= local.mdl.size; local.i++)
	{
		local.cal[local.i] = spawn script_model model local.mdl[local.i][2]
		local.cal[local.i].origin = local.o + local.mdl[local.i][1]
		local.cal[local.i] notsolid
	}

	// -------------------
	// Create Ammoboxes
	// -------------------
	local.ammo = makeArray
	( 0 -70 30 ) rifle "models/items/item_rifle_ammobox.tik" 16
	( -20 -70 30 ) mg "models/items/item_mg_ammobox.tik" 30 
	( -50 -70 30 ) smg "models/items/item_smg_ammobox.tik" 30
	endArray

	for (local.i = 1; local.i <= local.ammo.size; local.i++)
	{
		local.f[local.i] = spawn trigger_use 
		local.f[local.i].origin = local.o + local.ammo[local.i][1]
		local.f[local.i].box = spawn script_model model local.ammo[local.i][3]
		local.f[local.i].box.origin = local.f[local.i].origin
		local.f[local.i].box notsolid
		local.f[local.i] setsize ( -20 -20 -10 ) ( 20 20 10 )
		local.f[local.i].type = local.ammo[local.i][2]
		local.f[local.i].amount = local.ammo[local.i][4]
		local.f[local.i].respawn_time = 10
		local.f[local.i] wait 0.5
		local.f[local.i] setthread global/AIRborne_utils.scr::ammobox
	}

	local.t[1] = local.b	// Beam
	local.t[2] = local.c 	// Flag
	local.t[3] = local.cal	// Non-dispensible ammocrates
	local.t[4] = local.f	// Dispensible ammoboxes

end local.t

//------------------------------------------------------------------
create_naxos local.o local.a:

	local.n[1] = spawn script_model model "animate/naxosantenna.tik"
	local.n[1].origin = local.o
	local.n[1].angles = local.a
	local.n[1] solid
	
	local.n[2] = spawn script_model model "animate/naxosradar.tik"
	local.n[2].origin = local.o + ( 30 0 0 )
	local.n[2].angles = local.a
	local.n[2] solid

end local.n

/*****
==============================================
		Destruction Prefabs		    
----------------------------------------------
 Contents:
 ---------
 /General Destruction/
 destroyed_generic

 /Specific Creation/ 
 death_radar
 death_boat
 death_sherman
 death_radio
 death_opelgreen
 death_panzereu
 death_tiger
 death_enigma
 death_post
 death_ammodepot

==============================================
*/
//------------------------------------------------------------------
destroyed_generic local.thread local.o local.a:
//------------------------------------------------------------------

	println ("[Objective Prefabs::Death Generic]: Executing generic death sequence: " + local.thread)

	if (local.a == NIL || local.a == ( 0 0 0 ) )
	{
		thread local.thread local.o
	}
	else
	{
		thread local.thread local.o local.a
	}

end

//------------------------------------------------------------------
death_radar local.origin:

	local.lss = spawn script_model model "emitters/electric_arc.tik"
	local.lss.origin = local.origin + ( -30 0 110 )

	local.ls = spawn script_model model "emitters/firesmoke.tik"
	local.ls.origin = local.origin + ( -20 0 40 )
	local.ls.angles = ( -90 0 0)
	local.ls anim start

	local.f = spawn script_model model "animate/inferno_nosmoke.tik" 
	local.f.origin = local.origin + ( -20 0 60 )
	local.f anim start

end

//------------------------------------------------------------------
death_boat local.origin:

	local.master = spawn ScriptMaster
	local.master aliascache fire_higgins sound/amb/Amb_FireLoop_02.wav soundparms 1.0 0.0 1.0 0.0 400 1800 auto loaded maps "m dm moh obj train "

	local.t = spawn script_model model "emitters/fireandsmoke.tik"
	local.t.origin = local.origin + ( -75 0 60 ) // ( -110 0 60 )
	local.t loopsound fire_higgins

end

//------------------------------------------------------------------
death_sherman local.origin local.angles:

	local.neworigin = waitthread global/AIRborne_utils.scr::sherman_angle_correction local.origin local.angles

	local.s = spawn script_model model "vehicles/shermantank_damaged.tik"
	local.s.origin = local.neworigin
	local.s.angles = local.angles
	local.s solid

end

//------------------------------------------------------------------
death_radio local.o local.a:

	local.master = spawn ScriptMaster
	local.master alias radio_static sound/mechanics/static1.wav soundparms 2.0 0.0 1.0 0.0 100 1000 auto streamed maps "m dm moh obj train "
	local.master aliascache fire_radio sound/amb/Amb_FireLoop_01.wav soundparms 1.0 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train "

	local.t = spawn script_model model "emitters/electrical_fire.tik"
	local.t.origin = local.o - ( 10 0 0 )
	local.t.angles = local.a
	local.t loopsound radio_static

	local.p = spawn script_model model "emitters/fancyfire.tik"
	local.p.origin = local.o + ( 0 0 10 )
	local.p.angles = local.a
	local.p loopsound fire_radio

end

//------------------------------------------------------------------
death_opelgreen local.o local.a:

	local.master = spawn ScriptMaster
	local.master aliascache fire_opel sound/amb/Amb_FireLoop_02.wav soundparms 1.0 0.0 1.0 0.0 160 1200 auto loaded maps "m dm moh obj train "

	local.ob = spawn script_model model "emitters/fireandsmoke.tik"
	local.ob.origin = local.o + ( 20 0 50 )
	local.ob.angles = local.a
	local.ob loopsound fire_opel

end

//------------------------------------------------------------------
death_panzereu local.o:

	local.master = spawn ScriptMaster
	local.master aliascache fire_panzer sound/amb/fire.wav soundparms 1.2 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train "

	local.ob = spawn script_model model "fx/dummy.tik"
	local.ob.origin = local.o + ( 0 0 50 )
	local.ob notsolid

	wait 3
	local.ob loopsound fire_panzer

end

//------------------------------------------------------------------
death_tiger local.o local.a:

	local.f = spawn script_model model "vehicles/tigertank_d.tik"
	local.f.origin = local.o + ( 0 0 -20 )
	local.f.angles = local.a
	local.f solid

end

//------------------------------------------------------------------
death_enigma local.o:

	local.master = spawn ScriptMaster
	local.master aliascache fire_enigma sound/amb/Amb_FireLoop_01.wav soundparms 1.0 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train "

	local.f = spawn script_model model "emitters/fancyfire.tik"
	local.f.origin = local.o + ( 0 0 10 )
	local.f notsolid
	local.f loopsound fire_enigma

end

//------------------------------------------------------------------
death_post local.o local.beam local.flag local.ammo local.mg42:

	while(self.exploded != 1)
		waitframe

	local.flag delete
	for (local.i = 1; local.i <= local.ammo.size; local.i++)
	{
		local.ammo[local.i].box delete
		local.ammo[local.i] delete
	}

	local.mg42 delete
	local.beam endpoint (local.o + ( 10 10 125 ))

	local.master = spawn ScriptMaster
	local.master aliascache fires sound/amb/Amb_FirePlace.wav soundparms 8.0 0.0 1.0 0.0 150 2000 "local" loaded maps "m dm moh obj train "

	local.fx = spawn script_model model "emitters/firesmoke.tik"
	local.fx.origin = local.o + ( 0 0 20 )
	local.fx.angles = ( -90 0 0 )

	local.fx1 = spawn script_model model "emitters/fire.tik"
	local.fx1.origin = local.o
	local.fx1 loopsound fires

	local.fx2 = spawn script_model model "emitters/inferno.tik"
	local.fx2.origin = local.o

end

//------------------------------------------------------------------
death_ammodepot local.o local.beam local.flag local.ammo1 local.ammo2:

	while(self.exploded != 1)
		waitframe

	local.flag delete
	for (local.i = 1; local.i <= local.ammo1.size; local.i++)
	{
		local.ammo1[local.i] delete
	}

	for (local.i = 1; local.i <= local.ammo2.size; local.i++)
	{
		local.ammo2[local.i].box delete
		local.ammo2[local.i] delete
	}

	local.beam endpoint (local.o + ( 10 10 125 ))

	local.master = spawn ScriptMaster
	local.master aliascache fires sound/amb/Amb_FirePlace.wav soundparms 8.0 0.0 1.0 0.0 150 2000 "local" loaded maps "m dm moh obj train "

	local.fx = spawn script_model model "emitters/firesmoke.tik"
	local.fx.origin = local.o + ( 0 0 20 )
	local.fx.angles = ( -90 0 0 )

	local.fx1 = spawn script_model model "emitters/fire.tik"
	local.fx1.origin = local.o
	local.fx1 loopsound fires
	//local.fx1 stoploopsound
	//local.fx1 loopsound fires

	local.fx2 = spawn script_model model "emitters/inferno.tik"
	local.fx2.origin = local.o

end

//------------------------------------------------------------------
death_naxos local.ob:

	local.master = spawn ScriptMaster
	local.master aliascache naxos_boom sound/weapons/explo/Explo_Elec1.wav soundparms 1.5 0.2 0.8 0.4 1000 8000 auto loaded maps "m dm moh obj train "

	local.destroyed_naxos[1] = spawn script_model model "animate/naxosantenna_d.tik"
	local.destroyed_naxos[1].origin = local.ob[1].origin
	local.destroyed_naxos[1].angles = local.ob[1].angles
	local.destroyed_naxos[1] solid
	
	local.destroyed_naxos[2] = spawn script_model model "animate/naxosradar_d.tik"
	local.destroyed_naxos[2].origin = local.ob[2].origin
	local.destroyed_naxos[2].angles = local.ob[2].angles
	local.destroyed_naxos[2] solid 

	local.destroyed_naxos[2] playsound naxos_boom

	local.ob[1] delete
	local.ob[2] delete

end
```

# xyz_Airborne_Mod\global\AIRborne_utils.scr

```scr
/*
======================================================
*** AIRborne; Utility Scripts for MoH:AA
======================================================
by Sor
Version: v1.2.45
-----------------------------------

======================================================
*/



//====================================================
// To StringBox Array
// -------------------
// Converts an array created with makeArray
// to a stringbox array. For easier parsing.
//
// X being a variable, representing an entry in the array.
// eg makeArray: local.s[x][1] = "string" 
//			and local.s[x][2] = 5
//
// eg stringbox: local.s["string"] = 5
//
//====================================================
to_stringbox_array local.setting:

	// convert to stringbox array
	for (local.i = 1; local.i <= local.setting.size; local.i++)
	{
		local.p = local.setting[local.i][1]
		local.o = local.setting[local.i][2]
		local.set[local.p] = local.o
	}

end local.set

//====================================================
obj_array:

	local.d = makeArray
	"radar_bomb" 	3
	"boat_bomb"		3
	"radio_bomb"	4
	"bike_bomb"		3
	"kingt_bomb"	3
	"opelgr_bomb"	3
	"opel_bomb"		3
	"panzer_bomb"	3
	"panzer_eu_bomb"	3
	"sdkfz_bomb"	3
	"tiger_bomb"	3
	"stuka_bomb"	3
	"flockwulf_bomb"	3
	"15mm_bomb"		3
	"20mm_bomb"		3
	"nebelw_bomb"	3
	"post_bomb"		3
	"ammo_bomb"		3
	"flak_bomb"		3
	"v2_bomb"		3
	"enigma_bomb"	3
	"naxos_bomb"	3
	"machine_bomb"   	3
	"steal_docu"	4
	"steal_photo"	4
	"steal_enigma"	4
	"steal_papers"	4
	"steal_maps"	4
	"steal_plans"	4
	"steal_uniform"	4
	"steal_battery"	4
	"steal_camera"	4
	"steal_walkie"	4
	"shoot_radio"	5
	"shoot_naxos"	5
	endArray

end local.d
	

//==============================================================//
// Random Triggername
// ------------------
// For the bomb_thinker script, we need a targetname.
// The user shouldn't be needing to access it therefor 
// it is randomly generated here. 
//
//==============================================================//
get_random_triggername local.prefix:

	local.suffix_size = (randomint (5)) + 1

	local.case[1] = waitthread chardata_uppercase
	local.case[2] = waitthread chardata_lowercase
	local.case[3] = waitthread chardata_symbols

	local.target_name = local.prefix
	for (local.i = 1; local.i <= local.suffix_size; local.i++)
	{
		local.r = (randomint (3)) + 1
		local.c = (randomint (local.case[local.r].size)) + 1
		local.target_name = (local.target_name + "" + local.case[local.r][local.c])
	}

end local.target_name

//==============================================================//
chardata_symbols:

	local.o = makeArray
	"0"
	"1"
	"2"
	"3"
	"4"
	"5"
	"6"
	"7"
	"8"
	"9"
	endArray

	for(local.i = 1; local.i <= local.o.size; local.i++)
	{
		local.array[local.i] = local.o[local.i][1]
	}
	

end local.array

//==============================================================//
// Stolen from Elg, who stole it from jv
//==============================================================//
chardata_lowercase:

	local.hasharray = makeArray
	"a"
	"b"
	"c"
	"d"
	"e"
	"f"
	"g"
	"h"
	"i"
	"j"
	"k"
	"l"
	"m"
	"n"
	"o"
	"p"
	"q"
	"r"
	"s"
	"t"
	"u"
	"v"
	"w"
	"x"
	"y"
	"z"
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	

end local.array

//==============================================================//
// Stolen from Elg, who stole it from jv
//==============================================================//
chardata_uppercase:

	local.hasharray = makeArray
	"A"
	"B"
	"C"
	"D"
	"E"
	"F"
	"G"
	"H"
	"I"
	"J"
	"K"
	"L"
	"M"
	"N"
	"O"
	"P"
	"Q"
	"R"
	"S"
	"T"
	"U"
	"V"
	"W"
	"X"
	"Y"
	"Z"
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	
end local.array

/*
Waittill Roundstart
-------------------

for all gametypes
*/
waittill_roundstart:

	while(1)
	{
		local.allies = 0
		local.axis = 0

		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			if ( $player[local.i].status == "alive" && $player[local.i].dmteam == "axis" )
			{
				local.axis = 1
			}
			if ( $player[local.i].status == "alive" && $player[local.i].dmteam == "allies") 
			{
				local.allies = 1
			}
		}

		if (local.axis == 1 && local.allies == 1)
		{
			break
		}
		
		wait 0.5
	}

	waitthread respawns

	iprintlnbold_noloc "The Round has started!!"

end

/*
Respawn
--------

respawns all players at the same time
*/
respawns:

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		$player[local.i] respawn
	}

end


//==============================================================//
// Angle Correction for the Sherman Tank
// --------------------------------------
// This is a helper thread for placing the destroyed sherman model
// on the correct place with the correct "angle". 
// This is needed since the normal sherman model's rotation center 
// is not in the middle. 
//
// Here's where the rotation centers for both models are:
//
//  Sherman:				Damaged Sherman:
//  ---**---				--------
//  |	 **  |				|	 |
//  |	     |				|  **  |
//  |	     |				|  **  |
//  |	     |				|	 |
//  --------				--------
//
// This script will resolve this issue and return the origin
// (as accurately as possible) the damaged model should have, to
// be positioned correctly. 
//
// The damaged model still needs to have the same angles as the normal!
//
//==============================================================//
sherman_angle_correction local.origin local.angles:

	local.normal_length = 140

	if (local.a[1] == 0)
		end

	if (local.a[1] <= 90)
	{
		local.x = ( -local.normal_length) + ( 15.5 * ( local.a[1] / 10 ) )
		local.y = 0 - ( 16.5 * ( local.a[1] / 10 ) )
	}
	else if (local.a[1] > 90 && local.a[1] <= 180)
	{
		local.no = (local.a[1] - 90 )
		local.x = 0 + ( 15.5 * (local.no / 10 ) )
		local.y = ( -local.normal_length) + ( 15.5 * (local.no / 10 ) )  
	}
	else if (local.a[1] > 180 && local.a[1] <= 270)
	{
		local.no = (local.a[1] - 180 )
		local.x = local.normal_length - ( 16.5 * (local.no / 10 ) ) 
		local.y = 0 + ( 15.5 * (local.no / 10 ) ) 
	}
	else
	{
		local.no = (local.a[1] - 270 )
		local.x = 0 - ( 15.5 * (local.no / 10 ) ) 
		local.y = local.normal_length - ( 15.5 * (local.no / 10 ) )   
	}

	local.z = 25

	local.neworigin = local.o + ( local.x local.y local.z )

end local.neworigin

//==============================================================//
// Get Bounding Boxes
// ------------------								
// Stolen from Elg's BB mod; modified by Sor
//
// This gets the correct Bounding Box' size for the specified 
// object. Either make the object execute the thread, or pass 
// it on.
// 
// USAGE: 
//
// local.bbox = $myobject waitthread global/AIRborne_utils.scr::GetBBox
// local.bbox = waitthread global/AIRborne_utils.scr::GetBBox $myobject 
//
//==============================================================//
GetBBox local.object:

	if (local.object == NIL && self != NULL)
		local.object = self
	else if (local.object == NIL && self == NULL)
		end

	local.fwd = waitthread getbound 1 ( 1 0 0 ) local.object
	local.bwd = waitthread getbound 0 ( 1 0 0 ) local.object

	local.right = waitthread getbound 1 ( 0 1 0 ) local.object
	local.left = waitthread getbound 0 ( 0 1 0 ) local.object

	local.up = waitthread getbound 1 ( 0 0 1 ) local.object
	local.down = waitthread getbound 0 ( 0 0 1 ) local.object
		
	local.BBox[0] = ( -local.bwd -local.left -local.down )
	local.BBox[1] = ( local.fwd local.right local.up )

end local.BBox

//==============================================================//
getbound local.dir local.vector local.model:
//==============================================================//

	local.item = spawn script_origin origin local.model.origin
	local.item.angles = local.model.angles
	local.item setsize ( 0 0 0 ) ( 0 0 0 )

	for(local.i = 0;local.item istouching local.model; local.i++)
	{
		if(local.dir == 1)
		{
			local.item.origin += local.vector * 1
		}
		else
		{
			local.item.origin -= local.vector * 1
		}
	}	

	local.item delete
	    
	local.i = ( local.i * local.model.scale + 6) - 11.5

end local.i


/********
 Ammo Box Setthread
 ------------------
 This is a setthread for Ammo Triggers.
 Unlike using ammo entities, this doesn't keep giving 
 ammo once it's taken when you keep pressing use.

 It also only gives ammo if the player is holding the weapon
 to which the ammo belongs. Thus giving everyone a fair piece
 of the pie.

 These 3 properties must be defined:
 .type = <word> rifle, smg, mg, shotgun, grenade or heavy.
 .amount = <integer amount> 
 .respawn_time = <float time>
*/
ammobox:

	local.p = parm.other

	if (local.p.current_weapon == NIL && local.p.current_weaponclass == NIL && local.p.current_weapon_model == NIL)
	{
		local.p weaponcommand dual targetname ("w" + self.entnum)
		local.weapon = $("w" + self.entnum )

		if(local.weapon != NULL)
		{
			self.wpn = local.weapon.model
			local.weapon targetname ""
		}
		else
		{
			self.wpn = "models/weapons/unarmed.tik"
		}
		waitframe
		local.class = waitthread get_wpnclass self.wpn
		
	}
	else
	{
		local.class = local.p.current_weaponclass			
	}

	if (local.class != self.type)
	{
		end
	}
	else
	{
		local.p playsound snd_pickup
		local.p ammo self.type self.amount	
		local.p iprint ("You received " + self.amount + " " + self.type + " rounds!")
		
		self nottriggerable
		self.box hide
		wait self.respawn_time
		
		self triggerable
		self.box show
	}
end

//==============================================================//
/* Get Weaponclass
   ----------------
   If someone isn't using my modified statefile, then I'll check the
   weapon the Finder is holding in the old-fashion way therefor I need
   this helper script to give the ammo to the correct type of weapon!
*/
//==============================================================//
get_wpnclass local.wpn_model:

	switch(local.wpn_model)
	{
		case "models/weapons/m1_garand.tik":
		case "models/weapons/kar98.tik":
		case "models/weapons/kar98sniper.tik":
		case "models/weapons/springfield.tik":
			local.result = rifle
		break
		case "models/weapons/bar.tik":
		case "models/weapons/mp44.tik":
			local.result = mg
		break
		case "models/weapons/thompsonsmg.tik":
		case "models/weapons/mp40.tik":
			local.result = smg
		break
		case "models/weapons/bazooka.tik":
		case "models/weapons/panzerschreck.tik":
			local.result = heavy
		break
		case "models/weapons/shotgun.tik":
			local.result = shotgun
		break
		case "models/weapons/m2frag_grenade.tik":
		case "models/weapons/steilhandgranate.tik":
			local.result = grenade
		break
		case "models/weapons/colt45.tik":
		case "models/weapons/silencedpistol.tik":
		case "models/weapons/p38.tik":
			local.result = pistol
		break
		default:
			local.result = none
		break
	}
end local.result

/*
Player Models
-------------
Returns array of the specified team's player models.
*/
player_models local.team:

	if(local.team == "axis")
	{
		local.mdl[1] = "player/german_Afrika_Officer.tik"
		local.mdl[2] = "player/german_Afrika_Private.tik"
		local.mdl[3] = "player/german_Elite_Officer.tik"
		local.mdl[4] = "player/german_Elite_Sentry.tik"
		local.mdl[5] = "player/german_Kradshutzen.tik"
		local.mdl[6] = "player/german_Panzer_Grenadier.tik"
		local.mdl[7] = "player/german_Panzer_Obershutze.tik"
		local.mdl[8] = "player/german_Panzer_Shutze.tik"
		local.mdl[9] = "player/german_Panzer_Tankcommander.tik"
		local.mdl[10] = "player/german_Scientist.tik"
		local.mdl[11] = "player/german_Waffenss_Officer.tik"
		local.mdl[12] = "player/german_Waffenss_Shutze.tik"
		local.mdl[13] = "player/german_Wehrmacht_Officer.tik"
		local.mdl[14] = "player/german_Wehrmacht_Soldier.tik"
		local.mdl[15] = "player/german_Winter_1.tik"
		local.mdl[16] = "player/german_Winter_2.tik"
		local.mdl[17] = "player/german_Worker.tik"
	}
	else if (local.team == "allies")
	{
		local.mdl[1] = "player/allied_Airborne.tik"
		local.mdl[2] = "player/allied_Manon.tik"
		local.mdl[3] = "player/allied_Pilot.tik"
		local.mdl[4] = "player/allied_SAS.tik"
		local.mdl[5] = "player/american_Army.tik"
		local.mdl[6] = "player/american_Ranger.tik"
	}
	else
	{
		local.mdl[1] = "player/allied_Manon.tik"
		local.mdl[2] = "player/german_Wehrmacht_Private.tik"
	}
end local.mdl

/********
Steal-Objective Handler
-----------------------
 This is the setthread for steal-type objectives.
 Useful variables:

 level.targets_stolen["allies"]
 level.targets_stolen["axis"]
*/
steal:

	local.p = parm.other
	
	if (level.targets_stolen[self.team] == NIL)
		level.targets_stolen[self.team] = 0

	if (local.p.dmteam != self.team || self.stolen == 1)
	{
		end
	}
	else
	{
		self.object remove
		local.p playsound plantbomb1
		iprintlnbold ("The " + self.team + " have stolen the " + self.loc)
		level.targets_stolen[self.team]++
		self.stolen = 1
	}

end

/******
Numeral Suffix
---------------
Little helpthread to get the 
appropriate suffix for the 
specified numeral.
*/
get_numeralsuffix local.s:

	if (local.s == 1)
		local.add = "st"
	else if (local.s == 2)
		local.add = "nd"
	else if (local.s == 3)
		local.add = "rd"
	else
		local.add = "th"

end local.add

/******
Pulsating
----------
This thread will do a 
pulsating-like animation 
onto the specified object (self)
*/
pulsate:

	local.r = 1.0
	local.g = 0.4
	local.b = 0.4

	while(self)
	{
		for(local.i = 1; local.i <= 10 && self; local.i++)
		{
			self light (local.r - ( 0.1 * local.i)) (local.g - ( 0.04 * local.i)) (local.b - ( 0.04 * local.i)) 15
			wait 0.2
		}

		wait 0.5

		for(local.i = 1; local.i <= 10 && self; local.i++)
		{
			self light (0.0 + ( 0.01 * local.i)) (0.0 + ( 0.004 * local.i)) (0.0 + ( 0.004 * local.i)) 15
			wait 0.2
		}
	}
end

/******
Shoot
-----
 This is the setthread for 
 Shoot-type objectives. 
 Useful variables:

 level.targets_shot["allies"]
 level.targets_shot["axis"]
*/
shoot:

	local.p = parm.other

	if (level.targets_shot[self.team] == NIL)
		level.targets_shot[self.team] = 0

	if (local.p.dmteam != self.team || self.shot == 1)
	{
		end
	}
	else if (local.p.dmteam == self.team && self.h > 0)
	{
		self.object playsound snd_bh_metal
		self.h -= 10
	}
	if (local.p.dmteam == self.team && self.h <= 0)
	{
		local.master = spawn ScriptMaster
		local.master aliascache radio_boom sound/weapons/explo/Explo_Elec1.wav soundparms 1.5 0.4 0.8 0.4 1000 8000 item loaded maps "m dm moh obj train "

		thread global/AIRborne_prefabs.scr::destroyed_generic self.destruction self.object.origin self.object.angles
		self.object playsound radio_boom

		iprintlnbold ("The " + self.team + " have shot " + self.loc)
		level.targets_shot[self.team]++
		self.shot = 1
	}

end

/******
Shoot Naxos
------------
 This is a modified setthread for 
 Shoot-type objective Naxos.
 Useful variables:

 level.targets_shot["allies"]
 level.targets_shot["axis"]
*/
shoot_naxos:

	local.p = parm.other
	
	if (level.targets_shot[self.team] == NIL)
		level.targets_shot[self.team] = 0

	if (local.p.dmteam != self.team || self.shot == 1)
	{
		end
	}
	else if (local.p.dmteam == self.team && self.h > 0)
	{
		self.object playsound snd_bh_metal
		self.h -= 10
	}

	if (local.p.dmteam == self.team && self.h <= 0)
	{
		thread global/AIRborne_prefabs.scr::destroyed_generic self.destruction self.object

		iprintlnbold ("The " + self.team + " have shot " + self.loc)
		level.targets_shot[self.team]++
		self.shot = 1
	}

end

/******
Other Team
----------
Returns the strings of the team
opposite to the team specified.
*/
other_team local.t:

	if (local.t == "allies")
		local.result = "axis"
	else if (local.t == "axis")
		local.result = "allies"
	else 
		local.result = ""

end local.result

/****
Add HUD Objective
-----------------
*/
add_objective_to_hud local.obj local.type:

	if (level.obj_hudz == NIL)
		local.i = 1
	else
		local.i = level.obj_hudz.size + 1

	level.obj_hudz[local.i] = local.obj
	level.obj_hudz[local.i].type = local.type
end
/*****
Objective Match HUD
-------------------
 Start the Objective HUD.
*/
obj_hud:

	local.x = 20
	local.y = 100

	local.texture["allies"] = "textures/hud/allies"
	local.texture["axis"] = "textures/hud/axis"
	local.texture["allies_explode"] = "textures/hud/axis"
	local.texture["axis_explode"] = "textures/hud/allies" 

	local.colour["allies"] = ( 0.4 0.4 1.0 )
	local.colour["axis"] = ( 1.0 0.4 0.4 )
	local.colour["allies_explode"] = ( 0.4 0.4 1.0 )
	local.colour["axis_explode"] = ( 1.0 0.4 0.4 )

	while(1)
	{
		if (level.obj_hudz)
		{
			if (level.win_on_defuse == 1)
				local.gloc = "Win-On-Defuse v2.0"
			else
				local.gloc = "Objective Match v2.0"

			huddraw_font 248 facfont-20
			huddraw_align 248 "center" "top"
			huddraw_rect 248 -90 50 100 100
			huddraw_string 248 local.gloc
			huddraw_color 248 0.0 0.0 0.0
			huddraw_alpha 248 0.5

			huddraw_font 249 facfont-20
			huddraw_align 249 "center" "top"
			huddraw_rect 249 -89 50 100 100
			huddraw_string 249 local.gloc
			huddraw_color 249 0.0 0.4 1.0
			huddraw_alpha 249 0.8

			huddraw_font 250 facfont-20
			huddraw_align 250 "left" "center"
			huddraw_rect 250 (local.x) (local.y) 100 100
			huddraw_string 250 "[OBJECTIVES]:"
			huddraw_color 250 1.0 1.0 1.0
			huddraw_alpha 250 1.0

			local.h = local.y
			local.n = 251

			for (local.i = 1; local.i <= level.obj_hudz.size; local.i++)
			{
				local.ny = (local.y) + (25 * local.i)

				local.status = waitthread get_objhud_status level.obj_hudz[local.i]
				local.t = waitthread get_objhud_dteam level.obj_hudz[local.i]
				local.name = waitthread get_objhud_name level.obj_hudz[local.i] local.i

				huddraw_font local.n facfont-20
				huddraw_align local.n "left" "center"
				huddraw_rect local.n (local.x + 25) local.ny 100 100
				huddraw_string local.n (local.name + " " + local.status)
				huddraw_color local.n local.colour[local.t][0] local.colour[local.t][1] local.colour[local.t][2]
				huddraw_alpha local.n 1.0

				local.n++

				huddraw_align local.n "left" "center"
				huddraw_rect local.n (local.x) (local.ny - 40) 22 22
				huddraw_shader local.n local.texture[local.t]
				huddraw_alpha local.n 1.0

				local.n++
			}
		}

		wait 1
	}
end

get_objhud_status local.obj:

	if (local.obj.type == "shoot")
	{
		if (local.obj.shot != 1)
			local.status = ("[" + local.obj.h + " HP]")
		else
			local.status = "[Shot]"
	}
	else if (local.obj.type == "steal")
	{
		if (local.obj.stolen != 1)
			local.status = ""
		else
			local.status = "[Stolen]"
	}
	else
	{
		if (local.obj.live == 1)
			local.status = "[Planted]"
		else if (local.obj.exploded == 1)
			local.status = "[Exploded]"
		else
			local.status = ""
	}
end local.status

get_objhud_dteam local.obj:

	if (local.obj.type == "shoot")
	{
		if (local.obj.shot == 1)
			local.t = ( local.obj.team + "_explode")
		else
			local.t = (waitthread other_team local.obj.team) 
	}
	else if (local.obj.type == "steal")
	{
		if (local.obj.stolen == 1)
			local.t = ( local.obj.team + "_explode")
		else
			local.t = (waitthread other_team local.obj.team) 
	}
	else
	{
		if (local.obj.exploded != 1)
			local.t = local.obj.bomb["defusing_team"]
		else
			local.t = (local.obj.bomb["planting_team"] + "_explode")
	}
end local.t

get_objhud_name local.obj local.i:

	if (local.obj.loc != NIL)
	{
		local.name = local.obj.loc
	}
	else
	{
		if (local.obj.type == "shoot" || local.obj.type == "steal")
			local.name = ("Objective " + local.i)
		else
			local.name = ("Bomb " + local.i)
	}
end local.name

/**********************************************************************
 ----------------------------------------------------------------------
 					 Bomb Handler
 ----------------------------------------------------------------------
 These scripts handle all bomb objectives. 

 Useful Vars:
 ------------
 level.bomb_planted["allies"]
 level.bomb_planted["axis"]
 level.target_destroyed["allies"]
 level.target_destroyed["axis"]

 Contents:
 ---------
 adv_bomb_thinker
 bomb_waittill_set
 bomb_waittill_defuse
 bomb_waittill_explode
 bomb_exlode
 spawn_fx local.fx
 spawn_damaged local.model
 jitter_large
 jitter_local local.o
 quake local.d local.m local.o

******************************************************************** */

// -----------------------------------------------------
adv_bomb_thinker:
// -----------------------------------------------------

	if (self.bomb["planting_team"] == NIL)
	{
		println "ERROR[Bomb Thinker]: Planting team unknown."
		end
	}

	if (self.bomb["planting_team"] == "allies")
		self.bomb["defusing_team"] = "axis"
	else
		self.bomb["defusing_team"] = "allies"

	level.bomb_use_distance = 128 	//quake units
	level.bombusefov = 30

	level.subtitleX = 100
	level.subtitleY = 50

	local.d = makeArray
	"exploder_set"		"none"
	"explosion_fx"		"none"
	"explosion_sound"		"none"
	"jitter"			"large"
	"set_time"			50
	"defuse_time"		60
	"tick_time"			45
	"damage"			200
	"explosion_radius"	1054
	endArray

	for(local.i = 1; local.i <= local.d.size; local.i++)
	{
		local.t = local.d[local.i][1]
		if (self.bomb[local.t] == NIL || self.bomb[local.t] == "")
		{
			self.bomb[local.t] = local.d[local.i][2]
		}
	}

	println "------------------Bomb------------------"
	println "self = " self
	println "self.planting_team = " self.bomb["planting_team"]
	println "self.defusing_team = " self.bomb["defusing_team"]
	println " "
	if (self.target != NULL)
	{
		println "self.target (flak 88 or other) = " self.target
		println "self.target.destroyed_model = " self.target.destroyed_model
		println "self.target.destroyed_generic = " self.target.destroyed_generic
	}
	println "self.trigger_name = " self.trigger_name
	println "self.exploder_set = " self.bomb["exploder_set"]
	println "self.explosion_fx = " self.bomb["explosion_fx"]
	println "self.explosion_sound = " self.bomb["explosion_sound"]
	println "self.jitter = " self.bomb["jitter"]
	println " "
	println ("level.bomb_set_time = " + self.bomb["set_time"] + " (tenths of a second)")
	println ("level.bomb_defuse_time = " + self.bomb["defuse_time"] + " (tenths of a second)")
	println ("level.bomb_tick_time = " + self.bomb["tick_time"] + " (seconds)")
	println ("level.bomb_damage = " + self.bomb["damage"])
	println ("level.bomb_explosion_radius = " + self.bomb["explosion_radius"] + " (quake units)")
	println "------------------Bomb------------------"

	level.bomb_planted["allies"] = 0
	level.bomb_planted["axis"] = 0

	if (level.target_destroyed["allies"] == NIL)
		level.target_destroyed["allies"] = 0

	if (level.target_destroyed["axis"] == NIL)
		level.target_destroyed["axis"] = 0

	if (self.target != NIL && self.target != NULL)
		self.target notsolid

	thread bomb_waittill_set
end

// -----------------------------------------------------
// first thread... controls planting_team using the trigger
// -----------------------------------------------------
bomb_waittill_set:

self model items/pulse_explosive.tik

while ( $(self.trigger_name) )
{
	println "waittill trigger " self.trigger_name
	$(self.trigger_name) waittill trigger

	local.player = parm.other
	//"local.player.dmteam", can be 'spectator', 'freeforall', 'allies' or 'axis'
      if (local.player.dmteam != self.bomb["planting_team"]) 
	{
		//goto bomb_waittill_set
		println "failed dmteam check" local.player.dmteam	
	}
	else
	{
		local.counter = 0
		while ( (Isalive local.player) && (local.player cansee self level.bombusefov level.bomb_use_distance) && (local.player.useheld == 1) )
		{
			if (local.counter == 0)
			{
				local.player stopwatch (self.bomb["set_time"] * .1)
			}
			
			local.counter++
			wait .1
			if (local.counter >= self.bomb["set_time"])
			{
				if (self.loc != NIL)
					iprintlnbold ("A Bomb at the " + self.loc + " has been planted by the " + self.bomb["planting_team"] + "!")
				else
					iprintlnbold ("A Bomb has been planted by the " + self.bomb["planting_team"] + "!")

				if (self.bomb["planting_team"] == "allies")
					self playsound dfr_objective_o
				else
					self playsound den_objective_o

				thread bomb_waittill_defuse
				thread bomb_waittill_explode
				self.live = 1
				local.team = self.bomb["planting_team"]
				level.bomb_planted[local.team]++
				end
			}
		}

		if (local.counter > 0)
		{
			local.player stopwatch 0
		}

		println "usetrigger but failed check" 
	
		if !(local.player cansee self level.bombusefov level.bomb_use_distance)
			println "distance"
	}
}
end


// -----------------------------------------------------
// second thread... controls defusing_team using the trigger
// -----------------------------------------------------
bomb_waittill_defuse:

while ( $(self.trigger_name) )
{
	$(self.trigger_name) waittill trigger

	local.player = parm.other
	
	//"local.player.dmteam", can be 'spectator', 'freeforall', 'allies' or 'axis'
	if (local.player.dmteam != self.bomb["defusing_team"])
	{      
		println "failed dmteam check" local.player.dmteam
		//goto bomb_waittill_defuse
	}
	else
	{
		local.counter = 0
		while ( (Isalive local.player) && (local.player cansee self level.bombusefov  level.bomb_use_distance) && (local.player.useheld == 1) )
		{
			if (local.counter == 0)
			{
				local.player stopwatch (self.bomb["defuse_time"] * .1)
			}
			
			local.counter++

			wait .1
			if (local.counter >= self.bomb["defuse_time"])
			{
				if (self.loc != NIL)
					iprintlnbold ("A Bomb at the " + self.loc + " has been defused by the " + self.bomb["defusing_team"] + "!")
				else
					iprintlnbold ("A Bomb has been defused by the " + self.bomb["defusing_team"] + "!")

				if (self.bomb["defusing_team"] == "allies")
					self playsound dfr_diffused_d
				else
					self playsound den_diffused_d

				if ( level.win_on_defuse == 1 )
				{
					self.win_on_defused = 1
					end
				}

				else if ( level.win_on_defuse != 1 )
				{
					thread bomb_waittill_set //start first thread again
				}
				self.live = 0
				local.team = self.bomb["planting_team"]
				level.bomb_planted[local.team]--
				end
			}
		}

		if (local.counter > 0)
		{
			local.player stopwatch 0
		}
	}
}
end


// -----------------------------------------------------
// third thread... times the bomb and makes it explode at the right time
// -----------------------------------------------------
bomb_waittill_explode:

	self model items/explosive.tik
	self playsound plantbomb


	self loopsound bombtick
	
	local.start_time = level.time

	while (level.time < (local.start_time + self.bomb["tick_time"]) )
	{
		wait .1
		if (self.live != 1)
		{
			self stoploopsound
			end
		}
		if (level.time == (local.start_time + self.bomb["tick_time"] - 10) )
		{
			self stoploopsound
			self loopsound final_countdown
		}
 	}
 	self stoploopsound
	thread bomb_explode
end


// -----------------------------------------------------
// fourth thread... controls the explosion 
// -----------------------------------------------------
bomb_explode:

	if (self.loc != NIL && self.loc != "")
	{
		iprintlnbold ("The " + self.loc + " has been blown up by the " + self.bomb["planting_team"] + "!!")
	}

	$(self.trigger_name) remove
	
	if (self.bomb["jitter"] == "large")
	{
		thread jitter_large
	}
	else if (self.bomb["jitter"] == "local")
	{
		thread jitter_local self.origin
	}


	if (self.bomb["exploder_set"] != NIL && self.bomb["exploder_set"] != "none")
	{
		exec global/exploder.scr::explode self.bomb["exploder_set"]
	}
	
	if (self.bomb["explosion_fx"] != NIL && self.bomb["explosion_fx"] != "none")
	{
		self thread spawn_fx self.bomb["explosion_fx"]
	}
	
	if (self.bomb["explosion_sound"] != NIL && self.bomb["explosion_sound"] != "none")
	{
		self playsound self.bomb["explosion_sound"]
	}

	if (self.target != NIL && self.target != NULL)
	{
		if (self.target.destroyed_generic != NIL)
		{
			local.thread = self.target.destroyed_generic
			thread global/AIRborne_prefabs.scr::destroyed_generic local.thread self.target.origin self.target.angles
		}
		if (self.target.destroyed_model != NIL)
		{
			local.damaged = self.target waitthread spawn_damaged self.target.destroyed_model
			self.target remove
		}

		if (self.target.destroyed_generic == NIL && self.target)
		{
			self.target remove
		}
	}
	radiusdamage self.origin self.bomb["damage"] self.bomb["explosion_radius"]
	if (self.bomb["killarea"] != NIL && self.bomb["killarea"] != "none")
	{
		self.bomb["killarea"] volumedamage 1000
	}
	self hide
	
	self.live = 0
	
	self.exploded = 1
	local.team = self.bomb["planting_team"]
	level.target_destroyed[local.team]++

	// we delay the decrementing of level.bombs_planted so that the script has
	// time to determin the winner before the timelimit gets checked and hit
	wait 0.5
	level.bomb_planted[local.team]--

end


//----------------------------------
spawn_fx local.fx:
//----------------------------------

	local.temp = spawn script_model model local.fx
	local.temp.origin = self.origin
	local.temp anim start
	wait 5
	local.temp remove
end

//----------------------------------
spawn_damaged local.model:
//----------------------------------

	local.damaged = spawn script_model model local.model
	local.damaged.origin = self.origin
	local.damaged.angles = self.angles

end local.damaged

//----------------------------------
jitter_large:
//----------------------------------

	waitexec global/earthquake.scr .35 10 0 0
	waitexec global/earthquake.scr .23 6 0 0
	waitexec global/earthquake.scr 1 1 0 0
	waitexec global/earthquake.scr 1.25 .3 0 1

end

//----------------------------------
jitter_local local.o:
//----------------------------------

	waitthread quake .35 ( 9 7 4 ) local.o
	waitthread quake .23 ( 6 4 3 ) local.o
	waitthread quake 1 ( 1 0.8 1 ) local.o
	waitthread quake 1.25 ( 0.3 0.2 0.1 ) local.o

end

//----------------------------------
quake local.d local.m local.o:

	local.jitter = spawn func_viewjitter "targetname" "viewjitter" 
	local.jitter.origin = local.o
	local.jitter jitteramount local.m
	local.jitter duration local.d
	local.jitter radius 786

	wait local.d

	local.jitter remove

end
```

# xyz_Airborne_Mod\global\AIRborne.scr

```scr
/*
======================================================
*** AIRborne; OBJ Database Scripts for MoH:AA
======================================================
by Sor
Version: v1.1.65
-----------------------------------
--- NOTE:

 This might seem complicated to you, but it 
 doesn't seem that way to me. This was intended 
 to be used, only by me (Sor). I explained the use of 
 this script to myself, you could try to understand it.

-------------------

======================================================
*/

objective_setup local.obj local.settings:

	local.check = waitthread global/AIRborne_utils.scr::obj_array
	if (local.obj.size == 1)
	{
		for (local.o = 1; local.o <= local.check.size; local.o++)
		{
			if (local.check[local.o][1] == local.obj[1][1])
			{
				local.match = local.check[local.o][2]
			}
		}

		if (local.match == NIL)
		{
			println ("ERROR[Objective Setup::" + local.obj[1][1] + "]: Unknown objective")
			local.pass = 0
		}
		else
		{
			if (local.obj[1].size != local.match)
			{
				println ("ERROR[Objective Setup::" + local.obj[1][1] + "]: Unacceptable amount of objective parameters, you need " + local.match + " instead of " + local.obj[1].size + "!!")
				local.pass = 0
			}
			else
			{
				local.pass = 1
			}
		}
	} 
	else
	{
		local.pass = 0
		println "ERROR[Objective Setup]: Unacceptable amount of objectives to be set up. Only 1 at a time!"
	}

	if (local.pass == 0)
	{
		end
	}
	else
	{
		if (local.settings != NIL)
		{
			local.settings_parsed = waitthread parse_settings local.settings

			if (local.settings_parsed == NIL)
			{
				println ("ERROR[Objective Setup::" + local.obj[1][1] + "]: planting team unknown!")
				end
			}

			if (local.match == 4)
			{
				thread ("_" + local.obj[1][1]) local.obj[1][2] local.obj[1][3] local.obj[1][4] local.settings_parsed
			}
			else
			{
				thread ("_" + local.obj[1][1]) local.obj[1][2] local.obj[1][3] local.settings_parsed
			}
		}
		else
		{
			if (local.match == 5)
			{
				thread ("_" + local.obj[1][1]) local.obj[1][2] local.obj[1][3] local.obj[1][4] local.obj[1][5]
			}
			else if (local.match == 4)
			{
				thread ("_" + local.obj[1][1]) local.obj[1][2] local.obj[1][3] local.obj[1][4]
			}
			else
			{
				thread ("_" + local.obj[1][1]) local.obj[1][2] local.obj[1][3]
			}
		}
	}

end

//====================================================
parse_settings local.se:
//====================================================

	local.set = waitthread global/AIRborne_utils.scr::to_stringbox_array local.se

	local.default = makeArray
	"planting_team"			"ERROR"
	"defuse_time"			60				//tenths of a second
	"set_time"				50				//tenths of a second
	"tick_time"				45				//seconds
	"damage"				200				//health units
	"explosion_radius"		1054				//quake units
	"target_destroyed_model"	"models/fx/dummy.tik"
	"exploder_set"			NIL
	"explosion_fx"			"models/animate/fx_mortar_dirt.tik"
	"explosion_sound"			"arty_exp_sand"		
	"jitter"				"large"		
	endArray

	for (local.i = 1; local.i <= local.default.size; local.i++)
	{
		local.t = local.default[local.i][1]
		if (local.set[local.t] == NIL || local.set[local.t] == 0)
		{
			local.set[local.t] = local.default[local.i][2]
		}
	}

	if (local.set["planting_team"] == "ERROR")
		end NIL

	if (local.set["planting_team"] == "allies")
		local.set["defusing_team"] = "axis"
	else
		local.set["defusing_team"] = "allies"

end local.set

add_bombobj_to_array local.objective_bomb:

	if (level.AIRborne_bomb == NIL) 
		local.i = 1
	else
		local.i = ( level.AIRborne_bomb.size + 1 )

	level.AIRborne_bomb[local.i] = local.objective_bomb
end

add_stealobj_to_array local.objective_arti:

	if (level.AIRborne_steal == NIL) 
		local.i = 1
	else
		local.i = ( level.AIRborne_steal.size + 1 )

	level.AIRborne_steal[local.i] = local.objective_arti
end

add_shootobj_to_array local.objective_arti:

	if (level.AIRborne_shoot == NIL) 
		local.i = 1
	else
		local.i = ( level.AIRborne_shoot.size + 1 )

	level.AIRborne_shoot[local.i] = local.objective_arti
end


//****************************************************************************************//
// --------------------------------------------------------------------------------------	//
// 				  		 Bomb Objectives							//
// --------------------------------------------------------------------------------------	//
// These scripts set up all bomb objectives.								//
//															//
// Contents:													//
// ---------													//
// _kingt_bomb													//
// _radar_bomb													//
// _boat_bomb													//
// _sherman_bomb													//
// _radio_bomb													//
// _bike_bomb													//
// _opelgr_bomb													//
// _opel_canopy_bomb												//
// _opel_bomb													//
// _panzer_eu_bomb												//
// _panzer_bomb													//
// _sdkfz_sand_bomb 												//
// _sdkfz_bomb 													//
// _tiger_sand_bomb												//
// _tiger_bomb 													//
// _stuka_sand_bomb												//
// _stuka_bomb													//
// _fockwulf_bomb													//
// _15cm_bomb													//
// _20mm_bomb													//
// _nebelw_bomb													//
// _flak_bomb													//
// _v2_bomb														//
// _enigma_bomb													//
// _post_bomb													//
// _ammo_bomb													//
//															//
//****************************************************************************************//


//==============================================================//
// King Tiger Tank - Bomb						    //
// -----------------------						    //
//==============================================================//
_kingt_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 140 10 60 ))
	}

	local.tank = waitthread global/AIRborne_prefabs.scr::create_kingtiger local.target_origin local.an
	local.tank.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "kingtiger_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "kingtiger_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.tank
	local.bomb.target.destroyed_model = "vehicles/kingtank_all_d.tik"
	local.bomb.trigger_name = local.triggername

	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("King Tiger Tank")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Radar Station - Bomb						   	    //
// ---------------------						    //
//==============================================================//
_radar_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( -140 10 60 ))
	}

	local.radar = waitthread global/AIRborne_prefabs.scr::create_model "miscobj/radar.tik" local.target_origin local.an 1
	local.radar.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "radar_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "radar_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.radar
	local.bomb.target.destroyed_generic = "death_radar"
	local.bomb.trigger_name = local.triggername

	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Radar Station")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Higgins Boat - Bomb						   	    //
// ---------------------						    //
//==============================================================//
_boat_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 0 112 0 ))
	}

	local.boat = waitthread global/AIRborne_prefabs.scr::create_model "static/higginsxtrahull.tik" local.target_origin local.an
	local.boat.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "boat_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "boat_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.boat
	local.bomb.target.destroyed_model = "vehicles/higgins_damage.tik"
	local.bomb.target.destroyed_generic = "death_boat"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Higgins Boat")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Sherman Tank - Bomb						   	    //
// ---------------------						    //
//==============================================================//
_sherman_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 30 0 80 ))
	}

	local.tank = waitthread global/AIRborne_prefabs.scr::create_sherman local.target_origin local.an
	local.tank.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "sherman_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "sherman_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.tank
	local.bomb.target.destroyed_model = "fx/dummy.tik"	// Little hack to remove the target anyways
	local.bomb.target.destroyed_generic = "death_sherman"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Sherman Tank")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Radio - Bomb						   	    	    //
// -------------						    		    //
//==============================================================//
_radio_bomb local.model local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 20 0 0 ))
	}

	local.radio = waitthread global/AIRborne_prefabs.scr::create_model local.model local.target_origin local.an 1
	local.radio.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "radio_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "radio_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.radio
	local.bomb.target.destroyed_generic = "death_radio"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Radio")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Bike - Bomb						   	    	    //
// -------------						    		    //
//==============================================================//
_bike_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 65 0 20 ))
	}

	local.bike = waitthread global/AIRborne_prefabs.scr::create_model "vehicles/bmwbike.tik" local.target_origin local.an 1
	local.bike.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "bike_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "bike_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.bike
	local.bomb.target.destroyed_model = "vehicles/bmwbike_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("BMW Bike")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end


//==============================================================//
// Green Opel Truck - Bomb						    //
// ------------------------						    //
//==============================================================//
_opelgr_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 165 0 50 ))
	}

	local.truck = waitthread global/AIRborne_prefabs.scr::create_opelgreen local.target_origin local.an 
	local.truck.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "opelgreen_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "opelgreen_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.truck
	local.bomb.target.destroyed_model = "vehicles/opeltruckgreen_d.tik"
	local.bomb.target.destroyed_generic = "death_opelgreen"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Green Opel Truck")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Opel Truck Canopy - Bomb						    //
// -------------------------						    //
//==============================================================//
_opel_canopy_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 165 0 50 ))
	}

	local.truck = waitthread global/AIRborne_prefabs.scr::create_opelcanopy local.target_origin local.an 
	local.truck.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "opelcanopy_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "opelcanopy_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.truck
	local.bomb.target.destroyed_model = "vehicles/opeltruckgreen_d.tik"
	local.bomb.target.destroyed_generic = "death_opelgreen"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Opel Truck Canopy")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Opel Truck - Bomb						          //
// ------------------					    		    //
//==============================================================//
_opel_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 165 0 50 ))
	}

	local.truck = waitthread global/AIRborne_prefabs.scr::create_opel local.target_origin local.an 
	local.truck.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "opeltruck_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "opeltruck_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.truck
	local.bomb.target.destroyed_model = "vehicles/opeltruck_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Opel Truck")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Panzer IV Europe - Bomb						    //
// ------------------------					          //
//==============================================================//
_panzer_eu_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 180 0 30 ))
	}

	local.tank = waitthread global/AIRborne_prefabs.scr::create_model "static/vehicle_panzer_iv_europe.tik" local.target_origin local.an 1 
	local.tank.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "panzereu_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "panzereu_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.tank
	local.bomb.target.destroyed_model = "vehicles/panzer_iv_eud.tik"
	local.bomb.target.destroyed_generic = "death_panzereu"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Panzer IV Europe")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Panzer IV Desert - Bomb						    //
// ------------------------					          //
//==============================================================//
_panzer_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 180 0 30 ))
	}

	local.tank = waitthread global/AIRborne_prefabs.scr::create_model "vehicles/panzer_iv.tik" local.target_origin local.an 1 
	local.tank.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "panzer_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "panzer_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.tank
	local.bomb.target.destroyed_model = "vehicles/panzer_iv_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Panzer IV Desert")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// SDKFZ Desert - Bomb						    	    //
// ------------------------					          //
//==============================================================//
_sdkfz_sand_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 170 0 70 ))
	}

	local.tank = waitthread global/AIRborne_prefabs.scr::create_model "vehicles/sdkfz_afrika.tik" local.target_origin local.an 1 
	local.tank.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "sdkfzd_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "sdkfz_desert_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.tank
	local.bomb.target.destroyed_model = "vehicles/sdkfz_desert_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("SDKFZ Desert")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// SDKFZ Green - Bomb						    	    //
// -------------------					                //
//==============================================================//
_sdkfz_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 170 0 70 ))
	}

	local.tank = waitthread global/AIRborne_prefabs.scr::create_model "vehicles/sdkfz.tik" local.target_origin local.an 1 
	local.tank.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "sdkfzg_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "sdkfz_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.tank
	local.bomb.target.destroyed_model = "vehicles/sdkfz_green_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("SDKFZ Green")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Desert Tiger Tank - Bomb						    //
// --------------------------					          //
//==============================================================//
_tiger_sand_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 160 0 50 ))
	}

	local.tank = waitthread global/AIRborne_prefabs.scr::create_tiger_desert local.target_origin local.an 
	local.tank.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "tigerd_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "tiger_desert_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.tank
	local.bomb.target.destroyed_generic = "death_tiger"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Desert Tiger Tank")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end


//==============================================================//
// Tiger Tank - Bomb						          //
// -------------------				                      //
//==============================================================//
_tiger_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 160 0 50 ))
	}

	local.tank = waitthread global/AIRborne_prefabs.scr::create_tiger local.target_origin local.an 
	local.tank.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "tiger_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "tiger_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.tank
	local.bomb.target.destroyed_generic = "death_tiger"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Tiger Tank")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end


//==============================================================//
// Desert Stuka - Bomb						          //
// -------------------				                      //
//==============================================================//
_stuka_sand_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 160 0 50 ))
	}

	local.plane = waitthread global/AIRborne_prefabs.scr::create_model "vehicles/stuka-desert.tik" local.target_origin local.an 0
	local.plane.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "stukad_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "stuka_desert_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.plane
	local.bomb.target.destroyed_model = "vehicles/stukadesrt_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Desert Stuka")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Stuka - Bomb						          	    //
// -------------				                            //
//==============================================================//
_stuka_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 160 0 50 ))
	}

	local.plane = waitthread global/AIRborne_prefabs.scr::create_model "vehicles/stuka.tik" local.target_origin local.an 0
	local.plane.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "stuka_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "stuka_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.plane
	local.bomb.target.destroyed_model = "vehicles/stuka_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Stuka")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Fockwulf - Bomb						          //
// ----------------				                      //
//==============================================================//
_fockwulf_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 160 0 50 ))
	}

	local.plane = waitthread global/AIRborne_prefabs.scr::create_model "vehicles/fockwulf.tik" local.target_origin local.an 1
	local.plane.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "flockwulf_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "fockwulf_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.plane
	local.bomb.target.destroyed_model = "vehicles/fockwulf_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Fockwulf")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// 15cm Cannon - Bomb						          //
// ------------------				                      //
//==============================================================//
_15cm_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 80 0 50 ))
	}

	local.statw = waitthread global/AIRborne_prefabs.scr::create_model "statweapons/15cmcannon.tik" local.target_origin local.an 1
	local.statw.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "15cm_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "15cm_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.statw
	local.bomb.target.destroyed_model = "statweapons/15cmcannon_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("20mm Flak")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// 20mm Flak - Bomb						          //
// ------------------				                      //
//==============================================================//
_20mm_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( -100 0 50 ))
	}

	local.statw = waitthread global/AIRborne_prefabs.scr::create_model "statweapons/20mmflak.tik" local.target_origin local.an 1
	local.statw.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "20mm_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "20mm_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.statw
	local.bomb.target.destroyed_model = "statweapons/20mmflak_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("15cm Cannon")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end


//==============================================================//
// Nebelwerfer - Bomb						          //
// -------------------				                      //
//==============================================================//
_nebelw_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 30 -50 50 ))
	}

	local.statw = waitthread global/AIRborne_prefabs.scr::create_model "statweapons/nebelwerfer.tik" local.target_origin local.an 1
	local.statw.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "nebel_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "nebelwerfer_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.statw
	local.bomb.target.destroyed_model = "statweapons/nebelwerfer_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Nebelwerfer")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Flak 88 - Bomb						                //
// ---------------				                      //
//==============================================================//
_flak_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 0 -50 65 ))
	}

	local.statw = waitthread global/AIRborne_prefabs.scr::create_flak local.target_origin local.an
	local.statw.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "flak_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "flak_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.statw
	local.bomb.target.destroyed_model = "statweapons/flak88_d.tik"
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Flak 88")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// V2 Rocket - Bomb						          //
// -----------------				                      //
//==============================================================//
_v2_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 30 -40 65 ))
	}

	local.statw = waitthread global/AIRborne_prefabs.scr::create_model "static/v2.tik" local.target_origin local.an 0
	local.statw.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "v2_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "v2_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.statw
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("V2 Rocket")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Enigma - Bomb						                //
// --------------				                            //
//==============================================================//
_enigma_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 20 0 5 ))
	}

	local.statw = waitthread global/AIRborne_prefabs.scr::create_model "static/static_enigma_open.tik" local.target_origin local.an 0
	local.statw.targetname = waitthread global/AIRborne_utils.scr::get_random_triggername "enigma_"
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "enigma_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	local.bomb.target = local.statw
	local.bomb.target.destroyed_generic = "death_enigma"
	local.bomb.trigger_name = local.triggername

	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Enigma")
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Post - Bomb						    		    //
// ------------				                            //
//==============================================================//
_post_bomb local.or local.an local.settings:


	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( -10 35 50 ))
	}

	local.post = waitthread global/AIRborne_prefabs.scr::create_post local.target_origin local.an
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "post_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	//local.bomb.target = local.statw
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Defense Post")
	local.bomb thread global/AIRborne_prefabs.scr::death_post local.target_origin local.post[1] local.post[2] local.post[3] local.post[4]
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end

//==============================================================//
// Ammo Depot - Bomb						    	    //
// -----------------				                      //
//==============================================================//
_ammo_bomb local.or local.an local.settings:

	if (local.or.size > 1)
	{
		local.target_origin = local.or[1]
		local.bomb_origin = local.or[2]
	}
	else
	{
		local.target_origin = local.or
		local.bomb_origin = (local.or + ( 15 35 50 ))
	}

	local.post = waitthread global/AIRborne_prefabs.scr::create_ammodepot local.target_origin local.an
	local.bomb = waitthread global/AIRborne_prefabs.scr::create_pulsexp local.bomb_origin ( 0 0 0 ) 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "ammodepot_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.bomb_origin local.triggername

	local.bomb.bomb = local.settings
	//local.bomb.target = local.statw
	local.bomb.trigger_name = local.triggername


	waitthread add_bombobj_to_array local.bomb

	local.bomb.loc = ("Ammo Depot")
	local.bomb thread global/AIRborne_prefabs.scr::death_ammodepot local.target_origin local.post[1] local.post[2] local.post[3] local.post[4]
	local.bomb thread global/AIRborne_utils.scr::adv_bomb_thinker

end


//****************************************************************************************//
// --------------------------------------------------------------------------------------	//
// 				  		 Steal Objectives							//
// --------------------------------------------------------------------------------------	//
// These scripts set up all stealing objectives.							//
//															//
// Contents:													//
// ---------													//
// _steal_photo													//
// _steal_papers													//
// _steal_maps													//
// _steal_plans													//
// _steal_docu													//
// _steal_enigma													//
// _steal_bomb													//
//															//
//****************************************************************************************//


//==============================================================//
// Aerial Photos - Steal						    //
// ----------------------				                //
//==============================================================//
_steal_photo local.or local.an local.team:

	local.o = randomint(4)
	if (local.o == 0)
		local.o++

	local.model = ("animate/aerialphoto" + local.o + ".tik")
	local.steal = waitthread global/AIRborne_prefabs.scr::create_model local.model local.or local.an 0
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "photosteal_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.or local.triggername

	local.trigger.team = local.team
	local.trigger.object = local.steal
	local.trigger wait 0.5

	waitthread add_stealobj_to_array local.trigger

	local.trigger.loc = ("The Aerial Photos")
	local.trigger setthread global/AIRborne_utils.scr::steal

end

//==============================================================//
// Papers - Steal						  		    //
// ---------------				                      //
//==============================================================//
_steal_papers local.or local.an local.team:

	local.o = randomint(3)
	if (local.o == 0)
		local.o++

	local.model = ("animate/pulse_papers" + local.o + ".tik")
	local.steal = waitthread global/AIRborne_prefabs.scr::create_model local.model local.or local.an 0
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "paperssteal_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.or local.triggername

	local.trigger.team = local.team
	local.trigger.object = local.steal
	local.trigger wait 0.5

	waitthread add_stealobj_to_array local.trigger

	local.trigger.loc = ("The Papers")
	local.trigger setthread global/AIRborne_utils.scr::steal

end


//==============================================================//
// Maps - Steal						  		    //
// ---------------				                      //
//==============================================================//
_steal_maps local.or local.an local.team:

	local.o = randomint(5)
	if (local.o == 0)
		local.o++

	local.model = ("animate/pulse_map" + local.o + ".tik")
	local.steal = waitthread global/AIRborne_prefabs.scr::create_model local.model local.or local.an 0
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "mapssteal_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.or local.triggername

	local.trigger.team = local.team
	local.trigger.object = local.steal
	local.trigger wait 0.5

	waitthread add_stealobj_to_array local.trigger

	local.trigger.loc = ("The Maps")
	local.trigger setthread global/AIRborne_utils.scr::steal

end

//==============================================================//
// Plans - Steal						  		    //
// ---------------				                      //
//==============================================================//
_steal_plans local.or local.an local.team:

	local.o = randomint(6)
	if (local.o == 0)
		local.o++

	if (local.o != 5)
		local.model = ("items/naxosplans" + local.o + ".tik")
	else
		local.model = "animate/pulse_st44plans.tik"

	local.steal = waitthread global/AIRborne_prefabs.scr::create_model local.model local.or local.an 0
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "planssteal_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.or local.triggername

	local.trigger.team = local.team
	local.trigger.object = local.steal
	local.trigger wait 0.5

	waitthread add_stealobj_to_array local.trigger

	local.trigger.loc = ("The Plans")
	local.trigger setthread global/AIRborne_utils.scr::steal

end

//==============================================================//
// Documents - Steal						  	    //
// ------------------				                      //
//==============================================================//
_steal_docu local.or local.an local.team:

	local.o = randomint(5)
	if (local.o == 0)
		local.o++

	switch (local.o)
	{
		case 1:
			local.d = "a"
		break
		case 2:
			local.d = "b"
		break
		case 3:
			local.d = "c"
		break
		case 4:
			local.d = "d"
		break
	}

	local.model = ("items/documents1" + local.d + ".tik")

	local.steal = waitthread global/AIRborne_prefabs.scr::create_model local.model local.or local.an 0
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "docusteal_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.or local.triggername

	local.trigger.team = local.team
	local.trigger.object = local.steal
	local.trigger wait 0.5
	local.trigger.object thread global/AIRborne_utils.scr::pulsate

	waitthread add_stealobj_to_array local.trigger

	local.trigger.loc = ("The Documents")
	local.trigger setthread global/AIRborne_utils.scr::steal

end


//==============================================================//
// Enigma - Steal						  		    //
// ---------------				                      //
//==============================================================//
_steal_enigma local.or local.an local.team:

	local.model = "static/static_enigma_open.tik"

	local.steal = waitthread global/AIRborne_prefabs.scr::create_model local.model local.or local.an 0
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "enigmasteal_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.or local.triggername

	local.trigger.team = local.team
	local.trigger.object = local.steal
	local.trigger wait 0.5
	local.trigger.object thread global/AIRborne_utils.scr::pulsate

	waitthread add_stealobj_to_array local.trigger

	local.trigger.loc = ("The Enigma Machine")
	local.trigger setthread global/AIRborne_utils.scr::steal

end

//==============================================================//
// Bombs - Steal						  		    //
// ---------------				                      //
//==============================================================//
_steal_bomb local.or local.an local.team:

	local.o = randomint(3)
	if (local.o == 0)
		local.o++

	switch (local.o)
	{
		case 1:
			local.model = "animate/pulse_explosive_pickup.tik"
		break
		case 2:
			local.model = "animate/pulse_radiobomb_pickup.tik"
		break
	}

	local.steal = waitthread global/AIRborne_prefabs.scr::create_model local.model local.or local.an 0
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "bombsteal_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggeruse local.or local.triggername

	local.trigger.team = local.team
	local.trigger.object = local.steal
	local.trigger wait 0.5

	waitthread add_stealobj_to_array local.trigger

	local.trigger.loc = ("The Bomb")
	local.trigger setthread global/AIRborne_utils.scr::steal

end

//****************************************************************************************//
// --------------------------------------------------------------------------------------	//
// 				  		Shoot Objectives							//
// --------------------------------------------------------------------------------------	//
// These scripts set up all stealing objectives.							//
//															//
// Contents:													//
// ---------													//
// _shoot_radio													//
// _shoot_naxos													//
//															//
//****************************************************************************************//


//==============================================================//
// Radio - Shoot						  		    //
// ---------------				                      //
//==============================================================//
_shoot_radio local.health local.or local.an local.t:

	local.shoot = waitthread global/AIRborne_prefabs.scr::create_model "miscobj/radio_military.tik" local.or local.an 0
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "radioshoot_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggershoot local.or local.triggername (waitthread global/AIRborne_utils.scr::GetBBox local.shoot)

	local.trigger.destruction = "death_radio"
	local.trigger.object = local.shoot 
	local.trigger.team = local.t
	local.trigger.h = local.health
//	local.trigger.object thread global/AIRborne_utils.scr::pulsate

	waitthread add_shootobj_to_array local.trigger

	local.trigger.loc = ("The Radio")
	local.trigger setthread global/AIRborne_utils.scr::shoot

end

//==============================================================//
// Naxos Equipment - Shoot						    //
// ------------------------				                //
//==============================================================//
_shoot_naxos local.health local.or local.an local.t:

	local.shoot = waitthread global/AIRborne_prefabs.scr::create_naxos local.or local.an 
	local.triggername = waitthread global/AIRborne_utils.scr::get_random_triggername "naxosshoot_trigg_"
	local.trigger = waitthread global/AIRborne_prefabs.scr::create_triggershoot local.or local.triggername //local.health

	local.trigger.destruction = "death_naxos"
	local.trigger.object = local.shoot 
	local.trigger.team = local.t
	local.trigger.h = local.health

	waitthread add_shootobj_to_array local.trigger

	local.trigger.loc = ("The Naxos Equipment")
	local.trigger setthread global/AIRborne_utils.scr::shoot_naxos

end


/*
=========================================================================
					HELP SECTION
=========================================================================

	-------------------
	Available Prefabs:
	-------------------
	"sherman_bomb"	(origin)	(angles)
	"radar_bomb" 	(origin)	(angles) 			
	"boat_bomb"		(origin)	(angles) 			
	"radio_bomb"	"model"	(origin)	(angles) 	
	"bike_bomb"		(origin)	(angles) 			
	"kingt_bomb"	(origin)	(angles) 			
	"opelgr_bomb"	(origin)	(angles) 			
	"opel_bomb"		(origin)	(angles) 			
	"opel_canopy"	(origin)	(angles) 			
	"panzer_eu_bomb"	(origin)	(angles) 
	"panzer_bomb"	(origin)	(angles) 	
	"sdkfz_sand_bomb"	(origin)	(angles) 			
	"sdkfz_bomb"	(origin)	(angles) 			
	"tiger_bomb"	(origin)	(angles) 			
	"tiger_sand_bomb" (origin)	(angles) 			
	"stuka_bomb"	(origin)	(angles) 			
	"stuka_sand_bomb"	(origin)	(angles) 			
	"fockwulf_bomb"	(origin)	(angles) 			
	"15cm_bomb"		(origin)	(angles) 			
	"20mm_bomb"		(origin)	(angles)  			
	"nebelw_bomb"	(origin)	(angles)			
	"flak_bomb"		(origin)	(angles)  			
	"v2_bomb"		(origin)	(angles)  			
	"enigma_bomb"	(origin)	(angles) 			
	"post_bomb"		(origin)	(angles)  			
	"ammo_bomb"		(origin)	(angles)  		
	"steal_photo"	(origin)	(angles)     "team"    	
	"steal_papers"	(origin)	(angles)     "team"    	
	"steal_maps"	(origin)	(angles)     "team"    	
	"steal_plans"	(origin)	(angles)     "team"     
	"steal_docu"	(origin)	(angles)     "team"   	
	"steal_enigma" 	(origin)	(angles)     "team"  	
	"steal_bomb"	(origin)	(angles)     "team"	
	"shoot_radio"	health	(origin)	(angles)   "team" 
	"shoot_naxos"	health      (origin)  	(angles)   "team"

	------------
	Instructions
	------------
	(1) Only use one obj at a time, like so:

		   local.sth = makeArray
		   "steal_docu" ( 55 -684 16 ) ( 0 0 20 )
		   endArray

	    NOTE: You can, if needed, use a constant array in the origin setup: ((X Y Z)::(X Y Z))
  	    The first vector in this array is the one you would normally choose; the origin for the 
	    objective. But if a second one is defined (thus making a constant array), then the script 
          will not take the standard deviation for the location of the pulsating bomb but this second 
          origin will be taken as the origin of the pulsating bomb.

	(2) Now, if you've chosen a bomb objective (... _bomb), you must make a new array with all the
	    options you can define to your bomb objective. Else, skip this (in case of shoot_ and steal_).

		    local.sthe = makeArray
		    "planting_team"			"allies"
		    "defusing_team" 			"axis"
		    "defuse_time"				60						//tenths of seconds
		    "set_time"				45						//tenths of seconds
		    "tick_time"				80						//seconds
		    "damage"				345			
		    "explosion_radius"			360						//quake units
		    "exploder_set"			1
		    "explosion_fx"			"models/animate/fx_mortar_dirt.tik"
		    "explosion_sound"			"arty_sand"
		    "jitter"				"large"					//"large" = levelwide, "local" = locally
		    endArray		

	(3) No need to specify the target nor trigger_name, because that's going to 
          be set the _bomb prefab you've chosen.

		    exec global/AIRborne.scr::objective_setup local.sth local.sthe

	    And you're done!! The objective chosen (with the specified options) has 
	    been generated and ready to be used.

=========================================================================
=========================================================================
*/
```

# xyz_Airborne_Mod\global\cnh.scr

```scr
/*
======================================================
*** AIRborne; Capture-n'-Hold Script for MoH:AA
======================================================
by Sor
Version: v1.1 r6
-----------------------------------

========================================================================================
					INITIALIZATION THREAD
========================================================================================
*/
init local.array:

	if (level.cnh_running == 1)
		end

	level.cnh_running = 1
	level.cnh_ended = NIL

	waitthread sounds

	local.defaults = makeArray
	"fms"				1.0
	"multi_bonus" 		0
	"ticketcount" 		300
	"tickettime" 		4
	"ticketloss" 		5
	"ticket_compensation"  	0
	"HUD_display" 		1
	"HUD_underlay"		0
	"HUD_rect" 		 	(( 20)::( 65))
	endArray

	for (local.i = 1; local.i <= local.defaults.size; local.i++)
	{
		local.t = local.defaults[local.i][1]
		if (level.cnh[local.t] == NIL || level.cnh[local.t] == "")
		{
			level.cnh[local.t] = local.defaults[local.i][2]
		}
	}

	waitthread global/AIRborne_utils.scr::waittill_roundstart
	level.cnh_round_start = 1

	for (local.i = 1; local.i <= local.array.size; local.i++)
	{
		if (local.array[local.i].size == 5)
		{
			waitthread setup_base local.array[local.i][1] local.array[local.i][2] local.array[local.i][3] local.array[local.i][4] local.array[local.i][5]
		}
		else if (local.array[local.i].size == 4)
		{
			waitthread setup_base local.array[local.i][1] local.array[local.i][2] local.array[local.i][3] local.array[local.i][4]
		}
		else
		{
			// skip it
		}
	}

	thread score_handler
	if (level.cnh["HUD_display"] == 1)
	{
		thread hud_handler
	}


end

setup_base local.what local.time local.o local.team local.loc:

	if (local.team == "blank")
	{
		local.setup_team = "blank"
		local.a_team = "allies"
	}
	else
	{
		local.setup_team = local.team
		local.a_team = local.team
	}

	switch (local.what)
	{
		case "post_capture":
			local.post = waitthread create_post local.o local.setup_team
			//				          [center]   [Minimum_deviation]     [Maximum_deviation]
			local.b = waitthread get_boundries local.o    ( -70 -90 -10 )         ( 70 95 110 )

			thread check_within local.post local.b
			if (local.loc == NIL || local.loc == "")
			{
				local.post.loc = (local.setup_team + " Post")
			}
			else
			{
				local.post.loc = local.loc
			}
			thread start local.time local.a_team local.post local.o[2] 
		break
		case "ammo_capture":
			local.post = waitthread create_ammodepot local.o local.setup_team
			//				           [center]   [Minimum_deviation]     [Maximum_deviation]
			local.b = waitthread get_boundries local.o    ( -70 -90 -10 )         ( 70 95 110 )

			thread check_within local.post local.b
			if (local.loc == NIL || local.loc == "")
			{
				local.post.loc = (local.setup_team + " Ammo Depot")
			}
			else
			{
				local.post.loc = local.loc
			}
			thread start local.time local.a_team local.post local.o[2] 
		break
		case "custom_capture":
			// We're assuming that local.o is of this format: ((mins::maxs)::origin)

			local.post = waitthread create_custom local.o[2] local.setup_team
			local.b = local.o[1]

			thread check_within local.post local.b
			if (local.loc == NIL || local.loc == "")
			{
				local.post.loc = "Custom Base"
			}
			else
			{
				local.post.loc = local.loc
			}
			thread start local.time local.a_team local.post local.o[2][2] 
		break
	}

end

/*
========================================================================================
						HUD HANDLING THREADS
========================================================================================
*/
hud_handler:

	local.x = level.cnh["HUD_rect"][1]
	local.y = level.cnh["HUD_rect"][2]

	local.texture["neutralx"] = "textures/sprites/vsssource.tga"
	local.texture["neutral"] = "textures/sprites/vsssource.tga"
	local.texture["allies"] = "textures/hud/allies"
	local.texture["axis"] = "textures/hud/axis"

	local.colour["allies"] = ( 0.4 0.4 1.0 )
	local.colour["axis"] = ( 1.0 0.4 0.4 )
	local.colour["neutral"] = ( 1.0 1.0 1.0 )
	local.colour["neutralx"] = ( 1.0 1.0 1.0 )

	local.dir["up"] = "Up"
	local.dir["down"] = "Down"
	local.dir["ok"] = "Stable"

	while(1)
	{
		huddraw_font 49 facfont-20
		huddraw_align 49 "center" "top"
		huddraw_rect 49 -90 50 100 100
		huddraw_string 49 "Capture-n'-Hold (Conquest) v1.1.6"
		huddraw_color 49 0.0 0.0 0.0
		huddraw_alpha 49 0.5

		huddraw_font 50 facfont-20
		huddraw_align 50 "center" "top"
		huddraw_rect 50 -89 50 100 100
		huddraw_string 50 "Capture-n'-Hold (Conquest) v1.1.6"
		huddraw_color 50 0.0 0.4 1.0
		huddraw_alpha 50 0.8

		huddraw_font 52 facfont-20
		huddraw_align 52 "left" "center"
		huddraw_rect 52 (local.x) (local.y - 5) 100 100
		huddraw_string 52 "[SCORE]:"
		huddraw_color 52 1.0 1.0 1.0
		huddraw_alpha 52 1.0

		huddraw_font 53 handle-22
		huddraw_align 53 "left" "center"
		huddraw_rect 53 (local.x + 30) (local.y + 15) 100 100
		huddraw_string 53 ("( " + level.tickets["allies"] + " )")
		huddraw_color 53 0.0 0.1 0.8
		huddraw_alpha 53 1.0

		huddraw_font 54 handle-22
		huddraw_align 54 "left" "center"
		huddraw_rect 54 (local.x + 30) (local.y + 40) 100 100
		huddraw_string 54 ("( " + level.tickets["axis"] + " )")
		huddraw_color 54 0.8 0.1 0.0
		huddraw_alpha 54 1.0

		huddraw_align 55 "left" "center"
		huddraw_rect 55 (local.x) (local.y - 20) 22 22
		huddraw_shader 55 "textures/hud/allies"
		huddraw_alpha 55 1.0

		huddraw_align 56 "left" "center"
		huddraw_rect 56 (local.x) (local.y + 5) 22 22
		huddraw_shader 56 "textures/hud/axis"
		huddraw_alpha 56 1.0

		huddraw_font 58 facfont-20
		huddraw_align 58 "left" "center"
		huddraw_rect 58 (local.x) (local.y + 70) 100 100
		huddraw_string 58 "[BASES]:"
		huddraw_color 58 1.0 1.0 1.0
		huddraw_alpha 58 1.0

		local.h = local.y
		local.underlay_rect_y = (local.y - 35)
		local.underlay_rect_h = 75
		local.n = 59

		for (local.i = 1; local.i <= $cnhbase.size; local.i++)
		{
			local.ny = (local.y + 65) + (25 * local.i)
			local.underlay_rect_y += ( 38 - ($cnhbase.size * 5) )
			local.underlay_rect_h += ( 70 - ($cnhbase.size * 8) )

			local.t = $cnhbase[local.i].flag
			local.s = $cnhbase[local.i].loc
			local.d = $cnhbase[local.i].dir

			huddraw_font local.n facfont-20
			huddraw_align local.n "left" "center"
			huddraw_rect local.n (local.x + 25) local.ny 100 100
			huddraw_string local.n (local.s + " ( " + local.dir[local.d] + " )")
			huddraw_color local.n local.colour[local.t][0] local.colour[local.t][1] local.colour[local.t][2]
			huddraw_alpha local.n 1.0

			local.n++

			if (local.t == "neutral" || local.t == "neutralx")
			{
				huddraw_align local.n "left" "center"
				huddraw_rect local.n (local.x) (local.ny - 40) 22 22
				huddraw_shader local.n local.texture[local.t]
				huddraw_alpha local.n 1.0
			}
			else
			{
				huddraw_align local.n "left" "center"
				huddraw_rect local.n (local.x) (local.ny - 40) 22 22
				huddraw_shader local.n local.texture[local.t]
				huddraw_alpha local.n 1.0
			}

			local.n++
			
		}

		if (level.cnh["HUD_underlay"] == 1)
		{
			huddraw_align 51 "left" "center"
			huddraw_rect 51 (local.x - 10) local.underlay_rect_y 250 local.underlay_rect_h
			huddraw_shader 51 "textures/mohmenu/black"
			huddraw_alpha 51 0.6
		}

		wait 1
	}

end

/*
========================================================================================
						SCORE&WIN HANDLING THREADS
========================================================================================
*/
score_handler:

	local.bases["total"] = $cnhbase.size
	level.tickets["axis"] = level.cnh["ticketcount"] 
	level.tickets["allies"] = level.cnh["ticketcount"] 

	local.timelimit = ( (int (getcvar "timelimit")) * 60 )

	while(1)
	{
		local.time_remaining = (local.timelimit - level.time)

		if (int(local.time_remaining) == 5)
		{
			if (level.tickets["axis"] > level.tickets["allies"])
			{
				waitthread organize_win "axis"
			}
			else if (level.tickets["axis"] < level.tickets["allies"])
			{
				waitthread organize_win "allies"
			}
			else if (level.tickets["axis"] == level.tickets["allies"])
			{
				waitthread organize_win "draw"
			}

			level.cnh_ended = 1
			end
		}	

		if (level.tickets["axis"] <= 0)
		{
			waitthread organize_win "allies"
			level.cnh_ended = 1
			end
		}
		else if (level.tickets["allies"] <= 0)
		{
			waitthread organize_win "axis"
			level.cnh_ended = 1
			end
		}
		
		// Count bases
		local.bases["allies"] = 0
		local.bases["axis"] = 0
		local.bases["neutral"] = 0
		local.infavour = NIL

		local.decrease_ratio = level.cnh["ticketloss"]

		for (local.i = 1; local.i <= $cnhbase.size; local.i++)
		{
			if ($cnhbase[local.i].flag == "neutral" || $cnhbase[local.i].flag == "neutralx")
				local.bases["neutral"]++
			else if ($cnhbase[local.i].flag == "axis")
				local.bases["axis"]++
			else if ($cnhbase[local.i].flag == "allies")
				local.bases["allies"]++
		}

		// Scenarios:
		if (local.bases["allies"] == local.bases["axis"])
		{
			local.infavour = "stable"
		}
		else if (local.bases["allies"] > local.bases["axis"] && $player.size > 1)
		{
			local.infavour = "allies"
		}
		else if (local.bases["allies"] < local.bases["axis"] && $player.size > 1)
		{
			local.infavour = "axis"
		}
		else
		{
			local.infavour = "stable"
		}

		if (level.cnh["ticket_compensation"] == 1)
		{
			local.count = waitthread team_amount
			if (local.infavour == "axis" && local.count["allies"] < local.count["axis"])
			{
				local.decrease_ratio = int( local.decrease_ratio / (local.count["axis"] - local.count["allies"]) )
			}

			if (local.infavour == "allies" && local.count["allies"] > local.count["axis"])
			{
				local.decrease_ratio = int( local.decrease_ratio / (local.count["allies"] - local.count["axis"]) )
			}
		}

		
		if (local.infavour != NIL && local.infavour != "stable")
		{
			local.notinfavour = waitthread global/AIRborne_utils.scr::other_team local.infavour
			level.tickets[local.notinfavour] -= local.decrease_ratio
			if (level.tickets[local.notinfavour] <= 0 && level.tickets[local.infavour] > 0)
			{
				waitthread organize_win local.infavour
				level.cnh_ended = 1
				end
			}

			wait level.cnh["tickettime"]
		}

		wait 0.5
	}
	

end

organize_win local.winner:

	wait 2

	local.gt = getcvar "g_gametype"
	setcvar "g_gametype" "4"

	level.global_win["winner"] = local.winner
	level.global_win["winevent"] = "round_restart"
	level.global_win["winevent_delay"] = 0.5
	level.global_win["winevent_display"] = 0

	waitexec global/win.scr::teamwins

//	setcvar "g_gametype" local.gt

end

team_amount:

	local.teams["allies"] = 0
	local.teams["axis"] = 0
	local.teams["spectator"] = 0

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		local.t = $player[local.i].dmteam 
		local.teams[local.t]++
	}

end local.teams


/*
========================================================================================
					FLAG & BASE HANDLING THREADS
========================================================================================
*/
start local.time local.ot local.post local.down:

	// local.ot is the "defender"
	// local.t is the "attacker"
	// Though this doesn't really matter since both can lose
	// a base and it can constantly switch ownership.

	local.t = waitthread global/AIRborne_utils.scr::other_team local.ot
	local.wait = 0

	local.up = local.down + 200
	local.post.dir = "ok"

	group.printwait = 0
	local.check = 0

	local.orig_descend = ( 0 0 ( -25 / (level.cnh["fms"] * 10)) )
	local.orig_ascend = ( 0 0 ( 25 / (level.cnh["fms"] * 10)) )

	while(level.cnh_ended != 1)
	{
		///////////////////////////////
		//   Scenarios in Conquest   //
		///////////////////////////////

		// CAPTURER: If the enemy flag is on its way down or if it's still at the top of the pole
		if (local.post.within[local.t] > 0 && local.post.within[local.ot] == 0 && local.post.flag == local.ot )
		{
			if (local.post.original_owner == local.t)
				thread printline ("The " + local.t + " are recapturing the " + local.post.loc + "!")
			else 
				thread printline ("The " + local.t + " are capturing the " + local.post.loc + "!")
			local.wait = 0
			local.post.dir = "down"
			local.attacker = local.t
			local.defender = local.ot
		}
		// CAPTURER: If it's on its way up
		else if (local.post.within[local.t] > 0 && local.post.within[local.ot] == 0 && local.post.flag == "neutral") 
		{
			local.wait = 0
			if (local.post.original_owner == local.t)
			{
//				thread printline ("The " + local.post.loc + " is still being recaptured by the " + local.t + "!")
				if (local.check == 1)
					local.post.dir = "down"
				else
					local.post.dir = "up"
			}
			else
			{
//				thread printline ("The " + local.post.loc + " is still being captured by the " + local.t + "!")
				if (local.check == 1)
					local.post.dir = "up"
				else
					local.post.dir = "down"
			}
			local.attacker = local.t
			local.defender = local.ot
		}
		// CAPTURER: If you captured it but it's again on its way down
		else if (local.post.within[local.t] > 0 && local.post.within[local.ot] == 0 && local.post.flag == local.t && local.post.item[4].origin[2] != local.up)
		{
			thread printline ("The " + local.t + " are defending their " + local.post.loc + "!")
			local.wait = 0
			local.post.dir = "up"
			local.attacker = local.t
			local.defender = local.ot
		}
		// NEUTR: If the flag is neutral by default
		else if (local.post.within[local.t] > 0 && local.post.within[local.ot] == 0 && local.post.flag == "neutralx") 
		{
			thread printline ("The " + local.t + " are capturing the " + local.post.loc + "!")
			local.wait = 0
			local.post.dir = "down"
			local.attacker = local.t
			local.defender = local.ot
		}
		// DEFENDER: If the flag has been captured or if the captured flag is already on it's way to be recaptured
		else 	if (local.post.within[local.ot] > 0 && local.post.within[local.t] == 0 && local.post.flag == local.t)
		{
			if (local.post.original_owner == local.ot)
				thread printline ("The " + local.ot + " are recapturing the " + local.post.loc + "!")
			else 
				thread printline ("The " + local.ot + " are capturing the " + local.post.loc + "!")
			local.wait = 0
			local.post.dir = "down"
			local.attacker = local.ot
			local.defender = local.t
		}
		// DEFENDER: If the flag is on its way up to become captured
		else 	if (local.post.within[local.ot] > 0 && local.post.within[local.t] == 0 && local.post.flag == "neutral") 
		{
			local.wait = 0
			if (local.post.original_owner == local.ot)
			{
//				thread printline ("The " + local.post.loc + " is still being recaptured by the " + local.ot + "!")
				if (local.check == 1)
					local.post.dir = "down"
				else
					local.post.dir = "up"
			}
			else
			{
//				thread printline ("The " + local.post.loc + " is still being captured by the " + local.ot + "!")
				if (local.check == 1)
					local.post.dir = "up"
				else
					local.post.dir = "down"
			}
			local.attacker = local.ot
			local.defender = local.t
		}
		// DEFENDER: If the flag is on its way down.
		else 	if (local.post.within[local.ot] > 0 && local.post.within[local.t] == 0 && local.post.flag == local.ot && local.post.item[4].origin[2] != local.up)
		{
			thread printline ("The " + local.ot + " are defending their " + local.post.loc + "!")
			local.wait = 0
			local.post.dir = "up"
			local.attacker = local.ot
			local.defender = local.t
		}
		// NEUTR: If the flag is neutral by default
		else if (local.post.within[local.ot] > 0 && local.post.within[local.t] == 0 && local.post.flag == "neutralx") 
		{
			thread printline ("The " + local.ot + " are capturing the " + local.post.loc + "!")
			local.wait = 0
			local.post.dir = "down"
			local.attacker = local.ot
			local.defender = local.t
		}
		else if (local.post.within[local.t] > 0 && local.post.within[local.ot] > 0)
		{
			local.attacker = "no one"
			local.defender = "no one"

			if (local.wait == 0)
			{
				for (local.c = 1; local.c <= $player.size; local.c++)
				{
					if ($player[local.c].dmteam == local.t)
						$player[local.c] iprint ("[Capture by " + local.t + "] There are still " + local.ot + " in the vicinity of the " + local.post.loc + "!") 1
					else if ($player[local.c].dmteam == local.ot)
						$player[local.c] iprint ("[Defend by " + local.ot + "] There are still " + local.t + " in the vicinity of the " + local.post.loc + "!") 1

				}
				local.wait = 7
			}
			else
			{
				local.wait -= 0.05
			}
		}
		else
		{
			local.wait = 0
			local.attacker = "no one"
			local.defender = "no one"
		}

		
		if ( local.attacker != "no one" )
		{
			//println local.post.item[4].origin[2]

			//Multiplicity Bonus
			if (local.post.within[local.ot] > 1 || local.post.within[local.t] > 1)
			{
				if (level.cnh["multi_bonus"] == 1)
				{
					local.descend = ( 0 0 (local.orig_descend * 2))
					local.ascend = ( 0 0 (local.orig_ascend * 2))
				}
				else
				{
					local.descend = local.orig_descend
					local.ascend = local.orig_ascend
				}
			}
			else
			{
				local.descend = local.orig_descend
				local.ascend = local.orig_ascend
			}

			if (local.post.item[4].origin[2] > local.down)
			{ 
				for (local.c = 1; local.c <= local.post.item.size; local.c++)
				{
					if (local.post.dir == "down")
						local.post.item[local.c].origin += local.descend //( 0 0 -25 )
					else if (local.post.dir == "up")
						local.post.item[local.c].origin += local.ascend //( 0 0 25 )
							
					local.post.item[local.c] endpoint (local.post.item[local.c].origin + ( 0 0 25 ))
				}

				if (local.post.dir == "up" && local.post.item[4].origin[2] == local.up && local.post.flag != local.attacker)
				{
					local.post.dir = "ok"
					local.post.flag = local.attacker
					iprintlnbold_noloc ("[CnH]: The " + local.attacker + " have seized control of the " + local.post.loc + "!")
					for (local.c = 1; local.c <= local.post.item.size; local.c++)
					{
						local.post.item[local.c] shader ("textures/hud/" + local.attacker + ".tga") 
					}

					if (local.post.original_owner == "neutralx")
						local.post.original_owner = local.attacker

					thread play_capture_in_favour_of local.attacker

				}
				else if (local.post.dir == "up" && local.post.item[4].origin[2] == local.up && local.post.flag == local.attacker)
				{
					local.post.dir = "ok"
					iprintlnbold_noloc ("[CnH]: The " + local.attacker + " have claimed control of the " + local.post.loc + "!")
					for (local.c = 1; local.c <= local.post.item.size; local.c++)
					{
						local.post.item[local.c] shader ("textures/hud/" + local.attacker + ".tga") 
					}

					thread play_capture_in_favour_of local.attacker
				}

				if (local.time != NIL || local.time > 0)
				{
					wait local.time
				}
			}
			else if (local.post.item[4].origin[2] == local.down && local.post.dir == "down") 
			{
				if (local.check != 1)
					local.check = 1
				else if (local.check == 1)
					local.check = 0

				local.post.dir = "up"

				for (local.c = 1; local.c <= local.post.item.size; local.c++)
				{
					local.post.item[local.c].origin += local.ascend //( 0 0 25 )
					local.post.item[local.c] endpoint (local.post.item[local.c].origin + ( 0 0 25 ))
					if (local.post.flag == "neutralx")
						local.post.item[local.c] shader ("textures/hud/" + local.attacker + ".tga") 
					else
						local.post.item[local.c] shader "textures/sprites/vsssource.tga"
				}

				local.post.flag = "neutral"

				if (local.time != NIL || local.time > 0)
				{
					wait local.time
				}
			}
		}

		waitframe
	}

end

//-----------------------------------------------------
check_within local.post local.b:
//-----------------------------------------------------

	while(level.cnh_ended != 1)
	{
		local.post.within["axis"] = 0
		local.post.within["allies"] = 0

		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			local.pass = 0
			local.team = $player[local.i].dmteam
			if (local.b[1][0] < $player[local.i].origin[0] && $player[local.i].origin[0] < local.b[2][0] && $player[local.i].status == "alive") 
				local.pass++

			if (local.b[1][1] < $player[local.i].origin[1] && $player[local.i].origin[1] < local.b[2][1] && $player[local.i].status == "alive")
				local.pass++

			if (local.b[1][2] < $player[local.i].origin[2] && $player[local.i].origin[2] < local.b[2][2] && $player[local.i].status == "alive")
				local.pass++

			if (local.pass == 3)
				local.post.within[local.team]++
		}

		wait 0.5
	}

end


/*
========================================================================================
					FLAG & BASE CREATION THREADS
========================================================================================
*/
create_post local.o local.t:

	// -------------------
	// Create Sandbags
	// -------------------
	local.sandbags = makeArray
	( -65 -90 0 ) ( 0 90 0 ) "static/sandbag_link_topcap.tik"
	( 0 -90 0 ) ( 0 90 0 ) "static/sandbag_link_main.tik"
	( 70 -95 0 ) ( 0 -90 0 ) "static/sandbag_link_rightbend.tik"
	( 70 -50 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 25 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 95 0 ) ( 0 90 0 ) "static/sandbag_link_leftbend.tik"
	( 0 90 0 ) ( 0 -90 0 ) "static/sandbag_link_main.tik"
	( -70 90 0 ) ( 0 -270 0 ) "static/sandbag_link_topcap.tik"
      endArray

	for (local.i = 1; local.i <= local.sandbags.size; local.i++)
	{
		local.s = spawn script_model model local.sandbags[local.i][3]
		local.s.origin = local.o + local.sandbags[local.i][1]
		local.s.angles = local.sandbags[local.i][2]
		local.s solid
		local.s nodamage
	}

	// -------------------
	// Create Flag
	// -------------------
	local.post = spawn func_beam "targetname" "cnhbase"
	local.post.origin = local.o
	local.post endpoint (local.o + ( 0 0 300 ))
	local.post shader "textures/barrel/blackbarrel.jpg"
	local.post maxoffset 0
	local.post scale 2
	local.post activate


	local.flag = makeArray
	( 0 10 275 )
	( 0 10 250 )
	( 0 10 225 )
	( 0 10 200 )
	endArray

	for (local.i = 1; local.i <= local.flag.size; local.i++)
	{
		local.post.item[local.i] = spawn func_beam
		local.post.item[local.i].team = local.t
		local.post.item[local.i].origin = local.post.origin + local.flag[local.i][1]
		if (local.t != "blank")
		{
			local.post.item[local.i] shader ("textures/hud/" + local.t + ".tga") 
			local.post.flag = local.t
			local.post.original_owner = local.t
		}
		else
		{
			local.post.item[local.i] shader "textures/sprites/vsssource.tga"
			local.post.flag = "neutralx"
			local.post.original_owner = "neutralx"
		}
		local.post.item[local.i] endpoint (local.post.item[local.i].origin + ( 0 0 25 ))
		local.post.item[local.i] scale 5 //10
		local.post.item[local.i] numsegments 1
		local.post.item[local.i] activate
	}

	// -------------------
	// Create Ammoboxes
	// -------------------
	local.d = spawn script_model model "static/indycrate.tik"
	local.d.origin = local.post.origin + ( 20 40 0 )
	local.d.angles = ( 0 35 0 )
	local.d solid
	local.d nodamage

	// Ammo Boxes
	local.f[1] = spawn trigger_use 
	local.f[1].origin = local.d.origin + ( 0 20 45 )
	local.f[1].box = spawn script_model model "models/items/item_mg_ammobox.tik"
	local.f[1].box.origin = local.f[1].origin
	local.f[1].box notsolid
	local.f[1] setsize ( -20 -20 -10 ) ( 20 20 10 )
	local.f[1].type = mg
	local.f[1].amount = 30
	local.f[1].respawn_time = 10
	local.f[1] wait 0.5
	local.f[1] setthread global/AIRborne_utils.scr::ammobox
	

	local.f[2] = spawn trigger_use 
	local.f[2].origin = local.d.origin + ( 0 0 45 )
	local.f[2].box = spawn script_model model "models/items/item_smg_ammobox.tik"
	local.f[2].box.origin = local.f[2].origin
	local.f[2].box notsolid
	local.f[2] setsize ( -20 -20 -10 ) ( 20 20 10 )
	local.f[2].type = smg
	local.f[2].amount = 30
	local.f[2].respawn_time = 10
	local.f[2] wait 0.5
	local.f[2] setthread global/AIRborne_utils.scr::ammobox

	// -------------------
	// Create MG42 Turret
	// -------------------
	local.mg42 = spawn "models/statweapons/mg42_gun.tik"
	local.mg42.origin = local.o + ( 55 -10 70 )
	local.mg42.angles = ( 0 0 0 )
	local.mg42 maxyawoffset 75

	local.mg42b = spawn script_model model "statweapons/mg42_bipod.tik"
	local.mg42b.origin = local.mg42.origin
	local.mg42b.angles = local.mg42.angles
	local.mg42b solid

end local.post

create_ammodepot local.o local.t:

	// -------------------
	// Create Sandbags
	// -------------------
	local.sandbags = makeArray
	( -65 -90 0 ) ( 0 90 0 ) "static/sandbag_link_topcap.tik"
	( 0 -90 0 ) ( 0 90 0 ) "static/sandbag_link_main.tik"
	( 70 -95 0 ) ( 0 -90 0 ) "static/sandbag_link_rightbend.tik"
	( 70 -50 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 25 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 95 0 ) ( 0 90 0 ) "static/sandbag_link_leftbend.tik"
	( 0 90 0 ) ( 0 -90 0 ) "static/sandbag_link_main.tik"
	( -70 90 0 ) ( 0 -270 0 ) "static/sandbag_link_topcap.tik"
      endArray

	for (local.i = 1; local.i <= local.sandbags.size; local.i++)
	{
		local.s = spawn script_model model local.sandbags[local.i][3]
		local.s.origin = local.o + local.sandbags[local.i][1]
		local.s.angles = local.sandbags[local.i][2]
		local.s solid
		local.s nodamage
	}

	// -------------------
	// Create Flag
	// -------------------
	local.post = spawn func_beam "targetname" "cnhbase"
	local.post.origin = local.o
	local.post endpoint (local.o + ( 0 0 300 ))
	local.post shader "textures/barrel/blackbarrel.jpg"
	local.post maxoffset 0
	local.post scale 2
	local.post activate


	local.flag = makeArray
	( 0 10 275 )
	( 0 10 250 )
	( 0 10 225 )
	( 0 10 200 )
	endArray

	for (local.i = 1; local.i <= local.flag.size; local.i++)
	{
		local.post.item[local.i] = spawn func_beam
		local.post.item[local.i].team = local.t
		local.post.item[local.i].origin = local.post.origin + local.flag[local.i][1]
		if (local.t != "blank")
		{
			local.post.item[local.i] shader ("textures/hud/" + local.t + ".tga") 
			local.post.flag = local.t
			local.post.original_owner = local.t
		}
		else
		{
			local.post.item[local.i] shader "textures/sprites/vsssource.tga"
			local.post.flag = "neutralx"
			local.post.original_owner = "neutralx"
		}
		local.post.item[local.i] endpoint (local.post.item[local.i].origin + ( 0 0 25 ))
		local.post.item[local.i] scale 5 //10
		local.post.item[local.i] numsegments 1
		local.post.item[local.i] activate
	}

	// -------------------
	// Create AmmoDepot Crates
	// -------------------
	local.d = spawn script_model model "static/indycrate.tik"
	local.d.origin = local.post.origin + ( 40 40 0 )
	local.d solid
	local.d nodamage

	local.crates = makeArray
	( 30 -25 6 ) "static/exp_crate1.tik"
	( 40 -60 6 ) "static/heat_crate.tik"
	( 40 -60 45 ) "static/fragcrate1.tik"
	( -20 -70 6 ) "static/bunkerbench.tik" ( 0 -90 0 )
	endArray
	
	for (local.i = 1; local.i <= local.crates.size; local.i++)
	{
		local.cr = spawn script_model model local.crates[local.i][2]
		local.cr.origin = local.o + local.crates[local.i][1]
		if (local.crates[local.i][3] != NIL)
			local.cr.angles = local.crates[local.i][3]

		local.cr solid
	}

	// -------------------
	// Create Destructible crates
	// -------------------
	local.mdl = makeArray
	( 30 60 45 ) "static/30cal_crate.tik"
	( 50 30 45 ) "static/45cal_crate.tik"
	endArray

	for (local.i = 1; local.i <= local.mdl.size; local.i++)
	{
		local.cal[local.i] = spawn script_model model local.mdl[local.i][2]
		local.cal[local.i].origin = local.o + local.mdl[local.i][1]
		local.cal[local.i] notsolid
	}

	// -------------------
	// Create Ammoboxes
	// -------------------
	local.ammo = makeArray
	( 0 -70 30 ) rifle "models/items/item_rifle_ammobox.tik" 16
	( -20 -70 30 ) mg "models/items/item_mg_ammobox.tik" 30 
	( -50 -70 30 ) smg "models/items/item_smg_ammobox.tik" 30
	endArray

	for (local.i = 1; local.i <= local.ammo.size; local.i++)
	{
		local.f[local.i] = spawn trigger_use 
		local.f[local.i].origin = local.o + local.ammo[local.i][1]
		local.f[local.i].box = spawn script_model model local.ammo[local.i][3]
		local.f[local.i].box.origin = local.f[local.i].origin
		local.f[local.i].box notsolid
		local.f[local.i] setsize ( -20 -20 -10 ) ( 20 20 10 )
		local.f[local.i].type = local.ammo[local.i][2]
		local.f[local.i].amount = local.ammo[local.i][4]
		local.f[local.i].respawn_time = 10
		local.f[local.i] wait 0.5
		local.f[local.i] setthread global/AIRborne_utils.scr::ammobox
	}


end local.post

create_custom local.o local.t:

	// -------------------
	// Create Flag
	// -------------------
	local.post = spawn func_beam "targetname" "cnhbase"
	local.post.origin = local.o
	local.post endpoint (local.o + ( 0 0 300 ))
	local.post shader "textures/barrel/blackbarrel.jpg"
	local.post maxoffset 0
	local.post scale 2
	local.post activate


	local.flag = makeArray
	( 0 10 275 )
	( 0 10 250 )
	( 0 10 225 )
	( 0 10 200 )
	endArray

	for (local.i = 1; local.i <= local.flag.size; local.i++)
	{
		local.post.item[local.i] = spawn func_beam
		local.post.item[local.i].team = local.t
		local.post.item[local.i].origin = local.post.origin + local.flag[local.i][1]
		if (local.t != "blank")
		{
			local.post.item[local.i] shader ("textures/hud/" + local.t + ".tga") 
			local.post.flag = local.t
			local.post.original_owner = local.t
		}
		else
		{
			local.post.item[local.i] shader "textures/sprites/vsssource.tga"
			local.post.flag = "neutralx"
			local.post.original_owner = "neutralx"
		}
		local.post.item[local.i] endpoint (local.post.item[local.i].origin + ( 0 0 25 ))
		local.post.item[local.i] scale 5 //10
		local.post.item[local.i] numsegments 1
		local.post.item[local.i] activate
	}


end local.post

/*
========================================================================================
						HELPER THREADS
========================================================================================
*/
get_boundries local.origin local.mdev local.mxdev:

	local.min = local.origin + local.mdev
	local.max = local.origin + local.mxdev

	local.result = local.min::local.max

end local.result

printline local.txt:

	if (group.printwait != 0)
		end

	group.printwait = 1

	iprintlnbold_noloc ("[CnH]: " + local.txt)

	wait 10
	group.printwait = 0

end

/*
========================================================================================
					SOUND-HANDLING THREADS
========================================================================================
*/
sounds:

	local.master = spawn ScriptMaster
	local.master aliascache cnh_capturegood sound/items/Shell_DrumBack_01.wav soundparms 7.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache cnh_capturebad sound/items/hit_notify2.wav soundparms 4.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "

end

play_capture_in_favour_of local.team:

	if (local.team == "allies")
	{
		thread playasound_t "allies" "capturegood"
		thread playasound_t "axis" "capturebad"
	}
	else
	{
		thread playasound_t "allies" "capturebad"
		thread playasound_t "axis" "capturegood"
	}

end

playasound_t local.team local.sound:

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		if ($player[local.i].dmteam == local.team)
		{
			$player[local.i] playsound ("cnh_" + local.sound)
		}
	}

end
```

# xyz_Airborne_Mod\global\ctf_bases.scr

```scr
/*
======================================================
*** AIRborne; CTF Bases Library for MoH:AA
======================================================
by Sor
Version: v1.1 r09
-----------------------------------
--- NOTE:

 Stole some small things from mefy.
 This is for those who want some other relevant options,
 more special "perks" and don't want mefy's 
 scripting interference (like me).

-------------------

======================================================
*/
setup_base local.origin local.team local.basemdl local.op_angles local.op_voff:

	switch (local.basemdl)
	{
		case "ctf-default":
			level.base[local.team] = waitthread create_default_base local.origin local.team
			level.core[local.team] = waitthread create_basecore local.origin
			level.base[local.team].core = level.core[local.team]
			level.base[local.team].bbox[0] = ( -70 -90 -10 )
			level.base[local.team].bbox[1] = ( 70 95 110 )
			level.base[local.team].symbol = waitthread create_default_symb local.origin local.team

			if (local.team == "allies")
				local.offs = ( 0 10 70 )
			else
				local.offs = ( 0 -10 70 )

			level.base[local.team].flag = waitthread create_flag level.base[local.team].origin local.team local.offs
			level.base[local.team].check_area = waitthread get_boundries local.origin ( -70 -90 -10 ) ( 70 95 110 )
			level.base[local.team].trigger = waitthread create_trig level.base[local.team].flag local.team
		break
		default:
			level.base[local.team] = waitthread create_base local.origin local.team local.basemdl local.op_angles
			level.core[local.team] = waitthread create_basecore local.origin
			level.base[local.team].core = level.core[local.team]
			if ( (waitthread global/strings.scr::InStr "piano" local.basemdl) != NIL)
			{
				level.base[local.team].bbox[0] = ( -25 -50 0 )
				level.base[local.team].bbox[1] = ( 25 50 80 )
			}
			else
			{
				level.base[local.team].bbox = waitthread global/AIRborne_utils.scr::GetBBox level.base[local.team]
			}
			level.base[local.team].symbol = waitthread create_symb local.origin local.team level.base[local.team].bbox

			if (local.op_voff == NIL)
			{
				local.alx = (level.base[local.team].bbox[1][0] + 10)
				local.aly = (level.base[local.team].bbox[1][1] + 10)

				local.axx = (level.base[local.team].bbox[0][0] + 10)
				local.axy = (level.base[local.team].bbox[0][1] + 10)

				if (local.team == "allies")
				{
					local.op_voff = ( local.alx local.aly 0 )
				}
				else
				{
					local.op_voff = ( local.axx local.axy 0 )
				}
			}

			level.base[local.team].flag = waitthread create_flag level.base[local.team].origin local.team local.op_voff
			local.min = level.base[local.team].bbox[0] + ( -40 -40 -100 )
			local.max = level.base[local.team].bbox[1] + ( 40 40 60 )
			level.base[local.team].check_area = waitthread get_boundries local.origin local.min local.max
			level.base[local.team].trigger = waitthread create_trig level.base[local.team].flag local.team
		break
	}
end

get_boundries local.origin local.mdev local.mxdev:

	local.min = local.origin + local.mdev
	local.max = local.origin + local.mxdev

	local.result = local.min::local.max

end local.result

/*
========================================================================================
					FLAG & BASE CREATION THREADS
========================================================================================
*/
create_flag local.o local.t local.offs:

	local.flag = spawn func_beam
	local.flag.origin = local.o + local.offs
	local.flag.f_offset = local.offs
	local.flag minoffset 0.0
	local.flag maxoffset 0.0
	local.flag alpha 1.0
	local.flag color ( 1.0 1.0 1.0 )
	local.flag scale 20.0
	local.flag life 0
	local.flag endpoint (local.flag.origin + ( 0 0 130 ))
	local.flag tileshader ("textures/hud/" + local.t + "_headicon")
	local.flag numsegments 1	
	local.flag activate

	local.flag.team = local.t
	local.flag.beamstart = ( 0 0 0 )
	local.flag.beamend = ( 0 0 130 )

end local.flag

create_basecore local.o:

	local.core = spawn script_model model "fx/dummy.tik"
	local.core.origin = local.o
	local.core notsolid

end local.core

create_default_base local.o local.t:

	// -------------------
	// Create Sandbags
	// -------------------
	local.sandbags = makeArray
	( -65 -90 0 ) ( 0 90 0 ) "static/sandbag_link_topcap.tik"
	( 0 -90 0 ) ( 0 90 0 ) "static/sandbag_link_main.tik"
	( 70 -95 0 ) ( 0 -90 0 ) "static/sandbag_link_rightbend.tik"
	( 70 -50 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 25 0 ) ( 0 0 0 ) "static/sandbag_link_main.tik"
	( 70 95 0 ) ( 0 90 0 ) "static/sandbag_link_leftbend.tik"
	( 0 90 0 ) ( 0 -90 0 ) "static/sandbag_link_main.tik"
	( -70 90 0 ) ( 0 -270 0 ) "static/sandbag_link_topcap.tik"
      endArray

	for (local.i = 1; local.i <= local.sandbags.size; local.i++)
	{
		local.s = spawn script_model model local.sandbags[local.i][3]
		local.s.origin = local.o + local.sandbags[local.i][1]
		local.s.angles = local.sandbags[local.i][2]
		local.s solid
		local.s nodamage
	}

	local.base = spawn func_beam 
	local.base.origin = local.o
	local.base endpoint (local.o + ( 0 0 200 ))
	local.base shader "textures/barrel/blackbarrel.jpg"
	local.base maxoffset 0
	local.base scale 2
	local.base activate

end local.base

create_default_symb local.o local.t:

	local.add = ( 0 0 220 )

	local.symbol = spawn func_beam
	local.symbol.origin = local.o + local.add
	local.symbol endpoint (local.symbol.origin + ( 0 0 15 ))
	local.symbol minoffset 0.0
	local.symbol maxoffset 0.0
	local.symbol color ( 1.0 1.0 1.0 )
	local.symbol scale 5.0
	local.symbol shader ("textures/hud/" + local.t + "_headicon")
	local.symbol numsegments 1
	local.symbol alpha 0.75
	local.symbol life 0
	local.symbol activate

end local.symbol

create_base local.o local.t local.mdl local.a:

	local.base = spawn script_model model local.mdl
	local.base.origin = local.o
	if (local.a != NIL)
		local.base.angles = local.a
	local.base solid

end local.base

create_symb local.o local.t local.bbox:

	local.add = ( 0 0 (local.bbox[1][2] + 10 ) )

	if (local.add[2] <= 20.000)
	{
		local.add = ( 0 0 (local.add[2] + 20 ) )
	}

	local.symbol = spawn func_beam
	local.symbol.origin = local.o + local.add
	local.symbol endpoint (local.symbol.origin + ( 0 0 15 ))
	local.symbol minoffset 0.0
	local.symbol maxoffset 0.0
	local.symbol color ( 1.0 1.0 1.0 )
	local.symbol scale 5.0
	local.symbol shader ("textures/hud/" + local.t + "_headicon")
	local.symbol numsegments 1
	local.symbol alpha 0.75
	local.symbol life 0
	local.symbol activate

end local.symbol

create_trig local.flag local.t:

	local.trig = spawn trigger_multiple
	local.trig.origin = local.flag.origin + ( 0 0 50 )
	local.trig setsize ( -40 -40 -150 ) ( 40 40 100 )
	local.trig bind local.flag
	local.trig nottriggerable
	if (local.t == "allies")
		local.trig setthread global/ctf.scr::allies_trig
	else
		local.trig setthread global/ctf.scr::axis_trig
	local.trig wait 1

end local.trig
```

# xyz_Airborne_Mod\global\ctf.scr

```scr
/*
======================================================
*** AIRborne; Capture-The-Flag Scripts for MoH:AA
======================================================
by Sor
Version: v1.4 r15
-----------------------------------
--- NOTE:

 Stole some small things from mefy.
 This is for those who want some other relevant options,
 more special "perks" and don't want mefy's 
 scripting interference (like me).

-------------------
======================================================
*/

/*
========================================================================================
					INITIALIZATION THREAD
========================================================================================
*/
init:

	if (level.ctf_running == 1)
		end

	level.ctf_running = 1
	level.ctf_finishing = NIL

	println "[AIR GameMode::CTF]: Initializing..."

	waitthread cache_sounds

	local.defaults = makeArray
	"pointlimit"		4
	"returnboth"		0
	"countdown"			10
	"capturetime"		2
	"drophold"			"-1"
	"friendlyreturn"		0
	"groundreturn"		25
	"enemyreturn"		"-1"
	"returntime"		10
	"iphe_display"		0
	"flagcarrier_music"	1
	"sounds"			1
	"HUD_display"		1
	"HUD_underlay"		0
	"HUD_playerpos"		0
	"HUD_groundpos"		1
	"HUD_basepos"		1
	"HUD_rect"			(( 20)::( 130))
	endArray

	for (local.i = 1; local.i <= local.defaults.size; local.i++)
	{
		local.t = local.defaults[local.i][1]
		if (level.ctf[local.t] == NIL || level.ctf[local.t] == "" )
		{
			level.ctf[local.t] = local.defaults[local.i][2]
		}

		if (level.ctf[local.t] == "-1")
		{
			level.ctf[local.t] = -1
		}

	}

	println "[AIR GameMode::CTF]: Settings Parsed..."

	if (level.axisflag == NIL || level.alliesflag == NIL)
	{
		println "[AIR GameMode::CTF]: No flags detected. Terminating..."
		end
	}

	waitthread global/AIRborne_utils.scr::waittill_roundstart
	level.ctf_round_start = 1

	thread score_counter
	if (level.ctf["HUD_display"] == 1)
	{
		thread hud_manager
	}
	thread check_within
		
	thread atbase_flag_allies
	thread atbase_flag_axis

	println "[AIR GameMode::CTF]: Logic threads running..."

end

add_ctf_base local.origin local.team local.basemdl local.op_angles local.op_voff:

	if (level.base[local.team] != NIL)
		end

	if (local.op_angles == NIL)
		local.op_angles = ( 0 0 0 )

	if (local.op_voff == NIL)
		local.op_voff = ( 0 0 0 )


	if (local.basemdl == NIL)
		waitthread global/ctf_bases.scr::setup_base local.origin local.team "ctf-default"
	else  
		waitthread global/ctf_bases.scr::setup_base local.origin local.team local.basemdl local.op_angles local.op_voff

	if (local.team == "axis")
	{
		level.axisflag = level.base[local.team].flag
		level.axischeck = level.base[local.team].check_area

		level.axistrig = level.base[local.team].trigger
		thread flag_beam_thread level.axisflag
	}
	else
	{

		level.alliesflag = level.base[local.team].flag
		level.alliescheck = level.base[local.team].check_area

		level.alliestrig = level.base[local.team].trigger
		thread flag_beam_thread level.alliesflag
	}

	println ("[AIR GameMode::CTF]: " + local.team + " base and flag setup!")

end

/*
========================================================================================
						SCORE&WIN HANDLING THREADS
========================================================================================
*/

/*
 Score Counter
 --------------
 This thread keeps the scores and determines a winner
 (or draw) at the right time.
*/
score_counter:

	level.score["allies"] = 0
	level.score["axis"] = 0

	// Timelimit in seconds...
	local.timelimit = ( (int (getcvar "timelimit")) * 60 )

	while(1)
	{
		local.time_remaining = (local.timelimit - level.time)

		if (level.score["allies"] >= level.ctf["pointlimit"] || level.score["axis"] >= level.ctf["pointlimit"])
		{
			break
		}

		if ( int(local.time_remaining) == 5 )
		{
			break
		}
			
		wait 1
	}

	level.ctf_finishing = 1

	wait 2

	if (level.score["axis"] > level.score["allies"])
		local.winner = "axis"
	else if (level.score["axis"] < level.score["allies"])
		local.winner = "allies"	
	else if (level.score["axis"] == level.score["allies"])
		local.winner = "draw"

	local.gt = getcvar "g_gametype"
	setcvar "g_gametype" "4"

	level.global_win["winner"] = local.winner
	level.global_win["winevent"] = "round_restart"
	level.global_win["winevent_delay"] = 0.5
	level.global_win["winevent_display"] = 0

	waitexec global/win.scr::teamwins

//	setcvar "g_gametype" local.gt

end

/*
========================================================================================
						HUD HANDLING THREADS
========================================================================================
*/

/* 
 HUD Handler
 ------------
 This thread handles and displays the entire CTF HUD display.
 From score-updates to flagstatus changes.
*/
hud_manager:

	local.x = level.ctf["HUD_rect"][1]
	local.y = level.ctf["HUD_rect"][2] 

	local.colour["ground"] = ( 1.0 1.0 1.0 )
	local.colour["alliesplayer"] = ( 0.4 0.4 1.0 )
	local.colour["axisplayer"] = ( 1.0 0.4 0.4 )
	local.colour["allies_atbase"] = ( 0.4 0.4 1.0 )
	local.colour["axis_atbase"] = ( 1.0 0.4 0.4 )

	while(1)
	{
		huddraw_font 50 facfont-20
		huddraw_align 50 "center" "top"
		huddraw_rect 50 -90 50 100 100
		huddraw_string 50 "Capture-The-Flag v1.4.15"
		huddraw_color 50 0.0 0.0 0.0
		huddraw_alpha 50 0.5

		huddraw_font 51 facfont-20
		huddraw_align 51 "center" "top"
		huddraw_rect 51 -89 50 100 100
		huddraw_string 51 "Capture-The-Flag v1.4.15"
		huddraw_color 51 0.0 0.4 1.0
		huddraw_alpha 51 0.8

		huddraw_font 52 facfont-20
		huddraw_align 52 "left" "center"
		huddraw_rect 52 (local.x) (local.y - 5) 100 100
		huddraw_string 52 "[SCORE]:"
		huddraw_color 52 1.0 1.0 1.0
		huddraw_alpha 52 1.0

		huddraw_font 53 handle-22
		huddraw_align 53 "left" "center"
		huddraw_rect 53 (local.x + 30) (local.y + 15) 100 100
		huddraw_string 53 ("( " + level.score["allies"] + " / " + level.ctf["pointlimit"] + " )")
		huddraw_color 53 0.4 0.4 1.0
		huddraw_alpha 53 1.0

		huddraw_font 54 handle-22
		huddraw_align 54 "left" "center"
		huddraw_rect 54 (local.x + 30) (local.y + 40) 100 100
		huddraw_string 54 ("( " + level.score["axis"] + " / " + level.ctf["pointlimit"] + " )")
		huddraw_color 54 1.0 0.4 0.4 
		huddraw_alpha 54 1.0

		huddraw_align 55 "left" "center"
		huddraw_rect 55 (local.x) (local.y - 20) 22 22
		huddraw_shader 55 "textures/hud/allies"
		huddraw_alpha 55 1.0

		huddraw_align 56 "left" "center"
		huddraw_rect 56 (local.x) (local.y + 5) 22 22
		huddraw_shader 56 "textures/hud/axis"
		huddraw_alpha 56 1.0

		if (level.ctf["HUD_underlay"] == 1)
		{
			huddraw_align 49 "left" "center"
			huddraw_rect 49 (local.x - 10) (local.y + 15) 250 168
			huddraw_shader 49 "textures/mohmenu/black"
			huddraw_alpha 49 0.6
		}

		huddraw_font 57 facfont-20
		huddraw_align 57 "left" "center"
		huddraw_rect 57 (local.x) (local.y + 70) 100 100
		huddraw_string 57 "[FLAGS]:"
		huddraw_color 57 1.0 1.0 1.0
		huddraw_alpha 57 1.0

		local.loc_allies = waitthread get_location level.alliesflag
		local.loc_axis = waitthread get_location level.axisflag

		local.als = waitthread get_status_colour level.alliesflag
		local.axs = waitthread get_status_colour level.axisflag

		huddraw_font 58 facfont-20
		huddraw_align 58 "left" "center"
		huddraw_rect 58 (local.x + 25) (local.y + 90) 100 100
		huddraw_string 58 ("[ " + local.loc_allies + " ]")
		huddraw_color 58 local.colour[local.als][0] local.colour[local.als][1] local.colour[local.als][2]
		huddraw_alpha 58 1.0

		huddraw_align 59 "left" "center"
		huddraw_rect 59 (local.x) (local.y + 50) 22 22
		huddraw_shader 59 "textures/hud/allies"
		huddraw_alpha 59 1.0

		huddraw_font 60 facfont-20
		huddraw_align 60 "left" "center"
		huddraw_rect 60 (local.x + 25) (local.y + 115) 100 100
		huddraw_string 60 ("[ " + local.loc_axis + " ]")
		huddraw_color 60 local.colour[local.axs][0] local.colour[local.axs][1] local.colour[local.axs][2]
		huddraw_alpha 60 1.0

		huddraw_align 61 "left" "center"
		huddraw_rect 61 (local.x) (local.y + 75) 22 22
		huddraw_shader 61 "textures/hud/axis"
		huddraw_alpha 61 1.0

		wait 1
	}
end

win_hud local.msg:

	local.time = 0.000

	while(local.time <= 5.000)
	{
		huddraw_font 49 facfont-20
		huddraw_align 49 "center" "center"
		huddraw_rect 49 0 0 100 100
		huddraw_string 49 local.msg
		huddraw_color 49 1.0 1.0 1.0
		huddraw_alpha 49 1.0
	
		local.time += 1.000
		wait 1
	}

	huddraw_alpha 49 0.0

end

/* 
 Get Location
 -------------
 This returns the position (and status) of o flag 
 on the map. If the user has turned the position option on. 
 If not, only the status will be displayed.
*/
get_location local.flag:

	if (local.flag.status == "atbase")
	{
		if (level.ctf["HUD_basepos"] == 1 && level.AIR_landmark != NIL)
		{
			local.l = waitthread global/AIR_library.scr::findplayer local.flag.origin
			local.loc = ( (waitthread get_teamstring local.flag.team) + " Base :: " + local.l)
		}
		else
		{
			local.loc = ((waitthread get_teamstring local.flag.team) + " Base")
		}
	}
	else if (local.flag.status == "ground")
	{
		if (level.ctf["HUD_groundpos"] == 1 && level.AIR_landmark != NIL)
		{
			local.l = waitthread global/AIR_library.scr::findplayer local.flag.origin
			local.loc = ("Ground :: " + local.l)
		}
		else
		{
			local.loc = "Ground"
		}
	}
	else if (local.flag.status == "alliesplayer" || local.flag.status == "axisplayer")
	{
		if (local.flag.status == "alliesplayer")
			local.team = "Allied"
		else
			local.team = "Axis"

		if (level.ctf["HUD_playerpos"] == 1 && level.AIR_landmark != NIL)
		{
			local.l = waitthread global/AIR_library.scr::findplayer local.flag.origin
			local.loc = (local.team + " Player :: " + local.l)
		}
		else
		{
			local.loc = (local.team + " Player")
		}
	}
	else
	{
		local.loc = ""
	}

end local.loc

/*
Get Status Colour
 -------------
*/
get_status_colour local.flag:

	if (local.flag.status != "atbase")
		local.result = local.flag.status
	else
		local.result = (local.flag.team + "_" + local.flag.status)

end local.result


/*
========================================================================================
					FLAG & BASE HANDLING THREADS
========================================================================================
*/

/*==================================================================
 MAIN ALLIED FLAGBASE HANDLER
 ------------------------------

 These control the Allied/Axis flag near the Allied base.
 *==================================================================
*/
atbase_flag_allies:

	//flag states:	- "atbase"
	//			- "alliesplayer"
	//			- "axisplayer"
	// 			- "ground"

	//flag - pickup states: - "atbase"
	//				- "ground"

	// player flagged var:  - "allies"
	//				- "axis"
	//				- "score"
	//				- "return"

	level.alliesflag.status = "atbase"

	while(level.ctf_finishing != 1)
	{

		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			local.time = 0
			local.ok = 0
			local.continue = 0

			////////////////////////////////////////
			// CTF Scenarios for the Allied Flag  //
			////////////////////////////////////////

			/* (1) */
			if ($player[local.i].within == "allies" && $player[local.i].dmteam == "allies" && level.alliesflag.carrier == $player[local.i] && level.alliesflag.status == "alliesplayer" && level.ctf["friendlyreturn"] == 1)
			{
				local.time = level.ctf["returntime"] 

				local.ok = waitthread allies_flagbase_return $player[local.i] local.time

				if (local.ok == 1)
				{
					$player[local.i].flagged = "return"

					waitthread return_flag_to_base level.alliesflag
					waitthread disable_pickup "allies"

					if (level.ctf["sounds"] == 1)
					{
						thread playasound_return
					}

					thread globalwidget_to_player $player[local.i] "You returned your team's Flag!"
					$player[local.i] dmmessage 0 "<<< I returned the Allied Flag!! >>>"
					iprintlnbold_noloc "[CTF]: The Allies have returned the Allied Flag!"
				}

			}

			/* (2) */
			if ($player[local.i].within == "allies" && $player[local.i].dmteam == "axis" && level.alliesflag.carrier == NIL && level.alliesflag.status == "atbase")
			{
				if (level.ctf["capturetime"] > 0 && ($player[local.i] isTouching level.alliestrig) )
				{
					local.time = level.ctf["capturetime"]
					local.ok = waitthread allies_flagbase_capture $player[local.i] local.time
				}
				else if ($player[local.i].within == "allies" && $player[local.i].status == "alive" && ($player[local.i] isTouching level.alliestrig))
				{
					local.ok = 1
				}

				if (local.ok == 1)
				{
					waitthread enable_pickup "allies"
				}
			}
	
			/* (3) */
			if ($player[local.i].within == "allies" && $player[local.i].dmteam == "allies" && level.axisflag.carrier == $player[local.i] && level.axisflag.status == "alliesplayer")
			{
				local.continue = waitthread allies_flagbase_score_cont $player[local.i]

				if ( level.ctf["countdown"] > 0 && local.continue == 1)
				{
					local.time = level.ctf["countdown"]
					iprintlnbold_noloc "[CTF]: The Axis flag is at the Allied base!"
					local.ok = waitthread allies_flagbase_countdown $player[local.i] local.time
				}
				else if ($player[local.i].within == "allies" && $player[local.i].status == "alive" && local.continue == 1)
				{
					local.ok = 1
				}

				if (local.ok == 1)
				{
					thread unglobalwidget_player $player[local.i] 1
					$player[local.i].flagged = "score"
					waitthread return_flag_to_base level.axisflag

					thread globalwidget_to_player $player[local.i] "You scored for your team!!"
					$player[local.i] dmmessage 0 "<<< I scored for the Allies!! >>>"
					if (level.ctf["sounds"] == 1)
					{
						thread playasound "allies_victory"
					}
					thread win_hud "The Allies score!"

					level.score["allies"]++
					waitthread disable_pickup "axis"
				}
			}

		}

		wait 0.4
	}

end

/*********************************
 ALLIED FLAGBASE RETURN
 -----------------------

 This is the checkthread for the Return of the Allied Flag 
 at the Allied base.
 *********************************
*/
allies_flagbase_return local.player local.time:

	thread player_countdown local.player ("Your team's flag will be returned in " + local.time + " seconds!") local.time
	while (local.player.within == "allies" && level.alliesflag.carrier == local.player && local.player.status == "alive" && local.time >= 0)
	{
		local.time -= 0.05
		waitframe
	}

	if (local.time <= 0)
	{
		local.ok = 1
	}
	else
	{
		local.ok = 0
		local.player.ctf_countdown = 0
	}
end local.ok

/*********************************
 ALLIED FLAGBASE CAPTURE 
 -----------------------

 This is the checkthread for the Axis capture of the Allied Flag 
 at the Allied base.
 *********************************
*/
allies_flagbase_capture local.player local.time:

	thread player_countdown local.player ("The Allied Flag will be captured in " + local.time + " seconds!") local.time

	while (local.player.within == "allies" && local.player.status == "alive" && (local.player isTouching level.alliestrig) && local.time >= 0)
	{
		local.time -= 0.05
		waitframe
	}
			
	if (local.time <= 0)
	{
		local.ok = 1
	}
	else
	{
		local.ok = 0
		local.player.ctf_countdown = 0
	}

end local.ok

/*********************************
 FLAG-RETURN CHECK TO SCORE
 --------------------------
 
 This thread checks for the allies whether they can score
 based on the setting of the "returnboth" option and the
 location of the allied flag.
 *********************************
*/
allies_flagbase_score_cont local.player:

	if (level.ctf["returnboth"] == 1 && level.alliesflag.status == "atbase")
	{
		local.continue = 1
	}
	else if (level.ctf["returnboth"] == 1 && level.alliesflag.status != "atbase")
	{
		local.continue = 0
		//thread globalwidget_to_player local.player "You must wait to score till one of your teammates returns your team's flag!"
	}
	else //if (level.ctf["returnboth"] != 1)
	{
		local.continue = 1
	}

end local.continue

/*********************************
 ALLIED FLAGBASE SCORE
 ---------------------

 This is the checkthread for the Allied Score of the Axis Flag 
 at the Allied base.
 *********************************
*/
allies_flagbase_countdown local.player local.time:

	level.core["allies"] playsound plantbomb
	level.core["allies"] loopsound flag_tick 

	local.endtime = level.time + local.time
	local.starttime = local.time

	thread player_countdown local.player ("You are scoring for your team, hang on!") local.time
	while (local.player.within == "allies" && local.player.status == "alive" && level.axisflag.carrier == local.player && local.time >= 0)
	{
		if (level.time == (local.endtime - (int(local.starttime / 2))) )
		{
			level.core["allies"] stoploopsound
			level.core["allies"] loopsound flag_finaltick 
		}
		local.time -= 0.05
		waitframe
	}
		
	level.core["allies"] stoploopsound
	
	if (local.time <= 0)
	{
		local.ok = 1
	}
	else
	{
		local.ok = 0
		local.player.ctf_countdown = 0
	}

end local.ok

/*==================================================================
 MAIN AXIS FLAGBASE HANDLER
 ------------------------------

 These control the Allied/Axis flag near the Axis base.
 *==================================================================
*/
atbase_flag_axis:

	level.axisflag.status = "atbase"

	while(level.ctf_finishing != 1)
	{

		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			local.time = 0
			local.ok = 0
			local.continue = 0

			//////////////////////////////////////
			// CTF Scenarios for the Axis Flag  //
			//////////////////////////////////////

			/* (1) */
			if ($player[local.i].within == "axis" && $player[local.i].dmteam == "axis" && level.axisflag.carrier == $player[local.i] && level.axisflag.status == "axisplayer" && level.ctf["friendlyreturn"] == 1)
			{
				local.time = level.ctf["returntime"] 
				local.ok = waitthread axis_flagbase_return $player[local.i] local.time

				if (local.ok == 1)
				{
					$player[local.i].flagged = "return"
					waitthread return_flag_to_base level.axisflag
					waitthread disable_pickup "axis"
					if (level.ctf["sounds"] == 1)
					{
						thread playasound_return
					}
					thread globalwidget_to_player $player[local.i] "You returned your team's Flag!"
					$player[local.i] dmmessage 0 "<<< I returned the Axis Flag!! >>>"
					iprintlnbold_noloc "[CTF]: The Axis have returned the Axis Flag!"
				}
			}

			/* (2) */
			if ($player[local.i].within == "axis" && $player[local.i].dmteam == "allies" && level.axisflag.carrier == NIL && level.axisflag.status == "atbase")
			{
				if (level.ctf["capturetime"] > 0 && ($player[local.i] isTouching level.axistrig) )
				{
					local.time = level.ctf["capturetime"]
					local.ok = waitthread axis_flagbase_capture $player[local.i] local.time
				}
				else if ($player[local.i].within == "axis" && $player[local.i].status == "alive" && ($player[local.i] isTouching level.axistrig))
				{
					local.ok = 1
				}

				if (local.ok == 1)
				{
					waitthread enable_pickup "axis"
				}
			}
	
			/* (3) */
			if ($player[local.i].within == "axis" && $player[local.i].dmteam == "axis" && level.alliesflag.carrier == $player[local.i] && level.alliesflag.status == "axisplayer")
			{
				local.continue = waitthread axis_flagbase_score_cont $player[local.i]

				if ( level.ctf["countdown"] > 0 && local.continue == 1)
				{
					local.time = level.ctf["countdown"]
					iprintlnbold_noloc "[CTF]: The Allied flag is at the Axis base!"
					local.ok = waitthread axis_flagbase_countdown $player[local.i] local.time
				}
				else if ($player[local.i].within == "axis" && $player[local.i].status == "alive" && local.continue == 1)
				{
					local.ok = 1
				}

				if (local.ok == 1)
				{
					thread unglobalwidget_player $player[local.i] 1
					$player[local.i].flagged = "score"
					waitthread return_flag_to_base level.alliesflag

					thread globalwidget_to_player $player[local.i] "You scored for your team!!"
					$player[local.i] dmmessage 0 "<<< I scored for the Axis!! >>>"
					if (level.ctf["sounds"] == 1)
					{
						thread playasound "axis_victory"
					}
					thread win_hud "The Axis score!"

					level.score["axis"]++
					waitthread disable_pickup "allies"
				}
			}
		}

		wait 0.4
	}

end

/*********************************
 AXIS FLAGBASE RETURN
 -----------------------

 This is the checkthread for the Return of the Axis Flag 
 at the Axis base.
 *********************************
*/
axis_flagbase_return local.player local.time:

	thread player_countdown local.player ("Your team's flag will be returned in " + local.time + " seconds!") local.time
	while (local.player.within == "axis" && level.axisflag.carrier == local.player && local.player.status == "alive" && local.time >= 0)
	{
		local.time -= 0.05
		waitframe
	}

	if (local.time <= 0)
	{
		local.ok = 1
	}
	else
	{
		local.ok = 0
		local.player.ctf_countdown = 0
	}
end local.ok


/*********************************
 AXIS FLAGBASE CAPTURE 
 -----------------------

 This is the checkthread for the Allied capture of the Axis Flag 
 at the Axis base.
 *********************************
*/
axis_flagbase_capture local.player local.time:

	thread player_countdown local.player ("The Axis Flag will be captured in " + local.time + " seconds!") local.time 

	while (local.player.within == "axis" && local.player.status == "alive" && (local.player isTouching level.axistrig) && local.time >= 0)
	{

		local.time -= 0.05
		waitframe
	}
			
	if (local.time <= 0)
	{
		local.ok = 1
	}
	else
	{
		local.ok = 0
		local.player.ctf_countdown = 0
	}

end local.ok

/*********************************
 FLAG-RETURN CHECK TO SCORE
 --------------------------
 
 This thread checks for the axis whether they can score
 based on the setting of the "returnboth" option and the
 location of the axis flag.
 *********************************
*/
axis_flagbase_score_cont local.player:

	if (level.ctf["returnboth"] == 1 && level.axisflag.status == "atbase")
	{
		local.continue = 1
	}
	else if (level.ctf["returnboth"] == 1 && level.axisflag.status != "atbase")
	{
		local.continue = 0
		//thread globalwidget_to_player local.player "You must wait to score till one of your teammates returns your team's flag!"
	}
	else //if (level.ctf["returnboth"] != 1)
	{
		local.continue = 1
	}

end local.continue

/*********************************
 AXIS FLAGBASE SCORE
 ---------------------

 This is the checkthread for the Axis Score of the Allied Flag 
 at the Axis base.
 *********************************
*/
axis_flagbase_countdown local.player local.time:

	level.core["axis"] playsound plantbomb
	level.core["axis"] loopsound flag_tick 

	local.endtime = level.time + local.time
	local.starttime = local.time

	thread player_countdown local.player ("You are scoring for your team, hang on!") local.time
	while (local.player.within == "axis" && local.player.status == "alive" && level.alliesflag.carrier == local.player && local.time >= 0)
	{
		if (level.time == (local.endtime - (int(local.starttime / 2))) )
		{
			level.core["axis"] stoploopsound
			level.core["axis"] loopsound flag_finaltick
		}
		local.time -= 0.05
		waitframe
	}
		
	level.core["axis"] stoploopsound
	
	if (local.time <= 0)
	{
		local.ok = 1
	}
	else
	{
		local.ok = 0
		local.player.ctf_countdown = 0
	}

end local.ok

/*******************************
 Allied FlagTrigger Setthread
 ------------------------------
 This setthread is for the Allied Flag. 
 It sets some vital properties to the player and makes him 
 execute the statuscheck thread where the flagholder 
 and the flag will be handled (including the pickup)
 or returns the flag if necessary.

 It'll also, optionally, play capturesounds and 
 display IPHE to the player 
 *********************************
*/
allies_trig:

	local.player = parm.other

	waitthread disable_pickup "allies"
	thread play_capture_in_favour_of local.player.dmteam

	if (level.alliesflag.status == "atbase" && local.player.dmteam != "allies")
	{
		iprintlnbold_noloc ("[CTF]: The " + (waitthread get_teamstring local.player.dmteam) + " have captured the Allied Flag!!")

		local.player.flagged = level.alliesflag.team 
		level.alliesflag.status = "axisplayer"

		thread globalwidget_to_player local.player "You captured the Allied Flag!!"
		local.player dmmessage 0 "<<< I captured the Allied Flag!! >>>"
		level.alliesflag.carrier = local.player
		
		waitthread player_status_check local.player level.alliesflag

		local.player.flagged = NIL
	}
	else if (level.alliesflag.status == "ground")
	{
		if (level.ctf["friendlyreturn"] == 0 && local.player.dmteam == "allies")
		{
			thread globalwidget_to_player local.player "You returned your team's Flag!"
			waitthread return_flag_to_base level.alliesflag
			local.player.flagged = NIL

			iprintlnbold_noloc ("[CTF]: The " + (waitthread get_teamstring local.player.dmteam) + " have returned the Allied Flag!")
			local.player dmmessage 0 "<<< I returned the Allied Flag!! >>>"

			end
		}
		iprintlnbold_noloc ("[CTF]: The " + (waitthread get_teamstring local.player.dmteam) + " have picked up the Allied Flag!")

		local.player.flagged = level.alliesflag.team  
		level.alliesflag.status = (local.player.dmteam + "player")
		level.alliesflag.carrier = local.player

		thread globalwidget_to_player local.player "You captured the Allied Flag!!"
		local.player dmmessage 0 "<<< I captured the Allied Flag!! >>>"
		waitthread player_status_check local.player level.alliesflag

		local.player.flagged = NIL
	}
end

/*******************************
 Axis FlagTrigger Setthread
 ------------------------------
 This setthread is for the Axis Flag. 
 It sets some vital properties to the player and makes him 
 execute the statuscheck thread where the flagholder 
 and the flag will be handled (including the pickup)
 or returns the flag if necessary.

 It'll also, optionally, play capturesounds and 
 display IPHE to the player 
 *********************************
*/
axis_trig:

	local.player = parm.other

	waitthread disable_pickup "axis"
	thread play_capture_in_favour_of local.player.dmteam

	if (level.axisflag.status == "atbase" && local.player.dmteam != "axis")
	{
		iprintlnbold_noloc ("[CTF]: The " + (waitthread get_teamstring local.player.dmteam) + " have captured the Axis Flag!!")

		local.player.flagged = level.axisflag.team 
		level.axisflag.status = "alliesplayer"

		thread globalwidget_to_player local.player "You captured the Axis Flag!!"
		local.player dmmessage 0 "<<< I captured the Axis Flag!! >>>"

		level.axisflag.carrier = local.player
		waitthread player_status_check local.player level.axisflag

		local.player.flagged = NIL
	}
	else if (level.axisflag.status == "ground")
	{
		waitthread disable_pickup "axis"
		if (level.ctf["friendlyreturn"] == 0 && local.player.dmteam == "axis")
		{
			thread globalwidget_to_player local.player "You returned your team's Flag!"
			waitthread return_flag_to_base level.axisflag
			local.player.flagged = NIL

			iprintlnbold_noloc ("[CTF]: The " + (waitthread get_teamstring local.player.dmteam) + " have returned their Axis Flag!")
			local.player dmmessage 0 "<<< I returned the Axis Flag!! >>>"

			end
		}
		iprintlnbold_noloc ("[CTF]: The " + (waitthread get_teamstring local.player.dmteam) + " have picked up the Axis Flag!")

		local.player.flagged = level.axisflag.team 
		level.axisflag.status = (local.player.dmteam + "player")

		thread globalwidget_to_player local.player "You captured the Axis Flag!!"
		local.player dmmessage 0 "<<< I captured the Axis Flag!! >>>"
		level.axisflag.carrier = local.player

		waitthread player_status_check local.player level.axisflag

		local.player.flagged = NIL
	}
end

/*******************************
 Player Status Check
 --------------------
 This important thread will handle the flag
 (and its flagholder) when it's in the hands of a player.
 
 This includes the pickup and attachment to the player, 
 the "enemyreturn" and "friendlyreturn" options. As well as 
 dropping the flag, intentional or because the player is 
 no longer qualified  to hold the flag (he died, changed teams etc...)
*********************************
*/
player_status_check local.p local.flag:

	waitthread attach_flag_to_player local.p local.flag

	if (level.ctf["flagcarrier_music"] == 1)
	{
		thread music_for_holder local.p local.flag	
	}

	local.etime = 0
	local.ftime = 0
	local.holdtime = 0
	local.pos = ( 0 0 0 )
	local.team = local.p.dmteam

	local.delay = 0.1

	while (local.p.status == "alive" && local.flag.carrier == local.p)		
	{
		if (level.ctf["drophold"] != -1)
		{
			if(local.p.useheld)
			{
				local.holdtime += 0.05
			}

			if (local.holdtime >= level.ctf["drophold"])
			{
				local.loc = ("[CTF]: An " + (waitthread get_teamstring local.p.dmteam) + " player has dropped the " + (waitthread get_teamstring_pos local.flag.team) + " flag on purpose!")
				local.delay = 3.5
				break
			}
		}

		if (local.flag.team != local.p.dmteam && level.ctf["enemyreturn"] > 0 && local.p.within != local.p.dmteam)
		{
			if (local.etime >= level.ctf["enemyreturn"])
			{
				waitthread return_flag_to_base local.flag
				waitthread disable_pickup local.flag.team
				end
			}
			
			local.etime += 0.05
		}
		if (local.flag.team == local.p.dmteam && level.ctf["returntime"] > 0 && local.p.within != local.p.dmteam)
		{
			if (local.ftime >= (level.ctf["returntime"] * 2))
			{
				waitthread return_flag_to_base local.flag
				waitthread disable_pickup local.flag.team
				end
			}
			
			local.ftime += 0.05
		}

		if ((local.p getposition) == "crouching" && local.lastpos != "crouching")
		{
			local.pos = ( 0 0 -40 )
			local.lastpos = "crouching"
		} else if ((local.p getposition) != "crouching" && local.lastpos == "crouching")
		{
			local.pos = ( 0 0 0 )
			local.lastpos = "somethingelse"
		}

		local.flag.origin = (local.p.origin + local.pos) + ((angles_toleft local.p.angles) * local.flag.playeroffset[0]) + ( ( 0 0 1 ) * local.flag.playeroffset[2])

		waitframe
	}

	if (local.loc == NIL && local.p.flagged != "score" && local.p.flagged != "return")
	{
		local.loc = ("[CTF]: The " + (waitthread get_teamstring local.team) + " have lost the " + (waitthread get_teamstring_pos local.flag.team) + " flag!!")
	}

	if (local.p.flagged == "score" || local.p.flagged == "return")
		end

	thread enable_pickup local.flag.team local.delay
	if (level.ctf["sounds"] == 1)
	{
		thread playasound "drop"
	}
	iprintlnbold_noloc local.loc
	thread attach_flag_to_ground local.flag

end

/*******************************
 Check Within
 --------------
 This thread gives a special property to
 the players who are in the vicinity of a 
 flagbase.
*********************************
*/
check_within:

	while(level.ctf_finishing != 1)
	{
		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			local.alliespass = 0
			local.axispass = 0

			// Check if player is in Allies Base
			if (level.alliescheck[1][0] < $player[local.i].origin[0] && $player[local.i].origin[0] < level.alliescheck[2][0] && $player[local.i].status == "alive")
				local.alliespass++

			if (level.alliescheck[1][1] < $player[local.i].origin[1] && $player[local.i].origin[1] < level.alliescheck[2][1] && $player[local.i].status == "alive")
				local.alliespass++

			if (level.alliescheck[1][2] < $player[local.i].origin[2] && $player[local.i].origin[2] < level.alliescheck[2][2] && $player[local.i].status == "alive")
				local.alliespass++

			// Check if player is in Axis Base
			if (level.axischeck[1][0] < $player[local.i].origin[0] && $player[local.i].origin[0] < level.axischeck[2][0] && $player[local.i].status == "alive")
				local.axispass++

			if (level.axischeck[1][1] < $player[local.i].origin[1] && $player[local.i].origin[1] < level.axischeck[2][1] && $player[local.i].status == "alive")
				local.axispass++

			if (level.axischeck[1][2] < $player[local.i].origin[2] && $player[local.i].origin[2] < level.axischeck[2][2] && $player[local.i].status == "alive")
				local.axispass++

			if (local.alliespass == 3)
			{
				$player[local.i].within = "allies"
			}
			else if (local.axispass == 3)
			{
				$player[local.i].within = "axis"
			}
			else
			{
				$player[local.i].within = "none"
			}
		}

		wait 0.1
	}

end

/*
========================================================================================
					FLAG POSITION-HANDLING THREADS
========================================================================================
*/

attach_flag_to_player local.p local.flag:

	if (local.flag.team == "allies")
	{
		local.flag.playeroffset = ( -10 0 80 )
	}
	else
	{
		local.flag.playeroffset = ( 10 0 80 )
	}
	local.flag.beamstart = ( 0 0 10 )
	local.flag.beamend = ( 0 0 130 )

end


attach_flag_to_ground local.flag:

	local.neworigin = trace local.flag.origin (local.flag.origin + ( 0 0 -10000 )) 1
	local.terrain_check = trace local.neworigin (local.neworigin + ( 0 0 10000 )) 1

	local.flag.carrier = NIL

	if ( (local.terrain_check[2] - local.neworigin[2]) > 1200 )
	{
		local.flag.origin = (local.flag.origin + ( 0 0 -70 ))
	}
	else
	{
		local.flag.origin = (local.neworigin + ( 0 0 10 ))
	}

	if (local.flag.team == "axis")
		level.axistrig.origin = (local.flag.origin + ( 0 0 50 ))
	else
		level.alliestrig.origin = (local.flag.origin + ( 0 0 50 ))

	local.flag.status = "ground"

	local.flag.beamstart = ( 0 0 10 )
	local.flag.beamend = ( 0 0 130 )

	if (level.ctf["groundreturn"] == 0)
	{
		waitthread return_flag_to_base local.flag
	}
	else
	{
		thread check_groundreturn local.flag level.ctf["groundreturn"]
	}
end

flag_beam_thread local.flag:

	while (local.flag != NULL)
	{
		if (local.flag.beamstart != ( 0 0 0 ) && local.flag.beamstart != NIL)
		{
			local.flag.origin = (local.flag.origin + local.flag.beamstart)
			local.flag.beamstart = ( 0 0 0 )
		}

		local.flag endpoint (local.flag.origin + local.flag.beamend)
		waitframe
	}
end

check_groundreturn local.flag local.time:

	local.no = local.flag.origin

	while (local.flag.status == "ground" && local.time >= 0.0)
	{
		local.time -= 0.05
		waitframe

		if (local.flag.origin[2] < (local.no[2] - 50))
		{
			local.flag.origin = local.no

			if (local.flag.team == "axis")
				level.axistrig.origin = (local.flag.origin + ( 0 0 50 ))
			else
				level.alliestrig.origin = (local.flag.origin + ( 0 0 50 ))
		} 
	}

	if (local.time <= 0.0)
	{
		waitthread return_flag_to_base local.flag
		waitthread disable_pickup local.flag.team
	}

end

return_flag_to_base local.flag: 

	local.flag deactivate

	local.flag.origin = (level.base[local.flag.team].origin + local.flag.f_offset)
	local.flag.beamstart = ( 0 0 0 )
	local.flag.beamend = ( 0 0 130 )

	if (local.flag.team == "axis")
		level.axistrig.origin = (local.flag.origin + ( 0 0 50 ))
	else
		level.alliestrig.origin = (local.flag.origin + ( 0 0 50 ))

	if (level.ctf["sounds"] == 1)
	{
		thread playasound "reset"
	}
	iprintlnbold_noloc ("[CTF]: The server has reset the " + (waitthread get_teamstring_pos local.flag.team) + " flag!")

	local.flag.status = "atbase"
	local.flag.carrier = NIL
	local.flag activate

end

/*
========================================================================================
						HELPER THREADS
========================================================================================
*/
disable_pickup local.t local.w:

	if (local.w != NIL)
		wait local.w

	if (local.t == "allies")
		level.alliestrig nottriggerable
	else
		level.axistrig nottriggerable

end

enable_pickup local.t local.w:

	if (local.w != NIL)
		wait local.w

	if (local.t == "allies")
		level.alliestrig triggerable
	else
		level.axistrig triggerable
end

get_teamstring_pos local.t:

	if (local.t == "allies")
		end "Allied"
	else if (local.t == "axis")
		end "Axis"

end NIL

get_teamstring local.t:

	if (local.t == "allies")
		end "Allies"
	else if (local.t == "axis")
		end "Axis"

end NIL

get_other_flag local.flag:

	if (local.flag.team == "allies")
	{	
		end level.axisflag
	}
	else
	{
		end level.alliesflag
	}
end

/*
========================================================================================
			IPHE-HANGLING (Individual Player Hud Elements) THREADS
========================================================================================
*/
globalwidget_to_player local.player local.msg:

	if (level.ctf["iphe_display"] == 0)
	{
		local.player iprint local.msg 0
		end
	}

	if (local.player.widget_init != 1)
	{
		local.player.widget_init = 1
		waitthread init_widget local.player
	}

	local.player.widget = "n"
	local.team = local.player.dmteam

	wait 1
	if (local.player.widget == "n" && local.player.status == "alive" && local.player.dmteam == local.team && local.player) 
	{
		local.player stufftext ("set ctf_msg " + local.msg)
		local.player stufftext ("globalwidgetcommand june6 linkcvar ctf_msg")
		local.player stufftext "showmenu dday1"

		local.time = 0
		while( local.time <= 5.0 && local.player.widget == "n" )
		{
			local.time += 0.05
			waitframe
		}
	}

	waitthread unglobalwidget_player local.player 1
end

player_countdown local.player local.msg local.time:

	local.player iprint local.msg 0

	local.player.ctf_countdown = local.time
	local.player stopwatch (local.time)

	local.team = local.player.dmteam 

	while (local.player.ctf_countdown > 0 && local.player.status == "alive" && local.player.dmteam == local.team && local.player) 
	{
		waitframe
		local.player.ctf_countdown -= 0.05
	}

	local.player stopwatch 0
end

unglobalwidget_player local.player local.nowait:

	if (level.ctf["iphe_display"] == 0)
		end

	local.player.widget = "off"
	if (!local.nowait)
		waitframe

	local.player stufftext "hidemenu dday1"

end

init_widget local.player:

	local.player stufftext "globalwidgetcommand dday1 shader townhallwindow"
	local.player stufftext "globalwidgetcommand dday1 fgcolor 1.00 0.00 1.00 1.00"
	local.player stufftext "globalwidgetcommand dday1 bgcolor 0.00 0.00 0.00 0.00"
	local.player stufftext "globalwidgetcommand dday1 fadein 0"
	local.player stufftext "globalwidgetcommand dday1 menu dday1 640 480 NONE 0"
	local.player stufftext "globalwidgetcommand dday1 virtualres 1"
	local.player stufftext "globalwidgetcommand dday1 fullscreen 1"

	local.player stufftext "globalwidgetcommand june6 shader townhallwindow"
	local.player stufftext "globalwidgetcommand june6 rect 140 40 596 354"
	local.player stufftext "globalwidgetcommand june6 fgcolor 1.00 3.00 4.00 6.00"
	local.player stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	local.player stufftext "globalwidgetcommand june6 font handle-23"
	//local.player stufftext "globalwidgetcommand june6 title ."

	local.player stufftext "hidemenu dday1"
end

/*
========================================================================================
					SOUND-HANDLING THREADS
========================================================================================
*/
cache_sounds:

	local.master = spawn ScriptMaster
	local.master aliascache flag_drop sound/items/hit_notify3.wav soundparms 6.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_capturegood sound/items/Shell_DrumBack_01.wav soundparms 7.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_capturebad sound/items/hit_notify2.wav soundparms 4.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_reset sound/items/hit_notify.wav soundparms 10.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_return sound/amb/Amb_LightHum_01.wav soundparms 6.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_tick sound/items/Item_Timer_01.wav soundparms 1.5 0.0 1.0 0.0 10000 10000 local loaded maps "m dm moh obj train "
	local.master aliascache flag_finaltick sound/items/final_countdown.wav soundparms 1.5 0.0 1.0 0.0 10000 10000 local loaded maps "m dm moh obj train "


	//Global Victory - Allied
	local.master alias flag_allies_victory1 sound/dialogue/Multiplayer/a/AMdfr_v_01a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_allies_victory2 sound/dialogue/Multiplayer/a/AMdfr_v_01h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_allies_victory3 sound/dialogue/Multiplayer/a/AMdfr_v_01j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_allies_victory4 sound/dialogue/Multiplayer/a/AMdfr_v_02a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_allies_victory5 sound/dialogue/Multiplayer/a/AMdfr_v_02j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_allies_victory6 sound/dialogue/Multiplayer/a/AMdfr_v_03a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_allies_victory7 sound/dialogue/Multiplayer/a/AMdfr_v_03h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_allies_victory8 sound/dialogue/Multiplayer/a/AMdfr_v_03j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_allies_victory9 sound/dialogue/Multiplayer/a/AMdfr_v_04h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_allies_victory10 sound/dialogue/Multiplayer/a/AMdfr_v_04j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_allies_victory11 sound/dialogue/Multiplayer/a/AMdfr_v_06h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "

	//Global Victory - Axis 
	local.master alias flag_axis_victory1 sound/dialogue/Multiplayer/g/GRden_v_01a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_axis_victory2 sound/dialogue/Multiplayer/g/GRden_v_01c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_axis_victory3 sound/dialogue/Multiplayer/g/GRden_v_01i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_axis_victory4 sound/dialogue/Multiplayer/g/GRden_v_02a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_axis_victory5 sound/dialogue/Multiplayer/g/GRden_v_02b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_axis_victory6 sound/dialogue/Multiplayer/g/GRden_v_02c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_axis_victory7 sound/dialogue/Multiplayer/g/GRden_v_02d.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_axis_victory8 sound/dialogue/Multiplayer/g/GRden_v_03a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_axis_victory9 sound/dialogue/Multiplayer/g/GRden_v_03b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_axis_victory10 sound/dialogue/Multiplayer/g/GRden_v_03i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_axis_victory11 sound/dialogue/Multiplayer/g/GRden_v_04a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory12 sound/dialogue/Multiplayer/g/GRden_v_04b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory13 sound/dialogue/Multiplayer/g/GRden_v_04c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory14 sound/dialogue/Multiplayer/g/GRden_v_04d.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory15 sound/dialogue/Multiplayer/g/GRden_v_04i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory16 sound/dialogue/Multiplayer/g/GRden_v_06a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "
	local.master alias flag_axis_victory17 sound/dialogue/Multiplayer/g/GRden_v_06b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "

end

play_capture_in_favour_of local.team:

	if (local.team == "allies")
	{
		thread playasound_t "allies" "capturegood"
		thread playasound_t "axis" "capturebad"
	}
	else
	{
		thread playasound_t "allies" "capturebad"
		thread playasound_t "axis" "capturegood"
	}

end

playasound_t local.team local.sound:

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		if ($player[local.i].dmteam == local.team)
		{
			$player[local.i] playsound ("flag_" + local.sound)
		}
	}

end

playasound local.sound:

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		$player[local.i] playsound ("flag_" + local.sound)

		if (local.sound == "allies_victory" || local.sound == "axis_victory")
		{
			end
		}
	}

end

playasound_return:

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		$player[local.i] thread play_return
	}

end

play_return:

	self playsound flag_return
	wait 0.7
	self stopsound

end

music_for_holder local.player local.flag:

	local.of = waitthread get_other_flag local.flag

	if (local.of.carrier != local.player)
	{
		local.music = waitthread get_music
		local.player stufftext local.music[1]
	}

	local.time = 0
	while(local.player == local.flag.carrier)
	{
		if (local.time == local.music[2])
		{
			local.music = waitthread get_music
			local.player stufftext local.music[1]
			local.time = 0
		}

		local.time += 0.05
		waitframe
	}

	if (local.of.carrier != local.player)
	{
		local.player stufftext "stopmp3"
	}

end

get_music:

	local.m = makeArray
	("playmp3 main/sound/music/mus_14a_action.mp3")		238.000
	("playmp3 main/sound/music/mus_11a_surprise.mp3")	200.000
	("playmp3 main/sound/music/mus_18a_action.mp3")		253.000
	("playmp3 main/sound/music/mus_11b_action.mp3")		126.000
	("playmp3 main/sound/music/mus_SniperTown_01a.mp3")	198.000
	endArray

	local.chosen = local.m[((randomint local.m.size) + 1)]

end local.chosen

```

# xyz_Airborne_Mod\global\fix\anti_fps.scr

```scr
// Anti-FPS bug
main:
	local.o = waitthread global/strings.scr::InStr "fps" self.model
	if (local.o != NIL)
	{
		self physics_off
		self notsolid
		self noclip
		self dmmessage 0 "I'm trying to crash the server with the FPS bug!!" 
		// DIE friggin hackah!! :@
		self remove
		wait 0.2 
		// still not dead?
		if (self)	
			self delete
		wait 0.2
		// the next one is inescapable!! muhahah!
		if (self)  
			self immediateremove
	}

end
```

# xyz_Airborne_Mod\global\fix\anti_teamswap.scr

```scr
main local.hva:

	if(local.hva=="end")
	{
		self.tss = 0
		end
	}
	
	local.team = self.dmteam
	self.tss = 1

	while(isalive self && self.tss == 1)
	{
		waitframe
		
		if(self.dmteam != "spectator" && self.dmteam != local.team)
		{
			self usestuff
			self unattachfromladder 
			//self kill
		}
	}
end
		
```

# xyz_Airborne_Mod\global\ktf.scr

```scr
/*
======================================================
*** AIRborne; Keep-The-Flag Script for MoH:AA
======================================================
by Sor
Version: v1.1 r14
-----------------------------------
======================================================
*/

init local.o:

	if (local.o == NIL)
		end

	local.d = makeArray
	"scorelimit"		8
	"scoretime"			30
	"resettime"			100
	"iphe_display"		0
	"flagcarrier_music"	1
	"sounds"			1
	"hide_bases"		0
	"HUD_display"		1
	"HUD_underlay"		0
	"HUD_flagposition"	0
	"HUD_rect"			(( 20)::( 160))
	endArray

	for (local.i = 1; local.i <= local.d.size; local.i++)
	{
		local.t = local.d[local.i][1]
		if (level.ktf[local.t] == NIL || level.ktf[local.t] == "" )
		{
			level.ktf[local.t] = local.d[local.i][2]
		}
	}

	for (local.i = 1; local.i <= local.o.size; local.i++)
	{
		waitthread create_base local.o[local.i][1]
	}

	thread cache_sounds

	if (level.ktf["HUD_display"] == 1)
	{
		thread hud_manager
	}

	waitthread global/AIRborne_utils.scr::waittill_roundstart
	level.ktf_round_start = 1

	iprintlnbold_noloc "The Round has started!!"

	waitthread create_flag level.respawn_spot[((randomint(level.respawn_spot.size)) + 1)].origin
	waitthread start_flag_at_base level.ktf_flag

	thread score_counter

end

/*
 Score Counter
 --------------
 This thread keeps the scores and determines a winner
 (or draw) at the right time.
*/
score_counter:

	level.score["allies"] = 0
	level.score["axis"] = 0

	// Timelimit in seconds...
	local.timelimit = ( (int (getcvar "timelimit")) * 60 )
	
	while(1)
	{
		local.time_remaining = (local.timelimit - level.time)

		if (level.score["allies"] >= level.ktf["scorelimit"] || level.score["axis"] >= level.ktf["scorelimit"])
		{
			break
		}

		if ( int(local.time_remaining) == 5 )
		{
			break
		}
			
		wait 1
	}

	level.ktf_finishing = 1

	wait 2

	if (level.score["axis"] > level.score["allies"])
		local.winner = "axis"
	else if (level.score["axis"] < level.score["allies"])
		local.winner = "allies"	
	else if (level.score["axis"] == level.score["allies"])
		local.winner = "draw"

	local.gt = getcvar "g_gametype"
	setcvar "g_gametype" "4"

	level.global_win["winner"] = local.winner
	level.global_win["winevent"] = "round_restart"
	level.global_win["winevent_delay"] = 0.5
	level.global_win["winevent_display"] = 0

	waitexec global/win.scr::teamwins

//	setcvar "g_gametype" local.gt

end

/*
========================================================================================
						HUD HANDLING THREADS
========================================================================================
*/

/* 
 HUD Handler
 ------------
 This thread handles and displays the entire KTF HUD display.
 From score-updates to flagstatus changes.
*/
hud_manager:

	while(level.ktf_round_start != 1)
	{
		huddraw_font 49 facfont-20
		huddraw_align 49 "center" "top"
		huddraw_rect 49 105 50 100 100
		huddraw_string 49 "[WAITING]"
		huddraw_color 49 1.0 1.0 1.0
		huddraw_alpha 49 0.9

		huddraw_font 50 facfont-20
		huddraw_align 50 "center" "top"
		huddraw_rect 50 -90 50 100 100
		huddraw_string 50 "Keep-The-Flag v1.1.14"
		huddraw_color 50 0.0 0.0 0.0
		huddraw_alpha 50 0.5

		huddraw_font 51 facfont-20
		huddraw_align 51 "center" "top"
		huddraw_rect 51 -89 50 100 100
		huddraw_string 51 "Keep-The-Flag v1.1.14"
		huddraw_color 51 0.0 0.4 1.0
		huddraw_alpha 51 0.8

		wait 2
	}

	local.x = level.ktf["HUD_rect"][1]
	local.y = level.ktf["HUD_rect"][2] 

	local.colour["allies"] = ( 0.4 0.4 1.0 )
	local.colour["axis"] = ( 1.0 0.4 0.4 )
	local.colour["none"] = ( 1.0 1.0 1.0 )

	local.texture["allies"] = "textures/hud/allies"
	local.texture["axis"] = "textures/hud/axis"
	local.texture["none"] = "textures/sprites/vsssource.tga"

	while(level.ktf_finishing != 1)
	{
		if ($player.size > 1)
		{
			local.loc2 = "[STARTED]"
		}
		else
		{
			local.loc2 = "[WAITING]"
		}

		huddraw_font 49 facfont-20
		huddraw_align 49 "center" "top"
		huddraw_rect 49 105 50 100 100
		huddraw_string 49 local.loc2
		huddraw_color 49 1.0 1.0 1.0
		huddraw_alpha 49 0.9

		huddraw_font 50 facfont-20
		huddraw_align 50 "center" "top"
		huddraw_rect 50 -90 50 100 100
		huddraw_string 50 "Keep-The-Flag v1.1.14"
		huddraw_color 50 0.0 0.0 0.0
		huddraw_alpha 50 0.5

		huddraw_font 51 facfont-20
		huddraw_align 51 "center" "top"
		huddraw_rect 51 -89 50 100 100
		huddraw_string 51 "Keep-The-Flag v1.1.14"
		huddraw_color 51 0.0 0.4 1.0
		huddraw_alpha 51 0.8

		// Title
		huddraw_font 52 facfont-20
		huddraw_align 52 "left" "center"
		huddraw_rect 52 (local.x) (local.y - 5) 100 100
		huddraw_string 52 "[SCORE]:"
		huddraw_color 52 1.0 1.0 1.0
		huddraw_alpha 52 1.0

		huddraw_font 53 handle-22
		huddraw_align 53 "left" "center"
		huddraw_rect 53 (local.x + 30) (local.y + 15) 100 100
		huddraw_string 53 ("( " + level.score["allies"] + " )")
		huddraw_color 53 0.4 0.4 1.0
		huddraw_alpha 53 1.0

		huddraw_font 54 handle-22
		huddraw_align 54 "left" "center"
		huddraw_rect 54 (local.x + 30) (local.y + 40) 100 100
		huddraw_string 54 ("( " + level.score["axis"] + " )")
		huddraw_color 54 1.0 0.4 0.4
		huddraw_alpha 54 1.0

		huddraw_align 55 "left" "center"
		huddraw_rect 55 (local.x) (local.y - 20) 22 22
		huddraw_shader 55 "textures/hud/allies"
		huddraw_alpha 55 1.0

		huddraw_align 56 "left" "center"
		huddraw_rect 56 (local.x) (local.y + 5) 22 22
		huddraw_shader 56 "textures/hud/axis"
		huddraw_alpha 56 1.0

		if (level.ktf["HUD_underlay"] == 1)
		{
			huddraw_align 48 "left" "center"
			huddraw_rect 48 (local.x - 10) (local.y - 7) 200 110
			huddraw_shader 48 "textures/mohmenu/black"
			huddraw_alpha 48 0.6
		}

		local.loc = waitthread get_location level.ktf_flag
		if (level.ktf_flag.carrier == NIL)
			local.te = "none"
		else
			local.te = level.ktf_flag.carrier.dmteam

		huddraw_font 57 facfont-20
		huddraw_align 57 "left" "center"
		huddraw_rect 57 (local.x) (local.y + 73) 100 100
		huddraw_string 57 "[FLAG]:"
		huddraw_color 57 1.0 1.0 1.0
		huddraw_alpha 57 1.0

		huddraw_font 58 facfont-20
		huddraw_align 58 "left" "center"
		huddraw_rect 58 (local.x + 30) (local.y + 93) 100 100
		huddraw_string 58 ("[ " + local.loc + " ]")
		huddraw_color 58 local.colour[local.te][0] local.colour[local.te][1] local.colour[local.te][2]
		huddraw_alpha 58 1.0

		huddraw_align 59 "left" "center"
		huddraw_rect 59 (local.x) (local.y + 53) 22 22
		huddraw_shader 59 local.texture[local.te]
		huddraw_alpha 59 1.0

		wait 1
	}
end

/* 
 Get Location
 -------------
*/
get_location local.flag:

	if (local.flag.carrier == NIL)
	{
		if (level.ktf["HUD_flagposition"] == 1 && level.AIR_landmark != NIL)
		{
			local.loc = ("Base :: " + waitthread global/AIR_library.scr::findplayer local.flag.origin) 
		}
		else
		{
			local.loc = "Base"
		}
	}
	else
	{
		if (level.ktf["HUD_flagposition"] == 1 && level.AIR_landmark != NIL)
		{
			local.loc = ((waitthread get_teamstring_pos local.flag.carrier.dmteam) + " Player :: " + (waitthread global/AIR_library.scr::findplayer local.flag.origin))
		}
		else
		{
			local.loc = ((waitthread get_teamstring_pos local.flag.carrier.dmteam) + " Player")
		}
	}

end local.loc

/*
========================================================================================
						FLAG HANDLING THREADS
========================================================================================
*/
triggered:

	if ($player.size <= 1)
		end

	local.p = parm.other
	level.ktf_flag.carrier = local.p 

	local.scoring = 0
	local.origin = local.p.origin 
	local.pos = ( 0 0 0 )
	local.team = local.p.dmteam
	local.reset = 0
	local.wait = 0

	waitthread disable_pickup
	waitthread hide_all_bases

	waitthread attach_flag_to_player local.p level.ktf_flag

	thread globalwidget_to_player local.p "You captured the Flag!"
	local.p dmmessage 0 "<<< I captured the Flag!! >>>"
	iprintlnbold_noloc ("[KTF]: The " + (waitthread get_teamstring local.team) + " have captured the flag!")

	thread play_capture_in_favour_of local.team
	local.p iprint ("To Score: crouch and sit still for " + level.ktf["scoretime"] + " seconds!")

	if (level.ktf["flagcarrier_music"] == 1)
	{
		println "holder music"
		thread music_for_holder local.p level.ktf_flag	
	}

	while (local.p.status == "alive" && level.ktf_flag.carrier == local.p)		
	{
		local.inradius = vector_within local.origin local.p.origin 40
		if !(local.inradius)
		{
			if (local.p.widget != "off" && local.p.widget != NIL && local.p.widget != "n")
			{
				waitthread unglobalwidget_player local.p 1
			}
			local.scoring = -5
			local.origin = local.p.origin 
			if (level.ktf["sounds"] == 1)
			{
				local.p stoploopsound
			}
		}
		else if (local.inradius && (local.p getposition) == "crouching" )
		{
			local.scoring += 0.05
			if (local.p.widget != "dot" && local.p.widget != "n" && local.scoring == (int(level.ktf["scoretime"] / 2)) )
			{
				thread globalwidget_to_player_dots local.p "Scoring"
			}

			if (local.scoring == int(level.ktf["scoretime"] - (level.ktf["scoretime"] / 3))  && level.ktf["sounds"] == 1)
			{
				local.p loopsound flag_finaltick
				iprintlnbold_noloc ("[KTF]: The " + (waitthread get_teamstring local.team) + " are about to score!!")
			}

			if (int(local.scoring) == (level.ktf["scoretime"] + 1))
			{
				iprintlnbold_noloc ("[KTF]: The " + (waitthread get_teamstring local.team) + " have scored!!")
				thread globalwidget_to_player local.p "You scored for your team!"
				local.p dmmessage 0 "<<< I scored!! >>>"

				if (level.ktf["sounds"] == 1)
				{
					local.p stoploopsound
					thread playasound (local.team + "_victory")
				}

				level.score[local.team]++

				local.scoring = 0
				local.origin = local.p.origin 
				waitthread unglobalwidget_player local.p 1
			}
		}
		
		local.reset += 0.05
		local.wait += 0.05

		if ( int(local.reset) == (level.ktf["resettime"] + 1) || $player.size <= 1)
		{
			local.loc = "[KTF]: Carrier Time-Out!"
			break
		}
		if ( (local.wait) == 10.00 )
		{
			local.p iprint ("To Score: crouch and sit still for " + level.ktf["scoretime"] + " seconds!")
			local.wait = 0
		}

		if ((local.p getposition) == "crouching" && local.lastpos != "crouching")
		{
			local.pos = ( 0 0 -40 )
			local.lastpos = "crouching"
		} else if ((local.p getposition) != "crouching" && local.lastpos == "crouching")
		{
			local.pos = ( 0 0 0 )
			local.lastpos = "somethingelse"
		}

		level.ktf_flag.origin = (local.p.origin + local.pos) + ((angles_toleft local.p.angles) * level.ktf_flag.playeroffset[0]) + ( ( 0 0 1 ) * level.ktf_flag.playeroffset[2])

		waitframe
	}
	
	if (local.loc == NIL)
	{
		if (level.ktf["sounds"] == 1)
		{
			thread playasound "drop"
		}
		local.loc = ("[KTF]: The " + (waitthread get_teamstring local.team) + " have lost the flag!!")
	}

	iprintlnbold_noloc local.loc
	if (local.p)
	{
		if (local.p.widget != "off" || local.p.widget != NIL)
		{
			waitthread unglobalwidget_player local.p 1
		}

		local.p dmmessage 0 "<<< I lost the flag!! >>>"

		local.p stoploopsound
	}

	thread return_flag_to_base level.ktf_flag

end

/*
========================================================================================
						FLAG CREATION
========================================================================================
*/
create_flag local.o:

	level.ktf_flag = spawn func_beam
	level.ktf_flag.origin = local.o + ( 0 0 70 )
	level.ktf_flag minoffset 0.0
	level.ktf_flag maxoffset 0.0
	level.ktf_flag alpha 1.0
	level.ktf_flag color ( 1.0 1.0 1.0 )
	level.ktf_flag scale 20.0
	level.ktf_flag life 0
	level.ktf_flag endpoint (local.o + ( 0 0 130 ))
	level.ktf_flag tileshader ("textures/hud/allies_headicon")  //"textures/sprites/vsssource2.tga"
	level.ktf_flag numsegments 1	
	level.ktf_flag activate

	level.ktf_flag.beamstart = ( 0 0 0 )
	level.ktf_flag.beamend = ( 0 0 130 )

	thread flag_beam_thread level.ktf_flag

	level.ktf_flag.trig = spawn trigger_multiple
	level.ktf_flag.trig.origin = level.ktf_flag.origin + ( 0 0 50 )
	level.ktf_flag.trig setsize ( -20 -20 -150 ) ( 20 20 100 )
	level.ktf_flag.trig bind level.ktf_flag
	level.ktf_flag.trig nottriggerable
	level.ktf_flag.trig setthread triggered
	level.ktf_flag.trig wait 1

end

create_base local.origin:

	local.base = spawn script_model model "miscobj/searchlight.tik"
	local.base.origin = local.origin
	local.base.angles = ( 90 90 0 )
	local.base scale 4
	local.base light 1.0 1.0 1.0 60
	local.base notsolid
	if (level.ktf["hide_bases"] == 1)
	{
		local.base hide
	}
	local.base surface beam "+nodraw"

	if (level.respawn_spot == NIL)
		local.i = 1
	else
		local.i = level.respawn_spot.size + 1

	level.respawn_spot[local.i] = local.base

end

/*
========================================================================================
					FLAG POSITION-HANDLING THREADS
========================================================================================
*/

attach_flag_to_player local.p local.flag:

	if (local.p.team == "allies")
	{
		local.flag.playeroffset = ( -10 0 80 )
	}
	else
	{
		local.flag.playeroffset = ( 10 0 80 )
	}
	local.flag.beamstart = ( 0 0 10 )
	local.flag.beamend = ( 0 0 130 )

end

flag_beam_thread local.flag:

	while (local.flag != NULL)
	{
		if (local.flag.beamstart != ( 0 0 0 ) && local.flag.beamstart != NIL)
		{
			local.flag.origin = (local.flag.origin + local.flag.beamstart)
			local.flag.beamstart = ( 0 0 0 )
		}

		local.flag endpoint (local.flag.origin + local.flag.beamend)
		waitframe
	}
end

return_flag_to_base local.flag: 

	local.flag deactivate
	local.flag.trig nottriggerable

	local.spot = level.respawn_spot[((randomint(level.respawn_spot.size)) + 1)]

	local.flag.origin = (local.spot.origin + ( 0 0 70 ))
	local.flag.beamstart = ( 0 0 0 )
	local.flag.beamend = ( 0 0 130 )

	local.flag.trig.origin = (local.flag.origin + ( 0 0 80 ))

	if (level.ktf["sounds"] == 1)
	{
		thread playasound "reset"
	}
	iprintlnbold_noloc ("[KTF]: The server has reset the flag!")

	local.flag.carrier = NIL
	local.flag activate
	thread enable_pickup 0.5
	local.spot show

end

start_flag_at_base local.flag:

	local.flag deactivate
	local.flag.trig nottriggerable

	local.spot = level.respawn_spot[((randomint(level.respawn_spot.size)) + 1)]

	local.flag.origin = (local.spot.origin + ( 0 0 70 ))
	local.flag.beamstart = ( 0 0 0 )
	local.flag.beamend = ( 0 0 130 )

	local.flag.trig.origin = (local.flag.origin + ( 0 0 80 ))

	local.flag.carrier = NIL
	local.flag activate
	thread enable_pickup 1.0
	local.spot show
end

/*
========================================================================================
						HELPER THREADS
========================================================================================
*/

disable_pickup:

	level.ktf_flag.trig nottriggerable

end

enable_pickup local.delay:

	if (local.delay)
		wait local.delay

	level.ktf_flag.trig triggerable

end

get_teamstring_pos local.t:

	if (local.t == "allies")
		end "Allied"
	else if (local.t == "axis")
		end "Axis"

end NIL

get_teamstring local.t:

	if (local.t == "allies")
		end "Allies"
	else if (local.t == "axis")
		end "Axis"

end NIL

hide_all_bases:

	if (level.ktf["hide_bases"] != 1)
		end

	for (local.i = 1; local.i <= level.respawn_spot.size; local.i++)
	{
		level.respawn_spot[local.i] hide
	}
	
end

/*
========================================================================================
			IPHE-HANGLING (Individual Player Hud Elements) THREADS
========================================================================================
*/
globalwidget_to_player local.player local.msg:

	if (level.ktf["iphe_display"] == 0)
		end

	if (local.player.widget_init != 1)
	{
		local.player.widget_init = 1
		waitthread init_widget local.player
	}

	local.player.widget = "n"

	wait 1
	if (local.player.widget == "n" && local.player.status == "alive")
	{
		local.player stufftext ("set ktf_msg " + local.msg)
		local.player stufftext ("globalwidgetcommand june6 linkcvar ktf_msg")
		local.player stufftext "showmenu dday1"

		local.time = 0
		while( local.time <= 5.0 && local.player.widget == "n")
		{
			local.time += 0.05
			waitframe
		}
	}


	if (local.player.widget == "n")
		waitthread unglobalwidget_player local.player 1

end


globalwidget_to_player_dots local.player local.msg:

	if (level.ktf["iphe_display"] == 0)
		end

	if (local.player.widget_init != 1)
	{
		local.player.widget_init = 1
		waitthread init_widget local.player
	}

	local.player.widget = "dot"
	local.currentdot = "."

	local.time = 0
	while(local.player.widget == "dot" && local.player.status == "alive")
	{
		local.player stufftext ("set ktf_msg " + local.msg + "" + local.currentdot)
		local.player stufftext ("globalwidgetcommand june6 linkcvar ktf_msg")
		local.player stufftext "showmenu dday1"

		if (local.time == 0.800)
		{
			if (local.currentdot == ".")
				local.currentdot = ".."
			else if (local.currentdot == "..")
				local.currentdot = "..."
			else if (local.currentdot == "...")
				local.currentdot = "."
	
			local.time = 0
		}

		waitframe
		local.time += 0.05
	}

	if (local.player.widget == "dot")
		waitthread unglobalwidget_player local.player 1

end

unglobalwidget_player local.player local.nowait:

	if (level.ktf["iphe_display"] == 0)
		end

	local.player.widget = "off"
	if (!local.nowait)
		waitframe

	local.player stufftext "hidemenu dday1"

end

init_widget local.player:

	local.player stufftext "globalwidgetcommand dday1 shader townhallwindow"
	local.player stufftext "globalwidgetcommand dday1 fgcolor 1.00 0.00 1.00 1.00"
	local.player stufftext "globalwidgetcommand dday1 bgcolor 0.00 0.00 0.00 0.00"
	local.player stufftext "globalwidgetcommand dday1 fadein 0"
	local.player stufftext "globalwidgetcommand dday1 menu dday1 640 480 NONE 0"
	local.player stufftext "globalwidgetcommand dday1 virtualres 1"
	local.player stufftext "globalwidgetcommand dday1 fullscreen 1"

	local.player stufftext "globalwidgetcommand june6 shader townhallwindow"
	local.player stufftext "globalwidgetcommand june6 rect 140 40 596 354"
	local.player stufftext "globalwidgetcommand june6 fgcolor 1.00 3.00 4.00 6.00"
	local.player stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	local.player stufftext "globalwidgetcommand june6 font handle-23"
	//local.player stufftext "globalwidgetcommand june6 title ."

	local.player stufftext "hidemenu dday1"

end

/*
========================================================================================
					SOUND-HANDLING THREADS
========================================================================================
*/
cache_sounds:

	local.master = spawn ScriptMaster
	local.master aliascache flag_drop sound/items/hit_notify3.wav soundparms 6.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_reset sound/items/hit_notify.wav soundparms 10.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_capturegood sound/items/Shell_DrumBack_01.wav soundparms 7.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_capturebad sound/items/hit_notify2.wav soundparms 4.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache flag_tick sound/items/Item_Timer_01.wav soundparms 1.5 0.0 1.0 0.0 10000 10000 local loaded maps "m dm moh obj train "
	local.master aliascache flag_finaltick sound/items/final_countdown.wav soundparms 1.5 0.0 1.0 0.0 10000 10000 local loaded maps "m dm moh obj train "

	//Global Victory - Allied
	local.master alias flag_allies_victory1 sound/dialogue/Multiplayer/a/AMdfr_v_01a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_allies_victory2 sound/dialogue/Multiplayer/a/AMdfr_v_01h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_allies_victory3 sound/dialogue/Multiplayer/a/AMdfr_v_01j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_allies_victory4 sound/dialogue/Multiplayer/a/AMdfr_v_02a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_allies_victory5 sound/dialogue/Multiplayer/a/AMdfr_v_02j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_allies_victory6 sound/dialogue/Multiplayer/a/AMdfr_v_03a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_allies_victory7 sound/dialogue/Multiplayer/a/AMdfr_v_03h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_allies_victory8 sound/dialogue/Multiplayer/a/AMdfr_v_03j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_allies_victory9 sound/dialogue/Multiplayer/a/AMdfr_v_04h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_allies_victory10 sound/dialogue/Multiplayer/a/AMdfr_v_04j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_allies_victory11 sound/dialogue/Multiplayer/a/AMdfr_v_06h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "

	//Global Victory - Axis 
	local.master alias flag_axis_victory1 sound/dialogue/Multiplayer/g/GRden_v_01a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_axis_victory2 sound/dialogue/Multiplayer/g/GRden_v_01c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_axis_victory3 sound/dialogue/Multiplayer/g/GRden_v_01i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias flag_axis_victory4 sound/dialogue/Multiplayer/g/GRden_v_02a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_axis_victory5 sound/dialogue/Multiplayer/g/GRden_v_02b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_axis_victory6 sound/dialogue/Multiplayer/g/GRden_v_02c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_axis_victory7 sound/dialogue/Multiplayer/g/GRden_v_02d.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias flag_axis_victory8 sound/dialogue/Multiplayer/g/GRden_v_03a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_axis_victory9 sound/dialogue/Multiplayer/g/GRden_v_03b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_axis_victory10 sound/dialogue/Multiplayer/g/GRden_v_03i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias flag_axis_victory11 sound/dialogue/Multiplayer/g/GRden_v_04a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory12 sound/dialogue/Multiplayer/g/GRden_v_04b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory13 sound/dialogue/Multiplayer/g/GRden_v_04c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory14 sound/dialogue/Multiplayer/g/GRden_v_04d.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory15 sound/dialogue/Multiplayer/g/GRden_v_04i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias flag_axis_victory16 sound/dialogue/Multiplayer/g/GRden_v_06a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "
	local.master alias flag_axis_victory17 sound/dialogue/Multiplayer/g/GRden_v_06b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "

end

play_capture_in_favour_of local.team:

	if (local.team == "allies")
	{
		thread playasound_t "allies" "capturegood"
		thread playasound_t "axis" "capturebad"
	}
	else
	{
		thread playasound_t "allies" "capturebad"
		thread playasound_t "axis" "capturegood"
	}

end

playasound_t local.team local.sound:

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		if ($player[local.i].dmteam == local.team)
		{
			$player[local.i] playsound ("flag_" + local.sound)
		}
	}

end

playasound local.sound:

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		$player[local.i] playsound ("flag_" + local.sound)

		if (local.sound == "allies_victory" || local.sound == "axis_victory")
		{
			end
		}
	}

end

music_for_holder local.player local.flag:

	local.time = 0

	local.player stufftext ("playmp3 main/sound/music/mus_Schmerzen_01a.mp3")

	while(local.player == local.flag.carrier)
	{
		if (local.time == 214.0)
		{
			local.player stufftext ("playmp3 main/sound/music/mus_Schmerzen_01a.mp3")
			local.time = 0
		}

		local.time += 0.05
		waitframe
	}

	local.player stufftext "stopmp3"

end

```

# xyz_Airborne_Mod\global\limits.txt

```txt
// ************************************************************ //
// ************************************************************ //
//								//
// 		Weapon Limiter Options; by Sor			//
//								//
// ************************************************************	//
// ************************************************************	//


//==========================================================================================//
// BONUS
// ------
// Give people with a certain weapon a bonus!!
//
// Bonusses: 
//
// //Weaponmodel  //Option 	//amount to give?
// <"model">	"ammo"	 	<integer amount>
// <"model"> 	"nade"		<integer amount>
// <"model">   	"speed"		<float movementspeed>	//more than 1.00
// <"model"> 	"zoom"		<integer zoom>		//less than 20
//
//==========================================================================================//
bonuses: 

	level.AIR["bonus_weapons"] = makeArray

	// Weapon model					// Bonus	// Bonus Var 1	
	//"models/weapons/thompsonsmg.tik"		"ammo"		50

	endArray
end

//==========================================================================================//
// LIMITED
// --------
// Give people with a certain weapon a limit/restriction!!
//
// Limits: 
//
// //Weaponmodel  //Option 	//amount to give?
// <"model">	"ammo"	 	<"integer amount">	//use a negative (STRING)
// <"model"> 	"nade"		<"integer amount">	//use a negative (STRING)
// <"model">   	"speed"		<float movementspeed>	//less than 1.00 to decrease
// <"model"> 	"zoom"		<integer zoom>		//more than 20 to decrease
// <"model">	"take"		<"string model">	//take weapon (give modelstring)
//
//==========================================================================================//
limited:

	level.AIR["limited_weapons"] = makeArray

	// Weapon model					// Limitation	//Limitation variable
	//"models/weapons/panzerschreck.tik" 		"ammo" 		"-2"

	endArray
end


//==========================================================================================//
// BANNED
// -------
// Takes banned weapon immediately away! 
// This is a special version I made for my ranking system. Bazookas, Panzerschrecks and
// shotguns don't get taken away if the player is .zooka_worth = 1 or .shotty_worth = 1
//
// Bans:
// //Weaponmodel
// <"model">
//
//==========================================================================================//
banned:

	level.AIR["banned_weapons"] = makeArray

	// Weapon Name		// Weapon model
	"models/weapons/bazooka.tik"
	"models/weapons/panzerschreck.tik"
	"models/weapons/shotgun.tik"

	endArray

end

```

# xyz_Airborne_Mod\global\maths.scr

```scr

// big thanx to jv for letting me use his maths functions
// jv wrote this file btw:P

main:

	level.PI = 3.1415926
	//level.PI = 3.14159
end
// sin(x), x in rad
 // sin(x), x in rad
sin local.x:
end (waitthread cos(local.x - 0.5 * level.PI))

// cos(x), x in rad
cos local.x:
	// reduce to [0,2pi]
	if(local.x > 2.0 * level.PI)
	{
	  local.x -= (int (local.x / (2.0 * level.PI))) * 2.0 * level.PI
	}
	else if(local.x < 0.0)
	{
	  local.x += ((int ( -local.x / (2.0 * level.PI))) + 1) * 2.0 * level.PI
	}   

	// reduce to [-pi,pi]
	if(local.x > level.PI)
	{
	  local.x -= 2.0 * level.PI
	}

	local.x2 = local.x * local.x
	local.x4 = local.x2 * local.x2
	local.x6 = local.x4 * local.x2
	local.x8 = local.x6 * local.x2

	// taylor series expansion
	local.cosx = 1.0 - 0.5 * local.x2 + 0.04167 * local.x4 - 0.00139 * local.x6 + 0.00002 * local.x8

	if(local.cosx < -1.0)
	{
	  local.cosx = -1.0
	}
	else if(local.cosx > 1.0)
	{
	  local.cosx = 1.0
	}

end local.cosx

// tan(x), x in rad, undefined for x = (1/2 + k) * PI with k arbitrary int
tan local.x:
end ((waitthread sin local.x) / (waitthread cos local.x))



// transforms vectors to angles (pitch,yaw,roll)
// unlike vector_toangles this also includes roll
vectors_toangles local.vec_fwd local.vec_lf:
   local.base_angles = vector_toangles local.vec_fwd
   
   local.base_fwd = local.vec_fwd
   local.base_lf = -1.0 * (angles_toleft local.base_angles)
   local.base_up = vector_cross local.base_fwd local.base_lf
   
   local.cos = local.vec_lf * local.base_lf
   
   if(abs local.cos < 0.8)
   {
      local.roll_angle = waitthread arccos local.cos
      
      if(local.vec_lf * local.base_up < 0.0)
      {
         local.roll_angle = -local.roll_angle
      }
   }
   else
   {
      // arccos inaccurate here
      // so just use arcsin instead
      // (far more sensitive in this region)
      local.sin = local.vec_lf * local.base_up
      
      local.roll_angle = waitthread arcsin local.sin
      
      if(local.cos < 0.0)
      {
         local.roll_angle = level.PI - local.roll_angle
      }
   }
   
   // convert to degrees
   local.roll_angle = local.roll_angle / level.PI * 180.0
   
   local.angles = local.base_angles
   local.angles[2] = local.roll_angle
end local.angles

// inverse sin
// somewhat inaccurate near +-0.5PI
arcsin local.x:
   if(local.x < -0.857 || local.x > 0.857)
   {
      // some 9th order approximation
      local.x3 = local.x * local.x * local.x
      local.x9 = local.x3 * local.x3 * local.x3
      
      local.out = local.x + (0.5 * level.PI - 1.0) * local.x9
   }
   else
   {
      local.x2 = local.x * local.x
      local.x3 = local.x2 * local.x
      local.x5 = local.x3 * local.x2
   
      // Taylor series expansion
      local.out = local.x + 0.1667 * local.x3 + 0.075 * local.x5
   }
end local.out

// inverse cos
arccos local.rad:
   local.result = 0.5 * level.PI - (waitthread arcsin local.rad)
end local.result 


// square-root
sqrt local.x:
	// sqrt(2)
	local.SQRT_2 = 1.4142135623730951

	// known values, how convenient
	if(local.x == 0.0)
	{
		local.result = 0.0
	}
	else if(local.x == 1.0)
	{
		local.result = 1.0
	}
	else if(local.x == 2.0)
	{
		local.result = local.SQRT_2
	}
	else if (local.x < 0.0)
	{
		// error
		println "ERROR[math::sqrt]: sqrt(" local.x ") has no real solution"
		local.result = 0.0
	}
	else
	{
		// reduce x to [1,2] domain
		local.wx = local.x
		local.steps = 0
		local.dividesteps = 0
		
		// reduce below 2.0
		while (local.wx > 2.0)
		{
			local.wx = 0.5 * local.wx
			local.steps++
		}
		
		// increase above 1.0
		while(local.wx < 1.0)
		{
			local.wx = 2.0 * local.wx
			local.dividesteps++
		}
		
		// evaluate in [1,2] domain
		if(local.wx == 1.0)
		{
			local.eval = 1.0
		}
		else if (local.wx == 2.0)
		{
			local.eval = local.SQRT_2
		}
		else
		{
			// approximation
			local.EVALSLOPE = 0.4267766953
			local.EVALMOD = 1.224744871 - 1.51 * local.EVALSLOPE
			local.eval = local.EVALSLOPE * local.wx + local.EVALMOD
		}
		
		// multiply back to original domain
		for(local.i = 1; local.i <= local.steps; local.i++)
		{
			local.eval = local.eval * local.SQRT_2
		}
		
		// divide back to original domain
		for(local.i = 1; local.i <= local.dividesteps; local.i++)
		{
			local.eval = local.eval / local.SQRT_2
		}
	
		// correct until required accuracy has been reached
		local.MAXREFINEMENTSTEPS = 2;

		for(local.i = 1; local.i <= local.MAXREFINEMENTSTEPS; local.i++)
		{
			local.fact = local.eval * local.eval / local.x
			local.eval = local.eval / (waitthread sqrt1 local.fact)
		}
		
		local.result = local.eval
	}
end local.result

// fast square-root
// only usuable near x=1
// great for normalizing
sqrt1 local.x:
	// McLaurin expansion
	local.result = 0.5 + 0.5 * local.x - 0.125 * (local.x - 1.0) * (local.x - 1.0)
end local.result
```

# xyz_Airborne_Mod\global\minefield.scr

```scr
//*********************************************************************************
//
// Global Minefield Script by Sor
//	  - for Patch 1.12
//	---------------------
//
// I cleaned and fixed up the script, works perfectly even for maps which used it before the changes.
//
// -----------------------------------------
//
// All you need to do is place triggers with the targetname $minefield on the places you want a minefield.
// You can also determine what type of mines. Use #type and set it either to "water" or "ground", if you leave
// it NIL, then the default one will be "ground".
//
// Then this script'll do the rest. Syntax:
//
// 	thread global/minefield.scr::minefield_setup
//
// And you can also do it for 1 particular trigger: 
//
//	$minefield_targetname thread global/minefield.scr::minefield_single
//
//*********************************************************************************

//*************************************************
//*** setup the minefields
//*** the level scripts should call this thread
//*************************************************
minefield_setup:

if ($minefield == NULL || $minefield == NIL)
{
	println "[MineField Script]: There are no minefields in the map!!!"
	end
}


for (local.i = 1; local.i <= $minefield.size; local.i++)
{
	$minefield[local.i] thread mines
}

end

//****************************
mines:	
//****************************
while(self != NIL || self != NULL)
{	
	self waittill trigger

	local.sucker = parm.other
	local.sucker playsound mine_trigger

	wait (randomfloat .5 + .5)

	if (local.sucker istouching self == 1)
	{
		if (self.type == "water")
		{
      		local.mine = spawn models/animate/fx_mortar_water.tik
      		local.mine.origin = local.sucker.origin
      		local.mine anim start
      		local.mine playsound grenade_exp_water
      		radiusdamage local.mine.origin 4000 256
      	}
		else if (self.type == "ground" || self.type == NIL || self.type != "water" )
		{
			local.mine = spawn models/animate/fx_explosion_mine.tik
			local.mine.origin = local.sucker.origin
			local.mine anim start
     			radiusdamage local.mine.origin 4000 256
		}
	
		//*** remove the effect
		wait 3
		local.mine remove
	}
}
end

//**************************************
//*** single version minefield thread
//**************************************
minefield_single:

while (self != NIL || self != NULL)
{
	self waittill trigger

	local.sucker = parm.other
	local.sucker playsound mine_trigger

	wait (randomfloat .5 + .5)

	if ($player istouching self == 1)
	{
		local.mine spawn models/animate/fx_explosion_mine.tik
		local.mine.origin = local.player.origin
		local.mine anim start
     		radiusdamage local.mine.origin 4000 256

		wait 3
		local.mine remove
	}
}
end
```

# xyz_Airborne_Mod\global\modelCollision.scr

```scr
//-----------------------------------------------------------------------
main:

	level waittill spawn

	while(1)
	{
		if ($player.size > 0)
		{
  			for(local.i = 1; local.i <= $player.size; local.i++)
  			{
    				local.player = $player[local.i]
    				local.lean = (local.player getcontrollerangles 0)[2]
    
				if (local.lean != 0 && local.player.being_corrected != 1)
				{
        				local.headpos = local.player gettagposition "eyes bone"
        				local.origin = local.player gettagposition "Bip01 Spine"
       				local.yes = sighttrace local.origin local.headpos 1
        
        				if(!local.yes)
        				{
						if (local.lean > 0)
						{
							println "leaning left agaisnt something"
							local.player stufftext "-leanleft"
						}
						else if (local.lean < 0)
						{
							println "leaning right agaisnt something"
							local.player stufftext "-leanright"
						}

						wait 0.3
						local.lean = (local.player getcontrollerangles 0)[2]
						if (local.lean != 0)
						{
							local.player.being_corrected = 1
							local.player thread correct local.lean
						}
    					}
  				}
			}
		}

  		wait 0.5
	}

end

//-----------------------------------------------------------------------
correct local.l:

	local.headpos = self gettagposition "eyes bone"
      local.origin = self gettagposition "Bip01 Spine"
      local.yes = sighttrace local.origin local.headpos 1	
	
	if (!local.yes)
	{
		if (local.l > 0)
		{
			self.velocity += self.leftvector * -16
		}
		else if (local.l < 0)
		{
			self.velocity += self.leftvector * 16
		}
	}

	self.being_corrected = 0
end
```

# xyz_Airborne_Mod\global\obj_one.scr

```scr
/*
======================================================
*** AIRborne; OBJ One-Bomb-Planter Script for MoH:AA
======================================================
by Sor
Version: v1.0 r76
-----------------------------------
======================================================
*/

/*
========================================================================================
					INITIALIZATION THREAD
					---------------------

To set up the bombs, use this pattern and then pass on local.o in the exec:

local.o = makeArray
( X Y Z ) "team" 
( X Y Z ) "team" 
endArray

========================================================================================
*/
init local.bombs:

	if (local.bombs == NIL)
		end

	if(level.obj_one == 1)
		end

	level.obj_one = 1
	
	local.master = spawn ScriptMaster
	local.master aliascache obp_capturegood sound/items/Shell_DrumBack_01.wav soundparms 7.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache obp_capturebad sound/items/hit_notify2.wav soundparms 4.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train "
	local.master aliascache obp_drop sound/items/hit_notify3.wav soundparms 6.0 0.0 1.0 0.0 10000 20000 item loaded maps "m dm moh obj train "

	thread hud

	println "[OBP]: Started the HUD thread, now waiting for the round to start!"

	//waitthread global/AIRborne_utils::waittill_roundstart
	level.obp_round_start = 1
	setcvar "g_gametype" "4"

	println "[OBP]: Round started!"
	waitthread setup_bombs local.bombs
	thread information

	println "[OBP]: Bombs spawned!"

end

hud:

	local.x = 20
 	local.y = 80

	local.texture["allies"] = "textures/hud/allies"
	local.texture["axis"] = "textures/hud/axis"

	local.colour["allies"] = ( 0.4 0.4 1.0 )
	local.colour["axis"] = ( 1.0 0.4 0.4 )

	while(1)
	{
		huddraw_font 49 facfont-20
		huddraw_align 49 "center" "top"
		huddraw_rect 49 135 50 100 100
		if(level.obp_round_start != 1)
			huddraw_string 49 "[WAITING]"
		else
			huddraw_string 49 "[STARTED]"
		huddraw_color 49 1.0 1.0 1.0
		huddraw_alpha 49 0.9

		huddraw_font 50 facfont-20
		huddraw_align 50 "center" "top"
		huddraw_rect 50 -90 50 100 100
		huddraw_string 50 "OBJ One-Bomb-Planter v1.0.76"
		huddraw_color 50 0.0 0.0 0.0
		huddraw_alpha 50 0.5

		huddraw_font 51 facfont-20
		huddraw_align 51 "center" "top"
		huddraw_rect 51 -89 50 100 100
		huddraw_string 51 "OBJ One-Bomb-Planter v1.0.76"
		huddraw_color 51 0.0 0.4 1.0
		huddraw_alpha 51 0.8

		huddraw_font 52 facfont-20
		huddraw_align 52 "left" "center"
		huddraw_rect 52 (local.x) (local.y) 100 100
		huddraw_string 52 "[BOMBS]:"
		huddraw_color 52 1.0 1.0 1.0
		huddraw_alpha 52 1.0
	
		local.n = 53
		for (local.i = 1; local.i <= level.obp_bombs.size; local.i++)
		{
			local.ny = (local.y) + (25 * local.i)

			local.t = level.obp_bombs[local.i].team
			local.s = level.obp_bombs[local.i].status
			if(local.s == "axis")
				local.s = "Axis Player"
			else if (local.s == "allies")
				local.s = "Allied Player"

			huddraw_font local.n facfont-20
			huddraw_align local.n "left" "center"
			huddraw_rect local.n (local.x + 25) local.ny 100 100
			huddraw_string local.n ("Bomb " + local.i + " [ " + local.s + " ]")
			huddraw_color local.n local.colour[local.t][0] local.colour[local.t][1] local.colour[local.t][2]
			huddraw_alpha local.n 1.0

			local.n++

			huddraw_align local.n "left" "center"
			huddraw_rect local.n (local.x) (local.ny - 40) 22 22
			huddraw_shader local.n local.texture[local.t]
			huddraw_alpha local.n 1.0

			local.n++
			
		}

		wait 1
	}

end

information:

	while(1)
	{
		wait ( (randomint(70)) + 20 )
		iprintlnbold_noloc " "
		iprintln_noloc "[OBP::INFO]: Only the player holding a bomb can plant it!"
		wait 8
		iprintln_noloc "[OBP::INFO]: The defending team can steal the bomb(s) to thwart the attacking team's objectives!"
		iprintln_noloc "[OBP::INFO]: The attacking team can kill the thief and retrieve the lost bomb."	
		wait 15
		iprintln_noloc "[OBP::INFO]: If the bombholder gets killed or leaves, the bomb will be dropped on the ground."
		wait 20
		iprintln_noloc "[OBP::INFO]: Teamwork is essential!!"
		iprintlnbold_noloc " "
	}

end

/*
========================================================================================
						CREATION THREADS
========================================================================================
*/
setup_bombs local.bombs:

	for (local.i = 1; local.i <= local.bombs.size; local.i++)
	{
		if ( local.bombs[local.i].size == 2)
		{
			waitthread spawn_bomb local.bombs[local.i][1] local.bombs[local.i][2]
		}
	}

end

spawn_bomb local.origin local.team:

	local.bomb = spawn script_model model "items/explosive.tik"
	local.bomb.origin = local.origin
	local.bomb.obp_origin = local.origin
	local.bomb.team = local.team
	local.bomb.status = "Spawned"
	local.bomb notsolid
	if (local.bomb.team == "axis")
	{
		local.bomb.playeroffset = ( -10 -5 10 )
		local.bomb light 1.0 0.0 0.0 60
		local.bomb.r = 1.0
		local.bomb.g = 0.4
		local.bomb.b = 0.4
	}
	else
	{
		local.bomb.playeroffset = ( 10 -5 10 )
		local.bomb light 0.0 0.0 1.0 60
		local.bomb.r = 0.4
		local.bomb.g = 0.4
		local.bomb.b = 1.0
	}
	local.bomb thread do_bomblike

	local.bomb.trig = spawn trigger_multiple
	local.bomb.trig.origin = local.bomb.obp_origin
	local.bomb.trig.bomb = local.bomb
	local.bomb.trig bind local.bomb
	local.bomb.trig setsize ( -40 -40 -40 ) ( 40 40 40 )
	local.bomb.trig setthread pickup_expl

	if (level.obp_bombs == NIL)
		local.i = 1
	else
		local.i = level.obp_bombs.size + 1

	level.obp_bombs[local.i] = local.bomb

end

/*
========================================================================================
						LOGIC THREADS
========================================================================================
*/
do_bomblike:

	self scale 2
	self rotatey 60
	self light self.r self.g self.b 250
end

stop_bomblike:

	self scale 1
	self stop
	self.angles = ( 0 0 0 )
	self light self.r self.g self.b 60
end

pickup_expl:

	local.player = parm.other
	local.team = local.player.dmteam
	if (local.player.has_bomb == 1)
		end

	local.player.has_bomb = 1
	local.player.bombz = self.bomb
	self nottriggerable
	self.bomb waitthread stop_bomblike
	self.bomb.origin = ( local.player gettagposition "Bip01 Head" ) + ( -10 -5 10 )
	self.origin = self.bomb.origin

	if ( local.player.dmteam != self.bomb.team )
	{
		local.player light self.bomb.r self.bomb.g self.bomb.b 350
		iprintlnbold_noloc ("[OBP]: The " + (waitthread get_teamstring local.player.dmteam) + " have stolen an " + (waitthread get_teamstring_pos self.bomb.team) + " bomb!!")
	}
	else
	{
		local.player iprint "You can plant a bomb!!"
		iprintlnbold_noloc ("[OBP]: The " + (waitthread get_teamstring local.player.dmteam) + " have picked up an " + (waitthread get_teamstring_pos self.bomb.team) + " bomb!!")
	}

	thread play_capture_in_favour_of local.player.dmteam
	self.bomb.status = local.player.dmteam

	while (local.player.status == "alive" && local.player != NIL && local.player != NULL)
	{
		if (local.player.has_bomb == 0)
		{
			local.player lightOff
			end
		}

		self.bomb.origin = (( local.player gettagposition "Bip01 Head" )) + ((angles_toleft local.player.angles) * self.bomb.playeroffset[0]) + ( ( 0 0 1 ) * self.bomb.playeroffset[2])

		self.origin = self.bomb.origin
		waitframe
	}

	thread attach_bomb_to_ground self.bomb
	if (local.player)
	{
		local.player.bombz = NIL
		local.player.has_bomb = 0
		local.player lightOff
	}

	self.bomb playsound obp_drop
	iprintlnbold_noloc ("[OBP]: The " + (waitthread get_teamstring local.team) + " have lost an " + (waitthread get_teamstring_pos self.bomb.team) + " bomb!")

end

bomb_planted local.player local.pulse:

	local.player.has_bomb = 0
	local.player.bombz unglue

	local.detached_bomb = local.player.bombz
	local.player.bombz = NIL
	local.detached_bomb.origin = local.player.origin + ( 0 0 30 )
	local.detached_bomb notsolid
	local.detached_bomb hide
	local.detached_bomb.trig nottriggerable
	local.detached_bomb.trig.origin = local.detached_bomb.origin

	local.detached_bomb.status = "Planted"
	local.detached_bomb.tag = (local.detached_bomb.team + "_bomb_at_" + local.pulse.trigger_name)

	while (local.pulse.exploded != 1)
	{
		if (local.detached_bomb.status != "Planted")
		{
			local.diffused = 1
			break
		}

		waitframe
	}

	if !(local.diffused)
	{
		local.detached_bomb.status = "EXPLODED"
	}

end

bomb_diffused local.player local.ttn:

	for (local.i = 1; local.i <= level.obp_bombs.size; local.i++)
	{
		if (level.obp_bombs[local.i].tag == ( (waitthread get_other_team local.player.dmteam) + "_bomb_at_" + local.ttn) )
		{
			local.bomb = level.obp_bombs[local.i]
		}
	}

	if (local.bomb == NIL)
	{
		println "[OBP]: FATAL ERROR"
		end
	}
	else
	{
		local.bomb.origin = local.bomb.obp_origin
		local.bomb show
		local.bomb thread do_bomblike
		local.bomb.trig triggerable
		local.bomb.trig.origin = local.bomb.obp_origin

		local.bomb.tag = NIL
		local.bomb.status = "Spawned"

		iprintlnbold_noloc ("[OBP]: An " + (waitthread get_teamstring_pos local.bomb.team) + " bomb has respawned!")
	}

end

attach_bomb_to_ground local.bomb:

	local.neworigin = trace local.bomb.origin (local.bomb.origin + ( 0 0 -10000 )) 1
	local.bomb.origin = (local.neworigin + ( 0 0 10 ))
	local.bomb.trig.origin = (local.neworigin + ( 0 0 10 ))

	local.bomb.trig triggerable
	local.bomb thread do_bomblike
	local.bomb.status = "Ground"

	local.time = 0
	while(local.bomb.status == "Ground")
	{
		if (local.time > 120.000)
		{
			local.timehit = 1
			break
		}
		waitframe
		local.time += 0.05
	}

	if (local.timehit)
	{
		local.bomb.origin = local.bomb.obp_origin
		local.bomb.trig.origin = local.bomb.obp_origin

		local.bomb.status = "Spawned"
		iprintlnbold_noloc ("[OBP]: An " + (waitthread get_teamstring_pos local.bomb.team) + " bomb has respawned!")
	}
		
end

/*
========================================================================================
						HELPER THREADS
========================================================================================
*/
play_capture_in_favour_of local.team:

	if (local.team == "allies")
	{
		thread playasound_t "allies" "capturegood"
		thread playasound_t "axis" "capturebad"
	}
	else
	{
		thread playasound_t "allies" "capturebad"
		thread playasound_t "axis" "capturegood"
	}

end

playasound_t local.team local.sound:

	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		if ($player[local.i].dmteam == local.team)
		{
			$player[local.i] playsound ("obp_" + local.sound)
		}
	}

end

get_other_team local.team:

	if (local.team == "allies") { end "axis" }
	else { end "allies" }

end

get_teamstring_pos local.t:

	if (local.t == "allies")
		end "Allied"
	else if (local.t == "axis")
		end "Axis"

end NIL

get_teamstring local.t:

	if (local.t == "allies")
		end "Allies"
	else if (local.t == "axis")
		end "Axis"

end NIL

/*
========================================================================================
						OBJECTIVE MATCH LOGIC
========================================================================================
*/
// -----------------------------------------------------
adv_bomb_thinker:
// -----------------------------------------------------

	if (self.bomb["planting_team"] == NIL)
	{
		println "ERROR[Bomb Thinker]: Planting team unknown."
		end
	}

	if (self.bomb["planting_team"] == "allies")
		self.bomb["defusing_team"] = "axis"
	else
		self.bomb["defusing_team"] = "allies"

	level.bomb_use_distance = 128 	//quake units
	level.bombusefov = 30

	level.subtitleX = 100
	level.subtitleY = 50

	local.d = makeArray
	"exploder_set"		"none"
	"explosion_fx"		"none"
	"explosion_sound"		"none"
	"jitter"			"large"
	"set_time"			50
	"defuse_time"		60
	"tick_time"			45
	"damage"			200
	"explosion_radius"	1054
	endArray

	for(local.i = 1; local.i <= local.d.size; local.i++)
	{
		local.t = local.d[local.i][1]
		if (self.bomb[local.t] == NIL || self.bomb[local.t] == "")
		{
			self.bomb[local.t] = local.d[local.i][2]
		}
	}

	println "------------------Bomb------------------"
	println "self = " self
	println "self.planting_team = " self.bomb["planting_team"]
	println "self.defusing_team = " self.bomb["defusing_team"]
	println " "
	if (self.target != NULL)
	{
		println "self.target (flak 88 or other) = " self.target
		println "self.target.destroyed_model = " self.target.destroyed_model
		println "self.target.destroyed_generic = " self.target.destroyed_generic
	}
	println "self.trigger_name = " self.trigger_name
	println "self.exploder_set = " self.bomb["exploder_set"]
	println "self.explosion_fx = " self.bomb["explosion_fx"]
	println "self.explosion_sound = " self.bomb["explosion_sound"]
	println "self.jitter = " self.bomb["jitter"]
	println " "
	println ("level.bomb_set_time = " + self.bomb["set_time"] + " (tenths of a second)")
	println ("level.bomb_defuse_time = " + self.bomb["defuse_time"] + " (tenths of a second)")
	println ("level.bomb_tick_time = " + self.bomb["tick_time"] + " (seconds)")
	println ("level.bomb_damage = " + self.bomb["damage"])
	println ("level.bomb_explosion_radius = " + self.bomb["explosion_radius"] + " (quake units)")
	println "------------------Bomb------------------"

	level.bomb_planted["allies"] = 0
	level.bomb_planted["axis"] = 0

	if (level.target_destroyed["allies"] == NIL)
		level.target_destroyed["allies"] = 0

	if (level.target_destroyed["axis"] == NIL)
		level.target_destroyed["axis"] = 0

	if (self.target != NIL && self.target != NULL)
		self.target notsolid

	thread bomb_waittill_set
end

// -----------------------------------------------------
// first thread... controls planting_team using the trigger
// -----------------------------------------------------
bomb_waittill_set:

self model items/pulse_explosive.tik

while ( $(self.trigger_name) )
{
	println "waittill trigger " self.trigger_name
	$(self.trigger_name) waittill trigger

	local.player = parm.other

      if (local.player.dmteam != self.bomb["planting_team"] || local.player.has_bomb != 1) 
	{
		//goto bomb_waittill_set
		println "failed dmteam check" local.player.dmteam	
	}
	else
	{
		local.counter = 0
		while ( (Isalive local.player) && (local.player cansee self level.bombusefov level.bomb_use_distance) && (local.player.useheld == 1) )
		{
			if (local.counter == 0)
			{
				local.player stopwatch (self.bomb["set_time"] * .1)
			}
			
			local.counter++
			wait .1
			if (local.counter >= self.bomb["set_time"])
			{
				if (self.loc != NIL)
					iprintlnbold ("A Bomb at the " + self.loc + " has been planted by the " + self.bomb["planting_team"] + "!")
				else
					iprintlnbold ("A Bomb has been planted by the " + self.bomb["planting_team"] + "!")

				if (self.bomb["planting_team"] == "allies")
					self playsound dfr_objective_o
				else
					self playsound den_objective_o

				thread bomb_waittill_defuse
				thread bomb_waittill_explode
				self.live = 1
				local.team = self.bomb["planting_team"]
				level.bomb_planted[local.team]++

				thread bomb_planted local.player self				
				end
			}
		}

		if (local.counter > 0)
		{
			local.player stopwatch 0
		}

		println "usetrigger but failed check" 
	
		if !(local.player cansee self level.bombusefov level.bomb_use_distance)
			println "distance"
	}
}
end


// -----------------------------------------------------
// second thread... controls defusing_team using the trigger
// -----------------------------------------------------
bomb_waittill_defuse:

while ( $(self.trigger_name) )
{
	$(self.trigger_name) waittill trigger

	local.player = parm.other
	
	//"local.player.dmteam", can be 'spectator', 'freeforall', 'allies' or 'axis'
	if (local.player.dmteam != self.bomb["defusing_team"])
	{      
		println "failed dmteam check" local.player.dmteam
		//goto bomb_waittill_defuse
	}
	else
	{
		local.counter = 0
		while ( (Isalive local.player) && (local.player cansee self level.bombusefov  level.bomb_use_distance) && (local.player.useheld == 1) )
		{
			if (local.counter == 0)
			{
				local.player stopwatch (self.bomb["defuse_time"] * .1)
			}
			
			local.counter++

			wait .1
			if (local.counter >= self.bomb["defuse_time"])
			{
				if (self.loc != NIL)
					iprintlnbold ("A Bomb at the " + self.loc + " has been defused by the " + self.bomb["defusing_team"] + "!")
				else
					iprintlnbold ("A Bomb has been defused by the " + self.bomb["defusing_team"] + "!")

				if (self.bomb["defusing_team"] == "allies")
					self playsound dfr_diffused_d
				else
					self playsound den_diffused_d

				if ( level.win_on_defuse == 1 )
				{
					teamwin self.bomb["defusing_team"]
					end
				}

				else if ( level.win_on_defuse != 1 )
				{
					thread bomb_waittill_set //start first thread again
				}
				self.live = 0
				local.team = self.bomb["planting_team"]
				level.bomb_planted[local.team]--

				thread bomb_diffused local.player self.trigger_name
				end
			}
		}

		if (local.counter > 0)
		{
			local.player stopwatch 0
		}
	}
}
end


// -----------------------------------------------------
// third thread... times the bomb and makes it explode at the right time
// -----------------------------------------------------
bomb_waittill_explode:

	self model items/explosive.tik
	self playsound plantbomb


	self loopsound bombtick
	
	local.start_time = level.time

	while (level.time < (local.start_time + self.bomb["tick_time"]) )
	{
		wait .1
		if (self.live != 1)
		{
			self stoploopsound
			end
		}
		if (level.time == (local.start_time + self.bomb["tick_time"] - 10) )
		{
			self stoploopsound
			self loopsound final_countdown
		}
 	}
 	self stoploopsound
	thread bomb_explode
end


// -----------------------------------------------------
// fourth thread... controls the explosion 
// -----------------------------------------------------
bomb_explode:

	if (self.loc != NIL && self.loc != "")
	{
		iprintlnbold ("The " + self.loc + " has been blown up by the " + self.bomb["planting_team"] + "!!")
	}

	$(self.trigger_name) remove
	
	if (self.bomb["jitter"] == "large")
	{
		thread jitter_large
	}
	else if (self.bomb["jitter"] == "local")
	{
		thread jitter_local self.origin
	}


	if (self.bomb["exploder_set"] != NIL && self.bomb["exploder_set"] != "none")
	{
		exec global/exploder.scr::explode self.bomb["exploder_set"]
	}
	
	if (self.bomb["explosion_fx"] != NIL && self.bomb["explosion_fx"] != "none")
	{
		self thread spawn_fx self.bomb["explosion_fx"]
	}
	
	if (self.bomb["explosion_sound"] != NIL && self.bomb["explosion_sound"] != "none")
	{
		self playsound self.bomb["explosion_sound"]
	}

	if (self.target != NIL && self.target != NULL)
	{
		if (self.target.destroyed_generic != NIL)
		{
			local.thread = self.target.destroyed_generic
			thread global/AIRborne_prefabs.scr::destroyed_generic local.thread self.target.origin self.target.angles
		}
		if (self.target.destroyed_model != NIL)
		{
			local.damaged = self.target waitthread spawn_damaged self.target.destroyed_model
			self.target remove
		}

		if (self.target.destroyed_generic == NIL && self.target)
		{
			self.target remove
		}
	}
	radiusdamage self.origin self.bomb["damage"] self.bomb["explosion_radius"]
	if (self.bomb["killarea"] != NIL && self.bomb["killarea"] != "none")
	{
		self.bomb["killarea"] volumedamage 1000
	}
	self hide
	
	self.live = 0
	
	self.exploded = 1
	local.team = self.bomb["planting_team"]
	level.target_destroyed[local.team]++

	// we delay the decrementing of level.bombs_planted so that the script has
	// time to determin the winner before the timelimit gets checked and hit
	wait 0.5
	level.bomb_planted[local.team]--

end


//----------------------------------
spawn_fx local.fx:
//----------------------------------

	local.temp = spawn script_model model local.fx
	local.temp.origin = self.origin
	local.temp anim start
	wait 5
	local.temp remove
end

//----------------------------------
spawn_damaged local.model:
//----------------------------------

	local.damaged = spawn script_model model local.model
	local.damaged.origin = self.origin
	local.damaged.angles = self.angles

end local.damaged

//----------------------------------
jitter_large:
//----------------------------------

	waitexec global/earthquake.scr .35 10 0 0
	waitexec global/earthquake.scr .23 6 0 0
	waitexec global/earthquake.scr 1 1 0 0
	waitexec global/earthquake.scr 1.25 .3 0 1

end

//----------------------------------
jitter_local local.o:
//----------------------------------

	waitthread quake .35 ( 9 7 4 ) local.o
	waitthread quake .23 ( 6 4 3 ) local.o
	waitthread quake 1 ( 1 0.8 1 ) local.o
	waitthread quake 1.25 ( 0.3 0.2 0.1 ) local.o

end

//----------------------------------
quake local.d local.m local.o:

	local.jitter = spawn func_viewjitter "targetname" "viewjitter" 
	local.jitter.origin = local.o
	local.jitter jitteramount local.m
	local.jitter duration local.d
	local.jitter radius 786

	wait local.d

	local.jitter remove

end

```

# xyz_Airborne_Mod\global\osok.scr

```scr
/*
======================================================
*** AIRborne; One-Shot-One-Kill Script for MoH:AA
======================================================
by Sor
Version: v1.0 r96
-----------------------------------
======================================================
*/

init local.states:

	// Disable physical damage
	setcvar "dmflags" "8"

	level waittill spawn

	local.d = makeArray
	"rounds"		3
	"plusspeed"		1
	endArray
	
	for (local.i = 1; local.i <= local.d.size; local.i++)
	{
		local.t = local.d[local.i][1]
		if (level.osok[local.t] == NIL || level.osok[local.t] == "")
		{
			level.osok[local.t] = local.d[local.i][2]
		}
	}

	setcvar "g_gametype" "2"

	if (level.osok["plusspeed"] == 1)
	{
		setcvar "sv_runspeed" "420"
	}

	level.clockside = "kills"

	level.osok_round_end = 0
	level.osok_round_start = 1
	level.osok_ver = "v1.0.96"

	thread osok_announce
	thread osok

	wait 1
	thread osok_round

end


osok:

	while(level.osok_round_end != 1)
	{
		if (level.osok_round_start == 1)
		{
			for (local.i = 1; local.i <= $player.size; local.i++)
			{
				if ($player[local.i].status == "alive" && $player[local.i].health != 1.00 && $player[local.i].health > 0.0)
				{
					$player[local.i] healthonly 1
					$player[local.i] thread osok_equipment
				}	
			}
		}
	
		wait 0.5
	}

end

get_weapon_model local.p:

	local.p weaponcommand dual targetname ("w" + local.p.entnum)
	local.weapon = $("w" + local.p.entnum )

	if(local.weapon != NULL)
	{
		local.wpn = local.weapon.model
		local.weapon targetname ""
	}
	else
	{
		local.wpn = "models/weapons/unarmed.tik"
	}
end local.wpn

osok_equipment:

	self takeall

	if (self.dmteam == "axis")
	{
		self give "models/weapons/KAR98sniper.tik"
		self give "models/weapons/p38.tik"
	}
	else
	{
		self give "models/weapons/springfield.tik"
		self give "models/weapons/colt45.tik"
	}

	self thread use_gun
	wait 1
	self weaponcommand mainhand dmammorequired 999
	self weaponcommand mainhand clipsize 0
	self weaponcommand mainhand notdroppable

end

use_gun:

	local.time = 0
	while(local.time < 1.2)
	{
		if (self.dmteam == "axis")
			self use "models/weapons/p38.tik"
		else
			self use "models/weapons/colt45.tik"

		local.time += 0.3
		wait 0.3
	}

end

osok_round:

	local.timelimit = ( (int (getcvar "timelimit")) * 60 )

	while(1)
	{
		local.time_remaining = (local.timelimit - level.time)

		if (int(local.time_remaining) == 5)
		{
			level.osok_round_end = 1
			break
		}

		wait 1
	}

	if (level.osok["plusspeed"] == 1)
	{
		setcvar "sv_runspeed" "250"
	}

end

osok_announce:

	while(1)
	{
		if (level.osok["gametype"] == "1")
		{
			local.loc = ("One Shot One Kill " + level.osok_ver)
		}
		else
		{
			local.loc = ("Team One Shot One Kill " + level.osok_ver)
		}

		if (level.osok_round_start == 1)
		{
			local.loc2 = "[STARTED]"
		}
		else
		{
			local.loc2 = "[WAITING]"
		}

		huddraw_font 49 facfont-20
		huddraw_align 49 "center" "top"
		huddraw_rect 49 125 50 100 100
		huddraw_string 49 (local.loc2)
		huddraw_color 49 1.0 1.0 1.0
		huddraw_alpha 49 0.9

		huddraw_font 50 facfont-20
		huddraw_align 50 "center" "top"
		huddraw_rect 50 -90 50 100 100
		huddraw_string 50 (local.loc)
		huddraw_color 50 0.0 0.0 0.0
		huddraw_alpha 50 0.5

		huddraw_font 51 facfont-20
		huddraw_align 51 "center" "top"
		huddraw_rect 51 -89 50 100 100
		huddraw_string 51 (local.loc)
		huddraw_color 51 0.0 0.4 1.0
		huddraw_alpha 51 0.8

		wait 1
	}
end	
```

# xyz_Airborne_Mod\global\push.scr

```scr
//****************************************
// Player Push Script by Sor; BETA
//****************************************
// Directions:
// -------------
// If you want players to be able to push only in certain areas, create
// notsolid hidden clips (= script_origin) and set their setsize to 
// the area you want them to push in. Use sv_showbboxes 2 to see their 
// size in game.
//
// IMPORTANT: Give these clips are the following targetname: pusharea
//
// If you want players to be able to push anywhere and anytime, then don't 
// spawn any entities with the targetname "pusharea".
//
// Options:
// ----------
// These are some options you can set; please do this BEFORE executing 
// this script!
//
// level.push["indicator"] = 1  				// Do you want the player to be notified when he's able to push other players?
// level.push["indicator_loc"] = "PUSH players; use"	// What text should be displayed.
// level.push["power"] = 200					// Power of the push
//
//
init:

	if ( $pusharea == NULL )
	{
		level.pushmode = 2
	}
	else
	{
		level.pushmode = 1
	}

	//defaults
	local.default = makeArray
	// Settings			//value
	"indicator" 		0
	"indicator_loc"		""
	"power"			200
	endArray

	for (local.i = 1; local.i <= local.default.size; local.i++)
	{
		local.t = local.default[local.i][1]
		if (level.push[local.t] == NIL)
		{
			level.push[local.t] = local.default[local.i][2]
		}
	}

	level waittill spawn

	thread ("push_" + level.pushmode)

end

//****************************************//
// With specified areas				//
// ********************				//
push_1:
//****************************************//

	if (level.pushmode == 1 && level.push["indicator_method"] == "huddraw")
	{
		level.push["indicator"] = 0
	}

	local.power = level.push["power"]

	while(1)
	{
		if ($player.size > 1)
		{
			for (local.i = 1; local.i <= $player.size; local.i++)
			{
				if ($player[local.i].indicated != 1 && level.push["indicator"] == 1)
				{
					$player[local.i].indicated = 1
					$player[local.i] thread indication_1
				}
				if ($player[local.i].dmteam != "spectator" && isAlive $player[local.i])
				{
					for (local.f = $player.size; local.f > 0; local.f--)
					{
						for (local.s = 1; local.s <= $pusharea.size; local.s++)
						{
							if ($player[local.i] isTouching $player[local.f] && $player[local.i] != $player[local.f] && $player[local.i] isTouching $pusharea[local.s] && isAlive $player[local.f])
							{
								if ($player[local.i].useheld)
								{
									local.dir = (angles_toforward $player[local.i].viewangles)
									$player[local.f] pusher $player[local.i] $player[local.i] local.dir local.power 
								}
								else if ($player[local.f].useheld)
								{
									local.dir = (angles_toforward $player[local.f].viewangles)
									$player[local.i] pusher $player[local.f] $player[local.f] local.dir local.power 
								}
							}
						}
					}
				}
			}
		}

		wait 0.14
	}

end

//****************************************//
// Without specified areas			//
// ***********************			//
push_2:
//****************************************//

	local.power = level.push["power"]

	while(1)
	{
		if ($player.size > 1)
		{
			for (local.i = 1; local.i <= $player.size; local.i++)
			{
				if ($player[local.i].dmteam != "spectator" && isAlive $player[local.i])
				{
					for (local.f = $player.size; local.f > 0; local.f--)
					{
						if ($player[local.i] istouching $player[local.f] && $player[local.i] != $player[local.f] && isAlive $player[local.f])
						{
							if ($player[local.i].useheld)
							{
								local.dir = (angles_toforward $player[local.i].viewangles)
								$player[local.f] pusher $player[local.i] $player[local.i] local.dir local.power 
							}
							else if ($player[local.f].useheld)
							{
								local.dir = (angles_toforward $player[local.f].viewangles)
								$player[local.i] pusher $player[local.f] $player[local.f] local.dir local.power 
							}
						}
					}
				}
			}
		}

		wait 0.2
	}

end

//****************************************//
indication_1:

	local.txt = level.push["indicator_loc"]

	if (level.push["indicator_method"] == "iprint")
	{
		while(self != NULL)
		{
			for (local.i = 1; local.i <= $pusharea.size; local.i++)
			{
				if (self isTouching $pusharea[local.i] && self.dmteam != "spectator" && isAlive self)
				{
					self iprint local.txt //1
					wait 6.5
				}
			}
			
			wait 0.3
		}
	}

end
```

# xyz_Airborne_Mod\global\rank\kicknade.scr

```scr
/*
======================================================
*** AIRborne; Ranking System NadeKick for MoH:AA
======================================================
by Sor
Version: BETA
-----------------------------------
======================================================
*/
main:

	if(self.kick)
		end

	self.kick = 1
	local.origin = self.origin
	local.id = spawn trigger_use origin local.origin
	local.id glue self
	local.id setsize ( -50 -50 -50 ) ( 50 50 50 )
	local.id.nade = self
	local.id setthread KickNade

	while(self != NULL)
		waitframe
	if(local.id != NULL)
		local.id remove

end

KickNade:

	local.player = parm.other
	if (local.player.rankbonus["nades"] != 1 && level.running_ranking == 1)
		end

	self nottriggerable
	local.angles = angles_toforward local.player.angles
	self.nade.velocity = local.angles * 600 + ( 0 0 450 )
	local.player iprint "Good Kick!"
	if(self != NULL)
		self remove

end
	


```

# xyz_Airborne_Mod\global\rank\ranking_old.scr

```scr
/*
 =================================================
 *** Ranking System; Ranking Script for MoH:AA
 =================================================
 by Sor
 Version: v1.0 BETA
 -----------------------------------------------------
 --- INFO:

 This script controlls the entire ranking mod! No states used in
 this version. Known issues (because of no states):
 - Cannot detect players who crater to death.
 - Cannot detect scripted explosions and damage sequences

 (!) Activate only this script before waittill spawn with this:

 	thread global/ranking_old.scr::main

 -------------------
  =========================================================
*/

//------------------------------
main:
	waitthread setup_array
	waitthread cache
	//*****************************************
	//wait till all sentients have spawned
	//
	level waittill spawn 
	//
	//now activate the player handler
	//*******************

	thread player_handler

end


//-----------------------------------
setup_array:
//kills required for the highest rank is 70

	println "[Ranking Sys::Array]: Initializing Ranking-Array..."
	println "[Ranking Sys::Array]: Adding entries to Array..."

	level.rank = makeArray
		//Rankname - Allies		//Rankname - Axis			//kills needed
		"Traitor"				"Verraeter"
		"Army-Cadet"			"Cadet"				0
		"Private"				"Schuetze"				1
		"Private-First-Class"		"Oberschuetze"			4
		"Corporal"				"Gefreiter"				6
		//Promotion bonusses available now
		"Sergeant"				"Unteroffizier"			8
		"Staff-Sergeant"			"Stabsunteroffizier"		10
		"Sergeant-First-Class"		"Feldwebel"				14
		"2nd-Lieutenant"			"Leutnant"				18
		"1st-Lieutenant"			"Oberleutnant"			22
		"Captain"				"Hauptmann"				26
		"Major"				"Major"				30
		"Lieutenant-Colonel" 		"Oberstleutnant"			35
		"Colonel"				"Oberst"				40
		"Brigadier-General" 		"Brigadegeneral"			45
		"Major-General" 			"Generalmajor"			50
		"Lieutenant-General" 		"Generalleutnant"			55
		"General"				"General"				62
		"General-of-the-Army"		"Generalfeldmarschall"		70

	endArray

	println "[Ranking Sys::Array]: ...COMPLETED"

end

//-----------------------------------
player_handler:

	println "[Ranking Sys::MAIN]: Main player handler Active and Running!"
	level.message = 0

	while($player.size > 0)
	{
		for (local.a = 1; local.a <= $player.size; local.a++)
		{
			if ($player[local.a].dmteam != "spectator")
			{
				if ($player[local.a].killcount == NIL || $player[local.a].killcount == NULL) 
				{
					$player[local.a].killcount = 0
					$player[local.a] waitthread cadet
					$player[local.a] waitthread setup_kill
				}
				else if ($player[local.a].killcount != NIL || $player[local.a].killcount != NULL)
				{
				//MAIN Kill Handler
					if ($player[local.a].death_detect == NIL || $player[local.a].death_detect == NULL)
					{
						if (isAlive $player[local.a] == 1)
						{
							$player[local.a] waitthread setup_kill
						}
					}
					//TEAM SWAP FIX
					for (local.i = 1; local.i <= level.rank.size; local.i++)
					{
						if ($player[local.a].dmteam == "allies" && $player[local.a].rank == level.rank[local.i][2] && level.rank[local.i][1] != level.rank[local.i][2])
						{
							$player[local.a].rank = level.rank[local.i][1]
							$player[local.a] waitthread hud_setup
							waitframe
						}
						else if ($player[local.a].dmteam == "axis" && $player[local.a].rank == level.rank[local.i][1] && level.rank[local.i][1] != level.rank[local.i][2])
						{
							$player[local.a].rank = level.rank[local.i][2]
							$player[local.a] waitthread hud_setup
							waitframe
						}
					}
					//Activate MAIN Rank Handler
					waitframe
					$player[local.a] waitthread rank_handler
				}
			}
			else if ($player[local.a].dmteam == "spectator" && level.message != 1)
			{
				$player[local.a] thread message
			}
		}
	wait 0.5 //maybe higher
	}

	//if there are 0 players
	//boot backup handler
	println "[Ranking Sys::MAIN]: No players on server; turning Main Player Handler off, switching to backup"
	thread backup_player_handler

end

//-----------------------------------
backup_player_handler:

	println "[Ranking Sys::Backup]: Backup Handler initiated."

	while ( $player == NIL || $player.size == 0 || $player == NULL )
	{
		wait 0.8 //easing up loop
	}

	//boot the MAIN player handler back up
	println "[Ranking Sys::Backup]: Main Player Handler has rebooted!"
	thread player_handler

end 


//-----------------------------------
rank_handler:

	if (self == NULL)
		end

	waitframe

	//MAIN PROMOTION AND DEMOTION HANDLER
	for (local.i = 2; local.i <= level.rank.size && self != NULL; local.i++) 
	{
		local.nr = 0

		//Check for traitors seperatly, because if 
		//someone with -2 kills gains 1 kill(= -1), he gets 
		//promotion drums and print, that wouldn't make sense
		if (self.killcount < 0 && self.killcount != self.prevrank && self != NULL)
		{
			if (self.dmteam == "allies")
			{
				self.rank = level.rank[1][1]
			}
			else if (self.dmteam == "axis")
			{
				self.rank = level.rank[1][2]
			}
			self.prevrank = self.killcount
			self playsound demote

			self.money -= 100
			self iprint "YOU HAVE BEEN DEMOTED - DO YOU HAVE NO DISCIPLINE?" 1
			self waitthread hud_setup
		}
		// Check for a new entitled rank
		// Also prevents continuous "promoting" and checking for the same rank 
		// Because the rank handler gets activated in a loop
		if (local.i < level.rank.size && self.killcount >= level.rank[local.i][3] && self.killcount < level.rank[(local.i + 1)][3] && self.prevrank != local.i)
		{
			local.nr = 1
		}
		else if (local.i == level.rank.size && self.killcount >= level.rank[local.i][3] && self.prevrank != local.i)
		{
			local.nr = 1
		}

		if (local.nr == 1 && self != NULL && self.prevrank != local.i)
		{
			//Give new allies Rank
			if (self.dmteam == "allies" && level.rank[local.i][1] != self.rank && self != NULL)
			{
				self.rank = level.rank[local.i][1] 
				self waitthread hud_setup
				if ( local.i > self.prevrank )
				{
					self playsound promote
					//- let player know he's been promoted
					self iprint "YOU HAVE BEEN PROMOTED!!" 1
					self waitthread bonus_handler "plus"
				}
				else if ( local.i < self.prevrank )
				{
					self playsound demote
					//- let player know he's been DEmoted
					self iprint "YOU HAVE BEEN DEMOTED - DO YOU HAVE NO DISCIPLINE?" 1
					self waitthread bonus_handler "minus"
				}
				waitframe
				self.prevrank = local.i
			}
			//Give new axis Rank
			else if (self.dmteam == "axis" && level.rank[local.i][2] != self.rank && self != NULL)
			{
				self.rank = level.rank[local.i][2]
				self waitthread hud_setup
				if ( local.i > self.prevrank )
				{
					self playsound promote
					//- let player know he's been promoted
					self iprint "YOU HAVE BEEN PROMOTED!!" 1
					self waitthread bonus_handler "plus"
				}
				else if ( local.i < self.prevrank )
				{
					self playsound demote
					//- let player know he's been DEmoted
					self iprint "YOU HAVE BEEN DEMOTED - DO YOU HAVE NO DISCIPLINE?" 1
					self waitthread bonus_handler "minus"
				}
				waitframe
				self.prevrank = local.i
			}
		}
	}

end

//-----------------------------------
hud_setup:

	self stufftext "globalwidgetcommand dday1 shader townhallwindow"
	self stufftext "globalwidgetcommand dday1 fgcolor 1.00 0.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand dday1 fadein 0"
	self stufftext "globalwidgetcommand dday1 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday1 virtualres 1"
	self stufftext "globalwidgetcommand dday1 fullscreen 1"

	self stufftext "globalwidgetcommand june6 shader townhallwindow"
	self stufftext "globalwidgetcommand june6 rect 0 490 392 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 3.00 4.00 6.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 font facfont-20"
	//self stufftext ("globalwidgetcommand june6 title YourRank:_" + self.rank)
	self stufftext ("set rank_cvar Your Rank: " + self.rank)
	self stufftext "globalwidgetcommand june6 linkcvar rank_cvar"

	self stufftext "showmenu dday1"

end

//-----------------------------------
bonus_handler local.de_pro:

	//let's not make it too difficult - bunch of ifs
	//check if player hasn't left the server yet
	if ( self != NIL && self != NULL )
	{
		if (self.dmteam == "allies")
		{
			if ( self.rank == "Sergeant" )
			{
				//self exec rank/allies/bonus_sergeant.scr
			}
			else if ( self.rank == "Staff-Sergeant" )
			{
				//self exec rank/allies/bonus_staff_sergeant.scr
			}
			else if ( self.rank == "Sergeant-First-Class" )
			{
				//self exec rank/allies/bonus_sergeant_1st.scr
			}
			else if ( self.rank == "2nd-Lieutenant" )
			{
				//self exec rank/allies/bonus_lieutenant_2.scr
			}
			else if ( self.rank == "1st-Lieutenant" )
			{
				//self exec rank/allies/bonus_lieutenant_1.scr
			}
			else if ( self.rank == "Captain" )
			{
				//self exec rank/allies/bonus_captain.scr
			}
			else if ( self.rank == "Major")
			{
				//self exec rank/allies/bonus_Major.scr
			}
			else if ( self.rank == "Lieutenant-Colonel" )
			{
				//self exec rank/allies/bonus_lieutenant_col.scr
			}
			else if ( self.rank == "Colonel" )
			{
				//self exec rank/allies/bonus_colonel.scr
			}
			else if ( self.rank == "Brigadier-General" )
			{
				//self exec rank/allies/bonus_brig_general.scr
			}
			else if ( self.rank == "Major-General" )
			{
				//self exec rank/allies/bonus_major_general.scr
			}
			else if ( self.rank == "Lieutenant-General" )
			{
				//self exec rank/allies/bonus_lieut_general.scr
			}
			else if ( self.rank == "General" )
			{
				//self exec rank/allies/bonus_general.scr
			}
			else if ( self.rank == "General-of-the-Army" )
			{
				//self exec rank/allies/bonus_general_army.scr
			}
		}

		else if (self.dmteam == "axis")
		{
			if ( self.rank == "Unteroffizier")
			{
				//self exec rank/axis/bonus_unteroffizier.scr
			}
			else if ( self.rank == "Stabsunteroffizier")
			{
				//self exec rank/axis/bonus_stabsunteroffizier.scr
			}
			if ( self.rank == "Feldwebel")
			{
				//self exec rank/axis/bonus_feldwebel.scr
			}
			else if ( self.rank == "Leutnant")
			{
				//self exec rank/axis/bonus_Leutnant.scr
			}
			else if ( self.rank == "Oberleutnant")
			{
				//self exec rank/axis/bonus_Oberleutnant.scr
			}
			else if ( self.rank == "Hauptmann")
			{
				//self exec rank/axis/bonus_Hauptmann.scr
			}
			else if ( self.rank == "Major")
			{
				//self exec rank/axis/bonus_Major.scr
			}
			else if ( self.rank == "Oberstleutnant")
			{
				//self exec rank/axis/bonus_Oberstleutnant.scr
			}
			else if ( self.rank == "Oberst")
			{
				//self exec rank/axis/bonus_Oberst.scr
			}
			else if ( self.rank == "Brigadegeneral")
			{
				//self exec rank/axis/bonus_Brigadegeneral.scr
			}
			else if ( self.rank == "Generalmajor")
			{
				//self exec rank/axis/bonus_Generalmajor.scr
			}
			else if ( self.rank == "Generalleutnant")
			{
				//self exec rank/axis/bonus_Generalleutnant.scr
			}
			else if ( self.rank == "General")
			{
				//self exec rank/axis/bonus_General.scr
			}
			else if ( self.rank == "Generalfeldmarschall")
			{
				//self exec rank/axis/bonus_Generalfeldmarschall.scr
			}
		}
	}
end



//-----------------------------------
cadet:

//give the newbie his rank

	if (self == NULL)
		end

	if (self.dmteam == "allies")
	{
		self.rank = level.rank[2][1]
		self.prevrank = 2
	}
	if (self.dmteam == "axis")
	{
		self.rank = level.rank[2][2]
		self.prevrank = 2
	}


	waitframe
	self waitthread hud_setup

	wait 0.5
	self iprint "Welcome Cadet to this Ranked Server!" 1
	self iprint "Kill your way to glory or Kill yourself to shame!!!" 1
	self iprint "--------------------------------" 1
	self iprint "The amount of kills will determine your rank" 1
	self iprint "Play along, cadet!" 1

end

//-----------------------------------
//Based on giffe's death detection
setup_kill:

	if(self.death_detect != NIL && self.death_detect != NULL)
	{
		self.death_detect remove
	}

	while !(isAlive self)
	{
		wait 0.05
	}

	self.death_detect = spawn trigger_multipleall "spawnflags" "128"
	self.death_detect.origin = self.origin
	self.death_detect.angle = self.angle
	self.death_detect setthread killed
	self.death_detect glue self
	self.death_detect.player = self
	self.death_detect.team = self.dmteam
	self.death_detect.alive = 1
	self.death_detect.attacker = NIL	
	self.death_detect setsize ( -17 -17 0 ) ( 17 17 92 )

end

//-----------------------------------
killed:

	local.murderer = parm.other

	//check if player is still on the server or on the same team
	if (self.player == NIL || self.player == NULL || self.team != self.player.dmteam || self.alive == 0)
	{
		end
	}

	//MAIN KILL-HANDLER - crucial
	if ( isAlive self.player != 1 && self.alive == 1 )
	{	
		self nottriggerable
		self.alive = 0
		self.attacker = local.murderer
		waitframe
		
		//benzin barrel
		if (local.murderer == NULL) 
		{
			if (self.player.deathcount == NIL)
				self.player.deathcount = 0
			
			self.player.deathcount++
			end
		}
		//committed suicide or teamkill
		if ( local.murderer == self.player || local.murderer.dmteam == self.player.dmteam )
		{
			if ( local.murderer.killcount == NIL )
			{
				local.murderer.killcount = 0
				local.murderer.killcount--
			}
			else if ( local.murderer.killcount != NIL )
			{
				local.murderer.killcount--
			}
		}
		//no traitor
		else if ( local.murderer.dmteam != self.player.dmteam )
		{
			if ( local.murderer.killcount == NIL )
			{
				local.murderer.killcount = 0
				local.murderer.killcount++
			}
			else if ( local.murderer.killcount != NIL )
			{
				local.murderer.killcount++
			}
		}

		if (self.player.deathcount == NIL)
			self.player.deathcount = 0

		self.player.deathcount++
		self immediateremove
	}

end


//-----------------------------------
cache:
	println "[Ranking Sys::SoundCache]: Soundcaching started..."

	local.master = spawn ScriptMaster
	local.master aliascache promote sound/items/Shell_DrumApply_01.wav soundparms 5.0 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train"
	local.master aliascache demote sound/items/Shell_DrumBack_01.wav soundparms 8.0 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train"

	println "[Ranking Sys::SoundCache]: Soundcaching COMPLETED..."

end

//-----------------------------------
message:

	level.message = 1

	wait 5
	if (self.dmteam == "spectator")
	{
		self iprint "Welcome spectators!" 1
		wait 0.5
		self iprint "To this Ranked server" 1
		wait 3
		self iprint "Join the game to start getting higher ranks and more bonusses"
	}
	wait 15

	level.message = 0

end
	
```

# xyz_Airborne_Mod\global\rank\ranking.scr

```scr
/*
======================================================
*** AIRborne; Ranking System Main Script for MoH:AA
======================================================
by Sor
Version: BETA
-----------------------------------
--- NOTE:

 Customization Options are in the global/rank/ranks.txt file
 You can set this option to 1 if like to enable 
 your chosen bonuses.
 
 level.ranking["bonus"] = 1

-------------------
======================================================
*/
main:

	if (level.running_ranking == 1)
		end

	level.running_ranking = 1
	level.ranking["bonus"] = 1

	waitthread setup_array

	if (level.stop_ranking != 1)
	{
		waitthread cache

		level waittill spawn 

		if (level.ranking["bonus"] == NIL)
			level.ranking["bonus"] = 1

		thread player_handler
	}

end


//-----------------------------------
setup_array:

	println "[Ranking Sys::Array]: Adding entries to Array..."

	level.rank = waitexec global/rank/ranks.txt

	if (level.rank != NIL)
	{
		println "[Ranking Sys::Array]: ...COMPLETED"
	}
	else
	{
		level.stop_ranking = 1
		println "[Ranking Sys::Array]: A fatal error has occurred! Terminating system!"
	}

end

//-----------------------------------
player_handler:

	println "[Ranking Sys::MAIN]: Main player handler Active and Running!"
	level.message = 0

	while($player.size > 0)
	{
		for (local.a = 1; local.a <= $player.size; local.a++)
		{
			if ($player[local.a].dmteam != "spectator" && $player[local.a].status == "alive" && $player[local.a].rank != NIL)
			{
				//TEAM SWAP FIX
				for (local.i = 1; local.i <= level.rank.size; local.i++)
				{
					if ($player[local.a].dmteam == "allies" && $player[local.a].rank == level.rank[local.i][2] && level.rank[local.i][1] != level.rank[local.i][2])
					{
						$player[local.a].rank = level.rank[local.i][1]
						$player[local.a] waitthread hud_setup
						waitframe
					}
					else if ($player[local.a].dmteam == "axis" && $player[local.a].rank == level.rank[local.i][1] && level.rank[local.i][1] != level.rank[local.i][2])
					{
						$player[local.a].rank = level.rank[local.i][2]
						$player[local.a] waitthread hud_setup
						waitframe
					}
				}
				//Activate MAIN Rank Handler
				waitframe
				$player[local.a] waitthread rank_handler
			}
		}

		wait 0.4
	}

	//if there are 0 players
	//boot backup handler
	println "[Ranking Sys::MAIN]: No players on server; turning Main Player Handler off, switching to backup"
	thread backup_player_handler

end

//-----------------------------------
backup_player_handler:

	println "[Ranking Sys::Backup]: Backup Handler initiated."

	while ( $player.size == 0 || $player == NULL )
	{
		wait 1 //easing up loop
	}

	//boot the MAIN player handler back up
	println "[Ranking Sys::Backup]: Main Player Handler has rebooted!"
	thread player_handler

end 


//-----------------------------------
rank_handler:

	if (self == NULL)
		end

	waitframe

	//MAIN PROMOTION AND DEMOTION HANDLER
	for (local.i = 2; local.i <= level.rank.size && self != NULL; local.i++) 
	{
		local.nr = 0

		//Check for traitors seperatly, because if 
		//someone with -2 kills gains 1 kill(= -1), he gets 
		//promotion drums and print, that wouldn't make sense
		if (self.killcount < 0 && self.killcount != self.prevrank && self != NULL)
		{
			if (self.dmteam == "allies")
			{
				self.rank = level.rank[1][1]
			}
			else if (self.dmteam == "axis")
			{
				self.rank = level.rank[1][2]
			}
			self.prevrank = self.killcount
			self playsound demote

			self iprint "YOU HAVE BEEN DEMOTED - DO YOU HAVE NO DISCIPLINE?" 1
			self waitthread hud_setup
		}
		// Check for a new entitled rank
		// Also prevents continuous "promoting" and checking for the same rank 
		// Because the rank handler gets activated in a loop
		if (local.i < level.rank.size && self.killcount >= level.rank[local.i][3] && self.killcount < level.rank[(local.i + 1)][3] && self.prevrank != local.i)
		{
			local.nr = 1
		}
		else if (local.i == level.rank.size && self.killcount >= level.rank[local.i][3] && self.prevrank != local.i)
		{
			local.nr = 1
		}

		if (local.nr == 1 && self != NULL && self.prevrank != local.i)
		{
			//Give new allies Rank
			if (self.dmteam == "allies" && level.rank[local.i][1] != self.rank && self != NULL)
			{
				self.rank = level.rank[local.i][1] 
				self waitthread hud_setup
				if ( local.i > self.prevrank )
				{
					self playsound promote
					self thread motion_display 1

					if (level.ranking["bonus"] == 1)
					{
						self waitthread bonus_handler
					}
				}
				else if ( local.i < self.prevrank )
				{
					self playsound demote
					self thread motion_display 0

					if (level.ranking["bonus"] == 1)
					{
						self waitthread bonus_handler
					}
				}
				waitframe
				self.prevrank = local.i
			}
			//Give new axis Rank
			else if (self.dmteam == "axis" && level.rank[local.i][2] != self.rank && self != NULL)
			{
				self.rank = level.rank[local.i][2]
				self waitthread hud_setup
				if ( local.i > self.prevrank )
				{
					self playsound promote
					self thread motion_display 1

					if (level.ranking["bonus"] == 1)
					{
						self waitthread bonus_handler
					}
				}
				else if ( local.i < self.prevrank )
				{
					self playsound demote
					self thread motion_display 0

					if (level.ranking["bonus"] == 1)
					{
						self waitthread bonus_handler
					}
				}
				waitframe
				self.prevrank = local.i
			}
		}
	}

end

//-----------------------------------
hud_setup:

	self stufftext "globalwidgetcommand dday2 shader townhallwindow"
	self stufftext "globalwidgetcommand dday2 fgcolor 1.00 0.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday2 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand dday2 fadein 0"
	self stufftext "globalwidgetcommand dday2 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday2 virtualres 1"
	self stufftext "globalwidgetcommand dday2 fullscreen 1"

	self stufftext "globalwidgetcommand charliesector shader townhallwindow"
	self stufftext "globalwidgetcommand charliesector textalign left"
	self stufftext "globalwidgetcommand charliesector rect 280 525 392 64"
	self stufftext "globalwidgetcommand charliesector fgcolor 1.00 3.00 4.00 6.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext ("set rank_cvar RANK: " + self.rank)

	if (level.ranking["bonus"] == 1)
	{
		local.l = ""
		if (self.rankbonus["silencer"] == 1)
			local.l += "[Si]"
		if (self.rankbonus["nades"] == 1)
			local.l += "[KG]"
		if (self.rankbonus["zoom"] == 1)
			local.l += "[DZ]"
		if (self.rankbonus["speed"] == 1)
			local.l += "[Sp]"
		if (self.rankbonus["regenerate"] == 1)
			local.l += "[Re]"

		if (local.l != "")
			self stufftext ("set bonus_cvar BONUS: " + local.l)
		else
			self stufftext ("set bonus_cvar BONUS: none")

    		self stufftext "globalwidgetcommand credits2 name credits1"
		self stufftext "globalwidgetcommand credits1 shader townhallwindow"
		self stufftext "globalwidgetcommand credits1 fgcolor 1.00 0.00 1.00 1.00"
		self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
		self stufftext "globalwidgetcommand credits1 fadein 0"
		self stufftext "globalwidgetcommand credits1 menu dday1 640 480 NONE 0"
		self stufftext "globalwidgetcommand credits1 virtualres 1"
		self stufftext "globalwidgetcommand credits1 fullscreen 1"
   		self stufftext "globalwidgetcommand credits1 name credits2"    

		self stufftext "globalwidgetcommand credits1 shader townhallwindow"
		self stufftext "globalwidgetcommand credits1 textalign left"
		self stufftext "globalwidgetcommand credits1 rect 280 545 392 64"
		self stufftext "globalwidgetcommand credits1 fgcolor 1.00 3.00 4.00 6.00"
		self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
		self stufftext "globalwidgetcommand credits1 font facfont-20"

   		self stufftext "globalwidgetcommand credits1 linkcvar bonus_cvar"

		self stufftext "showmenu credits1"
	}

	self stufftext "globalwidgetcommand charliesector linkcvar rank_cvar"
	self stufftext "showmenu dday2"
   	
end

//-----------------------------------
bonus_handler local.de_pro:

	//let's not make it too difficult - bunch of ifs
	//check if player hasn't left the server yet
	if ( self != NIL && self != NULL )
	{
		for (local.i = 1; local.i <= level.rank.size; local.i++)
		{
			if (self.rank == level.rank[local.i][1] || self.rank == level.rank[local.i][2])
			{
				local.bonus = waitthread global/strings.scr::split_line level.rank[local.i][4] 1 " "
				for (local.o = 1; local.o <= local.bonus[1].size; local.o++)
				{
					local.t = local.bonus[1][local.o] 
					if (local.t == "zoom" || local.t == "silencer" || local.t == "nades" || local.t == "regenerate" || local.t == "speed")
					{
						local.b = int(local.bonus[1][(local.o + 1)])
						if (self.rankbonus[local.t] != 1 && local.b == 1)
						{
							self thread display_bonus local.t
						}
						self.rankbonus[local.t] = local.b
					}
				}

				end
			}
		}
	}
end



//-----------------------------------
cadet:

	//give the newbie his rank
	if (self == NULL)
		end

	self.killcount = 0
	self.deathcount = 0

	if (self.dmteam == "allies")
	{
		self.rank = level.rank[2][1]
		self.prevrank = 2
	}
	if (self.dmteam == "axis")
	{
		self.rank = level.rank[2][2]
		self.prevrank = 2
	}


	waitframe
	self waitthread hud_setup

	wait 0.5
	self iprint "Welcome Cadet to this Ranked Server!" 1
	self iprint "Kill your way to glory or Kill yourself to shame!!!" 1

end


//-----------------------------------
cache:
	println "[Ranking Sys::SoundCache]: Soundcaching started..."

	local.master = spawn ScriptMaster
	local.master aliascache promote sound/items/Shell_DrumApply_01.wav soundparms 5.0 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train"
	local.master aliascache demote sound/items/Shell_DrumBack_01.wav soundparms 8.0 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train"

	println "[Ranking Sys::SoundCache]: Soundcaching COMPLETED..."

end

_bonus_regenerate:

	local.origin = self.origin

	while (self.status == "alive" && self.rankbonus["regenerate"] == 1)
	{
		if ( (vector_within local.origin self.origin 10) == 1 && self.health < 100)
		{
			self healthonly (self.health + 1)
		}
	
		local.origin = self.origin
		
		local.time = 1.0
		while(local.time > 0)
		{
			if (self.status != "alive" || self.rankbonus["regenerate"] != 1)
			{
				end
			}
			local.time -= 0.1
			wait 0.1
		}
		wait 0.1
	}

end

_bonus_silencer:

	self give "models/weapons/silencedpistol.tik"
	self ammo pistol 16

end

_bonus_speed:

	self weaponcommand dual dmmovementspeed 1.20

end

display_bonus local.bonus:

	if (local.bonus == "nades")
	{
		local.l = "Bonus: Kick Grenades (press use)"
	}
	else if (local.bonus == "zoom")
	{
		local.l = "Bonus: Double Zoom (sniper only)"
	}
	else if (local.bonus == "silencer")
	{
		local.l = "Bonus: Silenced pistol (each spawn)"
		self thread _bonus_silencer
	}
	else if (local.bonus == "speed")
	{
		local.l = "Bonus: Increased Movement Speed"
		self thread _bonus_speed
	}
	else if (local.bonus == "regenerate")
	{
		local.l = "Bonus: Regeneration (when standing still)"
		waitframe
		self thread _bonus_regenerate
	}

    	self stufftext "globalwidgetcommand credits2 name credits1"
	self stufftext "globalwidgetcommand credits1 shader townhallwindow"
	self stufftext "globalwidgetcommand credits1 fgcolor 1.00 0.00 1.00 1.00"
	self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 fadein 0"
	self stufftext "globalwidgetcommand credits1 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand credits1 virtualres 1"
	self stufftext "globalwidgetcommand credits1 fullscreen 1"
   	self stufftext "globalwidgetcommand credits1 name credits2"    

	self stufftext "globalwidgetcommand credits1 shader townhallwindow"
	self stufftext "globalwidgetcommand credits1 rect 280 30 596 354"
	self stufftext "globalwidgetcommand credits1 fgcolor 1.00 3.00 4.00 6.00"
	self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 font handle-23"

	self stufftext ("set bonus_cvar " + local.l)
	self stufftext "globalwidgetcommand credits1 linkcvar rank_cvar

	self stufftext "showmenu credits1"

	wait 5

	self waitthread hud_setup

end

motion_display local.m:

	self stufftext "globalwidgetcommand dday2 shader townhallwindow"
	self stufftext "globalwidgetcommand dday2 fgcolor 1.00 0.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday2 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand dday2 fadein 0"
	self stufftext "globalwidgetcommand dday2 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday2 virtualres 1"
	self stufftext "globalwidgetcommand dday2 fullscreen 1"

	self stufftext "globalwidgetcommand charliesector shader townhallwindow"
	self stufftext "globalwidgetcommand charliesector rect 280 0 596 354"
	self stufftext "globalwidgetcommand charliesector fgcolor 1.00 3.00 4.00 6.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector font handle-23"

	if (local.m == 1)
		self stufftext ("set rank_cvar Promoted: " + self.rank)
	else
		self stufftext ("set rank_cvar Demoted: " + self.rank)

	self stufftext "showmenu dday2"
	
	wait 5

	self waitthread hud_setup

end
```

# xyz_Airborne_Mod\global\rank\ranks.txt

```txt
/*
======================================================
*** AIRborne; Ranking System Customization for MoH:AA
======================================================
by Sor
Version: BETA
-----------------------------------
--- NOTE:

 Customization Options for the Airborne ranking script.
 Here you can customize the following things:
  - the names for each rank (for both teams)
  - add new ranks
  - remove ranks
  - change the required kills for each rank
  - define the bonuses for each rank. Available bonuses:
    
	* "silencer"	- Get Silencer
	* "nades"	- Ability to kick nades
	* "zoom"	- Double Zoom for Snipers
        * "speed"	- Increased movement speed
	* "regenerate"	- You gain health slowly while standing still

  A few IMPORTANT REMARKS:
   1. Do not remove the Traitor rank! You may rename it.
   2. Do not enter a kill requirement for the Traitor rank!
   3. For every rank, if you are going to use bonuses, then all
      the bonuses must be defined (!) in the following layout:

      "bonus1 value ; bonus2 value ; bonus3 value ; bonus4 value"


-------------------
======================================================
*/

main:

	local.ranks = makeArray

	//Rankname - Allies		//Rankname - Axis		//kills needed		//Bonuses

	"Traitor"			"Verraeter"						"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0"    
	"Army Cadet"			"Cadet"				0			"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0"  
	"Private"			"Schuetze"			1			"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0"   
	"Private-First-Class"		"Oberschuetze"			2			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0"   
	"Corporal"			"Gefreiter"			4			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0"   
	"Sergeant"			"Unteroffizier"			6			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0"  
	"Staff Sergeant"		"Stabsunteroffizier"		8			"speed 0 ; zoom 0 ; nades 1 ; silencer 1 ; regenerate 0"
	"Sergeant-First-Class"		"Feldwebel"			10			"speed 0 ; zoom 0 ; nades 1 ; silencer 1 ; regenerate 0"
	"2nd Lieutenant"		"Leutnant"			14			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"1st Lieutenant"		"Oberleutnant"			18			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"Captain"			"Hauptmann"			21			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"Major"				"Major"				25			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"Lieutenant Colonel" 		"Oberstleutnant"		30			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"Colonel"			"Oberst"			35			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"Brigadier General" 		"Brigadegeneral"		40			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"Major General" 		"Generalmajor"			45			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"Lieutenant General" 		"Generalleutnant"		50			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"General"			"General"			60			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"General-of-the-Army"		"Generalfeldmarschall"		70			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"

	endArray

end local.ranks

```

# xyz_Airborne_Mod\global\snowman.scr

```scr
//=================================================================================
// Frosty the Snowman!
// by Sor
// ---------------------
// Spawn a kind snowman in your map but if someone tests his patience he
// will fight back! You can make him drop gifts (healthpacks), make him smoke
// cigarettes and even make him talk!!
//
// USE: 
// ----
// thread global/snowman.scr::frostman <origin> <angles> <team> <life> <scale> <model>
//
// - Origin: ( X Y Z ) Location in the map
// - Angles: ( X Y Z ) Direction he's facing
// - Team: ( String ) Choose "axis" or "allies" this is ONLY for the speech
// - life: ( Integer ) How many times can Frosty get shot before he dies?
//	     Use 9999 or something to make him invincible.
// - Scale: ( Float ) Scale of the model?
// - Model: The model of frosty; default: "player/german_Winter_1.tik" 
//
// OPTIONS:
// --------
// level.frosty_gift = does frosty need to drop gifts (healthpacks)?
// level.frosty_talk = may frosty say things?
// level.frosty_smoke = can frosty smoke?
//
//=================================================================================
frostman local.origin local.angles local.team local.max_hits local.scale local.model:

	if (level.frosty == 1)
	{
		println "[FROSTY::Spawn]: There can be only one frosty in a map!"
		end
	}

	if(local.origin == NIL)
		end

	if (local.angles == NIL)
		local.angles = ( 0 0 0 )

	if (local.team == NIL)
		local.team = "axis"

	if (local.max_hits == NIL)
		local.max_hits = 90

	if (local.scale == NIL || local.scale == 0)
		local.scale = 1
	
	if (local.model == NIL || local.model == "")
		local.model = "player/german_Winter_1.tik"

	local.frostman = spawn script_model
	local.frostman model local.model
	local.frostman.origin = local.origin
	local.frostman.angles = local.angles
	local.frostman solid
	local.frostman scale local.scale
	local.frostman.underfire = 0
	local.frostman.team = local.team
	local.frostman.lives = local.max_hits
	
	local.scale_app = ( 1.0 / local.scale )
	local.minus = ( -20 / local.scale_app )
	local.plus = ( 20 / local.scale_app )
	local.height = ( 92 / local.scale_app )
	
	local.num = local.frostman.entnum
	
	local.kill_frosty = spawn trigger_multiple "spawnflags" "144"
	local.kill_frosty.origin = local.origin
	local.kill_frosty setsize ( local.minus local.minus local.minus ) ( local.plus local.plus local.height )
	local.kill_frosty.frostman = local.frostman
	local.kill_frosty setthread frostys_revenge
	level.frosty = 1

	wait 10

	local.cig = 0
	local.gift = 0
	local.wait = 0
	local.say = 0

	while(local.frostman != NIL && local.frostman != NULL)
	{
		if (local.frostman.underfire != 1)
		{
		
			if (local.say == 20)
			{	
				local.frostman waitthread say_something
				local.say = 0
			}

			if (local.cig == 10 || local.cig == 60 || local.cig == 110 || local.cig == 160 || local.cig == 200)
			{
				local.frostman attachmodel "items/cigarette.tik" "Bip01 head" 1 ("cig" + local.num) 0 -1 -1 -1 -1 ( 3.6 7.5 2.0 ) spawnflags 1
				$("cig" + local.num).angles = ( 100 180 0 )
			}
			else if (local.cig == 20 || local.cig == 70 || local.cig == 120 || local.cig == 170 || local.cig == 220)
			{
				$("cig" + local.num) remove
			}
			if (local.gift == 10 || local.gift == 80 || local.gift == 160 || local.gift == 240)
			{
				local.far = randomint((100)+1)
				local.far1 = randomint((100)+1)
				local.minus = randomint((4)+1)
				if (local.minus == 1)
					local.far1 = -local.far1
				else if (local.minus == 2)
					local.far = -local.far

				local.healthbox = spawn health model "items/dm_50_healthbox.tik"
				local.healthbox.origin = local.frostman.origin + ( local.far local.far1 50)
				local.healthbox dmamount 50
				local.healthbox droptofloor
			}
		}
		wait 10
		if (local.wait == 280)
		{
			local.wait = 0
			local.cig = 0
			local.gift = 0
		}

		local.wait += 10

		if (level.frosty_talk == 1)
			local.say += 10

		if (level.frosty_gift == 1)
			local.cig += 10

		if (level.frosty_smoke == 1)
			local.gift += 10

		if (level.frosty_smoke != 1 && level.frosty_gift != 1 && level.frosty_talk != 1)
			end
	}

end

//==========================================================
// Frosty's Revenge
// ----------------
// Frosty is kind-hearted snowman and is forgiveful!
// But if someone tests his patience and shoots
// Frosty one time too much; then he gets violent!
//
// This is the setthread of the Bullet-Trigger
// 
//==========================================================
frostys_revenge:

	self nottriggerable
		
	local.player = parm.other
	local.weaponcheck = local.player waitthread getweapon
	if (local.weaponcheck == 0)
		end

	self.frostman.underfire = 1
	self.frostman.lives--
	if (self.frostman.lives == 0)
	{
		self.frostman waitthread say_something_death
		self waitthread blow_frosty local.player
		end
	}

	self.frostman thread say_something_pain

	if (local.player.leave_frosty_alone == NIL)
		local.player.leave_frosty_alone = 0

	local.player.leave_frosty_alone++

	if (local.player.leave_frosty_alone < 5)
	{
		if (local.player.leave_frosty_alone == 1)
		{
			wait 0.5
			local.player iprint "Leave frosty alone! What did he ever do to you?" 1
		}
		else if (local.player.leave_frosty_alone == 2)
		{
			wait 0.5
			local.player iprint "Stop poking frosty!!" 1
		}
		else if (local.player.leave_frosty_alone == 3)
		{
			wait 0.5
			local.player iprint "Frosty is getting angry!!" 1
		}
		else if (local.player.leave_frosty_alone == 4)	
		{	
			wait 0.5
			local.player iprint "Frosty is warning you to stop!!" 1
		}

		local.player.triggerfix = NIL
		self.frostman.underfire = 0
		wait 0.1
		self triggerable
		end
	}
	if (local.player.leave_frosty_alone >= 5)
	{
		local.player.leave_frosty_alone++

		// Choose a weapon in frostys arsenal
		local.frosty_weapon = waitthread frostys_weapons

		local.picky = (randomint(local.frosty_weapon.size) + 1)
		if (local.picky == 0)
		{
			local.picky++
		}

		local.chosen = local.frosty_weapon[local.picky][1]
		self waitthread local.chosen local.player

		local.player.leave_frosty_alone = NIL		
	}

	local.player.triggerfix = NIL
	self.frostman.underfire = 0
	wait 0.1
	self triggerable

end

//================================================
// Weapon Check
// ------------
// For some reason when rifles shoot Frosty's
// trigger, it gets activated twice and when a 
// shotgun shoots it, it gets activated 10-20 times
//
// So this stops the rifles and the shotgun 
// from triggering more than once!!
//
//================================================
getweapon:

	local.invalid = 0
	local.valid = 1

	self weaponcommand dual targetname ("weapon" + self.entnum)
	local.weapon = $("weapon" + self.entnum )

	if(local.weapon != NULL)
	{
		local.weapon_model = local.weapon.model
		local.weapon targetname ""
	}
	else
	{
		local.weapon_model = "models/weapons/unarmed.tik"
	}

	if ( (local.weapon_model == "models/weapons/springfield.tik") || (local.weapon_model == "models/weapons/m1_garand.tik") || \
		(local.weapon_model == "models/weapons/kar98sniper.tik") || (local.weapon_model == "models/weapons/kar98.tik"))
	{
		if (self.triggerfix == NIL)
		{
			self.triggerfix = 1
			end local.invalid
		}
		self.triggerfix++
		if (self.triggerfix == 2)
		{
			self.triggerfix = NIL
			end local.valid 
		}
	}

	else if (local.weapon_model == "models/weapons/shotgun.tik")
	{
		if (self.triggerfix == NIL)
		{
			self.triggerfix = 1
			end local.invalid
		}

		if (self.triggerfix == 11)
		{
			self.triggerfix = NIL
			end local.valid 
		}
		else if ( self.triggerfix != 11)
		{
			self.triggerfix++
			end local.invalid
		}
	}

end local.valid 

// **************************************************************************	//
//													//
// 					Frosty's Weapons!!					//
//					------------------					//
//		  	Don't mess with the cold hearted snowman!!			//
//													//
// **************************************************************************	//

//================================================
// Weapon Array
// ------------
// This returns all the weapons frosty 
// can use and 1 gets picked!
//
//================================================
frostys_weapons:

	local.frostys_weapons = makeArray

	"freezeray"
	"deathray"
	"heatray"

	endArray

end local.frostys_weapons

//================================================
// Frosty's FreezeRay
// ------------------
// Frosty is well equipped and this weapon
// is by far his favourite!
//
//================================================
freezeray local.player:

	local.origin = self.frostman gettagposition "eyes bone"
	local.endpoint = local.player gettagposition "bip01 head"
	
	local.beam = spawn funcbeam
	local.beam.origin = local.origin 
	local.beam endpoint local.endpoint
	local.beam color ( 0.0 0.1 1.0 )
	local.beam numsegments 2
	local.beam activate 
	local.beam scale 2
	
	local.team = local.player.dmteam
	local.player light 0.0 0.1 1.0 10
	local.player rendereffects "+viewlensflare"

	local.player iprint "Frosty freezed you! You should'n't have upset him!" 1
	local.player iprint "Frostbite is slowly killing you!!"
	local.player.freezed = 1

	// Side threads
	local.player thread freezehim	
	local.beam thread update local.player
	self.frostman thread lookingmad local.player 

	self.frostman loopsound m2l2b_radio1 10
	local.player loopsound m2l2b_radio1 3
	waitframe 
	local.dist = vector_length (self.frostman.origin - local.player.origin)
	local.dist = (local.dist + 200)

	while (local.player != NIL && local.player != NULL && isAlive local.player && local.player.dmteam == local.team && local.f == NIL)
	{
		if ( (vector_within self.frostman local.player local.dist) == 1)
		{
			local.player hurt 10
			wait 1
		}
		else 
		{
			local.f = 1
		}
		wait 1
	}
	
	self.frostman stoploopsound
	local.player stoploopsound
	local.player.freezed = NIL
	local.beam remove
	
	if (local.player != NIL && local.player != NULL)
	{
		local.player light 1.0 1.0 1.0 0
		local.player rendereffects "-viewlensflare"
		waitframe
	}

	self.frostman thread say_something_victory

end

//================================================
// Frosty's HeatRay
// ----------------
// Frosty hates heat and fire; he figures
// a human does too so he created this 
// devastating weapon!
//
//================================================
heatray local.player:

	local.origin = self.frostman gettagposition "eyes bone"
	local.endpoint = local.player gettagposition "bip01 head"
	
	local.beam = spawn funcbeam
	local.beam.origin = local.origin 
	local.beam endpoint local.endpoint
	local.beam color ( 1.0 0.3 0.0 )
	local.beam numsegments 8
	local.beam activate 
	local.beam scale 2
	
	local.team = local.player.dmteam
	local.player light 0.9 0.6 0.0 10
	local.player rendereffects "+viewlensflare"
	local.player.freezed = 1
	local.player loopsound fire_large 10
	local.player iprint "Frosty's HeatRay will burning you!!" 1
	local.player iprint "Frosty doesn't like fire and neither will you!"

	local.dist = vector_length (self.frostman.origin - local.player.origin)
	local.dist = (local.dist + 200)
	
	local.obj = spawn script_origin
	local.obj.origin = local.player.origin
	local.obj glue local.player

	local.effect1 = spawn "emitters/inferno.tik"
	local.effect1.origin = local.obj.origin
	local.effect1 notsolid
	local.effect1 anim start
	local.effect1 scale 2

	local.effect2 = spawn "emitters/fireandsmoke.tik"
	local.effect2.origin = local.obj.origin
	local.effect2 notsolid
	local.effect2 anim start

	local.effect1 bind local.obj
	local.effect2 bind local.obj

	local.beam thread update local.player
	self.frostman thread lookingmad local.player 
	
	local.dist = vector_length (self.frostman.origin - local.player.origin)
	local.dist = (local.dist + 300)

	while (local.player != NIL && local.player != NULL && isAlive local.player && local.player.dmteam == local.team && local.f == NIL)
	{
		if ( (vector_within self.frostman local.player local.dist) == 1)
		{
			local.player hurt 10
			wait 1
		}
		else 
		{
			local.f = 1
		}
		wait 1
	}
	local.beam remove
	local.player.freezed = NIL
	local.effect2 anim stop
	local.effect2 remove

	local.player stoploopsound
	
	if (isAlive local.player && local.player.dmteam == local.team && local.f == 1)
	{
		local.player loopsound fire_large 4

		for (local.i = 1; local.i <= 4; local.i++)
		{
			if (isAlive local.player && local.player.dmteam == local.team && local.player != NIL && local.player != NULL)
			{
				local.player hurt 5
				wait 1
			}
		}
	}
	else if (local.player == NIL || local.player == NULL)
	{
		local.player stoploopsound
		local.effect1 anim stop
		local.effect1 remove
		local.obj remove
		end
	}	
	else 
	{
		local.player light 0.0 0.0 0.0 0
		local.player rendereffects "+viewlensflare"
	}

	local.player light 0.0 0.0 0.0 0
	local.player rendereffects "-viewlensflare"
	local.player stoploopsound
	local.effect1 anim stop
	local.effect1 remove
	local.obj remove

end

//================================================
// Frosty's DeathRay
// -----------------
// When Frosty is really pissed he uses this
// weapon! It makes sure the attacker gets killed!
// You'd better watchout for Frosty ;)
//
//================================================
deathray local.player:

	local.team = local.player.dmteam
	local.angles = self.angles

	local.origin = self.frostman gettagposition "eyes bone"
	local.endpoint = local.player gettagposition "bip01 head"
	
	local.beam = spawn funcbeam
	local.beam.origin = local.origin 
	local.beam endpoint local.endpoint
	local.beam color ( 0.1 0.1 0.1 )
	local.beam numsegments 6
	local.beam activate 
	local.beam scale 4

	local.beam1 = spawn funcbeam
	local.beam1.origin = local.origin 
	local.beam1 endpoint local.endpoint
	local.beam1 color ( 0.9 0.0 0.7 )
	local.beam1 numsegments 2
	local.beam1 activate 
	local.beam1 scale 1
	
	local.player.freezed = 1
	local.beam thread update local.player
	local.beam1 thread update local.player
	self.frostman thread lookingmad local.player

	local.next = 0
	local.player iprint "Frosty's deathray will kill you!!" 1
	local.player iprint "The deathray's electrical and nuclear power are blowing your head!!"
	local.spin = 0

	local.obj = spawn script_origin
	local.obj.origin = local.player.origin

	local.effect1 = spawn script_model model "models/emitters/electrical_fire.tik"
	local.effect1.origin = local.obj.origin + ( 0 0 78 )
	local.effect1 notsolid

	local.effect2 = spawn script_model model "models/emitters/linger_smoke.tik"
	local.effect2.origin = local.obj.origin + ( 0 0 78 )
	local.effect2 notsolid
	  
	local.effect3 = spawn script_model model "models/emitters/electric_arc.tik"
	local.effect3.origin = local.obj.origin + ( 0 0 78 )
	local.effect3 notsolid

	local.effect1 bind local.obj
	local.effect2 bind local.obj
	local.effect3 bind local.obj
	local.obj glue local.player
	
	local.player loopsound m2l1_radio1 20
	self.frostman loopsound m2l1_radio1 38

	while (isAlive local.player && local.player.dmteam == local.team && local.player != NIL && local.player != NULL && local.next == 0)
	{
		if (local.spin == 60)
		{
			local.next = 1
		}
		local.player.viewangles =  ( local.player.viewangles[0] local.player.viewangles[1] (local.player.viewangles[2] + 30) )
		local.spin++
		waitframe
	}
	local.player stoploopsound
	self.frostman stoploopsound
	local.player.freezed = NIL

	local.effect1 delete
	local.effect2 delete
	local.effect3 delete
	local.obj delete
	local.beam delete
	local.beam1 delete

	waitframe
	local.or = spawn script_origin
	local.or.origin = local.player.origin
	local.exp = spawn script_model model "animate/fx_mortar_dirt.tik"
	local.exp.origin = local.or.origin
	local.exp anim start
	local.player kill
	wait 2
	local.or delete
	local.exp delete
	self.frostman thread say_something_victory
	
end

//================================================
// Freeze Script
// -------------
// This script freezes the player so
// that he can barely move.
//
//================================================
freezehim:

	local.team = self.dmteam

	while(self.freezed == 1 && self != NIL && self != NULL & isAlive self && self.dmteam == local.team)
	{
		self.velocity = ( 0 0 0 )
		waitframe
	}

end

//================================================
// Update Ray
// ----------
// This script updates the endpoint of the 
// funcbeam (or Ray)
//
//================================================
update local.player:

	local.team = local.player.dmteam

	while(local.player.freezed == 1 && local.player != NIL && local.player != NULL && isAlive local.player && local.player.dmteam == local.team)
	{
		if (self == NULL|| self == NIL)
			end

		local.endpoint = local.player gettagposition "bip01 head"
		self endpoint local.endpoint
		waitframe
	}
end

//================================================
// Frosty's Mad Look
// -----------------
// This script makes sure Frosty keeps looking
// at the player he's attacking.
//
//================================================
lookingmad local.player:

	local.angles = self.angles
	local.team = local.player.dmteam

	while(local.player.freezed == 1 && local.player != NIL && local.player != NULL && isAlive local.player && local.player.dmteam == local.team)
	{
		local.calc_angles = angles_pointat self self local.player

		self.angle = ( self.angle + (local.calc_angles[1] - 180 ))

		wait 0.1
	}

	self.angles = local.angles
end


// **************************************************************************	//
//													//
// 					   Say Manager						//
//					------------------					//
//		  	These scripts take care of Frosty's speech			//
//													//
// **************************************************************************	//

//================================================
// Normal Speech
// -------------
// This takes care of the normal speech of 
// Frosty depending on his team (axis/allies).
//
//================================================
say_something:

	if (level.frosty_talk != 1)
		end

	local.random = randomint((12)+1)

	switch (local.random)
	{
		case 1:
			if (self.team == "axis")
				self playsound axis_axis5_be // "You take the lead." 
			else
				self playsound allied_pilot_be

		break
		case 2:
			if (self.team == "axis")
				self playsound axis_axis5_ed // "That guy is going to get us all killed!"
			else
				self playsound allied_pilot_ed

		break
		case 3:
			if (self.team == "axis")
				self playsound axis_axis5_bi // "Open fire!"
			else
				self playsound allied_pilot_bi

		break
		case 4:
			if (self.team == "axis")
				self playsound axis_axis5_cc // "Enemy Spotted."
			else
				self playsound allied_pilot_cc

		break
		case 5:
			if (self.team == "axis")
				self playsound axis_axis5_ca  // "Yes sir!"
			else
				self playsound allied_pilot_ca

		break
		case 6:
			if (self.team == "axis")
				self playsound axis_axis5_cb  // "No sir!" 
			else
				self playsound allied_pilot_cb

		break
		case 7:
			if (self.team == "axis")
				self playsound axis_axis5_cg // "Great Shot!"
			else
				self playsound allied_pilot_cg

		break
		case 8:
			if (self.team == "axis")
				self playsound axis_axis5_ch // "Thanks."
			else
				self playsound allied_pilot_ch

		break
		case 9:
			if (self.team == "axis")
				self playsound axis_axis5_ci // "I owe you one."
			else
				self playsound allied_pilot_ci

		break
		case 10:
			if (self.team == "axis")
				self playsound axis_axis5_ee // "Hey buddy, get down!"
			else
				self playsound allied_pilot_ee

		break
		case 11:
			if (self.team == "axis")
				self playsound axis_axis5_ef // "Stay out of my foxhole, pal!"
			else
				self playsound allied_pilot_ef

		break
		case 12:
			if (self.team == "axis")
				self playsound axis_axis5_eg // "Find your own hiding place!"
			else
				self playsound allied_pilot_eg

		break
	}

	wait 1.8

end

//================================================
// Victory Speech
// --------------
// This takes care of the Victory speech of 
// Frosty depending on his team (axis/allies).
//
// When Frosty has killed or attacked an enemy
// he'll say one of these sounds.
//
//================================================
say_something_victory:

	if (level.frosty_talk != 1)
		end

	local.random = randomint((6)+1)

	switch (local.random)
	{
		case 1:
			if (self.team == "axis")
				self playsound axis_axis5_da // "Is that all you've got?"
			else
				self playsound allied_pilot_da

		break
		case 2:
			if (self.team == "axis")
				self playsound axis_axis5_ec // "Good riddance!"
			else
				self playsound allied_pilot_ec

		break
		case 3:
			if (self.team == "axis")
				self playsound axis_axis5_dd // "Try again!"
			else
				self playsound allied_pilot_dd

		break
		case 4:
			if (self.team == "axis")
				self playsound axis_axis5_di // "That made a mess."
			else
				self playsound allied_pilot_di

		break
		case 5:
			if (self.team == "axis")
				self playsound axis_axis5_df // "Come prepared next time!"
			else
				self playsound allied_pilot_df

		break
		case 6:
			if (self.team == "axis")
				self playsound axis_axis5_dh // "I've seen French school girls shoot better!"
			else
				self playsound allied_pilot_dh

		break
	}

	wait 1.8

end

//================================================
// Pain Sounds
// -----------
// This takes care of the pain sounds for 
// Frosty depending on his team (axis/allies).
//
// Without specifying a number for the alias,
// the game chooses 1 of the 98(per team) pain sounds!
//
// This only works when multiple soundaliases have the
// same name and a integer at the end.
//
//================================================
say_something_pain:

	if (level.frosty_talk != 1)
		end

	//play snow sound
	self playsound snd_landing_snow1 CHAN_BODY 80.0

	//plays one random pain sound
	if (self.team == "axis")
	{
		self playsound snd_den_pain_generic
	}
	else
	{
		self playsound snd_dfr_pain_generic
	}

	wait 1

end

//================================================
// Death Sounds
// ------------
// This takes care of the death sounds for 
// Frosty depending on his team (axis/allies).
//
// Without specifying a number for the alias,
// the game chooses 1 of the 98(per team) pain sounds!
//
// This only works when multiple soundaliases have the
// same name and a integer at the end.
//
//================================================
say_something_death:

	if (level.frosty_talk != 1)
		end

	//plays one random pain sound
	if (self.team == "axis")
	{
		self playsound snd_den_death_generic
	}
	else
	{
		self playsound snd_dfr_death_generic
	}

	wait 1

end

//================================================
// Death of Frosty
// ---------------
// This script takes care of the death sequence
// of Frosty...poor Frosty :(
//
//================================================
blow_frosty local.player:

	local.loc = spawn script_origin
	local.loc.origin = self.origin
	local.loc droptofloor
	local.loc notsolid

	local.exp = spawn script_model model "animate/fx_mortar_dirt.tik"
	local.exp.origin = local.loc.origin
	local.exp notsolid

	local.exp anim start
	radiusdamage local.loc 200 250
	self.frostman delete
	self delete

	wait 2

	local.loc delete
	local.exp delete

	iprintln "Frosty died!! :O"
	local.player iprint "Oh my god, you killed Frosty!! Are you happy now?"
	local.player iprint "Poor, poor Frosty :("

end

```

# xyz_Airborne_Mod\global\SPFIX_\soundfix.scr

```scr
/*
======================================================
*** AIRborne; Serverside SP sounds Fix for MoH:AA
======================================================
by Sor
Version: v1.10
-----------------------------------
======================================================
*/

//===================================
main local.weapon local.soundtype local.rtype:
	
	if (level.SPFIX_init == 0 || level.SPFIX_init == NIL)
		end

	if (self == NULL)
		end

	// Check if the sound needs to be played
	if ( level.SPFIX_[local.weapon] != NIL)
	{
		for (local.i = 1; local.i <= level.SPFIX_[local.weapon].size; local.i++)
		{
			if (level.SPFIX_[local.weapon][local.i] == local.soundtype)
			{
				if (local.rtype == NIL)
					thread ("_" + local.weapon) local.soundtype
				else
					thread ("_" + local.weapon) local.soundtype local.rtype

				end
			}
		}
	}

end

//===================================
init:

	if (level.SPFIX_init == 1 || level.SPFIX_init == 0)
		end

	if (level.AIR_mapscript == NIL)
		local.map = waitthread global/strings.scr::to_lower (getcvar "mapname")
	else
		local.map = level.AIR_mapscript

	// Set the required soundparameters according to the current SP map.
	switch(local.map)
	{
		case "m1l1":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["spring"] = "fire"::"rechamber"::"reload"
			level.SPFIX_["zooka"] = "fire"::"reload"
			level.SPFIX_["silence"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m1l2a":
		case "m1l2b":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["spring"] = "fire"::"rechamber"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_init = 1
		break
		case "m1l3a":
		case "m1l3b":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["spring"] = "fire"::"rechamber"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"putaway"
			level.SPFIX_["colt"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m1l3c":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["spring"] = "fire"::"rechamber"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"putaway"
			level.SPFIX_init = 1
		break
		case "m2l1":
		case "m2l2a":
		case "m2l2b":
		case "m2l2c":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["m1"] = "fire"::"ping"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["colt"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m2l3":
			level.SPFIX_["bar"] = "raise"::"putaway"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["m1"] = "fire"::"ping"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_init = 1
		break
		case "m3l1a":
		case "m3l1b":
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["m1"] = "ping"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["silence"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m3l2":
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["silence"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m3l3":
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "putaway"
			level.SPFIX_["silence"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m4l0":
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["spring"] = "fire"::"rechamber"::"reload"
			level.SPFIX_["colt"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m4l1":
			level.SPFIX_["silence"] = "fire"::"reload"
		case "m4l2":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["spring"] = "fire"::"rechamber"::"reload"
			level.SPFIX_init = 1
		break
		case "m4l3":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["colt"] = "fire"::"reload"
			level.SPFIX_["m1"] = "fire"::"ping"::"reload"
			level.SPFIX_init = 1
		break
		case "m5l1a":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["panzer"] = "fire"::"reload"
			level.SPFIX_["silence"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m5l1b":
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["panzer"] = "fire"::"reload"
			level.SPFIX_["silence"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m5l2a":
		case "m5l2b":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["m1"] = "fire"::"ping"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["silence"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m5l3":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["m1"] = "fire"::"ping"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["panzer"] = "fire"::"reload"
			level.SPFIX_["silence"] = "fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m6l1a":
		case "m6l1b":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["mp44"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["colt"] = "fire"::"reload"
			level.SPFIX_["m1"] = "fire"::"ping"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m6l1c":
		case "m6l2a":
		case "m6l2b":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["colt"] = "fire"::"reload"
			level.SPFIX_["m1"] = "fire"::"ping"::"reload"
			level.SPFIX_["shotty"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_init = 1
		break
		case "m6l3a":
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_init = 1
		break
		case "m6l3b":
			level.SPFIX_["silence"] = "fire"::"reload"
		case "m6l3c":
		case "m6l3d":
		case "m6l3e":
			level.SPFIX_["m1"] = "fire"::"ping"::"reload"
			level.SPFIX_["bar"] = "raise"::"putaway"::"fire"::"reload"
			level.SPFIX_["zooka"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_["panzer"] = "raise"::"fire"::"reload"::"putaway"
			level.SPFIX_init = 1
		break
		default: 
			//The current map isn't an SP map
			level.SPFIX_init = 0
		break		
	}

	if (level.SPFIX_init == 1 && level.SPFIX_sounds_loaded != 1)
		waitexec global/SPFIX_/wpn_soundcache.scr

end

//***************************
_bar local.s:

	switch (local.s)
	{
		case "raise":
			self playsound bar_snd_pullout
		break
		case "putaway":
			self playsound bar_snd_putaway
		break
		case "fire":
			self playsound bar_snd_fire
		break
		case "reload":
			self playsound bar_snd_reload
		break
	}

end

//***************************
_mp44 local.s:

	switch (local.s)
	{
		case "raise":
			self playsound mp44_snd_pullout
		break
		case "putaway":
			self playsound mp44_snd_putaway
		break
		case "fire":
			self playsound mp44_snd_fire1
		break
		case "reload":
			self playsound mp44_snd_reload
		break
	}

end

//***************************
_zooka local.s:

	switch (local.s)
	{
		case "raise":
			self playsound snd_bazooka_pullout
		break
		case "putaway":
			self playsound snd_bazooka_putaway
		break
		case "fire":
			self playsound bazooka_snd_fire
		break
		case "reload":
			self playsound bazooka_snd_reload
		break
	}

end

//***************************
_panzer local.s:

	switch (local.s)
	{
		case "raise":
			self playsound snd_bazooka_pullout
		break
		case "putaway":
			self playsound snd_bazooka_putaway
		break
		case "fire":
			self playsound panzerschreck_snd_fire
		break
		case "reload":
			self playsound panzerschreck_snd_reload
		break
	}

end


//***************************
_shotty local.s local.r:

	switch (local.s)
	{
		case "fire":
			self playsound shotgun_snd_fire
			waitframe
			self playsound shotgun_snd_rechamber
		break
		case "reload":
			if (local.r == "start")
				self playsound shotgun_snd_reload_start
			else if (local.r == "single")
				self playsound shotgun_snd_reload_single
			else if (local.r == "end")
				self playsound shotgun_snd_reload_end

		break
		case "raise":
			self playsound snd_shotgun_pullout
		break
		case "putaway":
			self playsound snd_shotgun_putaway
		break
	}

end

//***************************
_colt local.s:

	switch (local.s)
	{
		case "fire":
			self playsound colt45_snd_fire
		break
		case "reload":
			self playsound colt45_snd_reload
		break
	}

end


//***************************
_m1 local.s:

	switch (local.s)
	{
		case "fire":
			self playsound m1_snd_fire
		break
		case "reload":
			self playsound m1_snd_reload
			waitframe
			self playsound snd_ping
		break
	}

end


//***************************
_spring local.s local.r:

	switch (local.s)
	{
		case "rechamber":
			self playsound springfield_snd_bolt item
		break
		case "fire":
			self playsound springfield_snd_fire
		break
		case "reload":
			if (local.r == "start")
				self playsound springfield_snd_reload_start
			else if (local.r == "single")
				self playsound springfield_snd_reload_single
			else if (local.r == "end")
				self playsound springfield_snd_reload_end

		break
	}

end

//***************************
_silence local.s:

	switch (local.s)
	{
		case "fire":
			self playsound silencer_snd_fire
		break
		case "reload":
			self playsound silencer_snd_reload
		break
	}

end
```

# xyz_Airborne_Mod\global\SPFIX_\wpn_soundcache.scr

```scr
/*
======================================================
*** AIRborne; SP Weaponsounds Cache for MoH:AA
======================================================
by Sor
Version: v1.10
-----------------------------------
======================================================
*/
main:

	local.master = spawn scriptmaster
	
	if (level.SPFIX_["bar"])
	{
		println "bar"
		local.master aliascache bar_snd_pickup sound/weapons/foley/MP44Pickup1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache bar_snd_pickup_ammo sound/weapons/foley/AmmoPUMG1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache bar_snd_noammo sound/weapons/foley/DryFireMachineGun1.wav soundparms 1.2 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache bar_snd_fire sound/weapons/fire/BARFire2.wav soundparms 1.4 0.1 0.8 0.1 400 8000 weapon loaded maps "m"
		local.master aliascache bar_snd_reload sound/weapons/foley/BARReload1.wav soundparms 0.9 0.2 1.0 0.0 160 1000 auto loaded maps "m"
		local.master aliascache bar_reload_npc sound/weapons/foley/BARReloadNPC1.wav soundparms 1.0 0.0 1.0 0.0 160 1000 item loaded maps "m"
		local.master aliascache bar_snd_pullout1 sound/weapons/foley/HeavyWpnForward1.wav soundparms 0.9 0.2 0.9 0.2 160 1000 item loaded maps "m"
		local.master aliascache bar_snd_putaway1 sound/characters/body_mvmt_04.wav soundparms 0.7 0.2 0.9 0.2 160 1000 item loaded maps "m"
		local.master aliascache bar_snd_putaway2 sound/characters/body_mvmtgear_04.wav soundparms 0.7 0.2 0.9 0.2 160 1000 item loaded maps "m"
	}
	if (level.SPFIX_["spring"])
	{
		println "spring"
		local.master aliascache springfield_snd_fire1 sound/weapons/fire/SpringfieldFire1.WAV soundparms 1.3 0.2 0.95 0.1 400 8000 weapon loaded maps "m"
		local.master aliascache springfield_snd_fire2 sound/weapons/fire/SpringfieldFire2.WAV soundparms 1.3 0.2 0.95 0.1 400 8000 weapon loaded maps "m"
		local.master aliascache springfield_snd_pickup sound/weapons/foley/SpringfieldPickup1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache springfield_snd_pickup_ammo sound/weapons/foley/AmmoPURifle1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache springfield_snd_noammo sound/weapons/foley/DryFireRifle1.wav soundparms 1.2 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache springfield_snd_bolt sound/weapons/foley/Spring_Bolt.wav soundparms 0.9 0.01 0.95 0.1 160 1000 item loaded maps "m"
		local.master aliascache springfield_snd_reload_start sound/weapons/foley/SpringfieldReloadStart1.wav soundparms 1.3 0.2 1.0 0.0 160 1000 item loaded maps "m"
		local.master aliascache springfield_snd_reload_single1 sound/weapons/foley/SpringfieldReloadFill1.wav soundparms 1.3 0.2 0.92 0.15 160 1000 auto loaded maps "m"
		local.master aliascache springfield_snd_reload_single2 sound/weapons/foley/SpringfieldReloadFill2.wav soundparms 1.3 0.2 0.92 0.15 160 1000 auto loaded maps "m"
		local.master aliascache springfield_snd_reload_end sound/weapons/foley/SpringfieldReloadEnd1.wav soundparms 0.9 0.2 0.95 0.1 160 1000 item loaded maps "m"
		local.master aliascache springfield_reload_npc sound/weapons/foley/KARClipReloadNPC1.wav soundparms 1.0 0.0 1.0 0.0 160 1000 item loaded maps "m"
		local.master aliascache springfield_bolt_npc sound/weapons/foley/KARRechamberNPC1.wav soundparms 1.0 0.0 1.0 0.0 160 1000 item loaded maps "m"
	}
	if (level.SPFIX_["zooka"])
	{
		println "zooka"
		local.master aliascache bazooka_snd_fire sound/weapons/fire/BazookaFire2.wav soundparms 1.5 0.0 0.92 0.15 500 9000 weapon loaded maps "m "
		local.master aliascache bazooka_snd_pickup sound/weapons/foley/AmmoPUHeavy1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache bazooka_snd_pickup_ammo sound/weapons/foley/AmmoPUHeavy1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache bazooka_snd_noammo sound/weapons/foley/DryFireBazooka1.wav soundparms 1.2 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache bazooka_snd_reload sound/weapons/foley/BazookaReload1.wav soundparms 0.9 0.2 1.0 0.0 160 1000 item loaded maps "m"
		local.master aliascache bazooka_reload_npc sound/weapons/foley/BazookaReloadNPC1.wav soundparms 1.0 0.0 1.0 0.0 160 1000 item loaded maps "m"
		local.master aliascache snd_bazooka_pullout sound/weapons/foley/BazookaForward1.wav soundparms 1.0 0.2 0.9 0.1 160 1000 item loaded maps "m"
		local.master aliascache snd_bazooka_putaway1 sound/characters/body_mvmt_04.wav soundparms 0.7 0.2 0.9 0.2 160 1000 item loaded maps "m"
		local.master aliascache snd_bazooka_putaway2 sound/characters/body_mvmtgear_04.wav soundparms 0.7 0.2 0.9 0.2 160 1000 item loaded maps "m"
	}
	if (level.SPFIX_["shotty"])
	{
		println "shotty"
		local.master aliascache shotgun_snd_fire1 sound/weapons/fire/ShotgunFire1.wav soundparms 1.5 0.0 0.8 0.1 400 8000 weapon loaded maps "m
		local.master aliascache shotgun_snd_pickup sound/weapons/foley/Pickup_01.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache shotgun_snd_pickup_ammo sound/weapons/foley/Pickup_01.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache shotgun_snd_noammo sound/weapons/foley/DryFireRifle1.wav soundparms 1.2 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache shotgun_snd_reload_start sound/weapons/foley/ShotgunReloadStart1.wav soundparms 1.2 0.01 0.95 0.1 160 1000 item loaded maps "m"
		local.master aliascache shotgun_snd_reload_single1 sound/weapons/foley/ShotgunFill1.wav soundparms 1.2 0.01 0.95 0.1 160 1000 item loaded maps "m"
		local.master aliascache shotgun_snd_reload_single2 sound/weapons/foley/ShotgunFill2.wav soundparms 1.2 0.01 0.95 0.1 160 1000 item loaded maps "m"
		local.master aliascache shotgun_snd_reload_single3 sound/weapons/foley/ShotgunFill3.wav soundparms 1.2 0.01 0.95 0.1 160 1000 item loaded maps "m"
		local.master aliascache shotgun_snd_reload_end sound/weapons/foley/ShotgunReloadEnd1.wav soundparms 1.5 0.0 0.95 0.1 160 1000 item loaded maps "m"
		local.master aliascache shotgun_snd_rechamber sound/weapons/foley/ShotgunRechamber1.wav soundparms 1.5 0.0 0.95 0.1 160 1000 item loaded maps "m"
		local.master aliascache snd_shotgun_pullout sound/weapons/foley/ShotgunForward1.wav soundparms 1.5 0.0 1.0 0.0 160 1000 item loaded maps "m"
		local.master aliascache snd_shotgun_putaway1 sound/characters/body_mvmt_04.wav soundparms 0.7 0.2 0.9 0.2 160 1000 item loaded maps "m"
		local.master aliascache snd_shotgun_putaway2 sound/characters/body_mvmtgear_04.wav soundparms 0.7 0.2 0.9 0.2 160 1000 item loaded maps "m"
	}
	if (level.SPFIX_["mp44"])
	{
		println "mp44"
		local.master aliascache mp44_snd_fire1 sound/weapons/fire/MP44Fire1.wav soundparms 1.3 0.05 0.95 0.1 400 8000 weapon loaded maps "m "
		local.master aliascache mp44_snd_pickup sound/weapons/foley/MP44Pickup1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m "
		local.master aliascache mp44_snd_pickup_ammo sound/weapons/foley/AmmoPUMG1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m "
		local.master aliascache mp44_snd_noammo sound/weapons/foley/DryFireMachineGun1.wav soundparms 1.2 0.2 0.8 0.2 160 1000 item loaded maps "m "
		local.master aliascache mp44_snd_reload sound/weapons/foley/MP44Reload1.wav soundparms 0.9 0.2 1.0 0.0 160 1000 item loaded maps "m "
		local.master aliascache MP44_reload_npc sound/weapons/foley/MP44ReloadNPC1.wav soundparms 1.0 0.0 1.0 0.0 160 1000 item loaded maps "m "
		local.master aliascache mp44_snd_pullout1 sound/weapons/foley/MP44Forward1.wav soundparms 0.9 0.2 0.9 0.2 160 1000 item loaded maps "m "
		local.master aliascache mp44_snd_putaway1 sound/characters/body_mvmt_04.wav soundparms 0.7 0.2 0.9 0.2 160 1000 item loaded maps "m "
		local.master aliascache mp44_snd_putaway2 sound/characters/body_mvmtgear_04.wav soundparms 0.7 0.2 0.9 0.2 160 1000 item loaded maps "m "
	}
	if (level.SPFIX_["panzer"])
	{
		println "panzer"
		local.master aliascache panzerschreck_snd_fire sound/weapons/fire/PanzershrekFire2.wav soundparms 1.5 0.0 0.92 0.15 500 9000 weapon loaded maps "m"
		local.master aliascache panzerschreck_snd_pickup sound/weapons/foley/AmmoPUHeavy1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache panzerschreck_snd_pickup_ammo sound/weapons/foley/AmmoPUHeavy1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache panzerschreck_snd_noammo sound/weapons/foley/DryFireBazooka1.wav soundparms 1.2 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache panzerschreck_snd_reload sound/weapons/foley/PanzerReload1.wav soundparms 0.9 0.2 1.0 0.0 160 1000 item loaded maps "m"
		local.master aliascache panzerschreck_reload_npc sound/weapons/foley/BazookaReloadNPC1.wav soundparms 1.0 0.0 1.0 0.0 160 1000 item loaded maps "m"
	}
	if (level.SPFIX_["colt"])
	{
		println "colt"
		local.master aliascache colt45_snd_fire sound/weapons/fire/Colt45Fire1.wav soundparms 1.4 0.1 0.8 0.1 400 8000 weapon loaded maps "m"
		local.master aliascache colt45_snd_noammo sound/weapons/foley/DryFirePistol1.wav soundparms 1.5 0.0 1.0 0.0 160 1000 item loaded maps "m"
		local.master aliascache colt45_snd_reload sound/weapons/foley/Colt45Reload1b.wav soundparms 0.9 0.2 1.0 0.0 160 1000 item loaded maps "m"
	}
	if (level.SPFIX_["m1"])
	{
		println "m1"
		local.master aliascache m1_snd_fire1 sound/weapons/fire/M1GarandFire1a.wav soundparms 1.3 0.2 0.8 0.2 400 8000 weapon loaded maps "m"
		local.master aliascache m1_snd_fire2 sound/weapons/fire/M1GarandFire2a.wav soundparms 1.3 0.2 0.8 0.2 400 8000 weapon loaded maps "m"
		local.master aliascache m1_snd_pickup sound/weapons/foley/SpringfieldPickup1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache m1_snd_pickup_ammo sound/weapons/foley/AmmoPURifle1.wav soundparms 1.3 0.2 0.8 0.2 160 1000 item loaded maps "m "
		local.master aliascache m1_snd_noammo sound/weapons/foley/DryFireRifle1.wav soundparms 1.2 0.2 0.8 0.2 160 1000 item loaded maps "m "
		local.master aliascache m1_snd_reload sound/weapons/foley/m1_reload.wav soundparms 0.9 0.2 0.95 0.1 160 1000 item loaded maps "m "
		local.master aliascache snd_ping sound/weapons/foley/M1_Ping.WAV soundparms 1.5 0.3 0.95 0.1 160 1000 auto loaded maps "m "
		local.master aliascache m1_reload_npc sound/weapons/foley/M1ReloadNPC1.wav soundparms 1.0 0.0 1.0 0.0 160 1000 item loaded maps "m "
	}
	if (level.SPFIX_["silence"])
	{
		println "silence"
		local.master aliascache silencer_snd_fire1 sound/weapons/fire/SilencedFire2.wav soundparms 1.4 0.1 0.95 0.1 400 8000 weapon loaded maps "m"
		local.master aliascache silencer_snd_noammo sound/weapons/foley/DryFirePistol1.wav soundparms 1.2 0.2 0.8 0.2 160 1000 item loaded maps "m"
		local.master aliascache silencer_snd_reload sound/weapons/foley/SilencerReload1.wav soundparms 0.9 0.2 1.0 0.0 160 1000 item loaded maps "m"
	}

	level.SPFIX_sounds_loaded = 1

end
```

# xyz_Airborne_Mod\global\states\get_weapon.scr

```scr
/*
======================================================
*** AIRborne; Weapon Handler StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------
--- INFO:

1) WEAPONNAME: <player_alias>.current_weapon

 "StG44"			"UNARMED"			"BAR"	
 "MP40"			"Binoculars"		"Thompson SMG"
 "Panzerschreck"		"Shotgun"			"Bazooka"
 "Mauser KAR98 Rifle"					"M1 Garand"
 "KAR98 Sniper Rifle"					"Springfield '03 Sniper"
 "Walther P38"		"Silenced Pistol"		"Colt 45"
 "Stielhandgranate"					"Frag Grenade"

2) WEAPONCLASS: <player_alias>.current_weaponclass

 pistol			grenade
 mg				shotgun
 smg				none
 rifle			heavy

3) WEAPONMODEL: <player_alias>.current_weapon_model

 The string returned, contains the full weaponpath (with "models/")

-------------------

======================================================
*/

main local.name local.model local.class:

	if (self != NULL)
	{
		if (self.getweap != 1)
		{
			self.getweap = 1
			self.current_weapon = local.name
			self.current_weaponclass = local.class
			self.current_weapon_model = local.model

			if (self.rankbonus["speed"] == 1 && level.running_ranking == 1 && self.speed_bonus[local.model] != 1 )
			{
				self weaponcommand dual dmmovementspeed 1.20
				self.speed_bonus[local.model] = 1
			}

			waitframe
			local.weapon_limiter = level.AIR["weapon_limiter"]
			if (local.weapon_limiter == 1)
			{
				self waitexec global/states/weapon_limiter.scr::check local.model
			}
		
			wait 0.3
			self.getweap = 0
		}

	}
end
```

# xyz_Airborne_Mod\global\states\joined_allies.scr

```scr
/*
======================================================
*** AIRborne; Joined-Allies StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
joined_allies:

	println "Client ID " self.entnum " has joined the allies!"

	// Reset state-info records
	self.usingScope = NIL
	self.usingTurret = NIL
	self.inVehicle = NIL
	self.usingLadder = NIL
	self.secondary_Fireheld = NIL

	// Weapon Limiter
	self.already_limited = NIL 
	self.already_bonus = NIL

	// Speed Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.speed_bonus = NIL
	}

	wait 1

	if (self.status != "alive")
	{
		println "bugged"
		self exec global/states/player_spawn.scr "spawned"
	}

end
```

# xyz_Airborne_Mod\global\states\joined_axis.scr

```scr
/*
======================================================
*** AIRborne; Joined-Axis StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
joined_axis:

	println "Client ID " self.entnum " has joined the axis!"

	// Reset state-info records
	self.usingScope = NIL
	self.usingTurret = NIL
	self.inVehicle = NIL
	self.usingLadder = NIL
	self.secondary_Fireheld = NIL

	// Weapon Limiter
	self.already_limited = NIL 
	self.already_bonus = NIL

	// Speed Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.speed_bonus = NIL
	}

	wait 1

	if (self.status != "alive")
	{
		println "bugged"
		self exec global/states/player_spawn.scr "spawned"
	}


end
```

# xyz_Airborne_Mod\global\states\joined_spec.scr

```scr
/*
======================================================
*** AIRborne; Joined-Spectator StateScript for MoH:AA
======================================================
by Sor
Version: v1.3
-----------------------------------

======================================================
*/
joined_spec:

	println "Client ID " self.entnum " has become a spectator"

	// To prevent 'trigger-collisions'
	if (self.detect)
		self.detect delete

	// Reset state-info records
	self.usingScope = NIL
	self.usingTurret = NIL
	self.inVehicle = NIL
	self.usingLadder = NIL
	self.secondary_Fireheld = NIL

	// Weapon Limiter
	self.already_limited = NIL 
	self.already_bonus = NIL

	// Speed Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.speed_bonus = NIL
	}

	if ( level.AIR["music"] == 1)
	{
		exec global/AIR/AIR_music.scr
	}
end
```

# xyz_Airborne_Mod\global\states\just_left.scr

```scr
/*
======================================================
*** AIRborne; Left-Server StateScript for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/
left local.num:

	println "Client ID " local.num " has left the server!"

end
```

# xyz_Airborne_Mod\global\states\just_spawned.scr

```scr
/*
======================================================
*** AIRborne; Spawned StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
spawned:

	println "Client ID " self.entnum " has just spawned!"

	if (self.rank == NIL && level.running_ranking == 1)
	{
		self waitthread global/rank/ranking.scr::cadet
	}

	if ( level.AIR["spawn_protect"] == 1)
	{
		self exec global/AIR/AIR_sp.scr
	}

	if ( level.AIR["camper"] == 1)
	{
		self exec global/AIR/AIR_AntiCamp.scr
	}

	if (self.rankbonus["silencer"] == 1 && level.running_ranking == 1)
	{
		self thread global/rank/ranking.scr::_bonus_silencer
	}
	if (self.rankbonus["regenerate"] == 1 && level.running_ranking == 1)
	{
		self thread global/rank/ranking.scr::_bonus_regenerate
	}

end
```

# xyz_Airborne_Mod\global\states\new_player.scr

```scr
/*
======================================================
*** AIRborne; Entered-Server StateScript for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/

new_player:

	println "Client ID " self.entnum " has just entered the server."

	if ( level.AIR["music"] == 1)
	{
		exec global/AIR/AIR_music.scr
	}
end
```

# xyz_Airborne_Mod\global\states\player_died.scr

```scr
/*
======================================================
*** AIRborne; Player-Died StateScript for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/
died:

	println "Client ID " self.entnum " died."

	// Reset state-info records
	self.usingScope = NIL
	self.usingTurret = NIL
	self.inVehicle = NIL
	self.usingLadder = NIL
	self.secondary_Fireheld = NIL

	// Weapon Limiter
	self.already_limited = NIL 
	self.already_bonus = NIL	

	// Speed Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.speed_bonus = NIL
	}

end
```

# xyz_Airborne_Mod\global\states\player_info.scr

```scr
/*
======================================================
*** AIRborne; Player Info StateScript for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------
--- INFO:

 <player_alias>.secondary_Fireheld
 <player_alias>.usingTurret 
 <player_alias>.usingLadder
 <player_alias>.inVehicle

-------------------

======================================================
*/
main local.setting local.extra_setting local.more_settings:

	if (self == NULL)
		end

	switch(local.setting)
	{
		// TURRET:
		// (1) Player is using an turret 
		// (0) Player stopped using a turret 
		// (NIL) Player hasn't used a turret yet
		// <player_alias>.usingTurret 

		case "turret_on":
			if (self.usingTurret != 1)
			{
				self.usingTurret = 1
			}
		break
		case "turret_off":
			if (self.usingTurret != 0 && self.usingTurret != NIL)
			{
				self.usingTurret = 0
			}
		break

		// VEHICLE:
		// (1) Player has entered a vehicle and is using it
		// (0) Player has stopped using a vehicle and exited it
		// (NIL) Player has never used a vehicle before
		// <player_alias>.inVehicle

		case "vehicle_on":
			if (self.inVehicle != 1)
			{
				self.inVehicle = 1
			}
		break
		case "vehicle_off":
			if (self.inVehicle != 0 && self.inVehicle != NIL)
			{
				self.inVehicle = 0
			}
		break

		// LADDER:
		// (1) Player is on a ladder
		// (0) Player is off the ladder
		// (NIL) Player hasn't used a ladder yet
		// <player_alias>.usingLadder

		case "ladder_on":
			if (self.usingLadder != 1)
			{
				self.usingLadder = 1
			}
		break	
		case "ladder_off":
			if (self.usingLadder != 0 && self.usingLadder != NIL)
			{
				self.usingLadder = 0
			}
		break

		// SECONDARY FIREHELD
		// (0/NIL) Player isn't holding the Right Mouse Button (= Secondary Fireheld)
		// (1) Player is holding the Right Mouse Button (= Secondary Fireheld)
		// <player_alias>.secondary_Fireheld

		case "rmb_on":
			if (self.secondary_Fireheld != 1)
			{
				self.secondary_Fireheld = 1
			}
		break
		case "rmb_off":
			if (self.secondary_Fireheld != 0 && self.secondary_Fireheld != NIL)
			{
				self.secondary_Fireheld = 0
			}
		break
	}

end
```

# xyz_Airborne_Mod\global\states\player_spawn.scr

```scr
/*
======================================================
*** AIRborne; Player Handler StateScript for MoH:AA
======================================================
by Sor
Version: v1.4
-----------------------------------
--- INFO:

 STATUS: <player_alias>.status 
  "alive"
  "killed"
  "spectator"
  "entered_server"

 JUST SPAWNED: <player_alias>.jspawned
  This variable gets set to 1 when the player has just spawned and
  back to 0 after max 5 seconds!

 KILLCOUNT: <player_alias>.killcount
 DEATHCOUNT: <player_alias>.deathcount

-------------------

======================================================
*/
main local.dead_or_alive:

	if (self != NULL)
	{
		if (isAlive self && self.status != "alive" && local.dead_or_alive == "spawned" && self.dmteam != "spectator")
		{
			self exec global/fix/anti_fps.scr
			self.status = "alive"
			self.jspawned = 1

			self thread follow_player
			if (level.running_ranking == 1)
			{
				waitframe
				if (self.detect)
				{
					self.detect remove
				}

				self thread setup_kill
			}
		}
		else if (self.status != "killed" && local.dead_or_alive == "killed") //&& !(Isalive self))
		{
			self.status = "killed"
			//just in case
			self.jspawned = 0

			// wait till the states have reported if the player has cratered
			waitframe
			if (self.has_cratered == 1)
			{
				if (self.killcount == NIL)
					self.killcount = 0

				self.killcount--
				self.has_cratered = NIL
			}
				
		}
		else if (local.dead_or_alive == "cratered")
		{
			self.has_cratered = 1
		}
		else if (self.status == NIL && self.dmteam == "spectator" && local.dead_or_alive == NIL)
		{
			self.status = "entered_server"
			self exec global/states/new_player.scr
		}
		// Buggy Spawn...
		else if (self.status == NIL || self.status != "alive" && isAlive self)
		{
			wait 1
			self exec global/states/player_spawn.scr "spawned"
			end
		}
	}

end

//-----------------------------------
follow_player:

	if (self.followed == 1)
		end
	else
		self.followed = 1

	local.time = 0
	local.team = self.dmteam
	local.num = self.entnum


	// *****************************************************
	self exec global/states/just_spawned.scr

	while ( self && self.health >= 96 && local.time <= 5.00 && self.status != "killed" && self.dmteam == local.team )
	{
		waitframe
		local.time += 0.05
	}
	// *****************************************************

	// ...Left the server
	if (self == NULL || self == NIL)
	{
		exec global/states/just_left.scr local.num
		end
	}	
	else
	{
		self.followed = NIL
		self.jspawned = 0

		//...or Joined the spectators
		if (self.dmteam != local.team && self.dmteam == "spectator")
		{
			self.status = "joined_spectator"
			self exec global/states/joined_spec.scr
			end
		}
		//...or Joined the Axis
		else if (self.dmteam != local.team && self.dmteam == "axis")
		{
			self.status = "joined_axis"
			self exec global/states/joined_axis.scr
			end
		}
		//...or Joined the Allies
		else if (self.dmteam != local.team && self.dmteam == "allies")		
		{
			self.status = "joined_allies"
			self exec global/states/joined_allies.scr
			end
		}
		else if !(isAlive self)
		{
			self exec global/states/player_died.scr
			end
		}	
	}

	// *******************************************************************************************
	while ( self && self.status != "killed" && self.dmteam == local.team && isAlive self )
	{
		waitframe
	}
	// *******************************************************************************************

	//... left the server
	if (self == NULL || self == NIL)
	{
		exec global/states/just_left.scr local.num
		end
	}
	else if (self.dmteam != local.team)
	{
		self.followed = NIL

		if(self.dmteam == "spectator")
		{
			self.status = "joined_spectator"
			self exec global/states/joined_spec.scr
			end
		}
		else if (self.dmteam == "axis")
		{
			self.status = "joined_axis"
			self exec global/states/joined_axis.scr
			end
		}
		else if (self.dmteam == "allies")		
		{
			self.status = "joined_allies"
			self exec global/states/joined_allies.scr
			end
		}
	}
	else if !(isAlive self)
	{
		self.followed = NIL
		self exec global/states/player_died.scr
		end
	}

end

//-----------------------------------
setup_kill:

	if(self.detect != NIL && self.detect != NULL)
	{
		self.detect remove
	}

	self.detect = spawn trigger_multipleall "spawnflags" "128"
	self.detect.origin = self.origin
	self.detect.angle = self.angle
	self.detect glue self
	self.detect.player = self
	self.detect.team = self.dmteam
	self.detect.alive = 1
	self.detect.attacker = NIL
	self.detect setsize ( -17 -17 0 ) ( 17 17 72 )
	self.detect solid

	self.detect thread correct_detect

	while(1)
	{
		self.detect waittill trigger
		local.murderer = parm.other

		//check if player is still on the server or on the same team
		if (self == NIL || self == NULL || level.running_ranking != 1)
		{
			self.detect remove
			end
		}

		//MAIN KILL-HANDLER
		if ( isAlive self != 1 && self.detect.alive == 1 && self.dmteam != "spectator" )
		{	
			self.detect nottriggerable
			self.detect.alive = 0
			self.detect.attacker = local.murderer
			waitframe
		
			//benzin barrel
			if (local.murderer == NULL) 
			{
				if (self.deathcount == NIL)
					self.deathcount = 0
			
				self.deathcount++
				end
			}
			//committed suicide
			if ( local.murderer == self)
			{
				if ( local.murderer.killcount == NIL )
				{
					local.murderer.killcount = 0
					local.murderer.killcount--
				}
				else if ( local.murderer.killcount != NIL )
				{
					local.murderer.killcount--
				}
			}
			else if (local.murderer.dmteam == self.dmteam && (getcvar "g_gametype") != "1")
			{
				if ( local.murderer.killcount == NIL )
				{
					local.murderer.killcount = 0
					local.murderer.killcount--
				}
				else if ( local.murderer.killcount != NIL )
				{
					local.murderer.killcount--
				}
			}
			//no traitor
			else 
			{
				if ( local.murderer.killcount == NIL )
				{
					local.murderer.killcount = 0
					local.murderer.killcount++
				}
				else if ( local.murderer.killcount != NIL )
				{
					local.murderer.killcount++
				}
			}

			if (self.deathcount == NIL)
				self.deathcount = 0

			self.deathcount++
			self.detect immediateremove
			end
		}
	}
end

correct_detect:

	while(self && self.player)
	{
		if ( (self.player getposition)[0] == "c" && local.last_pos != 1)
		{
			local.last_pos = 1
			self setsize ( -17 -17 0 ) ( 17 17 42 )
		}
		else if ( (self.player getposition)[0] != "c" && local.last_pos == 1)
		{
			local.last_pos = 0
			self setsize ( -17 -17 0 ) ( 17 17 72 )
		}

		wait 0.2
	}
end
```

# xyz_Airborne_Mod\global\states\scopes.scr

```scr
/*
======================================================
*** AIRborne; Scopes StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
main:

	if (self != NULL)
	{
		if (self.usingScope != 1 && self.rankbonus["zoom"] != 1)
		{
			self.usingScope = 1
			end
		}
		else if (self.usingScope == 1 && self.rankbonus["zoom"] != 1)
		{
			self.usingScope = 0
			end
		}
		
		if (self.usingScope == NIL || self.usingScope == 0 && self.rankbonus["zoom"] == 1)
		{
			self.usingScope = 1

			self weaponcommand mainhand zoom 10 //15
		
		}
		else if (self.usingScope == 1 && self.rankbonus["zoom"] == 1)
		{
			self.usingScope = 2
		}
		else
		{
			self weaponcommand mainhand zoom 20
			self.usingScope = 0
		}
	}

end
```

# xyz_Airborne_Mod\global\states\weapon_limiter.scr

```scr
/*
======================================================
*** AIRborne; Weapon Limiter Script for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/

//----------------------------------------------
check local.model:
//----------------------------------------------

	if (level.AIR["banned_weapons"] == NIL)
	{
		waitthread global/limits.txt::banned
		//waitframe
	}

	if (level.AIR["limited_weapons"] == NIL)
	{
		waitthread global/limits.txt::limited
		//waitframe
	}

	if (level.AIR["bonus_weapons"] == NIL)
	{
		waitthread global/limits.txt::bonuses
		//waitframe
	}

	// Is it banned?
	for (local.i = 1; local.i <= level.AIR["banned_weapons"].size; local.i++)
	{
		if (local.model == level.AIR["banned_weapons"][local.i][1])
		{
			self thread invalid local.model
			//self take local.model
			end
		}
	}

	// Limited?
	for (local.i = 1; local.i <= level.AIR["limited_weapons"].size; local.i++)
	{
		if (local.model == level.AIR["limited_weapons"][local.i][1])
		{
			local.var = int (level.AIR["limited_weapons"][local.i][3])
			local.limitation = (level.AIR["limited_weapons"][local.i][2]::local.var)
			self waitthread apply_limit local.limitation local.model
			end 
		}
	}

	// Or does it gain a bonus?
	for (local.i = 1; local.i <= level.AIR["bonus_weapons"].size; local.i++)
	{
		if (local.model == level.AIR["bonus_weapons"][local.i][1])
		{
			local.bonus = (level.AIR["bonus_weapons"][local.i][2]::level.AIR["bonus_weapons"][local.i][3])
			self waitthread apply_bonus local.bonus local.model
			end 
		}
	}

end


//----------------------------------------------
invalid local.model:
//----------------------------------------------

	self take local.model

end 

//----------------------------------------------
apply_limit local.limited_weapon local.model:
//----------------------------------------------

	if (local.limited_weapon != NIL && self.already_limited[local.model] != 1)
	{
		switch(local.limited_weapon[1])
		{
			case "ammo":
				local.ammo = local.limited_weapon[2]
				self ammo self.current_weaponclass local.ammo
			break
			case "nade":
				local.nades = local.limited_weapon[2] 
				self ammo grenade	local.nades
			break
			case "speed":
				local.newspeed = local.limited_weapon[2]
				self weaponcommand dual dmmovementspeed local.newspeed
			break
			case "zoom":
				local.newzoom = local.limited_weapon[2]
				self weaponcommand dual zoom local.newzoom
				//self weaponcommand dual dmzoom local.newzoom
			break
			case "take":
				local.take_weapon = local.limited_weapon[2]
				self take local.take_weapon 
			break
		}

		self.already_limited[local.model] = 1
	}

end

//----------------------------------------------
apply_bonus local.bonus local.model:
//----------------------------------------------

	if (local.bonus != NIL && self.already_bonus[local.model] != 1)
	{
		switch(local.bonus[1])
		{
			case "ammo":
				local.class = self.current_weaponclass
				local.ammo = local.bonus[2]
				self ammo local.class local.ammo
			break
			case "nade":
				local.nades = local.bonus[2]
				self ammo grenade	local.nades
			break
			case "speed":
				local.newspeed = local.bonus[2]
				self weaponcommand dual dmmovementspeed local.newspeed
			break
			case "zoom":
				local.newzoom = local.bonus[2]
				self weaponcommand dual zoom local.newzoom
				//self weaponcommand dual dmzoom local.newzoom
			break
		}
		
		self.already_bonus[local.model] = 1
	}

end
```

# xyz_Airborne_Mod\global\strings.scr

```scr
// ------------------------------------------------------
// String Handler; by Elgan
// ------------------------------------------------------
//
// 11 September 2005 added 3 new functions
// array_to_int
// array_to_str
// array_to_float
//
/*
INDEX:
------
Array_to_lower
Array_to_upper
to_lower
to_upper
InStr
Right
left
Mid
Reverse
split_line
Replace
Remove
Format_replace
array_to_int
array_to_str
array_to_float
*/

// --------------------------------------------------------------------------
// Convert a array to lower  case.
// usage: exec global/strings.scr::Array_to_lower (const array of strings)
// returns: Array of lower case strings
// --------------------------------------------------------------------------
Array_to_lower local.strings:

	local.lower = waitthread chardata_lowercase
	local.upper = waitthread chardata_uppercase

	for(local.linni = 1; local.linni <= local.strings.size; local.linni++)
	{	
		for(local.anniken = 1; local.anniken <= local.strings[local.linni].size; local.anniken++)
		{
			local.string = local.strings[local.linni] [local.anniken]

			for(local.i = 0; local.i <= local.string.size - 1; local.i++)
			{
				local.letter = local.string[local.i]
				for(local.t = 1; local.t <= local.upper.size; local.t++)
				{
					if(local.letter == local.upper[local.t])
					{	
						local.letter = local.lower[local.t] 
						local.string[local.i] = local.letter 
					}
				}

			}
			local.strings[local.linni][local.anniken] = local.string
		}
	}

end  local.strings


// --------------------------------------------------------------------------
// Convert a array to upper case.
// usage: exec global/strings.scr::Array_to_upper (const array of strings)
// returns: Array of upper case strings
// --------------------------------------------------------------------------
Array_to_upper local.strings:

	local.lower = waitthread chardata_uppercase 
	local.upper = waitthread chardata_lowercase
 
	for(local.linni = 1; local.linni <= local.strings.size; local.linni++)
	{	
		for(local.anniken = 1; local.anniken <= local.strings[local.linni].size; local.anniken++)
		{
			local.string = local.strings[local.linni] [local.anniken]

			for(local.i = 0; local.i <= local.string.size - 1; local.i++)
			{
				local.letter = local.string[local.i]
				for(local.t = 1; local.t <= local.upper.size; local.t++)
				{
					if(local.letter == local.upper[local.t])
					{	
						local.letter = local.lower[local.t] 
						local.string[local.i] = local.letter 
					}
				}

			}
			local.strings[local.linni][local.anniken] = local.string
		}
	}

end  local.strings


// --------------------------------------------------------------------------	
//stolen arrays from jv's string handler:D
//of cause by jv

// returns all lowercase chars
// --------------------------------------------------------------------------
chardata_lowercase:
	local.hasharray = makeArray
	a
	b
	c
	d
	e
	f
	g
	h
	i
	j
	k
	l
	m
	n
	o
	p
	q
	r
	s
	t
	u
	v
	w
	x
	y
	z
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	

end local.array

// --------------------------------------------------------------------------
// returns all uppercase chars
// --------------------------------------------------------------------------

chardata_uppercase:
	local.hasharray = makeArray
	A
	B
	C
	D
	E
	F
	G
	H
	I
	J
	K
	L
	M
	N
	O
	P
	Q
	R
	S
	T
	U
	V
	W
	X
	Y
	Z
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	
end local.array


// --------------------------------------------------------------------------
// instr
// Instr will find the position in wich a string is found at.
// Usage: exec global/strings.scr::InStr (string to find \ string)
// returns the position of string_to_find
// eg
// exec global/strings.scr::InStr "\" "hell\o"
// gives 4 because it starts at 0

// If none found it will return NIL
// --------------------------------------------------------------------------

InStr local.char local.string:

	if(local.char.size == 1)
	{
		local.checktype = 0
	}
	else
	{
		local.checktype = 1
	}

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		if(local.checktype == 0)
		{
			local.check =  (local.char ==  local.string[local.i])
		}
		else
		{
			local.check =  (local.char[0] ==  local.string[local.i])
		}

		if(local.check)
		{
			if(local.checktype == 0)
			{
				local.i++
				end local.i
			}
			else
			{
				local.m = local.i
				for(local.t = 0;local.t <= local.char.size - 1 ;local.t++)
				{
					if(local.char[local.t] != local.string[local.m])
					{
						local.no = 1
					}
					local.m++
				}

				if(local.no != 1)
				{
					local.i++
					end local.i
				}
			}

		}
	}
end



// --------------------------------------------------------------------------
// Rightr
// Right will return a string of characters from the right.
// usage: waitexec global/strings.scr::Right ( Number of characters#, STRING STRING )
// Returns a string right from the number given as position
// eg
// local.string = waitexec global/strings.scr::Right 3 "hello"
// local.string will be 'llo'
// --------------------------------------------------------------------------

Right local.pos local.string:

	local.start = local.string.size - local.pos
	local.right = ""

	for(local.i = local.start; local.i <= local.string.size - 1 ; local.i++)
	{
		local.right += local.string[local.i]
	}

end local.right



// --------------------------------------------------------------------------
// Left
// Left will return Left of the string for the given number.
// usage: waitexec global/strings.scr::Right (NUMBER OF CHARACTERS LEFT, STRING STRING )
// Returns a string left from the number given as position
// eg
// local.string = waitexec global/strings.scr::Left 3 "hello" 
// local.string will be 'hell'
// --------------------------------------------------------------------------
Left local.pos local.string:

	local.pos--
	local.left = ""
	for(local.i = 0; local.i <=  local.pos; local.i++)
	{
		local.left += local.string[local.i]
	}

end local.left


// --------------------------------------------------------------------------
//Mid
//mid will return a string from a given position for a given number of characters.
// usage: local.string = waitexec global/strings.scr ( START POS, STRING, COUNT)
// returns: The string from start pos of string along the count.
//
//eg
// local.string = waitexec global/strings.scr 3 "hello" 2 
// local.string would become 'll'
// --------------------------------------------------------------------------
Mid local.start local.string local.count:

	local.start--
	local.mid = ""

	for(local.i = 1; local.i <= local.count;local.i++)
	{
		local.mid += local.string[local.start]
		local.start++
	}

end local.mid



// --------------------------------------------------------------------------
//Reverse
// Reverse will reverse a given string.
//useage:: local.string = waitexec global/strings.scr (STRING STRING)
// result: gives a string that is backwards to the string given.
//
//eg
// local.string = waitexec global/strings.scr::Reverse "hello" 
// local.string would become 'olleh'
// --------------------------------------------------------------------------
Reverse local.string:

	local.left = ""
	for(local.i = local.string.size - 1; local.i >=  0; local.i--)
	{
		local.left += local.string[local.i]
	}

end local.left


// --------------------------------------------------------------------------
// to_lower
// This will convert a given string to lower case
// usage local.string = waitexec global/strings.scr::to_lower (STRING STRING, INDEX TO CONVERT)
// Result: a lower case string
//
//eg
// local.string = waitexec global/strings.scr::to_lower "HELLO" 
// local.string will become 'hello'
//eg2
// local.string = waitexec global/strings.scr::to_lower "HELLO" 0
// local.string will become 'hELLO'
// --------------------------------------------------------------------------
to_lower local.string local.index:

	local.lower = waitthread chardata_lowercase
	local.upper = waitthread chardata_uppercase

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		local.letter = local.string[local.i]

		if(local.i == local.index || local.index == NIL)
		{
			for(local.t = 1; local.t <= local.upper.size; local.t++)
			{
				if(local.letter == local.upper[local.t])
				{	
					local.letter = local.lower[local.t] 
					local.string[local.i] = local.letter 
				}
			}
		}
		else
		{
			local.string[local.i] = local.letter 
		}

	}

end local.string


// --------------------------------------------------------------------------
// to_upper
// This will convert a given string to upper case
// usage local.string = waitexec global/strings.scr::to_upper (STRING STRING, INDEX TO CONVERT)
// Result: a upper case string
//
//eg
// local.string = waitexec global/strings.scr::to_upper "hello" 
// local.string will become 'HELLO'
//eg2
// local.string = waitexec global/strings.scr::to_upper "hello" 0
// local.string will become 'Hello'
// --------------------------------------------------------------------------
to_upper local.string local.index:

	local.upper = waitthread chardata_lowercase
	local.lower = waitthread chardata_uppercase

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		local.letter = local.string[local.i]

		if(local.i == local.index || local.index == NIL)
		{
			for(local.t = 1; local.t <= local.upper.size; local.t++)
			{
				if(local.letter == local.upper[local.t])
				{	
					local.letter = local.lower[local.t] 
					local.string[local.i] = local.letter 
				}
			}
		}
		else
		{
			local.string[local.i] = local.letter 
		}

	}

end local.string


// ----------------------------------------------------------------------------------------------------------------------
// Used to split a line of words into a array of words. return with word count
// localinfo == line to split
// local.say = say to admins input detected or not, set 1 usualy
// local.spacer = What to use to split the line. If none is set then " " will be used.
// usage local.wordarray = waitexec global/strings.scr::split_line ( STRING STRING , CONSOLE FEEDBACK, STRING SPACER)
//
//eg
//  local.wordarray = waitexec global/strings.scr::split_line "hello_mummy" 1 "_"
// local.wordarray is a const array
//
// local.wordarray[1] = array of words
// local.wordarray[2] word count
// local.wordarray[3] full string with " " spaces
//
// local.wordarray[1][1] is 'hello'
// local.wordarray[1][1] is 'mummy'
//
// local.wordarray[2] is 2 'two words'
//
// local.wordarray[3] is 'hello mummy'
// ----------------------------------------------------------------------------------------------------------------------

split_line local.info local.dont_say local.spacer:

	local.wordcount = 1

	if(local.spacer==NIL)
	{
		if(local.info[0] == "`")
		{
			local.spacer = "_"
			local.start = 1
		}
		else if(local.info[0] == " " || local.info[0] == "")
		{
			local.spacer = " "

			for(local.i = 0;local.i <= local.info.size;local.i++)
			{
				if(local.info[local.i] != " " && local.info[local.i] != "")
				{
					local.start = local.i
					break
				}
			}

		}
		else 
		{
			local.spacer = " "
			local.start = 0
		}
	}
	else
	{
		local.start = 0
		local.altcheck = 1
	}

	for(local.i=local.start;local.i<=local.info.size - 1;local.i++)
	{	
		if(local.info[local.i]!=local.spacer && local.info[local.i] != "`")
		{
			if(local.words[local.wordcount]==NIL)
			{
				local.words[local.wordcount]=""
			}

			local.words[local.wordcount] += local.info[local.i]
		}
		else
		{	
			if(local.altcheck != 1)
			{
				if(local.spacer == "_" && local.info[local.i + 1] == "`")	// if its like ui_hud 1. sud be ui_`hud so it knows:).
				{
					local.words[local.wordcount] += local.info[local.i]			
				}
				else if(local.spacer == "_" && local.info[local.i ] != "`")
				{
					local.wordcount++
				}
				else if(local.spacer == " " && local.info[local.i ] == " ")
				{
					if(local.i != local.info.size - 1)
					{
						if(local.info[local.i + 1] != " " && local.info[local.i + 1] != NIL)
						{
							local.wordcount++
						}
					}
				}
			}
			else
			{
				if(local.info[local.i ] == local.spacer)
				{
					local.wordcount++
				}
			}
		}
	}	

	if(local.spacer == "_")
	{
		local.actual = ""

		for(local.i=3;local.i<=local.words.size;local.i++)
		{
			if(local.i < local.words.size)
			{
				local.space = " "
			}
			else
			{
				local.space = ""
			}
			local.actual += ( local.words[local.i] + local.space )
		}

		if(local.dont_say != 1)
		{
			//exec global/ac/console_feedback.scr ( "> Input detected: " + local.actual )
		}
	}
	else
	{
		if(local.dont_say != 1)
		{
			//exec global/ac/console_feedback.scr ( "> Input detected: " + local.info)
			local.actual = local.info
		}
	}

end ( local.words::local.wordcount::local.actual) 



// --------------------------------------------------------------------------
// Replace is used just like replace in notepad or any text editor. 
// It will replace any string in a string with a string of any size. 
//
// exec global/strings::Replace ( String string , String String to replace, string string to replace with )
//
// eg
// local.string = waitexec global/strings.scr::Replace "once_upon_a_time_there_was__a_mod" "_" " "
// local.string would become
// "once upon a time there was  a mod" 
// --------------------------------------------------------------------------

Replace local.string local.replace local.replace_with:


	if(local.replace.size == 1)
	{
		local.checktype = 0
	}
	else
	{
		local.checktype = 1
	}
	
	local.new_str = ""

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		if(local.checktype == 0)
		{
			local.check =  (local.replace ==  local.string[local.i])
		}
		else
		{
			local.check =  (local.replace[0] ==  local.string[local.i])
		}

		if(local.check)
		{
			if(local.checktype == 0)
			{
				if(local.replace_with.size == 1)
				{
					local.new_str += local.replace_with
				}
				else
				{
					for(local.t = 0;local.t <= local.replace_with.size - 1 ;local.t++)
					{
						local.new_str += local.replace_with[local.t]
					}
				}

			}
			else
			{
				local.no = 0
				local.m = local.i
				for(local.t = 0;local.t <= local.replace.size - 1 ;local.t++)
				{
					if(local.replace[local.t] != local.string[local.m])
					{
						local.no = 1
					}
					local.m++
				}

				if(local.no != 1)
				{
					for(local.t = 0;local.t <= local.replace_with.size - 1 ;local.t++)
					{
						local.new_str += local.replace_with[local.t]
					}
					local.i += local.replace.size - 1
				}
				else
				{
					local.new_str += local.string[local.i]
				}
				
			}

		}
		else
		{
			local.new_str += local.string[local.i]
		}
	}

end local.new_str 



// --------------------------------------------------------------------------
// Remove is used to remove words or single characters from a line.
//
// exec global/strings::Remove ( String string , String String to replace )
//
// eg
// local.string = waitexec global/strings.scr::Remove "hello you idiot" "idiot"
// local.string would become
// "hello you idiot"
// --------------------------------------------------------------------------

Remove local.string local.string_remove:

	local.string = waitthread Replace local.string local.string_remove ""

end local.string



// --------------------------------------------------------------------------
// Format_replace is used like Replace except it will only replace a single instance in a group of the same character.
// It will only replace single characters.
//
// exec global/strings::Replace ( String string , String String to replace, string string to replace with )
//
// eg
// local.string = waitexec global/strings.scr::Format_replace "once_upon_a_time_there_was__a_mod" "_" " "
// local.string would become
// "once upon a time there was_a mod" 
// --------------------------------------------------------------------------

Format_replace local.string local.replace local.replace_with:

	local.new_str = ""

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{

		local.check =  (local.replace ==  local.string[local.i] && local.replace != local.string[local.i + 1])

		if(local.check)
		{
			if ( local.string[local.i - 1] !=  local.replace)
			{
				local.new_str += local.replace_with
			}
		}
		else
		{
			local.new_str += local.string[local.i]
		}
	}

end local.new_str 

// --------------------------------------------------------------------------
// Combine combines a array of stirngs into one single string of all.
// exec global/strings:;Combine (ARRAY , INT START IN ARRAY)
// --------------------------------------------------------------------------

Combine local.words local.start:

	local.actual = ""

	for(local.i=local.start;local.i<=local.words.size;local.i++)
	{
		if(local.i < local.words.size)
		{
			local.space = " "
		}
		else
		{
			local.space = ""
		}

		local.actual += ( local.words[local.i] + local.space )
	}

end local.actual

// --------------------------------------------------------------------------
// array_to_int
// converts a array into interger
// returns the array as int
// --------------------------------------------------------------------------
array_to_int local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = int local.array[local.i]
	}

end local.array

// --------------------------------------------------------------------------
// array_to_str
// converts a array into string
// returns the array as string
// --------------------------------------------------------------------------
array_to_str local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = string local.array[local.i]
	}

end local.array

// --------------------------------------------------------------------------
// array_to_float
// converts a array into float
// returns the array as float
// --------------------------------------------------------------------------
array_to_float local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = float local.array[local.i]
	}

end local.array

```

# xyz_Airborne_Mod\global\Tow.scr

```scr
/*
======================================================
*** AIRborne; Tug-of-War Script for MoH:AA
======================================================
remade by Sor
Version: v1.1 r55
-----------------------------------

======================================================
*/
main local.TowObjects:

	if(level.TowLoaded)
		end

	level.TowLoaded = 1

	local.master = spawn ScriptMaster
	local.master alias allies_towobj_complete1 sound/dialogue/Multiplayer/a/AMdfr_v_01a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm moh obj train "
	local.master alias allies_towobj_complete2 sound/dialogue/Multiplayer/a/AMdfr_v_01h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm moh obj train "
	local.master alias allies_towobj_complete3 sound/dialogue/Multiplayer/a/AMdfr_v_01j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm moh obj train "
	local.master alias axis_towobj_complete1 sound/dialogue/Multiplayer/g/GRden_v_01a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm moh obj train "
	local.master alias axis_towobj_complete2 sound/dialogue/Multiplayer/g/GRden_v_01c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm moh obj train "
	local.master alias axis_towobj_complete3 sound/dialogue/Multiplayer/g/GRden_v_01i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm moh obj train "
	
	setcvar "g_gametype" "4"

	if(local.TowObjects == NIL)
		end

	for(local.i = 1; local.i <= local.TowObjects.size; local.i++)
	{
		if (local.TowObjects[local.i].tow_type != "bomb")
		{
			local.TowObjects[local.i] waitthread setupTow
		}
		else
		{
			local.TowObjects[local.i] waitthread setupBomb
		}
	}

	level waittill spawn

	wait 1

	thread TowWinCheck
	thread hud
	level.dmrespawning = 1

end

setupBomb:

	if (self == NULL)
		end

	local.team = self.team
	local.thread = self.thread
	local.name = self.name

	if(local.team == allies)
	{
		if(level.AlliesTow == NIL)
			level.AlliesTow = 1
		else
			level.AlliesTow++

		if(level.AlliesTow <= 3)
			self.id = level.AlliesTow
		else
		{
			println "[TowAA]: Too many Allies FuncTow - removing this one."
			self remove
			level.AlliesTow--
			end
		}
	}
	else if(local.team == axis)
	{
		if(level.AxisTow == NIL)
			level.AxisTow = 4
		else
			level.AxisTow++

		if(level.AxisTow <= 6)
			self.id = level.AxisTow
		else
		{
			println "[TowAA]: Too many Axis FuncTow - removing this one."
			self remove
			level.AxisTow--
			end
		}
	}

	self notsolid
	self.targetname = "FuncTow"
	self.cont = local.team

	if (self.trigger_name != NIL)
	{
		self.loc = self.name
		self.bomb["planting_team"] = (waitthread global/AIRborne_utils.scr::other_team local.team)
		self.bomb["defending_team"] = local.team

		self thread adv_bomb_thinker
	}
end

setupTow:

	if (self == NULL)
		end

	local.team = self.team
	local.thread = self.thread
	local.name = self.name

	if(local.team == allies)
	{
		if(level.AlliesTow == NIL)
			level.AlliesTow = 1
		else
			level.AlliesTow++

		if(level.AlliesTow <= 3)
			self.id = level.AlliesTow
		else
		{
			println "[TowAA]: Too many Allies FuncTow - removing this one."
			self remove
			level.AlliesTow--
			end
		}
	}
	else if(local.team == axis)
	{
		if(level.AxisTow == NIL)
			level.AxisTow = 4
		else
			level.AxisTow++

		if(level.AxisTow <= 6)
			self.id = level.AxisTow
		else
		{
			println "[TowAA]: Too many Axis FuncTow - removing this one."
			self remove
			level.AxisTow--
			end
		}
	}


	self notsolid
	self.targetname = "FuncTow"
	self.cont = local.team

	if (self.neg == NIL)
		self.neg = ( -50 -50 0 )
	if (self.post == NIL)
		self.pos = ( 50 50 100 )

	local.usedetect = spawn trigger_use origin self.origin angles self.angles
	local.usedetect setsize self.neg self.pos
	local.usedetect.obj = self
	local.usedetect.name = local.name
	local.usedetect.cont = self.team
	local.usedetect.id = self.id
	local.usedetect setthread DoUse

	self.trigger = local.usedetect

end

hud:
	local.x = 20
	local.y = 90

	local.texture["allies"] = "textures/hud/allies"
	local.texture["axis"] = "textures/hud/axis"
	local.texture["allies_set"] = "textures/hud/axis"
	local.texture["axis_set"] = "textures/hud/allies"
	local.texture["axis_diffuse"] = "textures/hud/axis"
	local.texture["allies_diffuse"] = "textures/hud/allies"
	local.texture["neutral"] = "textures/sprites/vsssource.tga"

	local.colour["allies"] = ( 0.4 0.4 1.0 )
	local.colour["axis"] = ( 1.0 0.4 0.4 )
	local.colour["allies_set"] = ( 1.0 1.0 0.4 )
	local.colour["axis_set"] = ( 1.0 1.0 0.4 )
	local.colour["allies_diffuse"] = ( 0.4 1.0 1.0 )
	local.colour["axis_diffuse"] = ( 0.4 1.0 1.0 )
	local.colour["neutral"] = ( 1.0 1.0 1.0 )

	while(1)
	{
		huddraw_font 49 facfont-20
		huddraw_align 49 "center" "top"
		huddraw_rect 49 -90 50 100 100
		huddraw_string 49 "Tug-of-War v1.1.55"
		huddraw_color 49 0.0 0.0 0.0
		huddraw_alpha 49 0.5

		huddraw_font 50 facfont-20
		huddraw_align 50 "center" "top"
		huddraw_rect 50 -89 50 100 100
		huddraw_string 50 "Tug-of-War v1.1.55"
		huddraw_color 50 0.0 0.4 1.0
		huddraw_alpha 50 0.8

		huddraw_font 51 facfont-20
		huddraw_align 51 "left" "center"
		huddraw_rect 51 (local.x) (local.y) 100 100
		huddraw_string 51 "[OBJECTIVES]:"
		huddraw_color 51 1.0 1.0 1.0
		huddraw_alpha 51 1.0

		local.h = local.y
		local.n = 52

		for (local.i = 1; local.i <= $FuncTow.size; local.i++)
		{
			local.ny = (local.y) + (25 * local.i)

			local.t = $FuncTow[local.i].cont
			local.name = $FuncTow[local.i].name

			huddraw_font local.n facfont-20
			huddraw_align local.n "left" "center"
			huddraw_rect local.n (local.x + 25) local.ny 100 100
			huddraw_string local.n (local.name)
			huddraw_color local.n local.colour[local.t][0] local.colour[local.t][1] local.colour[local.t][2]
			huddraw_alpha local.n 1.0

			local.n++

			huddraw_align local.n "left" "center"
			huddraw_rect local.n (local.x) (local.ny - 40) 22 22
			huddraw_shader local.n local.texture[local.t]
			huddraw_alpha local.n 1.0

			local.n++
		}

		wait 0.7
	}

end

DoUse:

	self nottriggerable
	local.player = parm.other


	if(local.player.dmteam == self.cont)
	{
		self triggerable
		end
	}
	else if(local.player.dmteam != self.cont && local.player.status == "alive")
	{
		self.cont = local.player.dmteam
		self.obj.cont = local.player.dmteam
		if (self.obj.sound != 0)
			self.obj playsound (self.cont + "_towobj_complete")

		if(self.obj.thread != NIL)
			self.obj exec self.obj.thread local.player
	}

//	iprintlnbold_noloc ("[TOW]: " + self.name + " is under " + self.cont + " control!")

	self triggerable
end


TowWinCheck:

	if(level.WinTowCheck)
		end

	level.WinTowCheck = 1

	local.timelimit = ( (int (getcvar "timelimit")) * 60 )

	while(1)
	{
		local.time_remaining = (local.timelimit - level.time)
		local.allies = 0
		local.axis = 0
		local.towsize = $FuncTow.size

		if (int(local.time_remaining) == 5)
		{
			for(local.i = 1; local.i <= $FuncTow.size; local.i++)
			{
				if($FuncTow[local.i].cont == "allies")
					local.allies++
				else if($FuncTow[local.i].cont == "axis")
					local.axis++
			}

			if (local.allies > local.axis)
			{
				thread TeamWin "allies"
				end
			}
			else if (local.allies < local.axis)
			{
				thread TeamWin "axis"
				end
			}
			else
			{
				thread TeamWin "draw"
				end
			}
		}

		for(local.i = 1; local.i <= $FuncTow.size; local.i++)
		{
			if($FuncTow[local.i].cont == "allies")
				local.allies++
			else if($FuncTow[local.i].cont == "axis")
				local.axis++
		}

		if(local.allies == local.towsize)
		{
			thread TeamWin "allies"
			end
		}
		else if (local.axis == local.towsize)
		{
			thread TeamWin "axis"
			end
		}

		wait 0.8
	}

end

TeamWin local.winner:

	level.AIR_teamwin = 1

	wait 2

	local.gt = getcvar "g_gametype"
	setcvar "g_gametype" "4"

	level.global_win["winner"] = local.winner
	level.global_win["winevent"] = "round_restart"
	level.global_win["winevent_delay"] = 0.5
	level.global_win["winevent_display"] = 0

	waitexec global/win.scr::teamwins

	setcvar "g_gametype" local.gt

end

/**********************************************************************
 				 TOW Bomb Handler
				------------------
 level.bomb_planted["allies"]
 level.bomb_planted["axis"]
 level.target_destroyed["allies"]
 level.target_destroyed["axis"]
******************************************************************** */
adv_bomb_thinker:

	if (self.bomb["planting_team"] == NIL)
	{
		println "ERROR[Bomb Thinker]: Planting team unknown."
		end
	}

	if (self.bomb["planting_team"] == "allies")
		self.bomb["defusing_team"] = "axis"
	else
		self.bomb["defusing_team"] = "allies"

	level.bomb_use_distance = 128 	//quake units
	level.bombusefov = 30

	level.subtitleX = 100
	level.subtitleY = 50

	local.d = makeArray
	"exploder_set"		"none"
	"explosion_fx"		"none"
	"explosion_sound"		"none"
	"jitter"			"large"
	"set_time"			50
	"defuse_time"		60
	"tick_time"			45
	"damage"			200
	"explosion_radius"	1054
	endArray

	for(local.i = 1; local.i <= local.d.size; local.i++)
	{
		local.t = local.d[local.i][1]
		if (self.bomb[local.t] == NIL || self.bomb[local.t] == "")
		{
			self.bomb[local.t] = local.d[local.i][2]
		}
	}

	println "------------------Bomb------------------"
	println "self = " self
	println "self.planting_team = " self.bomb["planting_team"]
	println "self.defusing_team = " self.bomb["defusing_team"]
	println " "
	println "self.target (flak 88 or other) = " self.target
	println "self.target.destroyed_model = " self.target.destroyed_model
	println "self.target.destroyed_generic = " self.target.destroyed_generic
	println "self.trigger_name = " self.trigger_name
	println "self.exploder_set = " self.bomb["exploder_set"]
	println "self.explosion_fx = " self.bomb["explosion_fx"]
	println "self.explosion_sound = " self.bomb["explosion_sound"]
	println "self.jitter = " self.bomb["jitter"]
	println " "
	println ("level.bomb_set_time = " + self.bomb["set_time"] + " (tenths of a second)")
	println ("level.bomb_defuse_time = " + self.bomb["defuse_time"] + " (tenths of a second)")
	println ("level.bomb_tick_time = " + self.bomb["tick_time"] + " (seconds)")
	println ("level.bomb_damage = " + self.bomb["damage"])
	println ("level.bomb_explosion_radius = " + self.bomb["explosion_radius"] + " (quake units)")
	println "------------------Bomb------------------"

	level.bomb_planted["allies"] = 0
	level.bomb_planted["axis"] = 0

	if (level.target_destroyed["allies"] == NIL)
		level.target_destroyed["allies"] = 0

	if (level.target_destroyed["axis"] == NIL)
		level.target_destroyed["axis"] = 0

	if (self.target != NIL && self.target != NULL)
		self.target notsolid

	thread bomb_waittill_set
end

// -----------------------------------------------------
// first thread... controls planting_team using the trigger
// -----------------------------------------------------
bomb_waittill_set:

self model items/pulse_explosive.tik

while ( $(self.trigger_name) )
{
	self.cont = self.bomb["defusing_team"]
	self.name = (self.loc)

	println "waittill trigger " self.trigger_name
	$(self.trigger_name) waittill trigger

	local.player = parm.other
	//"local.player.dmteam", can be 'spectator', 'freeforall', 'allies' or 'axis'
      if (local.player.dmteam != self.bomb["planting_team"]) 
	{
		//goto bomb_waittill_set
		println "failed dmteam check" local.player.dmteam	
	}
	else
	{
		self.cont = (self.bomb["planting_team"] + "_set")

		local.counter = 0
		while ( (Isalive local.player) && (local.player cansee self level.bombusefov level.bomb_use_distance) && (local.player.useheld == 1) )
		{
			if (local.counter == 0)
			{
				local.player stopwatch (self.bomb["set_time"] * .1)
			}
			
			local.counter++
			wait .1
			if (local.counter >= self.bomb["set_time"])
			{
				if (self.loc != NIL)
					iprintlnbold ("A Bomb at the " + self.loc + " has been planted by the " + self.bomb["planting_team"] + "!")
				else
					iprintlnbold ("A Bomb has been planted by the " + self.bomb["planting_team"] + "!")

				if (self.bomb["planting_team"] == "allies")
					self playsound dfr_objective_o
				else
					self playsound den_objective_o

				thread bomb_waittill_defuse
				thread bomb_waittill_explode
				self.live = 1
				local.team = self.bomb["planting_team"]
				level.bomb_planted[local.team]++
				end
			}
		}

		if (local.counter > 0)
		{
			local.player stopwatch 0
		}

		println "usetrigger but failed check" 
	
		if !(local.player cansee self level.bombusefov level.bomb_use_distance)
			println "distance"
	}
}
end


// -----------------------------------------------------
// second thread... controls defusing_team using the trigger
// -----------------------------------------------------
bomb_waittill_defuse:

while ( $(self.trigger_name) )
{
	self.cont = (self.bomb["planting_team"] + "_set")
	local.name = self.loc
	self.name = (local.name + " [Planted]")

	$(self.trigger_name) waittill trigger

	local.player = parm.other
	
	//"local.player.dmteam", can be 'spectator', 'freeforall', 'allies' or 'axis'
	if (local.player.dmteam != self.bomb["defusing_team"])
	{      
		println "failed dmteam check" local.player.dmteam
		//goto bomb_waittill_defuse
	}
	else
	{
		self.cont = (self.bomb["defusing_team"] + "_diffuse")

		local.counter = 0
		while ( (Isalive local.player) && (local.player cansee self level.bombusefov  level.bomb_use_distance) && (local.player.useheld == 1) )
		{
			if (local.counter == 0)
			{
				local.player stopwatch (self.bomb["defuse_time"] * .1)
			}
			
			local.counter++

			wait .1
			if (local.counter >= self.bomb["defuse_time"])
			{
				if (self.loc != NIL)
					iprintlnbold ("A Bomb at the " + self.loc + " has been defused by the " + self.bomb["defusing_team"] + "!")
				else
					iprintlnbold ("A Bomb has been defused by the " + self.bomb["defusing_team"] + "!")

				if (self.bomb["defusing_team"] == "allies")
					self playsound dfr_diffused_d
				else
					self playsound den_diffused_d

				if ( level.win_on_defuse == 1 )
				{
					teamwin self.bomb["defusing_team"]
					end
				}

				else if ( level.win_on_defuse != 1 )
				{
					thread bomb_waittill_set //start first thread again
				}
				self.live = 0
				local.team = self.bomb["planting_team"]
				level.bomb_planted[local.team]--
				end
			}
		}

		if (local.counter > 0)
		{
			local.player stopwatch 0
		}
	}
}
end


// -----------------------------------------------------
// third thread... times the bomb and makes it explode at the right time
// -----------------------------------------------------
bomb_waittill_explode:

	self model items/explosive.tik
	self playsound plantbomb


	self loopsound bombtick
	
	local.start_time = level.time

	while (level.time < (local.start_time + self.bomb["tick_time"]) )
	{
		wait .1
		if (self.live != 1)
		{
			self stoploopsound
			end
		}
		if (level.time == (local.start_time + self.bomb["tick_time"] - 10) )
		{
			self stoploopsound
			self loopsound final_countdown
		}
 	}
 	self stoploopsound
	thread bomb_explode
end


// -----------------------------------------------------
// fourth thread... controls the explosion 
// -----------------------------------------------------
bomb_explode:

	self.cont = self.bomb["planting_team"]
	local.name = self.loc
	self.name = (local.name + " [Exploded]")

	if (self.thread != NIL)
		self exec self.thread

	if (self.loc != NIL && self.loc != "")
	{
		iprintlnbold ("The " + self.loc + " has been blown up by the " + self.bomb["planting_team"] + "!!")
	}

	$(self.trigger_name) remove
	
	if (self.bomb["jitter"] == "large")
	{
		thread jitter_large
	}
	else if (self.bomb["jitter"] == "local")
	{
		thread jitter_local self.origin
	}

	if (self.bomb["exploder_set"] != NIL && self.bomb["exploder_set"] != "none")
	{
		exec global/exploder.scr::explode self.bomb["exploder_set"]
	}
	
	if (self.bomb["explosion_fx"] != NIL && self.bomb["explosion_fx"] != "none")
	{
		self thread spawn_fx self.bomb["explosion_fx"]
	}
	
	if (self.bomb["explosion_sound"] != NIL && self.bomb["explosion_sound"] != "none")
	{
		self playsound self.bomb["explosion_sound"]
	}

	if (self.target != NIL && self.target != NULL)
	{
		if (self.target.destroyed_generic != NIL)
		{
			local.thread = self.target.destroyed_generic
			thread global/AIRborne_prefabs.scr::destroyed_generic local.thread self.target.origin self.target.angles
		}
		if (self.target.destroyed_model != NIL)
		{
			local.damaged = self.target waitthread spawn_damaged self.target.destroyed_model
			self.target remove
		}

		if (self.target.destroyed_generic == NIL && self.target)
		{
			self.target remove
		}
	}
	radiusdamage self.origin self.bomb["damage"] self.bomb["explosion_radius"]
	if (self.bomb["killarea"] != NIL && self.bomb["killarea"] != "none")
	{
		self.bomb["killarea"] volumedamage 1000
	}
	self hide
	
	self.live = 0
	
	self.exploded = 1
	local.team = self.bomb["planting_team"]
	level.target_destroyed[local.team]++

	// we delay the decrementing of level.bombs_planted so that the script has
	// time to determin the winner before the timelimit gets checked and hit
	wait 0.5
	level.bomb_planted[local.team]--

end


//----------------------------------
spawn_fx local.fx:
//----------------------------------

	local.temp = spawn script_model model local.fx
	local.temp.origin = self.origin
	local.temp anim start
	wait 5
	local.temp remove
end

//----------------------------------
spawn_damaged local.model:
//----------------------------------

	local.damaged = spawn script_model model local.model
	local.damaged.origin = self.origin
	local.damaged.angles = self.angles

end local.damaged

//----------------------------------
jitter_large:
//----------------------------------

	waitexec global/earthquake.scr .35 10 0 0
	waitexec global/earthquake.scr .23 6 0 0
	waitexec global/earthquake.scr 1 1 0 0
	waitexec global/earthquake.scr 1.25 .3 0 1

end

//----------------------------------
jitter_local local.o:
//----------------------------------

	waitthread quake .35 ( 9 7 4 ) local.o
	waitthread quake .23 ( 6 4 3 ) local.o
	waitthread quake 1 ( 1 0.8 1 ) local.o
	waitthread quake 1.25 ( 0.3 0.2 0.1 ) local.o

end

//----------------------------------
quake local.d local.m local.o:

	local.jitter = spawn func_viewjitter "targetname" "viewjitter" 
	local.jitter.origin = local.o
	local.jitter jitteramount local.m
	local.jitter duration local.d
	local.jitter radius 786

	wait local.d

	local.jitter remove

end
```

# xyz_Airborne_Mod\global\win.scr

```scr
// ******************************************************************
// 		Global Map Managing Script; v1.2 
// 			 by Sor
// -------------------------------------------------
//
// OPTIONS FOR teamwins SCRIPT:
// -----------------------------
// level.global_win["winner"] = "allies" 			// team who's won. Can be: "axis" or "allies" or "draw"
// level.global_win["win_sound"] = 1			// Play a sound?
// level.global_win["winscreen"] = 1			// Use this script's winscreen? (it will not be used if the "win_event" is "round_restart" since that's using teamwin)
// level.global_win["winscreen_hud"] = 0			// Keep or disable the player's HUD during the winscreen?
// level.global_win["winscreen_freeze"] = 0		// Freeze players during the winscreen?
// level.global_win["winevent"] = "map_restart" 	// what happens after this team has won? Can be: "map_restart"; "map_change" or "round_restart"
// level.global_win["winevent_delay"] = 10 		// Seconds before the "win_event" starts
// level.global_win["winevent_display"] =	1		// Location print what will happen (mapchange, maprestart or roundrestart) + the delay
// level.global_win["destination"] = "dm/mohdm1" 	// map to change to (if the "win_event" is "map_change")
// level.global_win["mapchange_keepstats"] = 0		// Keep player in same team with same weapon if the map is changed?
//
// OPTIONS FOR mapchange SCRIPT:
// -----------------------------
// level.global_mapchange["keepstats"] = 0		 // Keep player in same team with same weapon if the map is changed?
// level.global_mapchange["destination"] = "dm/mohdm1" // map to change to
// level.global_mapchange["delay"] = 10			 // delay before the change
// level.global_mapchange["display"] = 1			 // Location print the seconds before the map changes + to what map
//
//
// OPTIONS FOR maprestart SCRIPT:
// -------------------------------
// level.global_maprestart["delay"] = 10			 // delay before the restart
// level.global_maprestart["display"] = 1			 // Location print the seconds before the map restarts
//
// GLOBAL OPTIONS:
// ----------------
// level.global_win_scr["localization"] = "your text"  // This is the text locationprinted if the "Display" option is on. 
//									 // Use "Zeconds" in this string, to get it replaced by the seconds remaining
//
// AVAILABLE SCRIPTS:
// global/win.scr::maprestart
// global/win.scr::mapchange
// global/win.scr::teamwins
//

//*************************************
teamwins:
//*************************************
	
	local.continue = waitthread parse_teamwin_settings
	if (local.continue == 0)
		end

	level.win_stopscreen = NIL

	if (level.global_win["winevent"] != "round_start")
	{
		if (level.global_win["winscreen"] == 1)
		{
			local.undo_screen = 1
			thread screen_on level.global_win["winner"]

			if (level.global_win["winscreen_hud"] == 0)
			{
				local.redo_hud = 1
				drawhud 0
			}
			if (level.global_win["winscreen_freeze"] == 1)
			{
				freezeplayer
				for (local.i = 1; local.i <= $player.size; local.i++)
				{
					$player[local.i] nodamage
				}
				local.unfreeze = 1
			}
		}
	}
	if (level.global_win["win_sound"] == 1)
	{
		thread victory
	}

	if (level.global_win["winevent_delay"] > 1.0 && level.global_win["winevent_display"] == 1)
	{
		waitthread counter level.global_win["winevent_delay"]
	}
	else if (level.global_win["winevent_delay"] > 0)
	{
		wait level.global_win["winevent_delay"] 
	}

	println "Starting event..."

	// Undo all the fancy stuff
	if (local.redo_hud == 1)
		drawhud 1

	if (local.unfreeze == 1)
	{
		releaseplayer
		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			$player[local.i] takedamage
		}
	}

	// Restart the map
	if (level.global_win["winevent"] == "map_restart")
	{
		if (local.undo_screen == 1)
		{
			thread screen_off
		}

		for (local.i = 1; local.i <= $player.size; local.i++)
   		{
    			$player[local.i] vote no
    		}
    		local.allowvote = int(getcvar(g_allowvote))
    		setcvar "g_allowvote" 1

    		$player[1] callvote restart map

   		for (local.i = 1; local.i <= $player.size; local.i++)
   		{
    			$player[local.i] vote yes
    		}

		waitframe
    		setcvar "g_allowvote" local.allowvote
		end
	}
	// Change maps
	else if (level.global_win["winevent"] == "map_change")
	{
		if (local.undo_screen == 1)
		{
			thread screen_off
		}

		local.orig_nextmap = getcvar "nextmap"
		local.gametype = getcvar "g_gametype"

		setcvar "nextmap" level.global_win["destination"]
		setcvar "g_gametype" "0"

		if (level.global_win["mapchange_keepstats"] == 1)
		{
			bsptransition nextmap
		}
		else
		{
			leveltransition nextmap
		}

		setcvar "g_gametype" local.gametype
		waitframe
		setcvar "nextmap" local.orig_nextmap
		end
	}
	// Restart Round
	else 
	{
		if (level.global_win["winner"] != "draw")
		{
			teamwin level.global_win["winner"]
		}
		else
		{
			local.dmManager = spawn DM_Manager
			local.dmManager doroundtransition
		}
	}

end

//*************************************
parse_teamwin_settings:
//*************************************

	local.defaults = makeArray
	//settings			//default option
	"winner"			"ERROR"
	"win_sound"			0
	"winscreen"			0
	"winscreen_hud"		0
	"winscreen_freeze"	0
	"winevent"			"round_restart"
	"winevent_delay"		10
	"winevent_display"	1
	"destination"		""
	"mapchange_keepstats"	0
	endArray

	for (local.o = 1; local.o <= local.default.size; local.o++)
	{
		local.i = local.default[local.o][1]
		if (level.global_win[local.i] == NIL || level.global_win[local.i] == "")
		{
			level.global_win[local.i] = local.default[local.o][2]
		}
	}

	if (level.global_win["winner"] == "ERROR")
		local.pass = 0
	else if (level.global_win["win_event"] == "map_change" && level.global_win["destination"] == "")
		local.pass = 0
	else
		local.pass = 1


end local.pass

//*************************************
screen_on local.w:

	if (local.w != "draw")
	{
		setcvar "g_scoreboardpicover" ("textures/hud/" + local.w + "win")
	}

	while(level.win_stopscreen != 1)
	{
		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			$player[local.i] stufftext "+scores"
		}

		waitframe
	}

end

//*************************************
screen_off:

	level.win_stopscreen = 1
	setcvar "g_scoreboardpicover" ""

end

//*************************************
counter local.t:

	if (level.global_win_scr["localization"] == NIL)
		local.loc = ""
	else
		local.loc = level.global_win_scr["localization"]

	local.secs = waitthread split_line local.loc 1 " "
	for (local.f = 1; local.f <= local.secs[1].size; local.f++)
	{
		if (local.secs[1][local.f] == "Zeconds")
		{
			local.wl = local.f
			//break
		}
	}
	
	//form left string:
	if (local.wl != NIL)
	{
		local.left = ""
		for (local.x = 1; local.x < local.wl; local.x++)
		{
			local.left += (local.secs[1][local.x] + " ")
		}

		//form right string:
		local.right = ""
		for (local.p = (local.wl + 1); local.p <= local.secs[1].size; local.p++)
		{
			local.right += (" " + local.secs[1][local.p])
		}
	}

	if (local.left == NIL)
		local.left = ""

	if (local.right == NIL)
		local.right = ""

	huddraw_font 61 handle-18
	huddraw_rect 61 20 200 200 200
	huddraw_color 61 1.0 1.0 1.0
	huddraw_alpha 61 1.0
	for (local.wait = local.t; local.wait >= 0.000; local.wait -= 0.05)
	{
		huddraw_string 61 (local.left + local.wait + local.right)
		waitframe
	}

	waitframe
	for (local.i = 1.00; local.i >= 0.00; local.i -= 0.05)
	{
		huddraw_alpha 61 local.i
		waitframe
	}

end

//*************************************
mapchange:
//*************************************

	local.defaults = makeArray
	//settings			//default option
	"keepstats" 		0		 
	"destination" 		"ERROR" 
	"delay"			10			 
	"display"			1
	endArray

	for (local.o = 1; local.o <= local.default.size; local.o++)
	{
		local.i = local.default[local.o][1]
		if (level.global_mapchange[local.i] == NIL || level.global_mapchange[local.i] == "")
		{
			level.global_mapchange[local.i] = local.default[local.o][2]
		}
	}

	if (level.global_mapchange["destination"] == "ERROR")
		end

	if (level.global_mapchange["delay"] > 1.0 && level.global_mapchange["display"] == 1)
	{
		waitthread counter level.global_mapchange["delay"]
	}
	else if (level.global_mapchange["delay"] > 0)
	{
		wait level.global_mapchange["delay"] 
	}

	// Change maps
	local.orig_nextmap = getcvar "nextmap"
	local.gametype = getcvar "g_gametype"

	setcvar "nextmap" level.global_mapchange["destination"]
	setcvar "g_gametype" "0"

	if (level.global_win["mapchange_keepstats"] == 1)
	{
		bsptransition nextmap
	}
	else
	{
		leveltransition nextmap
	}

	setcvar "g_gametype" local.gametype
	waitframe
	setcvar "nextmap" local.orig_nextmap
	
end

//*************************************
maprestart:
//*************************************

	local.defaults = makeArray
	//settings			//default option
	"delay"			10			 
	"display"			1
	endArray

	for (local.o = 1; local.o <= local.default.size; local.o++)
	{
		local.i = local.default[local.o][1]
		if (level.global_maprestart[local.i] == NIL || level.global_maprestart[local.i] == "")
		{
			level.global_maprestart[local.i] = local.default[local.o][2]
		}
	}

	if (level.global_maprestart["delay"] > 1.0 && level.global_maprestart["display"] == 1)
	{
		waitthread counter level.global_maprestart["delay"]
	}
	else if (level.global_maprestart["delay"] > 0)
	{
		wait level.global_maprestart["delay"] 
	}


	// Restart map
	for (local.i = 1; local.i <= $player.size; local.i++)
   	{
    		$player[local.i] vote no
    	}
    	local.allowvote = int(getcvar(g_allowvote))
    	setcvar "g_allowvote" 1
	
    	$player[1] callvote restart map

   	for (local.i = 1; local.i <= $player.size; local.i++)
   	{
    		$player[local.i] vote yes
    	}

	waitframe
    	setcvar "g_allowvote" local.allowvote

end

//*************************************
victory:

	if (level.win_scr_sounds != 1)
	{
		waitthread victory_sounds
	}

	if (level.global_win["winner"] == "allies")
	{
		local.p = randomint(12)
		if (local.p == 0)
			local.p++

		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			if ($player[local.i].dmteam == "allies")
			{
				$player[local.i] playsound ("allies_victory" + local.p)
			}
		}
	}
	else if (level.global_win["winner"] == "axis")
	{
		local.p = randomint(18)
		if (local.p == 0)
			local.p++

		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			if ($player[local.i].dmteam == "axis")
			{
				$player[local.i] playsound ("axis_victory" + local.p)
			}
		}
	}

end

// By Elgan...from his strings.scr

// ----------------------------------------------------------------------------------------------------------------------
// Used to split a line of words into a array of words. return with word count
// localinfo == line to split
// local.say = say to admins input detected or not, set 1 usualy
// local.spacer = What to use to split the line. If none is set then " " will be used.
// usage local.wordarray = waitexec global/strings.scr::split_line ( STRING STRING , CONSOLE FEEDBACK, STRING SPACER)
//
//eg
//  local.wordarray = waitexec global/strings.scr::split_line "hello_mummy" 1 "_"
// local.wordarray is a const array
//
// local.wordarray[1] = array of words
// local.wordarray[2] word count
// local.wordarray[3] full string with " " spaces
//
// local.wordarray[1][1] is 'hello'
// local.wordarray[1][1] is 'mummy'
//
// local.wordarray[2] is 2 'two words'
//
// local.wordarray[3] is 'hello mummy'
// ----------------------------------------------------------------------------------------------------------------------

split_line local.info local.dont_say local.spacer:

	local.wordcount = 1

	if(local.spacer==NIL)
	{
		if(local.info[0] == "`")
		{
			local.spacer = "_"
			local.start = 1
		}
		else if(local.info[0] == " " || local.info[0] == "")
		{
			local.spacer = " "

			for(local.i = 0;local.i <= local.info.size;local.i++)
			{
				if(local.info[local.i] != " " && local.info[local.i] != "")
				{
					local.start = local.i
					break
				}
			}

		}
		else 
		{
			local.spacer = " "
			local.start = 0
		}
	}
	else
	{
		local.start = 0
		local.altcheck = 1
	}

	for(local.i=local.start;local.i<=local.info.size - 1;local.i++)
	{	
		if(local.info[local.i]!=local.spacer && local.info[local.i] != "`")
		{
			if(local.words[local.wordcount]==NIL)
			{
				local.words[local.wordcount]=""
			}

			local.words[local.wordcount] += local.info[local.i]
		}
		else
		{	
			if(local.altcheck != 1)
			{
				if(local.spacer == "_" && local.info[local.i + 1] == "`")	// if its like ui_hud 1. sud be ui_`hud so it knows:).
				{
					local.words[local.wordcount] += local.info[local.i]			
				}
				else if(local.spacer == "_" && local.info[local.i ] != "`")
				{
					local.wordcount++
				}
				else if(local.spacer == " " && local.info[local.i ] == " ")
				{
					if(local.i != local.info.size - 1)
					{
						if(local.info[local.i + 1] != " " && local.info[local.i + 1] != NIL)
						{
							local.wordcount++
						}
					}
				}
			}
			else
			{
				if(local.info[local.i ] == local.spacer)
				{
					local.wordcount++
				}
			}
		}
	}	

	if(local.spacer == "_")
	{
		local.actual = ""

		for(local.i=3;local.i<=local.words.size;local.i++)
		{
			if(local.i < local.words.size)
			{
				local.space = " "
			}
			else
			{
				local.space = ""
			}
			local.actual += ( local.words[local.i] + local.space )
		}

		if(local.dont_say != 1)
		{
			//exec global/ac/console_feedback.scr ( "> Input detected: " + local.actual )
		}
	}
	else
	{
		if(local.dont_say != 1)
		{
			//exec global/ac/console_feedback.scr ( "> Input detected: " + local.info)
			local.actual = local.info
		}
	}

end ( local.words::local.wordcount::local.actual) 


//*************************************
victory_sounds:

	local.master = spawn ScriptMaster

	//Global Victory - Allied
	local.master alias allies_victory1 sound/dialogue/Multiplayer/a/AMdfr_v_01a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias allies_victory2 sound/dialogue/Multiplayer/a/AMdfr_v_01h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias allies_victory3 sound/dialogue/Multiplayer/a/AMdfr_v_01j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias allies_victory4 sound/dialogue/Multiplayer/a/AMdfr_v_02a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias allies_victory5 sound/dialogue/Multiplayer/a/AMdfr_v_02j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias allies_victory6 sound/dialogue/Multiplayer/a/AMdfr_v_03a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias allies_victory7 sound/dialogue/Multiplayer/a/AMdfr_v_03h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias allies_victory8 sound/dialogue/Multiplayer/a/AMdfr_v_03j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias allies_victory9 sound/dialogue/Multiplayer/a/AMdfr_v_04h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias allies_victory10 sound/dialogue/Multiplayer/a/AMdfr_v_04j.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias allies_victory11 sound/dialogue/Multiplayer/a/AMdfr_v_06h.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "

	//Global Victory - Axis 
	local.master alias axis_victory1 sound/dialogue/Multiplayer/g/GRden_v_01a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias axis_victory2 sound/dialogue/Multiplayer/g/GRden_v_01c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias axis_victory3 sound/dialogue/Multiplayer/g/GRden_v_01i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Good job team!" maps "m dm obj moh train "
	local.master alias axis_victory4 sound/dialogue/Multiplayer/g/GRden_v_02a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias axis_victory5 sound/dialogue/Multiplayer/g/GRden_v_02b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias axis_victory6 sound/dialogue/Multiplayer/g/GRden_v_02c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias axis_victory7 sound/dialogue/Multiplayer/g/GRden_v_02d.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory is ours!" maps "m dm obj moh train "
	local.master alias axis_victory8 sound/dialogue/Multiplayer/g/GRden_v_03a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias axis_victory9 sound/dialogue/Multiplayer/g/GRden_v_03b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias axis_victory10 sound/dialogue/Multiplayer/g/GRden_v_03i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Victory!" maps "m dm obj moh train "
	local.master alias axis_victory11 sound/dialogue/Multiplayer/g/GRden_v_04a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias axis_victory12 sound/dialogue/Multiplayer/g/GRden_v_04b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias axis_victory13 sound/dialogue/Multiplayer/g/GRden_v_04c.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias axis_victory14 sound/dialogue/Multiplayer/g/GRden_v_04d.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias axis_victory15 sound/dialogue/Multiplayer/g/GRden_v_04i.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Outstanding performance!" maps "m dm obj moh train "
	local.master alias axis_victory16 sound/dialogue/Multiplayer/g/GRden_v_06a.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "
	local.master alias axis_victory17 sound/dialogue/Multiplayer/g/GRden_v_06b.wav soundparms 1.2 0.0 1.0 0.0 10000 10000 "local" streamed subtitle "Your parents would be proud." maps "m dm obj moh train "

	level.win_scr_sounds = 1
end
```

# xyz_Airborne_Mod\global\xmas_options.txt

```txt
/*
.:*~*:._.:*~*:._.:*~*:._.:*~*:._.:*~*:._.:*~*::*~*:._.:*~*:._.:*~*:._.:*~*:._.:*~*:._.:*~*:.
.     *                                                                                    .
.    /.\                Christmas Tree mod; by Sor                                         .
.   /..'\               --------------------------                             .      .    .
.   /'.'\        Based on Elgan's Christmas Tree mod and with the              _\/  \/_    .
.  /.''.'\       help of jv_map! Follow the instructions below                  _\/\/_     .
.  /.'.'.\       along the beautiful ASCII scenary!                         _\_\_\/\/_/_/_ .
. /'.''.'.\                                                                  / /_/\/\_\ \  .
. ^^^[_]^^^                                                                     _/\/\_     .
.                Date: 7 / 12 / 2008 (DD/MM/YY)                                 /\  /\     .
.                Version: BETA 1                                               '      '    .
.											   .
. 		-----------------------------------------------------			   .
.											   .
. BEFORE YOU START:								      	   .
. *****************								      	   .
. 										      	   .
. level.AIR_Xmas["Str1"]["Setting"] = Your Value					   .
. 										      	   .
. - Str1: 									      	   .
. -------										   .
. This is the word of your settings file, if you only use 1 settings file for spawning 1   .
. or more trees, then leave this string. HOWEVER if you wish to spawn more trees 	   .
. with different settings then you must do the following: 			       	   .
.											   .
. - COPY this file, and rename it.						       	   .
. - Rename every setting's first box (= str1)					      	   .
. - When executing this script; pass on the new filepath and			      	   .
. the new name you have given to the settings!					      	   .
.										 	   .
. - Setting: Do not change the "Setting" string!				           .
. ----------										   .
.											   .
. - Value: Insert your own value!							   .
. --------										   .
.											   .
. NOTE: that some settings are arrays! You notice this when a level.AIR_Xmas equals =	   .
. "makeArray"; In this case the values are on the line(s) below "makeArray" and above	   .
. "endArray". Str1 is still the same: level.AIR_Xmas["Str1"]["Setting"] = makeArray	   .
.											   .
.											   .
. USE: 											   .
. ***** 										   .
. Fill in settings here first, when you're done go to your mapscript after level waittill  .
. spawn and use this command:								   .
. 											   .
. thread global/xmas.scr::xmas_tree <origin> <angles> <settings_path> <settings_name>	   .
.											   .
. - <origin & angles>: ( X Y Z )						   	   .
. - <settings_path>: This is the path of your settings file (NO "" JUST WORDS!).           .
. Example: global/xmas_options.txt						           .
.											   .
. - <settings_name>: ( String ) Put the name of your settings here (= str1)		   .
.											   .
.:*~*:._.:*~*:._.:*~*:._.:*~*:._.:*~*:._.:*~*::*~*:._.:*~*:._.:*~*:._.:*~*:._.:*~*:._.:*~*:.
*/

/*
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
: +---------------------+						      	:
: |Tree Settings	|						      	:
: |-------------	|							:
: |Define your own tree!|							:
: +---------------------+							:
:										:
: TREE:										:
: -----										:
: "tree_name": Give your tree a name!						:
: "tree_model": ( String ) Set the model of the tree				:
: "tree_scale": ( Float ) Set the scale of the tree. Dimensions will be		:
:		adjusted to the scale. NO need to set the dimensions according	:
:		to the scale of the tree!					:
:										:
: "tree_angel": ( Integer ) Do you want an angel on the top of your tree?	:
: "tree_angelmodel": ( String ) Set the model of your angel			:
: "tree_angeldistance": ( Float) Distance of the angel from the top of the tree :
: "tree_light": ( Integer ) Do you want a light on the top of your tree?	:
: "tree_lightdistance": ( Float ) Distance of the light from the top of the tree:
:										:
:										:
: DIMENSIONS:									:
: -----------									:
: When setting another treemodel, its dimensions will differ from the 		:
: dimensions of the default tree. Use the following 4 settings to set the 	:
: correct dimension for your tree. 						:
:										:
: NOTE: No need to adjust these according to the SCALE of your tree, the script	:
: will take care of these calculations; set these according to SCALE 1!!	:
:										:
: "tree_height": ( Float ) Height of the tree 					:
: "tree_baseheight": ( Float ) Distance from the ground to baseheight 		:
: "tree_topwidth": ( Float ) Width at the top of the tree			:
: "tree_basewidth": ( Float ) Width at the base of the tree at baseheight	:
:										:
:										:
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
*/
tree_settings:

	level.AIR_Xmas["default"]["tree_name"] = "mytree"
	level.AIR_Xmas["default"]["tree_model"] = "static/tree_winter_midpine.tik"
	level.AIR_Xmas["default"]["tree_scale"] = 1.0

	level.AIR_Xmas["default"]["tree_angel"] = 1
	level.AIR_Xmas["default"]["tree_angelmodel"] = "player/allied_manon.tik"
	level.AIR_Xmas["default"]["tree_angeldistance"] = 20.00
	level.AIR_Xmas["default"]["tree_light"] = 1
	level.AIR_Xmas["default"]["tree_lightdistance"] = 50.00


	level.AIR_Xmas["default"]["tree_height"] = 440.00
	level.AIR_Xmas["default"]["tree_baseheight"] = 120.00
	level.AIR_Xmas["default"]["tree_topwidth"] = 20.00
	level.AIR_Xmas["default"]["tree_basewidth"] = 140.00

end

/*
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
: +---------------------+						      	:
: |TreeLights Settings	|						      	:
: |-------------	|							:
: |Define your own tree!|							:
: +---------------------+							:
:										:
: "winds": ( integer ) The number of times, the lights wind around the tree	:
: "degrees_apart": ( integer ) Degrees between each light			:
:										:
: "clockwise": ( Integer 1/0 ) Should the lights be spawned clockwise (1) or 	:
: 	       counter-clockwise (0)?						:
:										:
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
*/

lights_settings:

	level.AIR_Xmas["default"]["winds"] = 6
	level.AIR_Xmas["default"]["degrees_apart"] = 25
	level.AIR_Xmas["default"]["clockwise"] = 1


end

/*
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
: +---------------------+						      	:
: |Colour Settings	|						      	:
: |-------------	|							:
: |Define your own tree!|							:
: +---------------------+							:
:										:
: AVAILABLE COLOURS/OPTIONS:							:
: __________________________							:
: 										:
: Colour Preference	Brightness		Description			:
: -----------------------------------------------------------------------------	:
: "red_corona"				Red Coronas (spawns 2 per light)	:
: "white_corona"			White Coronas				:
: "orange_corona"			Orange Coronas				:
:										:
: "red_light" 		"1"		Red 	lights with viewlensflare	:
: "yellow_light"	"1"		Yellow 	lights with viewlensflare	:
: "green_light"		"1"		Green 	lights with viewlensflare	:
: "blue_light"		"1"		Blue 	lights with viewlensflare	:
: "white_light"		"1"		White 	lights with viewlensflare	:
: "orange_light"	"1"		Orange 	lights with viewlensflare	:
: "purple_light"	"1"		Purple 	lights with viewlensflare	:
:										:
: "random"		"1"		- This options picks 1 Random colour	:
: "all_random"		"1"		- This picks random colours		:
: "pattern"				- Create your own colour pattern! Set 	:
:					it in the colour_pattern thread below!	:
: "different"		"1"		- This picks random colours but the 	:
:					first won't equal the last colour!	:
: "ribbon" 		"1"		- In case you only want a ribbon!	:
: 					Note that the LINK settings must be	:
:					filled in!!!				:
:										:
: RIBBON COLOUR:								:
: ______________								:
:										:
: ( R G B )		R = Red; G = Green and B = Blue values!			:
:										:
:										:
: SETTINGS:									:
: _________									:
:										:
: "link": ( integer 1/0 ) Spawn a ribbon (= funcbeam) or not?			:
: "link_colour": ( R G B ) What colour does this ribbon have?			:
: "link_segments": ( integer ) Number for segments the ribbon (=funcbeam)	:
:										:
: "colour_scale": ( float ) Scale of the lights/coronas				:
: "colour": ( string ) Use one of the available COLOUR OPTIONS stated above	:
:										:
:										:
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
*/
colour_settings:


	level.AIR_Xmas["default"]["link"] = 1
	level.AIR_Xmas["default"]["link_colour"] = ( 1 0 0 )
	level.AIR_Xmas["default"]["link_segments"] = 10

	level.AIR_Xmas["default"]["colour_scale"] = 1
	level.AIR_Xmas["default"]["colour"] = makeArray
	//--------------------------------------------------------
	// COLOR/COLOR OPTION	      |  BRIGHTNESS (only lights)
	//	--------------------------------------
	// Set for patterns here too  |  Set also for patterns
	//--------------------------------------------------------
					
	"random" 			"1"

	endArray

end

/*
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
: +---------------------+						      	:
: |Animation Sequence	|						      	:
: |------------------	|							:
: |Define your own tree!|							:
: +---------------------+							:
:										:
: AVAILABLE ANIMATIONS:								:
: _____________________								:
:										:
: Colour: ( String ) Which colour/corona this anim has effect on, set nothing	:
:	  or "all" for it to have effect on all colours				:
:										:
: -----------------------------------------------------------------------------	:
: Animation	      	  Time between anims    Time blinked   	Colour		:
: -----------------------------------------------------------------------------	:
: "blink"	     	 ( Float )		( Float )	( String )	:
:  --> Makes the tree lights blink 						:
:										:
: "random_blink"	 ( Float )		( Float )	( String )	:
: --> Makes lights blink randomly						:
:										:
: "bright"	     	 ( Float )		( Float )	( String )	:
:  --> Makes the tree lights brighten up 					:
:										:
: "random_bright"      	 ( Float )		( Float )	( String )	:
: --> Makes lights brighten up randomly						:
:										:
: "spiral_blink_up"       ( Float )		( Float )	 ( String )	:
: --> Lights blink in order upward the spiral					:
:										:
: "spiral_blink_down"     ( Float )		( Float )	 ( String )	:
: --> Lights blink in order downward the spiral					:
:										:
: "spiral_bright_updown"  ( Float )		( Float )	 ( String )	:
: --> Lights blink in order first upward the spiral and then down again		:
:										:
: "spiral_bright_up"  	  ( Float )		( Float )	 ( String )	:
: --> Lights brighten up in order upward the spiral				:
:										:
: "spiral_bright_down"    ( Float )		( Float )	 ( String )	:
: --> Lights brighten up in order downward the spiral				:
:										:
: "spiral_bright_updown"  ( Float )		( Float )	 ( String )	:
: --> Lights brighten up in order first upward the spiral and then down again	:
:										:
:										:
: The animations you pick will remain looped until the level ends so choose	:
: the wait values wisely. These animations will probably cause some lag so	:
: don't use many lights and many trees.						:
:										:
:										:
: NO ANIMATIONS:								:
: ______________								:
:										:
: If you wish not to have any animations simple clear the all inserted values	:
: and insert "idle" or insert nothing!!						:
:										:
:										:
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
*/
animation_sequences:

	level.AIR_Xmas["default"]["anim_sequence"] = makeArray

	//animation		//time between anims	//time blinked		//colour light
	"blink"			6			1.5			"red_light"
	"random"_blink"		6			1.5
	"bright"		5			1.5
	"random_bright"		5			1.5

	"spiral_blink_up"	6			0.5
	"spiral_blink_down"	5			0.5			"white_corona"
	"spiral_blink_updown"	5			0.5
	
	"spiral_bright_up"	6			0.5
	"spiral_bright_down"	5			0.5
	"spiral_bright_updown"	5			0.5

	endArray

end

/*
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
: +---------------------+						      	:
: |Pattern Settings	|						      	:
: |-------------	|							:
: |Define your own tree!|							:
: +---------------------+							:
:										:
: AVAILABLE COLOURS/OPTIONS:							:
: __________________________							:
: 										:
: Colour Preference	Brightness		Description			:
: -----------------------------------------------------------------------------	:
: "red_corona"				Red Coronas (spawns 2 per light)	:
: "white_corona"			White Coronas				:
: "orange_corona"			Orange Coronas				:
:										:
: "red_light" 		"1"		Red 	lights with viewlensflare	:
: "yellow_light"	"1"		Yellow 	lights with viewlensflare	:
: "green_light"		"1"		Green 	lights with viewlensflare	:
: "blue_light"		"1"		Blue 	lights with viewlensflare	:
: "white_light"		"1"		White 	lights with viewlensflare	:
: "orange_light"	"1"		Orange 	lights with viewlensflare	:
: "purple_light"	"1"		Purple 	lights with viewlensflare	:
:										:
:										:
: Use these available colours to make your own colour pattern :D		:
:										:
.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.:^^:._.
*/
colour_pattern:

	level.AIR_Xmas["default"]["colour_pattern"] = makeArray

	//--------------------------------------------------------
	// COLOURS			//BRIGHTNESS (only lights)
	//--------------------------------------------------------

	//corona's
	"red_corona"
	"white_corona"
	"orange_corona"

	//lights with lensflare
	"red_light" 			"1"
	"yellow_light"			"1"
	"green_light"			"1"
	"blue_light"			"1"
	"white_light"			"1"
	"orange_light"			"1"
	"purple_light"			"1"

	endArray

end

/**********************************************
    ||::|:||   .--------,
    |:||:|:|   |_______ /        .-.
    ||::|:|| ."`  ___  `".    {\('v')/}
    \\\/\///:  .'`   `'.  ;____`(   )'____
     \====/ './  o   o  \|~     ^" "^   //
      \\//   |   ())) .  |Season        \
       ||     \ `.__.'  /|Greetings     //
       ||   _{``-.___.-'\|From Sor!     \
       || _." `-.____.-'`|    ___       //
       ||`        __ \   |___/   \_______\
     ."||        (__) \    \|     /
    /   `\/       __   vvvvv'\___/
    |     |      (__)        |
     \___/\                 /
       ||  |     .___.     |
       ||  |       |       |
       ||.-'       |       '-.
   jgs ||          |          )
       ||----------'---------'
***********************************************/


///////////////////////////////////////////////////////////
// Tells main script this is the correct settings file!	 //
//							 //
// 		    DON'T CHANGE!			 //
///////////////////////////////////////////////////////////
imAlive:

	local.message_in_a_bottle = "alive"

end local.message_in_a_bottle

```

# xyz_Airborne_Mod\global\xmas.scr

```scr
///////////////////////////
// Merry Christmas!
// And a Happy New Year!
//
// Season Greetings from Sor :)
///////////////////////////
//
// vars:
// -----
// level.AIR_Xmas = settings
// level.AIR_Xmas_light = lights
// level.AIR_Xmas_beam = funcbeams (ribbons)
// level.AIR_tree = Christmas Tree
//
// local.settingname: To be able to spawn more trees using the level. objects; 
// you can give each tree different settings by making:
// 	1. A copy of the settings file and rename it to something
//	2. Changing the string in the first [ ] box of each setting to a new name
//	3. Inserting that filepath and new name when execing this script
//
// TODO: More checks for "no free edicts"-errors?
//
xmas_tree local.origin local.angles local.file local.settingname:

	// Check if player has spawned enough trees
	// This helps prevent "no free edicts" errors
	if (level.total_trees == NIL)
	{
		level.total_trees = 0
	}
	if (level.total_trees == 5)
	{
		println "[Christmas::Tree]: You can't spawn more than 5 trees; to prevent crashes."
		end 
	}

	if (local.origin == NIL)
	{
		println "[AIR Xmas::Tree]: Invalid origin!"
	}
	if (local.angles == NIL)
	{
		local.angles = ( 0 0 0 )
	}

	if (local.file != NIL)
	{
		if (local.settingname == NIL)
		{
			println "[AIR Xmas::Tree]: Invalid settings name!"
			end
		}

		local.test = waitthread settings_test local.file
		if (local.test == NIL)
		{
			println "[AIR Xmas::Tree]: Invalid settings file!"
			end
		}
	}

	if (local.file == NIL )
	{
		local.file = global/xmas_options.txt
		local.settingname = "default"
	}

	// The get_xmas_settings script is expecting an array; So
	// I'll make a temporary array before defining the real one 
	// to the tree, below.
	local.files[1] = local.file
	local.files[2] = local.settingname

	local.model = waitthread get_xmas_settings "tree_model" local.files
	local.scale = waitthread get_xmas_settings "tree_scale" local.files
	local.name = waitthread get_xmas_settings "tree_name" local.files

	// The name is important for the spawning sequence
	// and the animations
	if (local.name == NIL || local.name == "")
	{
		println "[AIR Xmas::Tree]: Invalid tree name!!"
		end
	}
	// Check to see if the name of the tree has been
	// used already. End script if so.
	local.invalid = waitthread check_name local.name
	if (local.invalid == 1)
	{
		println "[AIR Xmas::Tree]: The tree name has already been used by another tree!!"
		end
	}

	if (level.AIR_tree == NIL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_tree.size + 1
	}

	// spawn tree
	level.AIR_tree[local.i] = spawn script_model 
	level.AIR_tree[local.i] model local.model
	level.AIR_tree[local.i].origin = local.origin
	level.AIR_tree[local.i].angles = local.angles
	level.AIR_tree[local.i] notsolid
	level.AIR_tree[local.i] scale local.scale

	level.AIR_tree[local.i].file[1] = local.file
	level.AIR_tree[local.i].file[2] = local.settingname
	level.AIR_tree[local.i].name = local.name
	level.AIR_tree[local.i].nr = local.i

	local.file = level.AIR_tree[local.i].file

	println "[AIR Xmas::Tree]: Tree " local.name " spawned!"	

	////////////////////////////////////////////////////////
	// Measurements and dimensions 				//
	////////////////////////////////////////////////////////
	// Defaults for tree_winter_midpine.tik:			//
	//									//
	// default_height = 440.00					//
	// default_basewidth = 120.00					//
	// default_topwidth = 20.00					//
	// default_baseheight = 140.00				//
	//									//
	////////////////////////////////////////////////////////

	local.default_height = waitthread get_xmas_settings "tree_height" local.file
	local.default_basewidth = waitthread get_xmas_settings "tree_baseheight" local.file
	local.default_topwidth = waitthread get_xmas_settings "tree_topwidth" local.file
	local.default_baseheight = waitthread get_xmas_settings "tree_basewidth" local.file

	// If scale is adjusted, redefine measurements...
	if (level.AIR_tree[local.i].scale != 1)
	{
		// get new scale application value
		local.scale_app = ( 1.0 / level.AIR_tree[local.i].scale )

		// get new measurements
		level.AIR_tree[local.i].height = ( local.default_height / local.scale_app )
		level.AIR_tree[local.i].baseheight = ( local.default_baseheight / local.scale_app )
		level.AIR_tree[local.i].topwidth = ( local.default_topwidth / local.scale_app )
		level.AIR_tree[local.i].basewidth = ( local.default_basewidth / local.scale_app )
	}
	else
	{
		level.AIR_tree[local.i].height = local.default_height
		level.AIR_tree[local.i].baseheight = local.default_baseheight
		level.AIR_tree[local.i].topwidth = local.default_topwidth
		level.AIR_tree[local.i].basewidth = local.default_basewidth
	}

	local.angel = waitthread get_xmas_settings "tree_angel" local.file
	local.light = waitthread get_xmas_settings "tree_light" local.file

	if (local.angel == 1)
	{
		local.angel_model = waitthread get_xmas_settings "tree_angelmodel" local.file
		local.angel_distance = waitthread get_xmas_settings "tree_angeldistance" local.file

		if (level.AIR_tree[local.i].scale != 1 )
		{
			// get new scale application value
			local.scale_app = ( 1.0 / level.AIR_tree[local.i].scale )
			level.AIR_tree[local.i].angel_dist = ( local.angel_distance / local.scale_app )
		}
		else 
		{
			level.AIR_tree[local.i].angel_dist = local.angel_distance
		}

		local.tree_angel = spawn script_model
		local.tree_angel model local.angel_model
		local.tree_angel.origin = level.AIR_tree[local.i].origin + ( 0 0 (level.AIR_tree[local.i].height + level.AIR_tree[local.i].angel_dist) )
		local.tree_angel.angles = level.AIR_tree[local.i].angles 
		local.tree_angel notsolid
		local.tree_angel scale ( level.AIR_tree[local.i].scale / 2 )

		level.AIR_tree[local.i].angel = local.tree_angel


		local.angel_sparks = spawn trigger_multiple "spawnflags" "128"
		local.angel_sparks.origin = local.tree_angel.origin - ( 0 0 30 )
		local.angel_sparks light 1.0 1.0 1.0 100
		local.angel_sparks setsize ( -10 -10 -100 ) ( 10 10 100 )
		local.angel_sparks setthread angel_sparks

		level.AIR_tree[local.i].angel_trig = local.angel_sparks

		println "[AIR Xmas::Tree]: Treetop Angel for Tree: " local.name " spawned!"
	}
	if (local.light == 1)
	{
		local.light_distance = waitthread get_xmas_settings "tree_lightdistance" local.file

		if (level.AIR_tree[local.i].scale != 1 )
		{
			// get new scale application value
			local.scale_app = ( 1.0 / level.AIR_tree[local.i].scale )
			level.AIR_tree[local.i].light_dist = ( local.light_distance / local.scale_app )
		}
		else 
		{
			level.AIR_tree[local.i].light_dist = local.light_distance
		}		
		local.tree_light = spawn script_model
		local.tree_light model "static/corona_reg.tik"
		local.tree_light.origin = level.AIR_tree[local.i].origin + ( 0 0 (level.AIR_tree[local.i].height + level.AIR_tree[local.i].light_dist) )
		local.tree_light.angles = level.AIR_tree[local.i].angles
		local.tree_light notsolid
		local.tree_light scale ( level.AIR_tree[local.i].scale * 3 )

		level.AIR_tree[local.i].toplight = local.tree_light

		println "[AIR Xmas::Tree]: Treetop Light for Tree: " local.name " spawned!"
	}

	thread spawn_decorations level.AIR_tree[local.i]

end


//=============================================================================================
// TREE DECORATIONS
// -----------------
// This thread spawns all the christmas lights and ribbons with the settings chosen 
// by the player.
// 
// You can retrieve your tree with the "get_tree" thread in this file like so:
//
//	local.tree = waitthread global/xmas.scr::get_tree "your_tree_name"
//
// Then you can adjust some settings from the xmas_options.txt file (copy&past the level. setting)
// in your mapscript and run this decorations-spawning script again! I only recommend this if 
// you wish to spawn another ribbon, not to spawn more lights!!
//
//=============================================================================================
spawn_decorations local.tree:

	local.file = local.tree.file
	local.tag = local.tree.name

	//////////////////////////
	// Get user settings
	//////////////////////////

	// Get spawning options
	local.loops = waitthread get_xmas_settings "winds" local.file
	local.degrees_away = waitthread get_xmas_settings "degrees_apart" local.file
	local.clockwise = waitthread get_xmas_settings "clockwise" local.file

	// Get colour/pattern options
	local.link = waitthread get_xmas_settings "link" local.file
	if (local.link == "1" || local.link == 1)
	{
		local.link_colour = waitthread get_xmas_settings "link_colour" local.file
		local.link_segments = waitthread get_xmas_settings "link_segments" local.file
	}

	local.colour_scale = waitthread get_xmas_settings "colour_scale" local.file
	local.colour = waitthread get_xmas_settings "colour" local.file
	if (local.colour[1][1] == "pattern")
	{
		local.pattern = waitthread get_xmas_settings "colour_pattern" local.file
	}

	/////////////////////////////////
	// Cheers, Elgan and jv!!
	// ty helping with this script
	/////////////////////////////////

	// Get PI
	exec global/maths.scr

	local.height = local.tree.baseheight
	local.gain_height = ( local.tree.height - local.height ) / local.loops
	local.number_of_lights = ( 360 / local.degrees_away )
	local.gain_height = (local.gain_height / local.number_of_lights)

	local.loops = 360 * local.loops
	local.baseheight = local.height
		
	local.start = 0
	local.end = local.loops
	local.add = local.degrees_away

	//////////////////////////////////////////////////////////
	// Count the amount of lights that will be spawned!
	// If too many, break off the spawn.
	//
	// + 1 because I'm more accurate than MoHAA's engine;
	// local.loops has been multiplied by 360 earlier
	//
	local.amount_lights = ( local.loops / local.degrees_away ) + 1
	local.amount_lights = int(local.amount_lights)
	if ( local.amount_lights >= 115 )
	{
		println ("[Christmas::Tree]: Dangerous amount of lights (= " + local.amount_lights + ") that will be spawned!!")
		println "[Christmas::Tree]: Free Edict cap could be breached; terminating sequence."
		waitthread kill_tree local.tree
		end
	}

	local.amount = 0
	for (local.i = local.start; local.i <= local.end; local.i += local.add)
	{
		// most parts modified from elg's script	
		local.radius = waitthread get_diameter local.tree local.height
		local.location = local.tree.origin 
		if (local.clockwise == "1" || local.clockwise == 1)
		{
			local.radian = (( -local.i * level.PI) / 180 )
		}
		else
		{
			local.radian = ((local.i * level.PI) / 180 )
		}

		local.cos = ( waitthread global/maths.scr::cos local.radian * local.radius )
		local.sin = ( waitthread global/maths.scr::sin local.radian * local.radius )

		local.location = local.location + ( local.sin local.cos local.height )

		local.height += local.gain_height

		if (local.pattern != NIL && local.colour[1][1] == "pattern")
		{
			local.info = waitthread pattern local.pattern local.location local.colour_scale local.colour[1][2] local.tag local.lastcolour
		}
		else if (local.colour[1][1] == "ribbon")
		{
			if (local.link == "1" || local.link == 1)
			{
				local.info = waitthread ribbon local.location local.tag
			}
		}
		else
		{
			local.info = waitthread spawn_handler local.colour local.location local.colour_scale local.tag local.lastcolour 
		}
		
		if (local.info == NIL)
		{
			waitthread kill_tree local.tree
			end
		}

		local.lastcolour = local.info[1]
		local.corona[local.amount] = local.info[2]

		if (local.link == "1" || local.link == 1)
		{
			if (local.amount > 0)
			{
				local.previous = local.amount - 1
				local.ribbon = waitthread linkem local.corona[local.previous] local.corona[local.amount] local.link_colour local.link_segments local.tag
			}
		}

		local.amount++
	}

	level.total_trees++
	println "[AIR Xmas::Decorations]: All decorations for Tree: " local.tag " spawned!"

	// Then go to the last thread: the animations :)
	// might need to pass more vars
	if (local.colour[1][1] == "ribbon")
	{
		waitthread del_help local.tag
	}
	else
	{
		thread tree_animations local.tree
	}
	
end

//===============================================================
// GET DIAMETER
// -------------
// by Elg. I don't know what he's doing here :) 
// 
//===============================================================
get_diameter local.tree local.height:

	local.result = (local.tree.basewidth -  (local.tree.basewidth - local.tree.topwidth) / (local.tree.height - local.tree.baseheight) * (local.height - local.tree.baseheight) )

end local.result


//===============================================================
// TREE ANIMATIONS
// ---------------
// This thread handles the animations a user has inserted in 
// his options .txt file! It automatically shuts down if
// he didn't insert anything at all.
//
//===============================================================
tree_animations local.tree:

	local.file = local.tree.file
	local.tag = local.tree.name
	
	while(local.tree != NIL && local.tree != NULL)
	{
		local.anims = waitthread get_xmas_settings "anim_sequence" local.file

		if (local.anims.size < 1 || local.anims[1][1] == "idle")
			end
		
		for (local.i = 1; local.i <= local.anims.size; local.i++)
		{
			// Activate -  threadname    	-    time between anims  -  time blinked/time anim takes - 	Colour   	-  	 tag
			//------------------------------------------------------------------------------------------------------------------
			if (local.anims[local.i].size == 3 && local.tree.anim_pause != 1)
			{
			waitthread local.anims[local.i][1] local.anims[local.i][2] local.anims[local.i][3] NIL local.tag
			}
			else if (local.anims[local.i].size > 3 && local.tree.anim_pause != 1)
			{
			waitthread local.anims[local.i][1] local.anims[local.i][2] local.anims[local.i][3] local.anims[local.i][4] local.tag
			}	
		}

		if (local.tree.anim_pause != 1)
			wait 0.5
		else
			wait 4
	}

end

//=========================================================================================
// SPAWN HANDLER - Handles the spawning of the Christmas lights
// ------------------------------------------------------------
// This handles individual colours; the Random(-one) colour setting; the Random-all colour 
// setting and the difference colour settings
//
// local.colour: The array containing the colour preferences or random settings
//	- local.colour[1][1]: Colour preference
//	- local.colour[1][2]: Brightness setting
//
// local.origin: Location where the new light should spawn
// local.scale: User-set scale
// local.tag: Tag for the light so we can retrieve them later on
// local.lastcolour: Holds the setting of what the colour of the previous light was
//
//=========================================================================================
spawn_handler local.colour local.origin local.scale local.tag local.lastcolour:

	if (local.colour[1][1] == "random")
	{
		if (local.lastcolour == NIL)
		{
			// get all colours
			local.random_colour = waitthread all_colours
			// pick one of them
			local.picky = randomint ((local.random_colour.size) + 1)
			if (local.picky == 0)
			{
				local.picky++
			}
			local.chosen_colour = local.random_colour[local.picky][1]
		
			// Set the colour to be spawn 
			local.lastcolour = local.chosen_colour
			// Spawn the colour light
			if (local.colour[1].size == 1)
				local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag NIL
			else
				local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag local.colour[1][2]
			
			end (local.lastcolour::local.xmas_light)
		}
		else 
		{
			// This makes sure the last colour used always stays the same
			// because the player wanted the tree's lights in 1 random colour
			local.chosen_colour = local.lastcolour
			if (local.colour[1].size == 1)
				local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag NIL
			else
				local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag local.colour[1][2]

			end (local.chosen_colour::local.xmas_light)
		}
	}
	else if (local.colour[1][1] == "different")
	{
		// get all colours
		local.random_colour = waitthread all_colours

		for (local.o = 0; local.o < 1; local.o = local.o)
		{
			// pick one of them
			local.picky = randomint ((local.random_colour.size) + 1)
			if (local.picky == 0)
			{
				local.picky++
			}
			local.chosen_colour = local.random_colour[local.picky][1]

			if (local.chosen_colour != local.lastcolour)
			{
				local.o = 1

				// Spawn the light
				if (local.colour[1].size == 1)
					local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag NIL
				else
					local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag local.colour[1][2]

				local.lastcolour = local.chosen_colour
				end (local.lastcolour::local.xmas_light)
			}
		}
	}
	else if (local.colour[1][1] == "random_all")
	{
		// get all colours
		local.random_colour = waitthread all_colours

		// pick one of them
		local.picky = randomint ((local.random_colour.size) + 1)
		if (local.picky == 0)
		{
				local.picky++
		}
		local.chosen_colour = local.random_colour[local.picky][1]
		if (local.colour[1].size == 1)
			local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag NIL
		else
			local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag local.colour[1][2]

		end (local.chosen_colour::local.xmas_light)
	}
	else 
	{
		if (local.colour[1].size == 1)
			local.xmas_light = waitthread local.colour[1][1] local.origin local.scale local.tag NIL
		else
			local.xmas_light = waitthread local.colour[1][1] local.origin local.scale local.tag local.colour[1][2]

		local.lastcolour = local.colour[1][1]
		end (local.lastcolour::local.xmas_light)
	}

end NIL

//=========================================================================================
// SPAWN PATTERN
// -------------
// This script spawns the lights according to the pattern the user has defined.
// 
// local.pattern: Array with the colour pattern in order
// local.origin: Location for the light to be spawned
// local.scale: Scale of the light
// local.tag: Name for the light so we can retrieve it later
// local.lastcolour: Last Colour in the pattern that has been spawned
//
//=========================================================================================
pattern local.pattern local.origin local.scale local.bright local.tag local.lastcolour:

	if (local.lastcolour == NIL)
	{
		local.chosen_colour = local.pattern[1][1]
		local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag local.bright
		local.lastcolour = 1

		end (local.lastcolour::local.xmas_light)
	}
	else
	{
		// Pick next colour in line
		local.n = local.lastcolour + 1
		if (local.pattern.size < local.n)
		{
			local.n = 1
		}
		// If this doesn't exist, start back at 1
		//if (local.pattern[local.n][1] == NIL)
		//{
		//	local.n = 1
		//}

		local.chosen_colour = local.pattern[local.n][1]
		local.xmas_light = waitthread local.chosen_colour local.origin local.scale local.tag local.bright
		local.lastcolour = local.n

		end (local.lastcolour::local.xmas_light)
	}

end NIL

//===============================================================
// LINK 2 LIGHTS (RIBBON)
// ----------------------
// 
// local.prev_corona = Starting corona for the beam
// local.current_corona = Ending corona for the beam
// local.colour = Beam colour ( R G B )
// local.segments = Number of segments for the beam
// local.tag = Name for the beam so we can find it back
//
//===============================================================
linkem local.prev_corona local.current_corona local.colour local.segments local.tag:

	if (level.AIR_Xmas_beam[local.tag] == NIL || level.AIR_Xmas_beam[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_beam[local.tag].size + 1
	}

	// check some settings
	if(local.segments == NIL)
	{
		local.segments = 1
	}
	if(local.colour == NIL)
	{
		local.colour = ( 1 1 1 )
	}

	//red corona resolvement (spawns 2)
	if(local.prev_corona.size > 1)
	{
		local.prev_corona = local.prev_corona[1]
	}

	if(local.current_corona.size > 1)
	{
		local.current_corona = local.current_corona[1]
	}

	level.AIR_Xmas_beam[local.tag][local.i] = spawn funcbeam
	level.AIR_Xmas_beam[local.tag][local.i].origin = local.prev_corona.origin
	level.AIR_Xmas_beam[local.tag][local.i] endpoint local.current_corona.origin
	level.AIR_Xmas_beam[local.tag][local.i] color local.colour
	level.AIR_Xmas_beam[local.tag][local.i] numsegments local.segments
	level.AIR_Xmas_beam[local.tag][local.i] activate 

end level.AIR_Xmas_beam[local.tag][local.i]


//===============================================================
// SPAWN RIBBON
// ------------
// If players only want a ribbon; then this threads helps the 
// funcbeam, which makes the ribbon, guide its way to the
// correct shape (= a spiral).
// 
// local.origin: Location for the light to be spawned
// local.tag: Name for the light so we can retrieve it later
//
// These helper entities will be deleted later.
//
//===============================================================
ribbon local.origin local.tag:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}

	level.AIR_Xmas_light[local.tag][local.i] = spawn script_origin 
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i].helper = 1

	local.lastcolour = NIL

end (local.lastcolour::level.AIR_Xmas_light[local.tag][local.i])


//===============================================================
// COLOUR ARRAY
// ------------
// This returns all available colours 
// in an array to the scripts who need it!
//
// USAGE: local.colours = waitthread global/xmas.scr::all_colours
//
//===============================================================
all_colours:

	local.colours = makeArray

	//corona's
	"red_corona"
	"white_corona"
	"orange_corona"

	//lights with lensflare
	"red_light"
	"yellow_light"
	"green_light"
	"blue_light"
	"white_light"
	"orange_light"
	"purple_light"
	
	endArray

end local.colours


// **************************************************************************************************	//
//																	//
//					SETTINGS, CHECK AND CONTROL SCRIPTS							//
//					___________________________________							//
//																	//
//	These scripts retrieve settings, check for invalids, delete entities, retrieves info...		//
//																	//
// **************************************************************************************************	//

//===============================================================
// Get Xmas Settings
// -----------------
//
// This script is used to get the most recent settings used
// for this Christmas script.
//
// local.cmd = ( String ) setting to retrieve (if it exists)
// local.file = path of the settings .txt file
//		    -> NO STRING!
//
//===============================================================
get_xmas_settings local.cmd local.file:

	if (local.cmd == NIL || local.cmd == "")
		end NIL

	// Filepath
	if (local.file[1] == NIL)
		end NIL	

	// Settings name
	if (local.file[2] == NIL)
		end NIL

	local.setting = local.file[2]
	local.filepath = local.file[1]

	if (level.AIR_Xmas == NIL)
	{
		local.test = waitthread settings_test local.filepath
		if (local.test == NIL)
		{
			println "[AIR Xmas::Tree]: Invalid settings file!"
			end NIL
		}
		waitthread local.filepath::tree_settings
		waitthread local.filepath::colour_settings
		waitthread local.filepath::lights_settings
		waitthread local.filepath::animation_sequences
		waitthread local.filepath::colour_pattern
	}

	

	if (level.AIR_Xmas[local.setting][local.cmd] == NIL)
	{
		println "[AIR Xmas::Get_Settings]: Setting/Command does not exist!"
		end NIL
	}

	end level.AIR_Xmas[local.setting][local.cmd]

end

//===============================================================
// Check For Settings File
// -----------------------
// This performs a sequence which checks for a response
// from the settings file in question.
//
// The only valid response is "alive"; if you change this
// in your settings file, this script will no longer work!
//
// local.settings_file = path of your settings .txt (if it exist)
//				 -> NO STRING!
//
//===============================================================
settings_test local.settings_file:

	if (local.settings_file == NIL)
		end NIL

	local.checking_if_script_isalive = waitthread local.settings_file::imAlive

	if (local.checking_if_script_isalive == NIL)
	{
		end NIL
	}
	// if valid
	else if (local.checking_if_script_isalive == "alive")
	{
		end local.checking_if_script_isalive
	}
	else
	{
		end NIL
	}

end NIL

//===================================================================
// DELETE TREE
// -----------
// PURPOSE: If a fatal error has occured, the script takes no
//		chances and removes everything it had made so far!
//
// local.tree: ( entity ) The tree entity with all attached vars
//
// Version without light & ribbon deletions
//
//===================================================================
kill_tree local.tree:

	println "[AIR Xmas::Fatal Error]: Cutting down tree..."

	// Kill Angel and blow toplight
	local.tree.angel remove
	local.tree.toplight remove
	local.tree.angel_trig remove
	waitframe
	
	// Clean all vars:
	local.tree.file = NIL
	local.tree.name = NIL
	local.tree.nr = NIL
	
	local.tree.height = NIL
	local.tree.baseheight = NIL
	local.tree.topwidth = NIL
	local.tree.basewidth = NIL

	// Cut down tree
	local.tree delete
	waitframe

	if (local.tree == NULL || local.tree == NIL)
	{
		println "[AIR Xmas::Fatal Error]: TIMBER!!"
	}

	level.total_trees--

end

//===============================================================
// DELETE HELPER ENTITIES
// ----------------------
// If the user only wanted a ribbon, then this deletes
// all the helper script_origins which helps form the ribbon.
//
// local.tag = ( String ) the name of your tree
//
//===============================================================
del_help local.tag:

	if (level.AIR_Xmas_light[local.tag] == NIL)
		end

	for (local.i = 1; local.i <= level.AIR_Xmas_light[local.tag].size; local.i++)
	{
		if (level.AIR_Xmas_light[local.tag][local.i].helper == 1)
		{
			level.AIR_Xmas_light[local.tag][local.i].tag = NIL
			level.AIR_Xmas_light[local.tag][local.i] delete
			println ("entity " + local.i + " deleted")
		}
	}

	level.AIR_Xmas_light = NIL

end

//===============================================================
// TREE NAME CHECK
// ----------------
// This checks if the Tree Name inserted by the user isn't 
// already used yet. I do this because if he uses the same name
// for every tree, it could mess up the animation and deletion
// sequences
//
// local.name = ( String ) the name of your tree
//
//===============================================================
check_name local.name:

	for (local.i = 1; local.i <= level.AIR_tree.size; local.i++)
	{
		if (level.AIR_tree[local.i].name == local.tag)
		{
			local.match_found = 1
			end local.match_found
		}
	}

end NIL

//===============================================================
// RETRIEVE TREE
// -------------
// Get the Tree entity you want by using the name you
// have given it!
//
// local.name = ( String ) the name of your tree
//
//===============================================================
get_tree local.name:

	if (local.name == NIL || local.name == "")
	{
		end NIL
	}
	
	for (local.i = 1; local.i <= level.AIR_tree.size; local.i++)
	{
		if(level.AIR_tree[local.i].name == local.name)
		{
			end level.AIR_tree[local.i]
		}
	}

end NIL

//===============================================================
// HIDE ALL LIGHTS
// ---------------
// If you want to disable/hide all lights in your christmas tree
// then activate this script with the name of your tree!
//
// local.tag = ( String ) the name of your tree
//
//===============================================================
hideall_lights local.tag:

	if(local.tag == NIL)
		end

	if (level.AIR_Xmas_light[local.tag] != NIL)
	{
		local.hidden = 1

		for (local.i = 1; local.i <= level.AIR_Xmas_light[local.tag].size; local.i++)
		{
			level.AIR_Xmas_light[local.tag][local.i] hide
		}
	}

	if (local.hidden == 1)
		println "[AIR Xmas::Hide Light]: All lights successfully hidden!"
	else
		println "[AIR Xmas::Hide Light]: Nothing hidden!!"
	

end

//===============================================================
// SHOW ALL LIGHTS
// ---------------
// If you want to enable/show all lights in your christmas tree
// after you've hidden them, then activate this script 
// with the name of your tree!
//
// local.tag = ( String ) the name of your tree
//
//===============================================================
showall_lights local.tag:

	if(local.tag == NIL)
		end

	if (level.AIR_Xmas_light[local.tag] != NIL)
	{
		local.shown = 1

		for (local.i = 1; local.i <= level.AIR_Xmas_light[local.tag].size; local.i++)
		{
			level.AIR_Xmas_light[local.tag][local.i] show
		}
	}

	if (local.shown == 1)
		println "[AIR Xmas::Show Light]: All lights successfully shown!"
	else
		println "[AIR Xmas::Show Light]: Nothing shown!!"

end

//===============================================================
// HIDE ALL RIBBONS
// ----------------
// If you want to disable/hide all ribbons in your christmas tree
// then activate this script with the name of your tree!
//
// local.tag = ( String ) the name of your tree
//
//===============================================================
hideall_ribbons local.tag:

	if(local.tag == NIL)
		end

	if (level.AIR_Xmas_beam[local.tag] != NIL)
	{
		local.hidden = 1

		for (local.i = 1; local.i <= level.AIR_Xmas_beam[local.tag].size; local.i++)
		{
			level.AIR_Xmas_beam[local.tag][local.i] deactivate
		}
	}
	
	if (local.hidden == 1)
		println "[AIR Xmas::Hide Ribbon]: All ribbons successfully hidden!"
	else
		println "[AIR Xmas::Hide Ribbon]: Nothing hidden!!"

end

//===============================================================
// SHOW ALL RIBBONS
// ----------------
// If you want to enable/show all ribbons in your christmas tree
// after you've hidden them, then activate this script 
// with the name of your tree!
//
// local.tag = ( String ) the name of your tree
//
//===============================================================
showall_ribbons local.tag:

	if(local.tag == NIL)
		end

	if (level.AIR_Xmas_beam[local.tag] != NIL)
	{
		local.shown = 1

		for (local.i = 1; local.i <= level.AIR_Xmas_beam[local.tag].size; local.i++)
		{
			level.AIR_Xmas_beam[local.tag][local.i] activate
		}
	}

	if (local.shown == 1)
		println "[AIR Xmas::Show Ribbon]: All ribbons successfully shown!"
	else
		println "[AIR Xmas::Show Ribbon]: Nothing shown!!"

end

//===============================================================
// PAUSE ANIMATIONS
// ----------------
// If you want to PAUSE the animation sequences of your
// christmas tree then use this thread with the name of your
// tree to do so. 
//
// local.name = ( String ) the name of your tree
//
// NOTE: The animations will only pause if this script has 
// completed running and if the current animation has ended!!
//
//===============================================================
pause_anim local.name:

	if(local.name == NIL)
		end

	for (local.i = 1; local.i <= level.AIR_tree.size; local.i++)
	{
		if (level.AIR_tree[local.i].name == local.name)
		{
			level.AIR_tree[local.i].anim_pause = 1
			local.paused = 1
		}
	}

	if (local.paused == 1)
		println "[AIR Xmas::Pause]: Animations successfully PAUSED!"
	else
		println "[AIR Xmas::Pause]: Animations UNsuccessfully PAUSED; check if you inserted the correct name for your tree!"
end

//===============================================================
// UNPAUSE ANIMATIONS
// ------------------
// If you want to UNPAUSE the animation sequences of your
// christmas tree after you paused it then use this thread 
// with the name of your tree to do so. 
//
// local.name = ( String ) the name of your tree
//
// NOTE: The animations will start running at about 3 seconds
// after you executed this thread!
//
//===============================================================
unpause_anim local.name:

	if(local.name == NIL)
		end

	for (local.i = 1; local.i <= level.AIR_tree.size; local.i++)
	{
		if (level.AIR_tree[local.i].name == local.name)
		{
			level.AIR_tree[local.i].anim_pause = NIL
			local.unpaused = 1
		}
	}

	if (local.unpaused == 1)
		println "[AIR Xmas::Unpause]: Animations successfully UNPAUSED!"
	else
		println "[AIR Xmas::Unpause]: Animations UNsuccessfully UNPAUSED; check if you inserted the correct name for your tree!"

end

//===============================================================
// ANGEL SPARKS
// ------------
// When the Angel on top of the tree (if chosen one) gets 
// shot at, it will release these sparks.
//
//===============================================================
angel_sparks:

	self nottriggerable

	local.sparks = spawn script_model model "emitters/welding_spark.tik"
	local.sparks.origin = self.origin + ( 0 0 60 )
	local.sparks notsolid

	wait 1
	self triggerable
	wait 1

	local.sparks remove

end


// **************************************************************************************************	//
//																	//
//						  CHRISTMAS COLOUR SCRIPTS							//
//						____________________________							//
//																	//
//	The easiest part lol... The threads are very similar (ofc because only the colour changes)	//
//																	//
// **************************************************************************************************	//


//===============================================================
// RED LIGHT (viewlensflare)					
// ------------------------
//
// local.origin = ( X Y Z ) place on the tree 
// local.scale = scale of the corona
// local.tag = name of the tree - so we can find them back
// local.bright =  viewlensflare bright or not?
//
//===============================================================
red_light local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "fx/searchlight.tik" spawnflags 1
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale
	
	if (local.bright == "1" || local.bright == 1)
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  1.0 0.0 0.0 0.01
		level.AIR_Xmas_light[local.tag][local.i].bright = 1
	}
	else
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  1.0 0.0 0.0 0.0
		level.AIR_Xmas_light[local.tag][local.i].bright = 0
	}	

	level.AIR_Xmas_light[local.tag][local.i].colour = "red_light"

end level.AIR_Xmas_light[local.tag][local.i]

//===============================================================
// YELLOW LIGHT (viewlensflare)					
// ----------------------------
//
// local.origin = ( X Y Z ) place on the tree 
// local.scale = scale of the corona
// local.tag = name of the tree - so we can find them back
// local.bright = viewlensflare bright or not?
//
//===============================================================
yellow_light local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "fx/searchlight.tik" spawnflags 1
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale
	
	if (local.bright == "1" || local.bright == 1)
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.9 0.7 0.0 0.01
		level.AIR_Xmas_light[local.tag][local.i].bright = 1
	}
	else
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.9 0.7 0.0 0.0
		level.AIR_Xmas_light[local.tag][local.i].bright = 0
	}	

	level.AIR_Xmas_light[local.tag][local.i].colour = "yellow_light"

end level.AIR_Xmas_light[local.tag][local.i]

//===============================================================
// GREEN LIGHT (viewlensflare)					
// ---------------------------
//
// local.origin = ( X Y Z ) place on the tree 
// local.scale = scale of the corona
// local.tag = name of the tree - so we can find them back
// local.bright = viewlensflare bright or not?
//
//===============================================================
green_light local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "fx/searchlight.tik" spawnflags 1
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale
	
	if (local.bright == "1" || local.bright == 1)
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.0 1.0 0.0 0.01
		level.AIR_Xmas_light[local.tag][local.i].bright = 1
	}
	else
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.0 1.0 0.0 0.0
		level.AIR_Xmas_light[local.tag][local.i].bright = 0
	}	

	level.AIR_Xmas_light[local.tag][local.i].colour = "green_light"

end level.AIR_Xmas_light[local.tag][local.i]

//===============================================================
// WHITE LIGHT (viewlensflare)					
// ---------------------------
//
// local.origin = ( X Y Z ) place on the tree 
// local.scale = scale of the corona
// local.tag = name of the tree - so we can find them back
// local.bright = viewlensflare bright or not?
//
//===============================================================
white_light local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "fx/searchlight.tik" spawnflags 1
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale
	
	if (local.bright == "1" || local.bright == 1)
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  1.0 1.0 1.0 0.01
		level.AIR_Xmas_light[local.tag][local.i].bright = 1
	}
	else
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  1.0 1.0 1.0 0.0 
		level.AIR_Xmas_light[local.tag][local.i].bright = 0
	}	

	level.AIR_Xmas_light[local.tag][local.i].colour = "white_light"

end level.AIR_Xmas_light[local.tag][local.i]


//===============================================================
// BLUE LIGHT (viewlensflare)					
// --------------------------
//
// local.origin = ( X Y Z ) place on the tree 
// local.scale = scale of the corona
// local.tag = name of the tree - so we can find them back
// local.bright = viewlensflare bright or not?
//
//===============================================================
blue_light local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "fx/searchlight.tik" spawnflags 1
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale
	
	if (local.bright == "1" || local.bright == 1)
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.0 0.0 1.0 0.01
		level.AIR_Xmas_light[local.tag][local.i].bright = 1
	}
	else
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.0 0.0 1.0 0.0
		level.AIR_Xmas_light[local.tag][local.i].bright = 0
	}	

	level.AIR_Xmas_light[local.tag][local.i].colour = "blue_light"

end level.AIR_Xmas_light[local.tag][local.i]


//===============================================================
// PURPLE LIGHT (viewlensflare)					
// ----------------------------
//
// local.origin = ( X Y Z ) place on the tree 
// local.scale = scale of the corona
// local.tag = name of the tree - so we can find them back
// local.bright = viewlensflare bright or not?
//
//===============================================================
purple_light local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "fx/searchlight.tik" spawnflags 1
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale
	
	if (local.bright == "1" || local.bright == 1)
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.9 0.0 0.7 0.01
		level.AIR_Xmas_light[local.tag][local.i].bright = 1
	}
	else
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.9 0.0 0.7 0.0
		level.AIR_Xmas_light[local.tag][local.i].bright = 0
	}	

	level.AIR_Xmas_light[local.tag][local.i].colour = "purple_light"

end level.AIR_Xmas_light[local.tag][local.i]



//===============================================================
// ORANGE LIGHT (viewlensflare)					
// ----------------------------
//
// local.origin = ( X Y Z ) place on the tree 
// local.scale = scale of the corona
// local.tag = name of the tree - so we can find them back
// local.bright = viewlensflare bright or not?
//
//===============================================================
orange_light local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "fx/searchlight.tik" spawnflags 1
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale
	
	if (local.bright == "1" || local.bright == 1)
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.9 0.4 0.0 0.01
		level.AIR_Xmas_light[local.tag][local.i].bright = 1
	}
	else
	{
		level.AIR_Xmas_light[local.tag][local.i] rendereffects "+viewlensflare"
		level.AIR_Xmas_light[local.tag][local.i] light  0.9 0.4 0.0 0.0		//increase or decrease...must test
		level.AIR_Xmas_light[local.tag][local.i].bright = 0
	}	

	level.AIR_Xmas_light[local.tag][local.i].colour = "orange_light"

end level.AIR_Xmas_light[local.tag][local.i]

//===============================================================
// RED CORONA 
//===============================================================
// TODO; spawn 2 red coronas
red_corona local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "fx/corona_red.tik"
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale ( local.scale * 2 )

	level.AIR_Xmas_light[local.tag][local.i].tag = local.tag
	level.AIR_Xmas_light[local.tag][local.i].colour = "red_corona"

	local.f = local.i + 1

	level.AIR_Xmas_light[local.tag][local.f] = spawn script_model model "fx/corona_red.tik"
	level.AIR_Xmas_light[local.tag][local.f].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.f] notsolid
	level.AIR_Xmas_light[local.tag][local.f] scale ( local.scale * 2 )

	level.AIR_Xmas_light[local.tag][local.f].colour = "red_corona"

end (level.AIR_Xmas_light[local.tag][local.i]::level.AIR_Xmas_light[local.f])

//===============================================================
// WHITE CORONA 
//===============================================================
white_corona local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}
	
	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "static/corona_reg.tik"
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale	

	level.AIR_Xmas_light[local.tag][local.i].tag = local.tag
	level.AIR_Xmas_light[local.tag][local.i].colour = "white_corona"

end level.AIR_Xmas_light[local.tag][local.i]

//===============================================================
// ORANGE CORONA 
//===============================================================
orange_corona local.origin local.scale local.tag local.bright:

	if (level.AIR_Xmas_light[local.tag] == NIL || level.AIR_Xmas_light[local.tag] == NULL)
	{
		local.i = 1
	}
	else
	{
		local.i = level.AIR_Xmas_light[local.tag].size + 1
	}

	level.AIR_Xmas_light[local.tag][local.i] = spawn script_model model "static/corona_orange.tik"
	level.AIR_Xmas_light[local.tag][local.i].origin = local.origin
	level.AIR_Xmas_light[local.tag][local.i] notsolid
	level.AIR_Xmas_light[local.tag][local.i] scale local.scale	

	level.AIR_Xmas_light[local.tag][local.i].colour = "orange_corona"

end level.AIR_Xmas_light[local.tag][local.i]

// **************************************************************************************************	//
//																	//
//						  CRHISTMAS LIGHTS ANIMATION							//
//						______________________________						//
//																	//
//																	//
// **************************************************************************************************	//


//===============================================================
// BLINK
// ------
// This blinks big parts of the tree randomly.
// Either all colours or a specifief colour (local.colour).
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the blinks
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//===============================================================
blink local.wait local.duration local.colour local.tag:


	if (level.AIR_Xmas_light[local.tag] == NIL)
		end
	
	// pick a lot
	local.picky = randomint((2)+1)
	if (local.picky == 0)
		local.picky++

	// blink the bottom half first than top half
	if (local.picky == 1)
	{
		local.half = (level.AIR_Xmas_light[local.tag].size / 2)
		local.half = int(local.half)

		local.start = 1
		local.end = local.half

		local.start2 = local.half
		local.end2 = level.AIR_Xmas_light[local.tag].size
	}
	
	//blink top half first than bottom half
	else if (local.picky == 2)
	{
		local.half = (level.AIR_Xmas_light[local.tag].size / 2)
		local.half = int(local.half)

		local.start = local.half
		local.end = level.AIR_Xmas_light[local.tag].size

		local.start2 = 1
		local.end2 = local.half
	}

	////////////////////////////////
	// Start animation		//
	// ----------------		//
	// FIRST HALF			//
	////////////////////////////////
	for (local.i = local.start; local.i <= local.end; local.i++)
	{
		if (local.colour == "all" || local.colour == NIL)
		{
			level.AIR_Xmas_light[local.tag][local.i] thread hide_n_show local.duration
		}
		else if (level.AIR_Xmas_light[local.tag][local.i].colour == local.colour)
		{
			level.AIR_Xmas_light[local.tag][local.i] thread hide_n_show local.duration
		}
	}

	//waiting...
	wait ( local.duration * 2 )

	////////////////////////////////
	// Start animation		//
	// ----------------		//
	// SECOND HALF			//
	////////////////////////////////
	for (local.i = local.start2; local.i <= local.end2; local.i++)
	{
		if (local.colour == "all" || local.colour == NIL)
		{
			level.AIR_Xmas_light[local.tag][local.i] thread hide_n_show local.duration
		}
		else if (level.AIR_Xmas_light[local.tag][local.i].colour == local.colour)
		{
			level.AIR_Xmas_light[local.tag][local.i] thread hide_n_show local.duration
		}
	}

	wait local.wait

end


//===============================================================
// RANDOM BLINK
// ------------
// This randomly blinks the lights of the christmas tree!
// Either all colours or a specifief colour (local.colour).
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the blinks
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//===============================================================
random_blink local.wait local.duration local.colour local.tag:

	// Blink half lights
	local.half = ( level.AIR_Xmas_light[local.tag].size / 2 )
	local.half = int(local.half)

	if (local.colour == "all" || local.colour == NIL)
	{
		for (local.g = 1; local.g <= local.half; local.g++)
		{
			local.r = randomint((level.AIR_Xmas_light[local.tag].size) + 1)
			if (local.r == 0)
			{
				local.o = randomint((20)+1)
				local.r += (local.o + 1)
			}

			level.AIR_Xmas_light[local.tag][local.r] thread hide_n_show local.duration
		}

		wait local.duration
		
		// and blink again
		for (local.b = 1; local.b <= local.half; local.b++)
		{
			local.r = randomint((level.AIR_Xmas_light[local.tag].size) + 1)
			local.r2 = randomint((local.r) + 1)
			if (local.r2 == 0)
			{
				local.o = randomint((20)+1)
				local.r2 += (local.o + 1)
			}
			
			level.AIR_Xmas_light[local.tag][local.r2] thread hide_n_show local.duration
		}		
	}
	else
	{
		for (local.g = 1; local.g <= local.half; local.g++)
		{
			local.r = randomint((level.AIR_Xmas_light[local.tag].size) + 1)
			if (local.r == 0)
			{
				local.o = randomint((20)+1)
				local.r += (local.o + 1)
			}

			if (level.AIR_Xmas_light[local.tag][local.r].colour == local.colour)
			{
				level.AIR_Xmas_light[local.tag][local.r] thread hide_n_show local.duration
			}
		}

		wait local.duration
		
		// and blink again
		for (local.b = 1; local.b <= local.half; local.b++)
		{
			local.r = randomint((level.AIR_Xmas_light[local.tag].size) + 1)
			local.r2 = randomint((local.r) + 1)
			if (local.r2 == 0)
			{
				local.o = randomint((20)+1)
				local.r2 += (local.o + 1)
			}

			if (level.AIR_Xmas_light[local.tag][local.r2].colour == local.colour)
			{
				level.AIR_Xmas_light[local.tag][local.r2] thread hide_n_show local.duration
			}
			else if (level.AIR_Xmas_light[local.tag][local.r].colour == local.colour)
			{
				level.AIR_Xmas_light[local.tag][local.r] thread hide_n_show local.duration
			}
		}	
	}

	wait local.wait 

end

//===============================================================
// BRIGHT
// ------
// This brightens big parts of the tree randomly.
// Either all colours or a specifief colour (local.colour).
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the brightness'
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//===============================================================
bright local.wait local.duration local.colour local.tag:

	if (level.AIR_Xmas_light[local.tag] == NIL)
		end
	
	// pick a lot
	local.picky = randomint((2)+1)
	if (local.picky == 0)
		local.picky++

	// blink the bottom half first than top half
	if (local.picky == 1)
	{
		local.half = (level.AIR_Xmas_light[local.tag].size / 2)
		local.half = int(local.half)

		local.start = 1
		local.end = local.half

		local.start2 = local.half
		local.end2 = level.AIR_Xmas_light[local.tag].size
	}
	
	//blink top half first than bottom half
	else if (local.picky == 2)
	{
		local.half = (level.AIR_Xmas_light[local.tag].size / 2)
		local.half = int(local.half)

		local.start = local.half
		local.end = level.AIR_Xmas_light[local.tag].size

		local.start2 = 1
		local.end2 = local.half
	}

	////////////////////////////////
	// Start animation		//
	// ----------------		//
	// FIRST HALF			//
	////////////////////////////////
	for (local.i = local.start; local.i <= local.end; local.i++)
	{
		if (local.colour == "all" || local.colour == NIL)
		{
			level.AIR_Xmas_light[local.tag][local.i] thread bright_n_dim local.duration
		}
		else if (level.AIR_Xmas_light[local.tag][local.i].colour == local.colour)
		{
			level.AIR_Xmas_light[local.tag][local.i] thread bright_n_dim local.duration
		}
	}

	//waiting...
	wait local.duration

	////////////////////////////////
	// Start animation		//
	// ----------------		//
	// SECOND HALF			//
	////////////////////////////////
	for (local.i = local.start2; local.i <= local.end2; local.i++)
	{
		if (local.colour == "all" || local.colour == NIL)
		{
			level.AIR_Xmas_light[local.tag][local.i] thread bright_n_dim local.duration
		}
		else if (level.AIR_Xmas_light[local.tag][local.i].colour == local.colour)
		{
			level.AIR_Xmas_light[local.tag][local.i] thread bright_n_dim local.duration
		}
	}

	wait local.wait

end


//===============================================================
// RANDOM BRIGHT
// -------------
// This randomly brightens the lights of the christmas tree!
// Either all colours or a specifief colour (local.colour).
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the brightness'
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//===============================================================
random_bright local.wait local.duration local.colour local.tag:


	// Blink half lights
	local.half = ( level.AIR_Xmas_light[local.tag].size / 2 )
	local.half = int(local.half)

	if (local.colour == "all" || local.colour == NIL)
	{
		for (local.g = 1; local.g <= local.half; local.g++)
		{
			local.r = randomint((level.AIR_Xmas_light[local.tag].size) + 1)
			if (local.r == 0)
			{
				local.o = randomint((20)+1)
				local.r += (local.o + 1)
			}

			level.AIR_Xmas_light[local.tag][local.r] thread bright_n_dim local.duration
		}

		wait local.duration
		
		// and blink again
		for (local.b = 1; local.b <= local.half; local.b++)
		{
			local.r = randomint((level.AIR_Xmas_light[local.tag].size) + 1)
			local.r2 = randomint((local.r) + 1)
			if (local.r2 == 0)
			{
				local.o = randomint((20)+1)
				local.r2 += (local.o + 1)
			}

			level.AIR_Xmas_light[local.tag][local.r2] thread bright_n_dim local.duration
		}		
	}
	else
	{
		for (local.g = 1; local.g <= local.half; local.g++)
		{
			local.r = randomint((level.AIR_Xmas_light[local.tag].size) + 1)
			if (local.r == 0)
			{
				local.o = randomint((20)+1)
				local.r += (local.o + 1)
			}

			if (level.AIR_Xmas_light[local.tag][local.r].colour == local.colour)
			{
				level.AIR_Xmas_light[local.tag][local.r] thread bright_n_dim local.duration
			}
		}

		wait local.duration
		
		// and blink again
		for (local.b = 1; local.b <= local.half; local.b++)
		{
			local.r = randomint((level.AIR_Xmas_light[local.tag].size) + 1)
			local.r2 = randomint((local.r) + 1)
			if (local.r2 == 0)
			{
				local.o = randomint((20)+1)
				local.r2 += (local.o + 1)
			}

			if (level.AIR_Xmas_light[local.tag][local.r2].colour == local.colour)
			{
				level.AIR_Xmas_light[local.tag][local.r2] thread bright_n_dim local.duration
			}
			else if (level.AIR_Xmas_light[local.tag][local.r].colour == local.colour)
			{
				level.AIR_Xmas_light[local.tag][local.r] thread bright_n_dim local.duration
			}
		}	
	}

	wait local.wait 

end

//===============================================================
// SPIRAL BLINK UP
// ---------------
// This blinks every light on the spiral going upward!
// Either all colours or a specifief colour (local.colour)
// on the spiral.
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the blinks
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//===============================================================
spiral_blink_up local.wait local.duration local.colour local.tag:


	for (local.i = 1; local.i <= level.AIR_Xmas_light[local.tag].size; local.i++)
	{
		if (local.colour == "all" || local.colour == NIL)
		{
			// waitthread (!)
			level.AIR_Xmas_light[local.tag][local.i] waitthread hide_n_show local.duration
		}
		else if (level.AIR_Xmas_light[local.tag][local.i].colour == local.colour)
		{
			// waitthread (!)
			level.AIR_Xmas_light[local.tag][local.i] waitthread hide_n_show local.duration
		}

	}

	wait local.wait

end


//===============================================================
// SPIRAL BLINK DOWN
// -----------------
// This blinks every light on the spiral going downward!
// Either all colours or a specifief colour (local.colour)
// on the spiral.
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the blinks
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//===============================================================
spiral_blink_down local.wait local.duration local.colour local.tag:


	local.total = level.AIR_Xmas_light[local.tag].size
	local.end = 1

	for (local.i = local.total; local.i >= local.end; local.i--)
	{
		if (local.colour == "all" || local.colour == NIL)
		{
			// waitthread (!)
			level.AIR_Xmas_light[local.tag][local.i] waitthread hide_n_show local.duration
		}
		else if (level.AIR_Xmas_light[local.tag][local.i].colour == local.colour)
		{
			// waitthread (!)
			level.AIR_Xmas_light[local.tag][local.i] waitthread hide_n_show local.duration
		}

	}

	wait local.wait

end


//===============================================================
// SPIRAL BRIGHT UP
// ----------------
// This brightens every light on the spiral going upward!
// Either all colours or a specifief colour (local.colour)
// on the spiral.
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the brightness'
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//===============================================================
spiral_bright_up local.wait local.duration local.colour local.tag:


	for (local.i = 1; local.i <= level.AIR_Xmas_light[local.tag].size; local.i++)
	{
		if (local.colour == "all" || local.colour == NIL)
		{
			// waitthread (!)
			level.AIR_Xmas_light[local.tag][local.i] waitthread bright_n_dim local.duration
		}
		else if (level.AIR_Xmas_light[local.tag][local.i].colour == local.colour)
		{
			// waitthread (!)
			level.AIR_Xmas_light[local.tag][local.i] waitthread bright_n_dim local.duration
		}

	}

	wait local.wait

end


//===============================================================
// SPIRAL BRIGHT DOWN
// ------------------
// This brightens every light on the spiral going downward!
// Either all colours or a specifief colour (local.colour)
// on the spiral.
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the brightness'
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//===============================================================
spiral_bright_down local.wait local.duration local.colour local.tag:
//===============================================================

	local.total = level.AIR_Xmas_light[local.tag].size
	local.end = 1

	for (local.i = local.total; local.i >= local.end; local.i--)
	{
		if (local.colour == "all" || local.colour == NIL)
		{
			// waitthread (!)
			level.AIR_Xmas_light[local.tag][local.i] waitthread bright_n_dim local.duration
		}
		else if (level.AIR_Xmas_light[local.tag][local.i].colour == local.colour)
		{
			// waitthread (!)
			level.AIR_Xmas_light[local.tag][local.i] waitthread bright_n_dim local.duration
		}

	}

	wait local.wait

end

//==========================================================================
// SPIRAL BLINK UP & DOWN
// -----------------------
// This blinks every light on the spiral going first upward 
// then downward OR first downward and then upward. (Chooses randomly!)
// Either all colours or a specifief colour (local.colour)
// on the spiral.
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the blinks
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//==========================================================================
spiral_blink_updown local.wait local.duration local.colour local.tag:


	local.picker = randomint(2)
	if (local.picker == 0)
		local.picker++

	if (local.picker == 1)
	{
		// First up then down
		waitthread spiral_blink_up 0.2 local.duration local.colour local.tag

		waitframe

		waitthread spiral_blink_down 0.2 local.duration local.colour local.tag

	}
	else if (local.picker == 2)
	{
		// First down then up
		waitthread spiral_blink_down 0.2 local.duration local.colour local.tag

		waitframe

		waitthread spiral_blink_up 0.2 local.duration local.colour local.tag

	}

	wait local.wait

end

//==========================================================================
// SPIRAL BRIGHT UP & DOWN
// ------------------------
// This brightens every light on the spiral going first upward 
// then downward OR first downward and then upward. (Chooses randomly!)
// Either all colours or a specifief colour (local.colour)
// on the spiral.
//
// - local.wait = ( float ) wait between animation sequences
// - local.duration = ( float ) time between the brightness'
// - local.colour = ( String/NIL ) Passed on colour information;
// can be NIL if user wants the animation applied to all,
// else it contains a string which equals the .colour property of
// the christmas lights.
// - local.tag = ( String ) the name of your tree
//
//==========================================================================
spiral_bright_updown local.wait local.duration local.colour local.tag:
//===============================================================

	local.picker = randomint(2)
	if (local.picker == 0)
		local.picker++

	if (local.picker == 1)
	{
		// First up then down
		waitthread spiral_bright_up 0.2 local.duration local.colour local.tag

		waitframe

		waitthread spiral_bright_down 0.2 local.duration local.colour local.tag

	}
	else if (local.picker == 2)
	{
		// First down then up
		waitthread spiral_bright_down 0.2 local.duration local.colour local.tag

		waitframe

		waitthread spiral_bright_up 0.2 local.duration local.colour local.tag

	}

	wait local.wait

end

//===============================================================
// BRIGHT 'N DIM
// --------------
// This helper thread brightens the lights, waits the 
// specified period and then returns the light to its previous
// state.
//
// - local.duration = ( float ) time the brightness lasts
//
//===============================================================
bright_n_dim local.duration:

	switch (self.colour)
	{
		case "red_light":
		case "yellow_light":
		case "blue_light":
		case "purple_light":
		case "orange_light":
		case "green_light":
		case "white_light":

			local.scale = self.scale
			self rendereffects "-viewlensflare"

			self scale ( local.scale * 2 )
			wait local.duration

			self rendereffects "+viewlensflare"	
			self scale local.scale

		break
		case "red_corona":
		case "white_corona":
		case "orange_corona":
			
			local.scale = self.scale
			self scale ( local.scale * 2)

			wait local.duration

			self scale local.scale

		break
	}
end

//===============================================================
// SHOW 'N HIDE
// -------------
// This helper thread blink the lights, waits the 
// specified period and then returns the light to its previous
// state.
//
// - local.duration = ( float ) time the blink lasts
//
//===============================================================
hide_n_show local.duration:

	self hide
	wait local.duration

	self show

end
```

# xyz_Airborne_Mod\models\equipment\parachute.tik

```tik
TIKI
setup 
{
	scale 0.52				
	path models/equipment/usgear		
	skelmodel supachute.skd			
	surface lambert1 shader sc_p_hangingchute
	

init 
{
	server
	{
	}
	client
	{
	}
} 

animations // Now list all of the animations and any special commands for them
{
	idle		supachute.skc
	collapse        supachute_collapse.skc
}
```

# xyz_Airborne_Mod\models\equipment\USGear\supachute_collapse.skc

This is a binary file of the type: Binary

# xyz_Airborne_Mod\models\equipment\USGear\supachute.skc

This is a binary file of the type: Binary

# xyz_Airborne_Mod\models\equipment\USGear\supachute.skd

This is a binary file of the type: Binary

# xyz_Airborne_Mod\models\static\chute.skc

This is a binary file of the type: Binary

# xyz_Airborne_Mod\models\static\chute.skd

This is a binary file of the type: Binary

# xyz_Airborne_Mod\models\static\parachute_actors\parachute_actors.lod

This is a binary file of the type: Binary

# xyz_Airborne_Mod\models\static\parachute_actors\parachute_actors.skc

This is a binary file of the type: Binary

# xyz_Airborne_Mod\models\static\parachute_actors\parachute_actors.skd

This is a binary file of the type: Binary

# xyz_Airborne_Mod\models\static\parachute_damaged.tik

```tik
TIKI
setup
{
	scale 0.52					
	path models/static
	skelmodel chute.skd
	surface canopy shader chute
	surface rope1 shader rope
	surface rope2 shader rope
}

init
{
	server
	{
		classname animate
		setsize "-8 -8 -8" "8 8 8"
	}
	client
	{
	}
}

animations
{
	idle chute.skc
}

/*QUAKED sfx_Parachute-damaged (0.0 0.0 0.0) (-50 -40 0) (50 40 60)
chute
*/
```

# xyz_Airborne_Mod\models\static\parachute_white_canvas.tik

```tik
TIKI
setup
{
	scale 0.52
	path models/static/parachute_actors
	skelmodel parachute_actors.skd
	surface parachutequarter shader parachutequarter
//	surface parachutestrap shader parachutestrap
}

animations
{
	idle parachute_actors.skc
}


/*QUAKED addon_static_props_parachute (0.0 0.0 1.0) (-74.7534 -74.5784 0) (74.7534 74.5784 202.0000)
parachute to be attached to falling actors
*/

```

# xyz_Airborne_Mod\models\static\parachute.tik

```tik
TIKI
setup
{
	scale 0.52					
	path models/static
	skelmodel chute.skd
	surface canopy shader chute2
	surface rope1 shader rope
	surface rope2 shader rope
}

init
{
	server
	{
		classname animate
		setsize "-8 -8 -8" "8 8 8"
	}
	client
	{
	}
}

animations
{
	idle chute.skc
}

/*QUAKED sfx_Parachute-white-canvas (0.0 0.0 0.0) (-50 -40 0) (50 40 60)
chute
*/

```

# xyz_Airborne_Mod\scripts\parachute.shader

```shader
rope
{

      qer_editorimage textures/models/parachute/rope.tga
      {
            map textures/models/parachute/rope.tga
            rgbGen lightingSpherical

      }
}
chute
{
cull none
      qer_editorimage textures/models/parachute/chute.tga
      {
            map textures/models/parachute/chute.tga
            rgbGen lightingSpherical
      }
}

chute1
{
cull none
      qer_editorimage textures/models/parachute/chute1.tga
      {
            map textures/models/parachute/chute1.tga
            rgbGen lightingSpherical

      }
}

chute2
{
cull none
      qer_editorimage textures/models/parachute/chute2.tga
      {
            map textures/models/parachute/chute2.tga
            rgbGen lightingSpherical
      }
}
```

# xyz_Airborne_Mod\scripts\static_props.shader

```shader
//parachute
parachutequarter
{
	qer_editorimage textures/models/static/parachute/Parachutequarter.tga
	{
		map textures/models/static/parachute/Parachutequarter.tga
		rgbGen lightingSpherical
	}
}
parachutequarter_d
{
	qer_editorimage textures/models/static/parachute/Parachutequarter_d.tga
	{
		map textures/models/static/parachute/Parachutequarter_d.tga
		rgbGen lightingSpherical
		alphafunc GE128
	}
}
parachutestrap
{
	cull none
	qer_editorimage textures/models/static/parachute/cord.tga
	{
		map textures/models/static/parachute/strap.tga
		alphafunc ge128
		rgbGen lightingSpherical
	}
}


sc_p_hangingchute
{
	qer_editorimage textures/models/static/parachute/sc_p_hangingchute.tga
	cull none
	{
		map textures/models/static/parachute/sc_p_hangingchute.tga
		rgbGen lightingSpherical
	}
}



```

# xyz_Airborne_Mod\server_planes_b\avatar.scr

```scr
main:

	local.avatar = spawn func_beam
	local.avatar shader ("textures/hud/" + self.dmteam + ".tga") 
	local.avatar.origin = self.origin

	local.avatar color ( 1.0 1.0 1.0 )
	local.avatar scale 6
	local.avatar numsegments 1

	while(self.plane != NIL && self.plane != NULL)
	{
		waitframe
		local.avatar.origin =  ( self.plane.origin + ( 0 0 50) )
		local.avatar endpoint  ( self.plane.origin + ( 0 0 70) )
	}

	local.avatar remove

end
```

# xyz_Airborne_Mod\server_planes_b\damage.scr

```scr
// file for, shooting. being shot, and wepaons


main local.action:

	switch(local.action)
	{
	case "BOMB":
		self zoomoff	
		self waitthread bomb
	break
	case "SHOOT":
		self thread shoot
		self.shooting=1
		wait self.shootdelay
		self.shooting=0
	break
	case "CHANGE_WEAPON":
		self.canchange = 0 
		self thread change_weapon
		wait self.changedelay 
		self.canchange = 1 
	break
	}
end

shoot:

	local.fwd_vec = angles_toforward self.viewangles
	local.start = self gettagposition "eyes bone"
	local.hit = trace (local.start + local.fwd_vec * 64 ) (local.start + local.fwd_vec * 22000 ) 0
	
	switch(self.planeweap)
	{
	case 1: //mg
		self.plane playsound mg42_gun_snd_fire
		self thread checkhit local.hit
	break
	case 2: //30 call
		self.plane playsound jeep_snd_fire
		self thread checkhit local.hit
	break	
	case 3: 
		self thread rocket local.hit
	break
	default:
		self thread checkhit local.hit

	}
end

checkhit local.place: 

   self thread mgeffect local.place 

   for(local.i = 1; local.i <= $player.size; local.i++) 
   { 
      local.player= $player[local.i]  
      if(local.player!=self && local.player) 
      { 
         local.end_or_not = waitthread team_check local.player self 

         if(local.end_or_not==1) 
         { 
            end //end if same team and team team killing is not on 
         } 

         if(local.player.flying == 1 && local.player.plane) 
         { 

            if(local.player.plane.scale == .75) 
            { 
               local.hitvec = local.place - local.player.plane.origin 

               local.hitvec_fwd = local.hitvec * local.player.plane.forwardvector 
               local.hitvec_lf = local.hitvec * local.player.plane.leftvector 
               local.hitvec_up = local.hitvec * local.player.plane.upvector 

               local.is_hit_fwd = (abs local.hitvec_fwd) <= 200.0 
               local.is_hit_lf = (abs local.hitvec_lf) <= 200.0 
               local.is_hit_up = local.hitvec_up >= 0.0 && local.hitvec_up <= 35.0 
               local.damage = 20 
            } 
            else 
            { 


               local.hitvec = local.place - local.player.plane.origin 

               local.hitvec_fwd = local.hitvec * local.player.plane.forwardvector 
               local.hitvec_lf = local.hitvec * local.player.plane.leftvector 
               local.hitvec_up = local.hitvec * local.player.plane.upvector 


               local.is_hit_fwd = (abs local.hitvec_fwd) <= 120.0 
               local.is_hit_lf = (abs local.hitvec_lf) <= 120.0 
               local.is_hit_up = local.hitvec_up >= 0.0 && local.hitvec_up <= 15.0 
               local.damage = 30 
            } 

         } 
         else 
         { 
            local.hitvec = local.place - local.player.origin 

            local.hitvec_fwd = local.hitvec * local.player.forwardvector 
            local.hitvec_lf = local.hitvec * local.player.leftvector 
            local.hitvec_up = local.hitvec * local.player.upvector 

            local.is_hit_fwd = (abs local.hitvec_fwd) <= 32.0 
            local.is_hit_lf = (abs local.hitvec_lf) <= 32.0 
            local.is_hit_up = local.hitvec_up >= 0.0 && local.hitvec_up <= 92.0 
            local.damage = 45 
         } 

         if(local.is_hit_fwd && local.is_hit_lf && local.is_hit_up) 
         { 
            local.player damage self local.damage self.plane local.player.origin self.forwardvector (0 0 0) 10 1 18 -1 
         } 
      } 

   } 
if (level.jvbot_jv_mp_ai_running == 1 && level.botlastid != NIL)
{
   for(local.i = 1; local.i <= level.botlastid; local.i++) 
   { 
      local.player= level.actualbots[local.i] 
      if(local.player!=self && local.player != NIL) 
      { 
         local.end_or_not = waitthread team_check local.player self 

         if(local.end_or_not==1) 
         { 
            end //end if same team and team team killing is not on 
         } 

         local.hitvec = local.place - local.player.origin 

         local.hitvec_fwd = local.hitvec * local.player.forwardvector 
         local.hitvec_lf = local.hitvec * local.player.leftvector 
         local.hitvec_up = local.hitvec * local.player.upvector 

         local.is_hit_fwd = (abs local.hitvec_fwd) <= 32.0 
         local.is_hit_lf = (abs local.hitvec_lf) <= 32.0 
         local.is_hit_up = local.hitvec_up >= 0.0 && local.hitvec_up <= 92.0 
         local.damage = 45 

         if(local.is_hit_fwd && local.is_hit_lf && local.is_hit_up) 
         { 
            local.player damage self local.damage self.plane local.player.origin self.forwardvector (0 0 0) 10 1 18 -1 
         } 
      } 

   } 
}
end 


team_check local.player local.shooter:
	
	local.gametype = getcvar "g_gametype"
	
	if(local.gametype=="1")
	{
		end 0
	}
	
	local.ff =  getcvar "g_teamdamage"

	if(local.ff=="0")
	{
		if(local.player.dmteam == local.shooter.dmteam)
		{
			end 1
		}
	}

end 0
	
mgeffect local.place:

	if(self.spawnedmg == 0)
	{
		self.spawnedmg=1
		local.left = ( self.plane gettagposition "tag_barrel01")

		self.plane.gunleft = spawn statweapons/mg42_gun_fake.tik "targetname" ("planesmgleft" + self.entnum)  spawnflags 1
		self.plane.gunleft.angles = self.plane.angles
		self.plane.gunleft.origin = local.left
		self.plane.gunleft attach self.plane "tag_barrel01"
		self.plane.gunleft setPlayerUsable 0

		if(self.dmteam=="axis")
		{
			local.right = ( self.plane gettagposition "tag_barrel02")  
			self.plane.gunright = spawn statweapons/mg42_gun_fake.tik targetname ("planesmgright" + self.entnum) spawnflags 1
			self.plane.gunright.angles = self.plane.angles
			self.plane.gunright.origin = local.right
			self.plane.gunright attach self.plane "tag_barrel02"
			self.plane.gunright setPlayerUsable 0
		}
		else
		{
			local.right = ( self.plane gettagposition "tag_barrel04") 
			self.plane.gunright = spawn statweapons/mg42_gun_fake.tik "targetname" ("planesmgright" + self.entnum)  spawnflags 1
			self.plane.gunright.angles = self.plane.angles
			self.plane.gunright.origin = local.right
			self.plane.gunright attach self.plane "tag_barrel04"
			self.plane.gunright setPlayerUsable 0
		}

		self.plane.gunright hide
		self.plane.gunleft hide
		self.plane.gunright notsolid
		self.plane.gunleft notsolid
	}

	local.org = spawn script_origin 
	local.org.origin = local.place

	self.plane.gunright.angles = self.viewangles
	self.plane.gunleft.angles = self.viewangles

	self.plane.gunright setaimtarget local.org
	self.plane.gunleft setaimtarget local.org

	self.plane.gunleft anim fire
	self.plane.gunright anim fire

	local.org remove

end

////////////shot down////////////

shotdown_setup:

	local.shoot = spawn trigger_multiple "spawnflags" "128" "targetname" ("planehit" + self.entnum)
	
	if(self.plane.scale == .75)
	{
		local.shoot setsize ( -100 -100 -5 ) ( 100 100 30 )
	}
	else if(self.plane.scale == .2)
	{
		local.shoot setsize ( -60 -60 -5 ) ( 60 60 10 )
	}

	local.shoot.origin = self.plane.origin
	local.shoot setthread shotdown
	local.shoot.player = self
	self.shottrig = local.shoot
	local.shoot bind self.plane
end
		
shotdown:

	if(self != parm.other.shottrig && parm.other != $("world"))
	{
		local.player = parm.other

		if(local.player != NULL && isalive local.player && isAlive self.player && self.player != NULL)
		{
			local.end_or_not = waitthread team_check self.player local.player
		
			if(local.end_or_not == 1)
			{
				end //end if same team and team team killing is not on
			}

			self.player damage local.player level.plane_hit_damage local.player self.player.origin local.player.forwardvector (0 0 0) 10 1 0 -1
			end
		}
		else
		{
			self remove
		}
	}
end


////////////^^shot down////////////

rocket local.pos:

	self.rocketside++
	if(self.rocketside>2)
	{
		self.rocketside=1
	}

	if(self.rocket_ammo==0)
	{
		self iprint "0 Rockets"
		self playsound bazooka_snd_noammo
		end
	}

	self.rocket_ammo--

	self iprint ("Fired Rocket " + self.rocket_ammo)

	self playsound bazooka_snd_fire 

	if(self.rocketside==1)
	{
		local.place = ( self.plane gettagposition "tag_barrel01")
	}
	else
	{
		if(self.dmteam=="axis")
		{
			local.place = ( self.plane gettagposition "tag_barrel02")
		}
		else
		{
			local.place = ( self.plane gettagposition "tag_barrel04")
		}	
	}


	local.shell = spawn script_model "model" "projectiles/bazookashell_dm.tik" //"milkshape/missile/missile.tik" //
	local.shell.angles = self.angles
	local.shell.origin = local.place
	local.shell notsolid //if they are solid when they hit things like tanks or anyhting that gets in the way it makes bashes it out the way
	local.shell scale .5

	local.shell speed 2000
	local.shell moveto local.pos
	local.shell waitmove	
	self thread explode local.shell.origin
	local.shell remove



end

change_weapon:
	self.planeweap++

	if(self.planeweap > 3)
	{
		self.planeweap=1
	}	

	switch(self.planeweap)
	{
	case 1: //mg
		self iprint ("Using MG") 1	
	break
	case 2:
		self iprint ("Using 30 Cal") 1
	break
	case 3:
		self iprint ("Using Rockets") 1
	break
	default:
		self iprint ("Using MG") 1
	}
	
end

explode local.explosionplace: 

   thread bang local.explosionplace 
   local.radius = 200.00 * 200.00 

   for(local.i = 1; local.i <= $player.size; local.i++) 
   { 
      local.player= $player[local.i] 
      local.distance =  (local.player.origin - local.explosionplace) * (local.player.origin - local.explosionplace) 

      //local.distance = local.distance * local.distance 

      if(local.distance <= local.radius) 
      { 
         if(local.player != self) 
         { 
            local.end_or_not = waitthread team_check local.player self 
       
            if(local.end_or_not==1) 
            { 
               end //end if same team and team team killing is not on 
            } 

            local.dmg_fact = 1 - local.distance / local.radius 
            local.dmg = 150 * local.dmg_fact + 30 
            local.player damage self local.dmg self (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 
         } 
      } 

   } 
if (level.jvbot_jv_mp_ai_running == 1 && level.botlastid != NIL)
{
   for(local.i = 1; local.i <= level.botlastid; local.i++) 
   { 
      local.player= level.actualbots[local.i] 
      local.distance =  (local.player.origin - local.explosionplace) * (local.player.origin - local.explosionplace) 

      //local.distance = local.distance * local.distance 

      if(local.distance <= local.radius) 
      { 
         if(local.player != self) 
         { 
            local.end_or_not = waitthread team_check local.player self 
       
            if(local.end_or_not==1) 
            { 
               end //end if same team and team team killing is not on 
            } 

            local.dmg_fact = 1 - local.distance / local.radius 
            local.dmg = 150 * local.dmg_fact + 30 
            local.player damage self local.dmg self (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1 
         } 
      } 

   } 
}

end

bang local.place:

	local.Exp3 = spawn "fx/scriptbazookaexplosion.tik"
	local.Exp4 = spawn "animate/fx_mortar_dirt.tik"
	local.Exp3 radiusdamage 0
	local.Exp3.origin = local.place
	local.Exp4.origin = local.place
	local.Exp3 anim start
	local.Exp4 anim start

	wait 1
	local.Exp3 remove	
	local.Exp4 remove
 
end

bomb:
	if(self.candrop==0)
	{
		self iprint "No bombs"
		self playsound bazooka_snd_noammo
		end
	}

	self iprint ("Bomb :" + self.candrop)
	self.candrop--

	local.bomb = spawn script_model "targetname" "planebomb"
	local.bomb model "ammo/us_bomb.tik" 
	local.bomb.origin = self.plane.origin - ( 0 0 50 )

	local.bomb.angles = ( self.plane.angles + ( 0 90 0 ) )
	local.bomb notsolid 

	thread bombtwist local.bomb
	local.bomb physics_on

	local.bomb.velocity = self.plane.velocity 
	local.bomb playsound leadinmp2
	local.didnt=1

	while(local.didnt==1)
	{
		local.bomb waittill touch
		if!(parm.other==self || parm.other == self.plane)
		{
			local.didnt=0
		}
	}
	
	self thread explode local.bomb.origin
	local.bomb remove

	
end


bombtwist local.bomb:

	for(local.i=0;local.i<=90 ;local.i+=5)
	{

		waitframe
		if(local.bomb==NULL || local.bomb==NIL)
		{
			end
		}
		else
		{
			local.bomb.angles = (  local.bomb.angles[0] local.bomb.angles[1] local.i )
		}
	}
end

```

# xyz_Airborne_Mod\server_planes_b\movement.scr

```scr
main local.movement:

	if(self.plane==NULL || self.plane==NIL)
	{
		end
	}

	switch(local.movement)
	{
	case "BACKWARD_WALK":
		self.seat[0] -= 5		
	break
	case "FORWARD_WALK":
		self.seat[0] += 4		
	break
	case "LEFT_WALK":
		self.seat[1] +=2		
	break
	case "RIGHT_WALK":
		self.seat[1] -=2		
	break
	case "BACKWARD_RUN":
		self.speed -= self.deceleration
	
		if(self.speed < self.minspeed)
		{
			self.speed =  self.minspeed
		}
	break
	case "FORWARD_RUN":
		self.speed += self.acceleration
		if(self.speed > self.maxspeed)
		{
			self.speed =  self.maxspeed
		}
	break
	case "LEFT_RUN":
		if(self.z > -180)
		{
			self.z -= 20
		}
	break
	case "RIGHT_RUN":
		if(self.z < 180)
		{
			self.z += 20
		}
	break
	case "LEVEL_OUT":
		self thread level_out
	break
	case "JUMP":
		self exec server_planes/parachute.scr::parachute
	break
	}
end
```

# xyz_Airborne_Mod\server_planes_b\parachute.scr

```scr
// Global chute script for allied assault

main:

	if(self.ejecting==1)
	{
		self gravity 1
		self.ejecting=0
	}
end

parachute:

	local.eject = waitexec server_planes/settings.scr::getcmd "eject"

	if(local.eject == "0")
	{
		self iprint "Eject dissabled"
		end
	}

	local.player = self

	self.ejecting=1

	waitframe
	local.player show
	local.player solid

	local.player.in_para_drop=1

	local.vec = local.player.velocity
	local.velocity_get = -390

	local.player forcelegsstate STAND
	local.player forcetorsostate STAND

	local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

	local.chute = spawn script_model

	if(local.player.dmteam!="axis")
	{
		local.chute model "static/parachute_white_canvas.tik"
	}
	else
	{
		local.chute model "static/parachute.tik"
	}

	local.chute.origin = ( local.player gettagposition "Bip01 Spine1" )
	local.chute notsolid
	local.chute scale 2
	local.chute.angles = local.player.angles
	//local.chute.angles[1] = local.chute.angles[1]

	local.chute1 = spawn script_origin
	local.chute1.origin = ( local.player gettagposition "Bip01 Spine1" ) + ( 0 0 100)

	local.chute1 attach local.player "Bip01 Spine1"
	local.chute glue local.chute1
	// local.chute attach local.player "Bip01 Spine1"

	while(local.player.ejecting==1)
	{
		if(local.player.health>2)
		{
			local.vec[0] = local.player.velocity[0]
			local.vec[1] = local.player.velocity[1]
			local.vec[2] = local.velocity_get

			local.player.velocity = local.vec
		}
		else
		{
			local.player.ejecting=0
		}
		
		if(local.player.dmteam=="spectator")
		{
			local.player.ejecting=0
			local.chute remove
		}
		if (local.player == NIL || local.player == NULL)
		{
			local.chute remove
			end
		}

		if (( local.player getposition ) == "standing")
		{
			local.player.ejecting=0
		}

		waitframe
	}

	local.chute detach local.player
	//local.chute waittill animdone
	wait .3
	local.chute remove
end

```

# xyz_Airborne_Mod\server_planes_b\plane_crash.scr

```scr
main:
	self thread plane_explode
end

plane_crashing:

	if (self == NULL)
		end
	
	if (self.classname != "Player")
	{
		local.noplayer = 1
	}

	if(self.plane == NULL || self.plane == NIL)
	{
		if (local.noplayer != 1)
		{
			end
		}
	}

	if (local.noplayer == 1)
	{
		self.plane = self
		self thread plane_crash
	}
	else
	{
		self thread plane_crash self.plane
	}

	local.flyingexplosion = spawn "models/emitters/fireandsmoke.tik"			
	local.flyingexplosion glue self.plane
	local.flyingexplosion.origin = self.plane.origin
	local.flyingexplosion.scale = self.plane.scale
	local.flyingexplosion anim start
	local.flyingexplosion notsolid

	local.flyingsmoke = spawn "models/emitters/plane_smoke.tik"			
	local.flyingsmoke glue self.plane
	local.flyingsmoke.origin = self.plane.origin
	local.flyingsmoke.scale = self.plane.scale
	local.flyingsmoke anim start
	local.flyingsmoke notsolid

	local.now = self.plane.angles[0]
	local.end = local.now + 40

	for(local.i=0;local.i<=45 ;local.i+=2)
	{
		waitframe
		if(self == NULL || self.plane == NULL || self.plane == NIL)
		{
			break
		}
		else
		{
			self.plane.angles = ( local.i self.plane.angles[1] self.plane.angles[2] )
		}
	}

	while(self.plane && self != NULL)
	{
		waitframe
	}

	local.flyingsmoke remove
	local.flyingexplosion remove
end	

plane_crash local.plane:

	if (self == NULL && local.plane != NIL)
	{
		local.plane thread plane_explode
		end
	}

	if(self.plane != NULL && self.plane != NIL)
	{
		local.hitthing = self
		local.plane = self.plane
		local.team = self.dmteam

		while(local.hitthing == self || local.hitthing.targetname == "planebomb")
		{
			self.plane waittill touch
			local.hitthing = parm.other
		}
		
		self thread plane_explode
	}

end	


plane_explode:

	if (self == NULL)
		end

	if (self.classname != "Player")
	{
		local.noplayer = 1
	}

	if (local.noplayer == 1)
	{
		local.plane = self
		local.origin = self.origin
	}
	else
	{
		self solid
		local.plane = self.plane
		local.origin = local.plane.origin
	}
	//self.plane explode
	local.plane remove

	local.Exp = spawn "emitters/aircraft_explosion.tik"
	local.Exp2 = spawn "animate/fx_mortar_dirt.tik"
	local.Exp.origin = local.origin
	local.Exp2.origin = local.origin
	
	if(local.noplayer != 1 && self.in_para_drop !=1 )
	{
		if (self.health > 100) //&& level.jvbot_jv_mp_ai_running == 1)
			self.health = 100
		self damage local.Exp2 100 local.Exp2 (0 0 0) (0 0 0) (0 0 0) 0 1 rocket -1
	}

	radiusdamage local.origin 100 300 0

	local.Exp anim start
	local.Exp2 anim start
	wait 1
	local.Exp remove	
	local.Exp2 remove
	
	if (local.noplayer != 1)
	{
		self.flying = 0
	}

	$("planehit" + self.entnum) remove

end	

```

# xyz_Airborne_Mod\server_planes_b\plane_settings.txt

```txt
// Adjust the settings as you wish
main:

	level.plane_settings = makearray
		//SETTINGNAME		// VALUE	// INFORMATION

		"maxspeed"		"3000"		"Max speed of the aircraft"
		"minspeed"		"300"		"minimum speed of the aircraft"
		"startspeed"		"350-550" 	"Speed the aircraft starts with"
		"plane-bombs"		"4"		"Amount of bombs the plane has"
		"rockets"		"6"		"Plane rocket ammo count"
		"eject"			"1"		"if 1 the player can eject if 0 they cant."
		"acceleration"		"20"		"Amount of acceleration upon key press"
		"deceleration"		"20"		"Amount of deceleration upon key press"
		"plane-hit-dmg"	 	"15"		"Amount of damage a plane takes when shot (any weapon)"
		"max-axis"		"0"		"Amount of axis planes allowed in the air at one time, 0 = Dont care"
		"max-allies"		"0"		"Amount of allies planes allowed in the air at one time, 0 = Dont care"	
		"trig-delay"		"5"		"Delay to wait after a trigger has been used to re-activate it"
		"use-teams"		"0"		"If not set 1 any team can use any trigger else a team can only use triggers that link to that team"
		"plane-bots-damage"	"1000"		"Amount of health a plane have when shot by BOTS (any weapon)"
	endarray

end
```

# xyz_Airborne_Mod\server_planes_b\plane_states.txt

```txt
//Put this at the bottom of your mike_torso.st file
//////////////// SERVER PLANES
state PLANE_TORSO
{

	movetype anim

	camera behind

	entrycommands
	{
		//deactivateweapon righthand
		safeholster 1 
		modheight "stand" 
		movementstealth "1.0"
		moveposflags "running" "running"
		viewmodelanim idle
	}
	
	action
	{
		unarmed_stand_idle			: default
	}

	states
	{
		IN_PLANE		 	: default
		STAND				: KILLED
		
	}
}

state IN_PLANE
{

	states
	{
		PLANE_BOMB	 		: MOVEMENT_TYPE "running" ATTACK_SECONDARY
		STAND				: KILLED
		PLANE_SPEED_BACKWARD		: RUN BACKWARD
		PLANE_SPEED_FORWARD 		: RUN FORWARD
		PLANE_CAM_FORWARD		: !RUN FORWARD
		PLANE_CAM_BACKWARD		: !RUN BACKWARD
		PLANE_CAM_UP			: !RUN STRAFE_LEFT 
		PLANE_CAM_DOWN			: !RUN STRAFE_RIGHT
		PLANE_LEFT			: RUN STRAFE_LEFT 
		PLANE_RIGHT			: RUN STRAFE_RIGHT		
		PLANE_PARACHUTE			: +JUMP
	}
}


state PLANE_BOMB
{

	entrycommands
	{
		moveposflags "standing" "walking"
		exec server_planes/damage.scr "BOMB"
		commanddelay .70 moveposflags "standing" "running"
	}

	states
	{
		IN_PLANE			: default //MOVEMENT_TYPE "running"
		STAND				: KILLED
	}

}

state PLANE_CAM_BACKWARD
{
	entrycommands
	{
		exec server_planes/movement.scr "BACKWARD_WALK"
	}

	states
	{
		PLANE_BOMB	 		: MOVEMENT_TYPE "running" ATTACK_SECONDARY
		STAND				: KILLED
		PLANE_SPEED_BACKWARD		: RUN BACKWARD
		PLANE_SPEED_FORWARD 		: RUN FORWARD
		PLANE_CAM_FORWARD		: !RUN FORWARD
		PLANE_CAM_BACKWARD		: !RUN BACKWARD
		PLANE_CAM_UP			: !RUN STRAFE_LEFT 
		PLANE_CAM_DOWN			: !RUN STRAFE_RIGHT
		PLANE_LEFT			: RUN STRAFE_LEFT 
		PLANE_RIGHT			: RUN STRAFE_RIGHT
		PLANE_PARACHUTE			: +JUMP
	}
}

state PLANE_CAM_FORWARD 
{
	entrycommands
	{
		exec server_planes/movement.scr "FORWARD_WALK"
	}

	states
	{
		PLANE_BOMB	 		: MOVEMENT_TYPE "running" ATTACK_SECONDARY
		STAND				: KILLED
		PLANE_SPEED_BACKWARD		: RUN BACKWARD
		PLANE_SPEED_FORWARD 		: RUN FORWARD
		PLANE_CAM_FORWARD		: !RUN FORWARD
		PLANE_CAM_BACKWARD		: !RUN BACKWARD
		PLANE_CAM_UP			: !RUN STRAFE_LEFT 
		PLANE_CAM_DOWN			: !RUN STRAFE_RIGHT
		PLANE_LEFT			: RUN STRAFE_LEFT 
		PLANE_RIGHT			: RUN STRAFE_RIGHT
		PLANE_PARACHUTE			: +JUMP
	}
}

state PLANE_SPEED_BACKWARD
{
	entrycommands
	{
		exec server_planes/movement.scr "BACKWARD_RUN"
	}

	states
	{
		PLANE_BOMB	 		: MOVEMENT_TYPE "running" ATTACK_SECONDARY
		STAND				: KILLED
		PLANE_SPEED_BACKWARD		: RUN BACKWARD
		PLANE_SPEED_FORWARD 		: RUN FORWARD
		PLANE_CAM_FORWARD		: !RUN FORWARD
		PLANE_CAM_BACKWARD		: !RUN BACKWARD
		PLANE_CAM_UP			: !RUN STRAFE_LEFT 
		PLANE_CAM_DOWN			: !RUN STRAFE_RIGHT
		PLANE_LEFT			: RUN STRAFE_LEFT 
		PLANE_RIGHT			: RUN STRAFE_RIGHT
		PLANE_PARACHUTE			: +JUMP
	}
}

state PLANE_SPEED_FORWARD 
{
	entrycommands
	{
		exec server_planes/movement.scr "FORWARD_RUN"
	}

	states
	{
		PLANE_BOMB	 		: MOVEMENT_TYPE "running" ATTACK_SECONDARY
		STAND				: KILLED
		PLANE_SPEED_BACKWARD		: RUN BACKWARD
		PLANE_SPEED_FORWARD 		: RUN FORWARD
		PLANE_CAM_FORWARD		: !RUN FORWARD
		PLANE_CAM_BACKWARD		: !RUN BACKWARD
		PLANE_CAM_UP			: !RUN STRAFE_LEFT 
		PLANE_CAM_DOWN			: !RUN STRAFE_RIGHT
		PLANE_LEFT			: RUN STRAFE_LEFT 
		PLANE_RIGHT			: RUN STRAFE_RIGHT
		PLANE_PARACHUTE			: +JUMP
	}
}


state PLANE_CAM_DOWN
{
	entrycommands
	{
		exec server_planes/movement.scr "RIGHT_WALK"
	}

	states
	{
		PLANE_BOMB	 		: MOVEMENT_TYPE "running" ATTACK_SECONDARY
		STAND				: KILLED
		PLANE_SPEED_BACKWARD		: RUN BACKWARD
		PLANE_SPEED_FORWARD 		: RUN FORWARD
		PLANE_CAM_FORWARD		: !RUN FORWARD
		PLANE_CAM_BACKWARD		: !RUN BACKWARD
		PLANE_CAM_UP			: !RUN STRAFE_LEFT 
		PLANE_CAM_DOWN			: !RUN STRAFE_RIGHT
		PLANE_LEFT			: RUN STRAFE_LEFT 
		PLANE_RIGHT			: RUN STRAFE_RIGHT
		PLANE_PARACHUTE			: +JUMP
	}
}

state PLANE_CAM_UP
{
	entrycommands
	{
		exec server_planes/movement.scr "LEFT_WALK"
	}

	states
	{
		PLANE_BOMB	 		: MOVEMENT_TYPE "running" ATTACK_SECONDARY
		STAND				: KILLED
		PLANE_SPEED_BACKWARD		: RUN BACKWARD
		PLANE_SPEED_FORWARD 		: RUN FORWARD
		PLANE_CAM_FORWARD		: !RUN FORWARD
		PLANE_CAM_BACKWARD		: !RUN BACKWARD
		PLANE_CAM_UP			: !RUN STRAFE_LEFT 
		PLANE_CAM_DOWN			: !RUN STRAFE_RIGHT
		PLANE_LEFT			: RUN STRAFE_LEFT 
		PLANE_RIGHT			: RUN STRAFE_RIGHT
		PLANE_PARACHUTE			: +JUMP
	}
}


state PLANE_RIGHT
{
	entrycommands
	{
		exec server_planes/movement.scr "RIGHT_RUN"
	}

	states
	{
		PLANE_RIGHT			: RUN STRAFE_RIGHT
		IN_PLANE			: !STRAFE_RIGHT
		PLANE_PARACHUTE			: +JUMP
	}
}

state PLANE_LEFT
{
	entrycommands
	{
		exec server_planes/movement.scr "LEFT_RUN"
	}

	states
	{
		PLANE_LEFT			: RUN STRAFE_LEFT 
		IN_PLANE			: !STRAFE_LEFT 
		PLANE_PARACHUTE			: +JUMP
	}
}



state PLANE_PARACHUTE
{
	entrycommands
	{
		exec server_planes/movement.scr "JUMP"
	}

	states
	{
		IN_PLANE			: default
	}
}
```

# xyz_Airborne_Mod\server_planes_b\server_fly.scr

```scr
main:
	
	if(self.flying == 1)
	{
		self.scale = 1
		end
	}

	if(self.OWNS == 1)
	{
		self.scale = 1
		self.flying = 0
		end
	}

	self.no_usemine = 1 //stop them using a mine
	self.no_usemedic = 1 //stop medics

	self.flying = 1
	self takedamage

	local.team = self.dmteam

	if(level.planes_max["allies"]== NIL)
	{
		waitexec server_planes/setup.scr
	}

	level.planes[local.team]++

	local.allies = waitexec server_planes/settings.scr::getcmd "max-allies"
	local.axis = waitexec server_planes/settings.scr::getcmd "max-axis"

	level.planes_max["allies"] = int local.allies 
	level.planes_max["axis"] = int local.axis

	if(level.planes[local.team] == level.planes_max[local.team])
	{
		exec server_planes/trigger.scr::from_fly local.team
	}

	//spawn the plane
	local.plane = spawn script_model "targetname" ("flyingplane" + self.entnum)
	if(self.dmteam == "axis")
	{
		local.plane model "vehicles/fockwulffly.tik"
	}
	else
	{
		local.plane model "vehicles/p47fly.tik"	
	}

	local.plane.origin = self.plane_start
	local.plane.scale = self.scale 


	if(self.seat == NIL)
	{
		if(local.plane.scale == .75)
		{
			self.seat[0] = -335 //3
			self.seat[1] = 10
		}
		else if(local.plane.scale == .2)
		{
			self.seat[0] = -115 //3
			self.seat[1] = -50 //-65
		}
		else
		{
			self.seat[1] = -65
		}
	}
		
	if(local.plane.scale == .75)
	{
		local.plane setsize ( -100 -100 -5 ) ( 100 100 30 )
	}
	else if(local.plane.scale == .2)
	{
		local.plane setsize ( -60 -60 -5 ) ( 60 60 10 )
	}

	local.plane touchtriggers

	local.plane physics_on
	local.plane.gravity = 0

	//set the plane
	self.plane = local.plane

	//hmm
	local.plane takedamage

	self.maxspeed = waitexec server_planes/settings.scr::getcmd "maxspeed"
	self.minspeed = waitexec server_planes/settings.scr::getcmd "minspeed"
	local.speed =  waitexec server_planes/settings.scr::getcmd "startspeed"
	self.candrop =  waitexec server_planes/settings.scr::getcmd "plane-bombs"
	self.rocket_ammo =  waitexec server_planes/settings.scr::getcmd "rockets"
	level.plane_hit_damage =  waitexec server_planes/settings.scr::getcmd "plane-hit-dmg"
	self.acceleration =  waitexec server_planes/settings.scr::getcmd "acceleration"
	self.deceleration =  waitexec server_planes/settings.scr::getcmd "deceleration"
	if (level.jvbot_jv_mp_ai_running == 1 && level.botlastid != NIL)
	{
		self.health = waitexec server_planes/settings.scr::getcmd "plane-bots-damage"
	}

	self.acceleration = int self.acceleration
	self.deceleration = int self.deceleration

	//set start speed
	waitexec server_planes/speedup.scr local.speed self

	self.maxspeed = int self.maxspeed 
	self.minspeed = int self.minspeed 
	self.candrop = int self.candrop
	self.rocket_ammo  = int self.rocket_ammo 

	self solid
	self forcetorsostate PLANE_TORSO
	self forcelegsstate STAND
	self hide
	self.scale = 1
	self.planeweap = 1 
	self.rocketside=1
	self.firingrocket=0
	self.spawnedmg = 0
	self.extraangle = 0
	self.in_para_drop=0
	self.shooting=0	
	self.shootdelay = 0.10
	self.changedelay = .3
	self.canchange = 1 
	self.ejecting=0
	self.origin = local.plane.origin

	//announce Player in plane
	local.team  = waitexec global/strings.scr::to_upper local.team  0
	iprintlnbold (local.team  + " Aircraft Spotted On Radar!!!")
	local.team = self.dmteam

	local.plane.angles = self.viewangles
//main loop
	self exec server_planes/plane_crash.scr::plane_crash local.plane
	self exec server_planes/damage.scr::shotdown_setup 

	local.plane loopsound fly_snd

	self.z = 0

	while(self.plane != NIL && self.plane != NULL && self != NULL && isalive self && self.dmteam == local.team && self.ejecting != 1 && self.in_para_drop != 1)
	{
		if(self==NIL || self==NULL)
		{
			end
		}

		self waitthread playerkeep

		/// set planes angles

		if(self != NULL && isAlive self && self.viewangles[1] != local.oldangle)
		{
			local.viewvec = angles_toforward self.viewangles
			local.leftdot = vector_dot local.viewvec self.leftvector
			local.right = 0
			local.right -= local.leftdot
			
			self.z = self.z  + local.right * 10

			local.newangle = local.right * 100 // * 200 //350 //400 //50
			local.newangle =  self.viewangles[2] + local.newangle
			local.plane.angles = ( self.viewangles[0]  self.viewangles[1] local.newangle )
			
			local.newangle =  local.newangle / 10

			
			self.viewangles = ( self.viewangles[0]  self.viewangles[1] self.z )

		}
		else
		{
			
			if(self.z > 10 || self.z < -10 && isAlive self && self != NULL )
			{
				if(self.z >=1)
				{ 
					if(self.z > 180)
					{
						self.z += 10
					}
					else
					{
						self.z -= 10
					}
				}
				else if(self.z <= -1)
				{
					if(self.z < -180)
					{
						self.z -= 10
					}
					else
					{
						self.z += 10
					}
				}
			}
			else
			{
				if(self.z >=1 && isAlive self && self != NULL)
				{ 
					self.z -= 1
				}
				else if(self.z <= -1 && isAlive self && self != NULL)
				{
					self.z+= 1
				}
			}

			self.viewangles = ( self.viewangles[0]  self.viewangles[1] self.z )

			local.plane.angles = 	self.viewangles
			
		}

		local.oldangle = self.viewangles[1]

		if(self.z >= 360 && isAlive self && self != NULL)
		{
			self.z = 0
		}
		else if(self.z <= -360 && isAlive self && self != NULL)
		{
			self.z = 0
		}


		local.plane.velocity = local.plane.forwardvector * self.speed

		if(self.useheld == 1 && self.canchange == 1 && isAlive self && self != NULL)
		{
			self exec server_planes/damage.scr "CHANGE_WEAPON"
		}
		
		
		if(self.fireheld==1 && self.shooting != 1 && isAlive self && self != NULL)
		{
			self exec server_planes/damage.scr "SHOOT"	
		}
				
		waitframe
//colision

		if(isAlive self && self != NULL && local.origin == self.origin)
		{
			self exec server_planes/plane_crash.scr::plane_explode
			self kill
			end
		}
		else if ( !(isAlive self) && self != NULL && local.origin == self.origin)
		{
			self.plane exec server_planes/plane_crash.scr::plane_explode
			end
		}
		
		local.origin = self.origin
	}
	
	self.no_usemine = 0 //can use a mine again
	self.no_usemedic = 0 //
	if (level.jvbot_jv_mp_ai_running == 1 && level.botlastid != NIL && self.health > 100)
	{
		self.health = 100 // bot setup
	}

////// END OF MAIN LOOOP
	level.planes[local.team]--

	if (self == NULL)
	{
		local.plane exec server_planes/plane_crash.scr::plane_crashing 
	}
	else
	{
		self exec server_planes/plane_crash.scr::plane_crashing
	}

	if(self.plane != NIL && self.plane != NULL && isAlive self && self != NULL)
	{
		waitframe
		self.origin = self.plane.origin + ( 0 10 100 )
	}
end


playerkeep:
	local.offset = self.plane.origin + ( 0 0 self.seat[1] ) + self.plane.forwardvector  * self.seat[0] + 0.05 * self.plane.forwardvector * self.speed
	self.origin = local.offset
end


```

# xyz_Airborne_Mod\server_planes_b\settings.scr

```scr
// Get Settings

getcmd local.cmd:

	if (level.plane_settings == NIL)
	{
		waitexec server_planes/plane_settings.txt
	}

	if (local.cmd == NIL || local.cmd == "")
	{
		end NIL
	}

	for (local.i = 1; local.i <= level.plane_settings.size; local.i++)
	{
		if (local.cmd == level.plane_settings[local.i][1])
		{
			end level.plane_settings[local.i][2]
		}
	}

end

```

# xyz_Airborne_Mod\server_planes_b\setup.scr

```scr
main:
	thread sound

	level.planes["allies"] = 0
	level.planes["axis"] = 0
end

sound:

	local.master = spawn scriptmaster

	local.master aliascache jeep_snd_fire sound/weapons/fire/50CalFire2.wav soundparms 1.05 0.2 0.95 0.1 800 4000 weapon loaded maps "m dm moh obj train "
	local.master aliascache explode_plane_flying sound/weapons/explo/Explo_MetalMed1.wav soundparms 0.9 0.2 0.8 0.2 1000 8000 weapon loaded maps "m dm moh obj train "
	local.master aliascache leadinmp2 sound/weapons/explo/Exp_LeadIn_07.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm moh obj train "
	local.master aliascache fly_snd sound/vehicle/M1_StukaIdle.wav soundparms 1.5 0.5 2.0 0.5 2000 1000 item loaded maps "m dm moh obj train "

	local.master aliascache arty_exp_sand1 sound/weapons/explo/exp_dirt_01.wav soundparms 0.8 0.3 0.7 0.4 1000 8000 weapon loaded maps "m dm moh obj train "
	local.master aliascache arty_exp_sand2 sound/weapons/explo/exp_dirt_02.wav soundparms 0.8 0.3 0.7 0.4 1000 8000 weapon loaded maps "m dm moh obj train "
	local.master aliascache arty_exp_sand3 sound/weapons/explo/exp_dirt_03.wav soundparms 0.8 0.3 0.7 0.4 1000 8000 weapon loaded maps "m dm moh obj train "
	local.master aliascache arty_exp_sand4 sound/weapons/explo/exp_dirt_04.wav soundparms 0.8 0.3 0.7 0.4 1000 8000 weapon loaded maps "m dm moh obj train "

end
```

# xyz_Airborne_Mod\server_planes_b\speedup.scr

```scr
main local.speed local.player:

	if ( !(isAlive local.player) || local.player == NIL || local.player == NULL)
		end	

	local.speed = waitexec global/strings.scr::split_line local.speed 1 "-"

	self.speed = int local.speed[1][1]
	local.player thread speedup local.speed[1][2] 
end

speedup local.speed:

	local.speed = int local.speed

	while(self.speed < local.speed && isAlive self && self != NULL)
	{
		self.speed += self.acceleration
		waitframe
	}
end
```

# xyz_Airborne_Mod\server_planes_b\trigger.scr

```scr
main local.origin local.team local.scale local.start_pos:

	if(level.planes == NIL)
		exec server_planes/setup.scr

	if(local.origin == NIL)
		end

	if(local.scale == NIL)
		local.scale = .2

	if(local.start_pos == NIL)
		local.start_pos = local.origin + ( 0 0 500 )

	if(local.team == NIL)
	{
		local.team = randomint (1) + 1
		
		if(local.team == 0)
		{
			local.team = "axis"
		}
		else
		{
			local.team = "allies"
		}
	}

	local.plane = spawn script_model "targetname" ("plane_trigger" + local.team)

	if(local.team =="axis")	
		local.plane model "vehicles/fockwulffly.tik"
	else
		local.plane model "vehicles/p47fly.tik"

	local.plane.origin = local.origin 
	local.plane.scale = .1
	local.plane light 1 0 0 50
	local.plane ghost

	local.plane.shot = 0

	local.plane_trig = spawn trigger_multiple "targetname" ("plane_trigger_fly" + local.team)
	local.plane_trig.origin = local.origin 
	local.plane_trig setthread fly
	local.plane_trig setsize ( -40 -40 -40 ) ( 40 40 40 ) 
	local.plane_trig.plane = local.plane
	local.plane_trig.plane_scale = local.scale
	local.plane_trig.start_pos = local.start_pos
	local.plane_trig.team = local.team
	
	local.plane_trig_shot = spawn trigger_multiple "spawnflags" "128"  "targetname" ("plane_shottrigger" + local.team)
	local.plane_trig_shot.origin = local.origin 
	local.plane_trig_shot setthread shot
	local.plane_trig_shot setsize ( -40 -40 -40 ) ( 40 40 40 ) 
	local.plane_trig_shot.plane = local.plane
	local.plane_trig_shot.team = local.team
	
	level waittill spawn 

	local.i[0] = 0
	local.i[1] = 0
	local.i[2] = 0

	local.v[0] = 3
	local.v[1] = 4
	local.v[2] = 5

	while(1)
	{
		if(local.minues!=1)
		{
			local.v[0] ++ 
			local.v[1] ++
			local.v[2] ++
		}

		if(local.v[2]==10)
		{
			local.minues=1
		}

		if(local.v[2]==3)
		{
			local.minues=0
		}

		if(local.minues==1)
		{
			local.v[0] -- 
			local.v[1] --
			local.v[2] --
		}


		for(local.p=0;local.p<=10;local.p++)
		{

		waitframe

			local.i[0] += local.v[0]
			local.i[1] += local.v[1]
			local.i[2] += local.v[2]

			if(local.plane.shot==1)
			{
				local.i[0] += local.v[0]
				local.i[1] += local.v[1]
				local.i[2] += local.v[2]
				local.i[0] += local.v[0]
				local.i[1] += local.v[1]
				local.i[2] += local.v[2]
				local.plane light 1 0 1 50
			}

			local.plane.angles = ( local.i[0] local.i[1] local.i[2] )
		}
	}

end

fly:
	local.player = parm.other
	
	if(local.player.flying != 1 ||  local.player.OWNS == 1)
	{
		local.team = parm.other.dmteam

		local.use_teams = waitexec server_planes/settings.scr::getcmd "use-teams"

		if (local.use_teams  == "1" || local.use_teams == 1)
		{	
			if(self.team != local.player.dmteam)
			{
				local.player iprint "You don't have the training for this aircraft"
				self.plane light 0 0 1 100
				waitframe
				
				self.plane light 1 0 0 50
				end
			}
		}

		local.player.plane_start = self.start_pos	
		local.player scale self.plane_scale 
		local.player exec server_planes/server_fly.scr

		local.trigdelay = waitexec server_planes/settings.scr::getcmd "trig-delay"
		local.trigdelay = int local.trigdelay

		self nottriggerable
		self.plane hide

		wait local.trigdelay

		self.plane show
		self triggerable
	}
end

shot:
	self.plane.shot=1
	wait 1 
	self.plane.shot = 0
	self.plane light 1 0 0 50
	end
end

switch__all local.team local.dissable:
	

	for(local.i=1;local.i <=  $("plane_trigger_fly" + local.team).size;local.i++)
	{
		if(local.dissable == 1)
		{
			$("plane_trigger_fly" + local.team)[local.i] nottriggerable
			$("plane_shottrigger" + local.team)[local.i] nottriggerable
			$("plane_trigger" + local.team)[local.i] hide
		}
		else
		{
			$("plane_trigger_fly" + local.team)[local.i] triggerable
			$("plane_shottrigger" + local.team)[local.i] triggerable
			$("plane_trigger" + local.team)[local.i] show
		}
	}
end

from_fly local.team:

	thread switch__all local.team 1

	while(level.planes[local.team] == level.planes_max[local.team])
	{
		wait 1
	}
			
	thread switch__all local.team

end
```

# xyz_Airborne_Mod\textures\models\parachute\chute.tga

This is a binary file of the type: Binary

# xyz_Airborne_Mod\textures\models\parachute\chute1.tga

This is a binary file of the type: Binary

# xyz_Airborne_Mod\textures\models\parachute\chute2.tga

This is a binary file of the type: Binary

# xyz_Airborne_Mod\textures\models\parachute\rope.tga

This is a binary file of the type: Binary

# xyz_Airborne_Mod\textures\models\static\parachute\cord.tga

This is a binary file of the type: Binary

# xyz_Airborne_Mod\textures\models\static\parachute\Parachute.tga

This is a binary file of the type: Binary

# xyz_Airborne_Mod\textures\models\static\parachute\parachutequarter_d.tga

This is a binary file of the type: Binary

# xyz_Airborne_Mod\textures\models\static\parachute\parachutequarter.jpg

This is a binary file of the type: Image

# xyz_Airborne_Mod\textures\models\static\parachute\Sc_P_HangingChute.tga

This is a binary file of the type: Binary

# xyz_Airborne_Mod\textures\models\static\parachute\strap.tga

This is a binary file of the type: Binary

# zz_admin-Pro_1.22_modif\countdown\mohdm1.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 1103.13 278.22 304.13 )
	local.origin[1] = ( 304.73 478.19 384.13 )
	local.origin[2] = ( 159.73 1553.99 384.13 )
	local.origin[3] = ( 1070.00 1407.15 384.13 )
	local.origin[4] = ( 47.24 2286.88 384.13 )
	local.origin[5] = ( -203.92 1303.86 48.13 )
	local.origin[6] = ( -1262.73 1597.23 62.87 )
	local.origin[7] = ( -667.92 478.47 -15.88 )
	local.origin[8] = ( -927.80 387.14 -15.88 )
	local.origin[9] = ( -452.64 1352.12 384.13 )
	local.origin[10] = ( 319.31 602.83 112.12 )
	local.origin[11] = ( 496.90 495.69 48.13 )
	local.origin[12] = ( -43.28 462.96 48.13 )
	local.origin[13] = ( 1125.97 2005.73 512.13 )
	local.origin[14] = ( 1612.19 1506.78 289.81 )
	local.origin[15] = ( 1528.24 936.87 528.13 )
	local.origin[16] = ( -126.37 1126.21 272.13 )
	local.origin[17] = ( -291.57 1136.87 552.13 )
	local.origin[18] = ( -535.80 1173.87 540.31 )
	local.origin[19] = ( 240.87 1679.13 552.13 )
	local.origin[20] = ( 229.23 1913.35 608.13 )
	local.origin[21] = ( 222 1355 108 )

end local.origin


```

# zz_admin-Pro_1.22_modif\countdown\mohdm2.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( -798.92 -2611.05 -61.88 )

	local.origin[1] = ( -403.24 -1764.55 -30.12 )

	local.origin[2] = ( 123.39 -934.01 -71.56 )

	local.origin[3] = ( -770.52 -622.89 40.13 )

	local.origin[4] = ( -227.13 -4.92 40.13 )

	local.origin[5] = ( -1051.94 1.62 40.13 )

	local.origin[6] = ( -2051.03 -781.71 16.13 )

	local.origin[7] = ( -2488.87 -415.13 16.13 )

	local.origin[8] = ( -1984.13 -1686.27 16.13 )

	local.origin[9] = ( -2119.48 -1000.62 240.13 )

	local.origin[10] = ( -1247.13 -1965.30 8.13 )

	local.origin[11] = ( -3560.88 -616.87 8.12 )

	local.origin[12] = ( -3367.08 -71.13 220.13 )

	local.origin[13] = ( -3341.59 -255.38 476.13 )

	local.origin[14] = ( -2813.03 -551.00 199.01 )

	local.origin[15] = ( -2269.70 -846.65 240.13 )

	local.origin[16] = ( -2128.51 -1335.31 480.13 )

	local.origin[17] = ( -1988.20 -499.34 240.13 )

	local.origin[18] = ( -104.86 -1678.01 94.00 )

	local.origin[19] = ( -1553.36 -2802.43 -53.00 )

	local.origin[20] = ( -2275.13 1840.87 216.13 )

	local.origin[21] = ( -1569 -525 -27)

end  local.origin


```

# zz_admin-Pro_1.22_modif\countdown\mohdm3.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 1256.00 352.00 -63.88 )

	local.origin[1] = ( 1155.33 -1475.50 -60.33 )

	local.origin[2] = ( 1712.87 -1927.13 -13.02 )

	local.origin[3] = ( 1057.82 -2564.45 8.13 )

	local.origin[4] = ( 1696.59 -3251.16 -0.55 )

	local.origin[5] = ( 3793.71 -2805.54 24.13 )

	local.origin[6] = ( 3820.07 -3439.51 8.13 )

	local.origin[7] = ( 3831.93 -2123.95 8.13 )

	local.origin[8] = ( 2319.13 -2292.87 8.12 )

	local.origin[9] = ( 2213.34 -1697.53 -0.33 )

	local.origin[10] = ( 2234.88 -1173.95 72.13 )

	local.origin[11] = ( 2384.19 -375.13 -63.88 )

	local.origin[12] = ( 2860.83 -593.73 -87.88 )

	local.origin[13] = ( 3152.05 -2591.17 0.12 )

	local.origin[14] = ( 2484.42 -2641.53 8.13 )

	local.origin[15] = ( 4925.90 -3175.54 278.13 )

	local.origin[16] = ( 4951.20 -3538.83 278.13 )

	local.origin[17] = ( 4522.25 -3562.75 248.13 )

	local.origin[18] = ( 2627.09 -2360.99 208.13 )

	local.origin[19] = ( 2479.16 -2680.88 208.13 )

	local.origin[20] = ( 2752.70 -2578.92 208.13 )

	local.origin[21] = ( 2781.75 -2191.13 208.13 )

	local.origin[22] = ( 1930.50 -1802.93 144.13 )

	local.origin[23] = ( 3572.32 -1602.70 264.13 )

	local.origin[24] = ( 1981 -1594 288 )

end  local.origin



```

# zz_admin-Pro_1.22_modif\countdown\mohdm4.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 1284.00 -804.00 192.13 )

	local.origin[1] = ( 97.62 -596.27 32.13 )

	local.origin[2] = ( -79.38 -49.08 16.13 )

	local.origin[3] = ( -43.70 511.35 32.12 )

	local.origin[4] = ( -1311.13 887.80 248.13 )

	local.origin[5] = ( -1247.44 1093.87 432.13 )

	local.origin[6] = ( -1212.83 1023.13 608.13 )

	local.origin[7] = ( -432.07 1368.52 728.13 )

	local.origin[8] = ( 405.25 1727.52 240.13 )

	local.origin[9] = ( 1103.15 1449.85 240.13 )

	local.origin[10] = ( -11.42 1329.40 240.13 )

	local.origin[11] = ( 668.53 2730.60 264.13 )

	local.origin[12] = ( 527.13 2559.13 264.13 )

	local.origin[13] = ( 783.30 3302.20 240.13 )

	local.origin[14] = ( 1549.09 2850.55 240.13 )

	local.origin[15] = ( 16.43 2677.56 16.13 )

	local.origin[16] = ( 715.07 4660.59 240.13 )

	local.origin[17] = ( -732.90 2182.16 248.13 )

	local.origin[18] = ( -1390.83 1310.57 248.13 )

	local.origin[19] = ( 337 1154 264 )

end  local.origin


```

# zz_admin-Pro_1.22_modif\countdown\mohdm5.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 2154 -4800 166 )

end  local.origin

```

# zz_admin-Pro_1.22_modif\countdown\mohdm6.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 120 96 9 )

	local.origin[1] = ( -21.25 841.47 -151.88 )
	// local.temp.angles = ( 15.10 -178.55 0.00 )

	local.origin[2] = ( -764.02 -176.02 -130.84 )
	// local.temp.angles = ( 10.85 -167.41 0.00 )

	local.origin[3] = ( -673.24 781.73 -151.81 )
	// local.temp.angles = ( 10.48 64.30 0.00 )

	local.origin[4] = ( 126.01 82.34 -150.70 )
	// local.temp.angles = ( 11.33 2.27 0.00 )

	local.origin[5] = ( 676.66 -637.14 -143.88 )
	// local.temp.angles = ( 17.27 34.46 0.00 )

	local.origin[6] = ( -120.85 -584.36 -151.88 )
	// local.temp.angles = ( 7.93 80.72 0.00 )

	local.origin[7] = ( -264.88 -467.25 32.13 )
	// local.temp.angles = ( 13.88 105.93 0.00 )

	local.origin[8] = ( -149.65 -671.14 272.13 )
	// local.temp.angles = ( 17.27 -167.69 0.00 )

	local.origin[9] = ( -908.87 -695.13 272.13 )
	// local.temp.angles = ( 20.20 -129.36 0.00 )

	local.origin[10] = ( -973.44 -426.81 256.13 )
	// local.temp.angles = ( 15.57 85.25 0.00 )

	local.origin[11] = ( -832.97 308.96 48.13 )
	// local.temp.angles = ( 20.20 -9.06 0.00 )

	local.origin[12] = ( -1196.87 496.87 48.13 )
	// local.temp.angles = ( 21.62 77.04 0.00 )

	local.origin[13] = ( -163.02 453.40 48.13 )
	// local.temp.angles = ( 13.22 -25.58 0.00 )

	local.origin[14] = ( 368.57 315.31 160.13 )
	// local.temp.angles = ( 15.57 -26.71 0.00 )

	local.origin[15] = ( 306.05 -39.19 364.88 )
	// local.temp.angles = ( 59.47 -111.77 0.00 )

	local.origin[16] = ( 239.13 -299.30 224.12 )
	// local.temp.angles = ( 22.84 80.76 0.00 )

	local.origin[17] = ( 696.63 124.46 224.12 )
	// local.temp.angles = ( 13.59 75.66 0.00 )

	local.origin[18] = ( 919.13 -304.87 224.13 )
	// local.temp.angles = ( 12.08 141.27 0.00 )

	local.origin[19] = ( -366.58 77.06 326.63 )
	// local.temp.angles = ( -11.99 5.14 0.00 )
end  local.origin


```

# zz_admin-Pro_1.22_modif\countdown\mohdm7.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( -567.01 166.63 -111.88 )

	local.origin[1] = ( -779.10 -412.86 -111.88 )

	local.origin[2] = ( -1476.66 -160.87 -115.88 )

	local.origin[3] = ( -1418.19 564.63 -127.88 )

	local.origin[4] = ( -1105.41 504.32 -105.88 )

	local.origin[5] = ( -1880.87 319.13 -119.88 )

	local.origin[6] = ( -1525.81 1034.49 -103.88 )

	local.origin[7] = ( -711.68 1944.20 -110.03 )

	local.origin[8] = ( -1034.31 -1205.41 -283.88 )

	local.origin[9] = ( -1304.46 -459.69 -163.88 )

	local.origin[10] = ( -2504.87 2045.37 0.12 )

	local.origin[11] = ( -2557.94 1055.19 0.12 )

	local.origin[12] = ( -3272.87 674.81 -107.88 )

	local.origin[13] = ( -2799.13 1355.13 0.13 )

	local.origin[14] = ( -1551.13 2215.18 184.13 )

	local.origin[15] = ( -272.11 1104.09 -135.79 )

	local.origin[16] = ( -240.85 50.98 40.13 )

	local.origin[17] = ( -1499.13 -1043.11 -283.88 )

	local.origin[18] = ( -1634.01 -511.13 -151.88 )

	local.origin[19] = ( -1414 162 -127 )


end  local.origin

```

# zz_admin-Pro_1.22_modif\countdown\mp_anzio_lib.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_ardennes_tow.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:


	local.origin[0] = ( -3387.30 1738.30 -27.95 )

	local.origin[1] = ( -2405.67 -2681.34 31.85 )

	local.origin[2] = ( -2680.54 -3721.42 21.59 )

	local.origin[3] = ( -746.59 -2317.11 5.81 )

	local.origin[4] = ( 1805.79 -1002.85 68.47 )

	local.origin[5] = ( 3464.87 12.66 -19.88 )

	local.origin[6] = ( 1505.73 504.79 248.13 )

	local.origin[7] = ( 1620.95 671.13 248.13 )

	local.origin[8] = ( 441.95 893.73 -11.87 )

	local.origin[9] = ( -819.80 1037.98 -95.88 )

	local.origin[10] = ( 1020.87 388.87 148.13 )
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_bahnhof_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( -647.48 3708.94 -447.88 )

	local.origin[1] = ( -1002.84 3773.44 -367.88 )

	local.origin[2] = ( -1257.80 3593.07 -447.88 )

	local.origin[3] = ( -1607.65 2718.48 -431.88 )

	local.origin[4] = ( -2560.47 3438.48 -607.88 )

	local.origin[5] = ( -2648.32 2651.79 -143.88 )

	local.origin[6] = ( -2934.49 2695.65 -110.98 )

	local.origin[7] = ( -2766.86 2227.58 -143.88 )

	local.origin[8] = ( -2801.95 1720.45 -344.31 )

	local.origin[9] = ( -3237.20 2345.24 -130.88 )

	local.origin[10] = ( -3414.59 1576.79 -135.35 )

	local.origin[11] = ( -3701.27 1781.53 -119.80 )

	local.origin[12] = ( -4026.35 1807.13 -127.88 )

	local.origin[13] = ( -4292.98 1810.06 -127.88 )

	local.origin[14] = ( -4542.24 1807.13 -127.88 )

	local.origin[15] = ( -4803.47 1807.13 -127.88 )

	local.origin[16] = ( -4949.08 2350.94 -399.76 )

	local.origin[17] = ( -4328.79 3291.16 -415.88 )

	local.origin[18] = ( -4281.99 3763.54 -435.66 )

	local.origin[19] = ( -3451.45 3944.70 -455.88 )

	local.origin[20] = ( -3063.34 3949.78 -447.88 )

	local.origin[21] = ( -2371.87 4503.42 -391.88 )

	local.origin[22] = ( -1663.71 3916.79 -187.67 )

	local.origin[23] = ( -1476.06 3972.02 -225.74 )

	local.origin[24] = ( -1252.64 3928.96 -235.88 )

	local.origin[25] = ( -2103.41 5497.58 -447.88 )

	local.origin[26] = ( -2615.39 4058.45 -227.50 )

	local.origin[27] = ( -3015.87 2963.89 -159.88 )

	local.origin[28] = ( -3224.24 3101.08 -130.88 )

	local.origin[29] = ( -3390.07 3159.58 -374.64 )

	local.origin[30] = ( -4272.96 1595.03 -399.88 )

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_bazaar_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:
	local.origin[0] = ( -633.98 -837.17 160.13 )

	local.origin[1] = ( -139.06 343.46 -103.88 )

	local.origin[2] = ( 528.88 159.26 -207.88 )

	local.origin[3] = ( -174.93 -135.94 -28.86 )

	local.origin[4] = ( -902.88 -422.45 128.13 )

	local.origin[5] = ( -615.72 -826.41 160.13 )

	local.origin[6] = ( -329.37 -468.03 -212.07 )

	local.origin[7] = ( -588.58 -191.84 -255.88 )

	local.origin[8] = ( -1136.60 -368.87 -255.88 )

	local.origin[9] = ( -534.04 770.54 -31.88 )

	local.origin[10] = ( 353.99 1895.34 256.13 )

	local.origin[11] = ( 559.13 1093.92 224.13 )

	local.origin[12] = ( 1152.07 1036.87 96.13 )

	local.origin[13] = ( 805.18 631.20 -253.59 )

	local.origin[14] = ( 584.51 966.16 -47.88 )

	local.origin[15] = ( 170.27 -1330.07 -207.88 )
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_berlin_tow.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:
	local.origin[0] = ( -2124.15 1511.28 16.12 )

	local.origin[1] = ( -2125.45 1289.32 75.13 )

	local.origin[2] = ( -2110.56 621.11 24.13 )

	local.origin[3] = ( -1725.14 682.44 256.13 )

	local.origin[4] = ( -2037.04 939.26 256.13 )

	local.origin[5] = ( -1781.19 1105.91 256.13 )

	local.origin[6] = ( -3532.95 1641.77 -7.87 )

	local.origin[7] = ( -3842.91 1927.67 16.13 )

	local.origin[8] = ( -5045.78 3132.44 16.13 )

	local.origin[9] = ( -4527.05 4897.88 200.13 )

	local.origin[10] = ( -4538.69 4421.68 168.13 )

	local.origin[11] = ( -4648.41 4201.59 43.69 )

	local.origin[12] = ( -5829.99 3858.77 16.13 )

	local.origin[13] = ( -5900.77 4020.15 192.13 )

	local.origin[14] = ( -5558.61 4587.79 59.13 )

	local.origin[15] = ( -3533.33 3063.62 0.12 )

	local.origin[16] = ( -3691.69 3539.50 0.12 )

	local.origin[17] = ( -3244.69 3976.76 0.12 )

	local.origin[18] = ( -2740.53 4260.88 0.12 )

	local.origin[19] = ( -2176.22 4389.16 0.12 )

	local.origin[20] = ( -1863.64 4721.43 0.12 )

	local.origin[21] = ( -1053.01 4839.60 32.13 )

	local.origin[22] = ( -590.35 5834.36 24.13 )

	local.origin[23] = ( 511.41 5249.55 72.13 )

	local.origin[24] = ( 150.43 5441.46 72.13 )

	local.origin[25] = ( 533.11 5644.77 128.13 )

	local.origin[26] = ( 949.95 5470.06 72.13 )

	local.origin[27] = ( 2704.61 4938.86 24.13 )

	local.origin[28] = ( 2859.77 3641.51 178.13 )

	local.origin[29] = ( 2765.33 3191.60 124.13 )

	local.origin[30] = ( 2438.62 2565.46 16.13 )

	local.origin[31] = ( 1210.28 2440.38 16.13 )

	local.origin[32] = ( 492.42 3702.80 16.13 )

	local.origin[33] = ( 2512.52 1233.40 -167.88 )

	local.origin[34] = ( 3830.75 2689.95 -167.88 )

	local.origin[35] = ( 4817.64 1769.37 -231.88 )

	local.origin[36] = ( 5720.36 1004.21 32.13 )

	local.origin[37] = ( 5713.87 1986.05 272.13 )

	local.origin[38] = ( 6125.44 2101.65 24.13 )

	local.origin[39] = ( 5340.25 3762.02 24.13 )

	local.origin[40] = ( 3734.03 2629.78 80.13 )

	local.origin[41] = ( -246.83 3437.95 36.13 )

	local.origin[42] = ( -823.10 2995.00 264.13 )

	local.origin[43] = ( -996.13 3230.38 264.13 )

	local.origin[44] = ( -953.44 2496.30 264.13 )

	local.origin[45] = ( -1479.94 2195.47 264.13 )

	local.origin[46] = ( -1892.18 2274.83 128.13 )

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_bizertefort_obj.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_bizerteharbor_lib.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_bologna_obj.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_brest_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:
	local.origin[0] = ( -156.29 1392.48 217.00 )

	local.origin[1] = ( -787.45 -77.88 270.27 )

	local.origin[2] = ( 471.17 899.12 448.13 )

	local.origin[3] = ( 858.63 662.92 271.13 )

	local.origin[4] = ( 696.22 -283.99 280.13 )

	local.origin[5] = ( -106.79 -1350.81 400.13 )

	local.origin[6] = ( -1083.53 -2087.91 408.13 )

	local.origin[7] = ( -1383.47 -1857.31 568.13 )

	local.origin[8] = ( -2629.40 -1067.12 392.13 )

	local.origin[9] = ( -2583.62 -277.51 377.19 )

	local.origin[10] = ( -839.12 682.80 512.13 )

	local.origin[11] = ( -906.81 1644.02 408.13 )

	local.origin[12] = ( 400.34 1801.12 252.13 )

	local.origin[13] = ( 690.10 952.80 258.98 )

	local.origin[14] = ( 1245.05 -1062.06 280.13 )

	local.origin[15] = ( 813.41 -615.33 280.13 )

	local.origin[16] = ( 865.99 -334.81 280.13 )

	local.origin[17] = ( -101.90 1132.04 293.26 )

	local.origin[18] = ( -687.57 1358.68 512.13 )

	local.origin[19] = ( -550.44 -40.75 383.13 )
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_castello_obj.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_druckkammern_tow.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:


	local.origin[0] = ( -1309.92 -1805.13 -639.86 )

	local.origin[1] = ( -162.05 -3065.73 -511.88 )

	local.origin[2] = ( 533.00 -2896.66 -511.88 )

	local.origin[3] = ( 1093.23 -3818.04 -511.88 )

	local.origin[4] = ( 1342.38 -4789.89 -303.88 )

	local.origin[5] = ( 2466.75 -4035.57 -236.73 )

	local.origin[6] = ( 2746.80 -4036.51 -229.15 )

	local.origin[7] = ( 3477.37 -4313.01 -271.88 )

	local.origin[8] = ( 2897.08 -2852.06 -235.77 )

	local.origin[9] = ( 2692.92 -2840.07 -226.86 )

	local.origin[10] = ( 2061.92 -2581.42 -255.88 )

	local.origin[11] = ( 3163.48 -2482.15 -511.88 )

	local.origin[12] = ( 2650.19 -3314.23 -624.88 )

	local.origin[13] = ( 2535.87 -3912.73 -624.88 )

	local.origin[14] = ( 2691.49 -4227.40 -624.88 )

	local.origin[15] = ( 2659.20 -3554.03 -445.88 )

	local.origin[16] = ( 2649.15 -3807.61 -444.88 )

	local.origin[17] = ( 2677.21 -4019.96 -544.88 )

	local.origin[18] = ( 3526.79 -4142.62 -567.88 )

	local.origin[19] = ( 3858.80 -1049.71 -515.88 )

	local.origin[20] = ( 5077.92 -2985.30 -479.88 )

	local.origin[21] = ( 5290.75 -2620.94 -255.88 )

	local.origin[22] = ( 5365.17 -3278.22 -255.88 )

	local.origin[23] = ( 5294.56 -3793.61 -405.88 )

	local.origin[24] = ( 4148.00 -3725.14 -639.88 )

	local.origin[25] = ( 3621.02 -4161.52 -567.88 )

	local.origin[26] = ( 2438.08 -1015.13 -255.88 )

	local.origin[27] = ( 3955.58 -992.96 -255.88 )

	local.origin[28] = ( 5155.69 -493.13 -159.88 )

	local.origin[29] = ( 5648.60 975.91 -161.88 )

	local.origin[30] = ( 3301.02 -1651.80 -511.88 )

	local.origin[31] = ( 3606.50 -2017.64 -271.88 )
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_flughafen_tow.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:



	local.origin[0] = ( 1996.26 3317.25 -23.85 )

	local.origin[1] = ( 1203.76 3473.46 -416.88 )

	local.origin[2] = ( 44.26 2933.53 -416.88 )

	local.origin[3] = ( -7.24 2243.11 -416.88 )

	local.origin[4] = ( -517.30 1596.27 -415.88 )

	local.origin[5] = ( -1568.00 793.12 -382.28 )

	local.origin[6] = ( -1797.48 867.02 -23.88 )

	local.origin[7] = ( -3745.09 883.53 -23.88 )

	local.origin[8] = ( -2897.97 2268.68 -23.88 )

	local.origin[9] = ( -1943.24 2096.12 -23.88 )

	local.origin[10] = ( -1031.17 1972.27 -23.88 )

	local.origin[11] = ( -85.39 2028.80 -23.88 )

	local.origin[12] = ( 1028.58 959.28 328.13 )

	local.origin[13] = ( 1077.09 1369.13 281.46 )

	local.origin[14] = ( 165.42 1230.37 -23.88 )

	local.origin[15] = ( -1722.82 1365.52 -62.88 )

	local.origin[16] = ( -1971.87 3112.87 -23.88 )

	local.origin[17] = ( -1543.06 3376.78 35.13 )

	local.origin[18] = ( -2706.36 3373.27 35.13 )

	local.origin[19] = ( -3952.87 3008.87 -23.88 )

	local.origin[20] = ( 350.89 4176.87 -15.88 )

	local.origin[21] = ( -334.43 993.39 -23.88 )

	local.origin[22] = ( -299.49 183.90 -23.88 )

	local.origin[23] = ( -1369.24 -2014.41 -23.88 )

	local.origin[24] = ( -217.79 -1210.63 -15.88 )

	local.origin[25] = ( -398.32 -1092.68 280.13 )

	local.origin[26] = ( -314.44 -1023.07 440.13 )

	local.origin[27] = ( -427.99 -1260.61 440.13 )

	local.origin[28] = ( -2323.58 -3051.03 77.62 )

	local.origin[29] = ( 531.34 1096.87 -23.88 )

	local.origin[30] = ( -1024.87 1080.87 -23.88 )


end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_gewitter_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 2637.19 1394.39 144.13 )

	local.origin[1] = ( 1719.94 1759.16 128.13 )

	local.origin[2] = ( 2148.68 671.13 120.13 )

	local.origin[3] = ( 1595.14 603.49 328.13 )

	local.origin[4] = ( 1718.21 1316.11 372.13 )

	local.origin[5] = ( 2159.44 1823.08 328.13 )

	local.origin[6] = ( 2011.41 1539.10 374.62 )

	local.origin[7] = ( 231.11 1357.13 56.13 )

	local.origin[8] = ( -980.66 3008.52 16.13 )

	local.origin[9] = ( -1657.95 2923.11 16.13 )

	local.origin[10] = ( -1853.46 2914.89 224.13 )

	local.origin[11] = ( -2528.75 2008.97 0.13 )

	local.origin[12] = ( -2659.56 1433.29 0.14 )

	local.origin[13] = ( -4185.70 641.15 64.13 )

	local.origin[14] = ( -4088.21 962.14 176.13 )

	local.origin[15] = ( -4728.87 1225.49 256.13 )

	local.origin[16] = ( -3850.28 1485.06 256.13 )

	local.origin[17] = ( -3670.92 817.17 264.13 )

	local.origin[18] = ( -3940.10 461.48 256.13 )

	local.origin[19] = ( -2624.70 1417.40 192.13 )

	local.origin[20] = ( -1698.37 2930.17 16.13 )

	local.origin[21] = ( -4384.74 2641.40 122.79 )

	local.origin[22] = ( -4807.11 1232.97 168.23 )
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_holland_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:
	local.origin[0] = ( 3820.52 -712.61 -143.87 )

	local.origin[1] = ( 2554.17 -1079.52 127.13 )

	local.origin[2] = ( 1690.85 1290.00 2.13 )

	local.origin[3] = ( 254.18 1246.93 88.13 )

	local.origin[4] = ( -725.34 1294.34 82.13 )

	local.origin[5] = ( -1572.87 1349.46 82.13 )

	local.origin[6] = ( -1893.37 1474.26 -2.02 )

	local.origin[7] = ( -2178.80 696.87 28.13 )

	local.origin[8] = ( -2016.03 -1804.32 36.15 )

	local.origin[9] = ( -1828.96 -1797.97 -191.88 )

	local.origin[10] = ( -1217.96 -1219.15 8.13 )

	local.origin[11] = ( -1254.61 -1043.15 248.13 )

	local.origin[12] = ( -1222.28 -2288.83 0.13 )

	local.origin[13] = ( -652.84 -1123.34 -7.87 )

	local.origin[14] = ( -172.58 -454.03 0.12 )
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_kasserine_tow.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_malta_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:
	local.origin[0] = ( -657.16 -1308.56 -1279.88 )

	local.origin[1] = ( 249.39 -1536.66 -1375.88 )

	local.origin[2] = ( 185.98 -1839.88 -1367.88 )

	local.origin[3] = ( 521.56 -2005.99 -1375.88 )

	local.origin[4] = ( 930.58 -1937.07 -1407.88 )

	local.origin[5] = ( 1508.09 -2046.19 -1367.98 )

	local.origin[6] = ( 2471.38 -955.40 -1207.88 )

	local.origin[7] = ( 1969.92 -410.89 -1279.88 )

	local.origin[8] = ( 2112.49 341.85 -1421.75 )

	local.origin[9] = ( 2680.87 231.01 -1471.88 )

	local.origin[10] = ( 2691.62 -580.38 -1695.88 )

	local.origin[11] = ( 2575.18 195.87 -1680.88 )

	local.origin[12] = ( 2598.94 830.79 -1722.09 )

	local.origin[13] = ( 2618.77 1501.22 -1407.88 )

	local.origin[14] = ( 2445.56 2255.14 -1407.88 )

	local.origin[15] = ( 2294.54 2804.52 -1279.88 )

	local.origin[16] = ( 1722.67 2624.65 -1407.88 )

	local.origin[17] = ( 874.65 2625.27 -1407.88 )

	local.origin[18] = ( 1476.41 3035.98 -1199.88 )

	local.origin[19] = ( 1686.03 2423.52 -1219.04 )

	local.origin[20] = ( 1200.08 2666.33 -1199.88 )

	local.origin[21] = ( 978.79 2715.27 -1199.88 )

	local.origin[22] = ( 1505.50 2750.91 -1023.88 )

	local.origin[23] = ( 2134.96 2516.11 -1023.88 )

	local.origin[24] = ( 1561.80 3323.54 -1023.88 )

	local.origin[25] = ( 2532.94 3880.31 -1055.88 )

	local.origin[26] = ( -188.97 2786.10 -1023.88 )

	local.origin[27] = ( 16.87 2108.36 -1215.88 )

	local.origin[28] = ( -451.50 2018.24 -1398.89 )

	local.origin[29] = ( -227.72 2896.87 -1343.88 )

	local.origin[30] = ( 66.18 2825.93 -1407.88 )

	local.origin[31] = ( 327.43 2335.15 -1407.88 )

	local.origin[32] = ( -65.90 1965.68 -1407.88 )

	local.origin[33] = ( -934.88 1197.10 -1399.88 )

	local.origin[34] = ( -889.62 86.28 -1471.88 )

	local.origin[35] = ( -884.42 -255.21 -1471.88 )

	local.origin[36] = ( -1119.79 -1355.63 -1484.92 )

	local.origin[37] = ( -1666.15 -1368.20 -1567.88 )

	local.origin[38] = ( -1840.62 -1816.69 -1563.88 )

	local.origin[39] = ( -2327.39 -2627.54 -1391.88 )

	local.origin[40] = ( -1780.19 -2343.74 -1039.88 )

	local.origin[41] = ( -1211.09 -1811.65 -1223.88 )

	local.origin[42] = ( -1776.26 -1262.81 -1343.88 )

	local.origin[43] = ( -1775.69 -957.44 -1343.81 )

	local.origin[44] = ( 596.76 624.12 -999.88 )

	local.origin[45] = ( 857.40 1219.53 -1407.88 )

	local.origin[46] = ( 864.02 1568.42 -1407.88 )

	local.origin[47] = ( 622.36 2436.18 -1407.88 )

	local.origin[48] = ( 1388.76 2008.90 -1407.88 )

	local.origin[49] = ( 960.72 1423.44 -1735.88 )

	local.origin[50] = ( 847.93 967.99 -1735.88 )

	local.origin[51] = ( -896.99 1269.12 -1735.88 )

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_montebattaglia_tow.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_montecassino_tow.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_palermo_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_palermo_obj.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_ship_lib.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_stadt_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:


	local.origin[0] = ( -2545.75 2701.64 56.13 )


	local.origin[1] = ( -2283.95 2218.06 56.13 )


	local.origin[2] = ( -2209.75 1723.44 0.12 )


	local.origin[3] = ( -1678.24 1172.44 57.13 )


	local.origin[4] = ( -2508.41 273.38 8.13 )


	local.origin[5] = ( -1808.24 -737.51 59.13 )


	local.origin[6] = ( -1208.86 -1344.87 64.13 )


	local.origin[7] = ( -863.63 -598.01 336.13 )


	local.origin[8] = ( -759.50 -432.48 336.13 )


	local.origin[9] = ( -1131.90 77.39 -7.88 )


	local.origin[10] = ( -742.91 5.26 -7.88 )


	local.origin[11] = ( -1072.72 1878.46 -263.88 )


	local.origin[12] = ( -326.75 2468.38 -263.88 )


	local.origin[13] = ( -2.63 1878.87 -303.88 )


	local.origin[14] = ( 125.03 1241.72 168.13 )


	local.origin[15] = ( -308.74 1522.77 280.13 )


	local.origin[16] = ( -975.42 1091.41 -251.26 )


	local.origin[17] = ( -1104.96 3.74 -263.88 )


	local.origin[18] = ( -1884.21 -1164.26 -263.88 )


	local.origin[19] = ( 144.86 -728.23 40.13 )


	local.origin[20] = ( -234.15 2051.16 67.13 )


	local.origin[21] = ( -1051.79 -1008.86 8.13 )


	local.origin[22] = ( -1113.72 2987.80 520.13 )


	local.origin[23] = ( -1088.51 2583.64 164.13 )


	local.origin[24] = ( -1420.15 2578.96 164.13 )


	local.origin[25] = ( -1164.25 1164.28 0.12 )

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_tunisia_lib.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_unterseite_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( -1436.50 2006.28 48.13 )

	local.origin[1] = ( -1264.19 1148.39 -127.88 )

	local.origin[2] = ( -709.25 1100.28 224.13 )

	local.origin[3] = ( -268.48 394.92 181.90 )

	local.origin[4] = ( 1152.32 1091.92 219.04 )

	local.origin[5] = ( 876.47 1428.49 208.13 )

	local.origin[6] = ( 679.46 1110.66 -207.88 )

	local.origin[7] = ( -376.26 1529.83 -447.88 )

	local.origin[8] = ( 221.74 1870.10 -367.88 )

	local.origin[9] = ( -738.20 1984.08 -31.88 )

	local.origin[10] = ( 131.41 2446.41 259.13 )

	local.origin[11] = ( -259.87 1379.80 232.98 )

	local.origin[12] = ( 419.41 2327.73 154.69 )

	local.origin[13] = ( -45.13 2589.17 200.13 )

	local.origin[14] = ( -738.26 2673.95 40.13 )

	local.origin[15] = ( -1171.75 1966.51 -191.88 )

	local.origin[16] = ( -1164.96 1139.20 28.13 )

	local.origin[17] = ( -490.85 972.25 288.13 )

	local.origin[18] = ( -450.70 766.72 288.13 )

	local.origin[19] = ( 403.14 555.79 35.50 )
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\mp_verschneit_dm.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:
	local.origin[0] = ( 60.27 -2163.11 -86.88 )

	local.origin[1] = ( -965.62 -1458.41 -127.88 )

	local.origin[2] = ( -1482.90 -1970.08 224.13 )

	local.origin[3] = ( -1296.44 -2073.10 304.13 )

	local.origin[4] = ( -1809.11 -2444.56 -55.88 )

	local.origin[5] = ( -2220.29 -2719.39 8.13 )

	local.origin[6] = ( -2385.97 -2670.87 8.13 )

	local.origin[7] = ( -2894.13 -2627.11 9.13 )

	local.origin[8] = ( -3200.52 -1982.02 188.13 )

	local.origin[9] = ( -2854.39 -2201.48 240.13 )

	local.origin[10] = ( -3046.19 -1570.80 240.13 )

	local.origin[11] = ( -2789.18 -1323.67 40.34 )

	local.origin[12] = ( -2324.64 -391.23 0.12 )

	local.origin[13] = ( -2021.61 -592.87 36.12 )

	local.origin[14] = ( -1064.42 -1400.04 164.33 )

	local.origin[15] = ( -966.01 -1555.57 220.99 )

	local.origin[16] = ( -352.54 -2871.75 -287.88 )

	local.origin[17] = ( -416.73 -3430.69 -119.88 )

	local.origin[18] = ( -2345.05 -1855.51 8.12 )

	local.origin[19] = ( -3169.06 -1280.69 8.12 )
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\obj_team1.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 2884.03 4252.13 -237.19 )

	local.origin[1] = ( 3384.87 4419.52 -223.88 )

	local.origin[2] = ( 3721.05 3719.97 -268.13 )

	local.origin[3] = ( 4418.54 4182.41 -287.90 )

	local.origin[4] = ( 4829.44 4089.92 -279.07 )

	local.origin[5] = ( 2917.90 2783.28 -245.54 )

	local.origin[6] = ( 3065.62 2911.14 -71.88 )

	local.origin[7] = ( 2335.14 3141.89 -217.94 )

	local.origin[8] = ( 2716.87 4235.13 19.13 )

	local.origin[9] = ( 4580.85 1479.46 -349.65 )

	local.origin[10] = ( 4528.30 1302.14 -351.81 )

	local.origin[11] = ( 4356.15 1856.87 -167.88 )

	local.origin[12] = ( 3226.82 1364.84 -282.97 )

	local.origin[13] = ( 3480.21 2255.51 -201.18 )

	local.origin[14] = ( 3471.13 2822.51 -209.96 )

	local.origin[15] = ( 21.96 251.00 -357.44 )

	local.origin[16] = ( 1576.86 -44.55 -279.88 )

	local.origin[17] = ( 1319.13 -184.87 -279.88 )

	local.origin[18] = ( 5531.53 -13.89 -419.88 )

	local.origin[19] = (  3096 3173 -228 )

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\obj_team2.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:
	local.origin[0] = ( 1236.43 1989.03 -575.88 )

	local.origin[1] = ( 95.75 1149.64 -511.88 )

	local.origin[2] = ( 411.19 1135.13 -223.88 )

	local.origin[3] = ( 368.41 621.46 0.13 )

	local.origin[4] = ( 368.87 511.13 -239.88 )

	local.origin[5] = ( 1020.18 786.93 -217.88 )

	local.origin[6] = ( 850.86 2523.82 -447.88 )

	local.origin[7] = ( 704.87 1516.21 0.13 )
	
	local.origin[8] = ( 171 2009 -374 )

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\obj_team3.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 334.25 -1230.78 -501.88 )

	local.origin[1] = ( 1134.41 -1226.44 -503.88 )

	local.origin[2] = ( 2581.79 -112.02 -571.88 )

	local.origin[3] = ( 1676.80 94.13 -127.88 )

	local.origin[4] = ( 604.97 -316.68 -547.88 )

	local.origin[5] = ( 1792.41 1011.19 256.13 )

	local.origin[6] = ( 3174.55 -4504.73 -458.13 )

	local.origin[7] = ( -453.72 -5144.63 -505.39 )

	local.origin[8] = ( -399.71 -3889.94 -436.68 )

	local.origin[9] = ( 2556.46 -3376.76 -394.56 )

	local.origin[10] = ( 3029.50 -2574.53 -248.08 )

	local.origin[11] = ( 2256.64 -1904.85 -323.88 )

	local.origin[12] = ( -608.00 -1621.71 -483.08 )

	local.origin[13] = ( 562.93 -2042.52 -353.34 )

	local.origin[14] = ( 794 -1034 275 )
	
end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\obj_team4.scr

```scr
//The mod will choose between a random number of starting positions. 
//I only added one but you can add as many as you want.
//By adding them into an array of local.origin and then ending with the local.origin variable.
//Each tiemyou add a ogiin use the same format btu increase the number by one for the index, for example.
//
//main:
//
//	local.origin[0] = ( 504 -5128 -447 )
//	local.origin[1] = ( -1414 162 -127 )
//	local.origin[2] = ( 120 96 9 )
//
//end  local.origin

main:

	local.origin[0] = ( 1284.00 -804.00 192.13 )

	local.origin[1] = ( 97.62 -596.27 32.13 )

	local.origin[2] = ( -79.38 -49.08 16.13 )

	local.origin[3] = ( -43.70 511.35 32.12 )

	local.origin[4] = ( -1311.13 887.80 248.13 )

	local.origin[5] = ( -1247.44 1093.87 432.13 )

	local.origin[6] = ( -1212.83 1023.13 608.13 )

	local.origin[7] = ( -432.07 1368.52 728.13 )

	local.origin[8] = ( 405.25 1727.52 240.13 )

	local.origin[9] = ( 1103.15 1449.85 240.13 )

	local.origin[10] = ( -11.42 1329.40 240.13 )

	local.origin[11] = ( 668.53 2730.60 264.13 )

	local.origin[12] = ( 527.13 2559.13 264.13 )

	local.origin[13] = ( 783.30 3302.20 240.13 )

	local.origin[14] = ( 1549.09 2850.55 240.13 )

	local.origin[15] = ( 16.43 2677.56 16.13 )

	local.origin[16] = ( 715.07 4660.59 240.13 )

	local.origin[17] = ( -732.90 2182.16 248.13 )

	local.origin[18] = ( -1390.83 1310.57 248.13 )

	local.origin[19] = ( 337 1154 264 )

end  local.origin
```

# zz_admin-Pro_1.22_modif\countdown\Template.txt

```txt
local.origin[ARRAY] = ( ORIGIN_TEMPLATE )


```

# zz_admin-Pro_1.22_modif\global\ac\admin_feedback.scr

```scr
// this script just messages the server console (or admin menu.

main local.message local.bold:

	if(local.message == NIL || local.message == "")
	{
		end
	}

	if(level.admins)
	{
		for(local.i = 0 ; local.i <= level.admins.size ; local.i++)
		{

			if(level.admins[local.i] != NIL && level.admins[local.i] != NULL)
			{
				if(local.bold == 1 )
				{
					level.admins[local.i] iprint local.message 1
				}
				else
				{
					level.admins[local.i] iprint local.message 
				}
			}	
		}
	}
end

/*
	else
	{	if(local.error)
		{
			if(level.errorlog == NIL)
			{
				local.i = 0
				thread errorlog
			}
			else
			{
				local.i = level.errorlog.size
			}

			level.errorlog[local.i] = local.message
		}

		println local.message

	}


end 


errorlog:

		while !(level.admins)
		{
			wait 2
		}


		if(level.admins)
		{
			for(local.i = 0;local.i <= level.errorlog.size - 1; local.i++)
			{
				exec global/ac/console_feedback.scr ("ERROR LOG: " + level.errorlog[local.i])
			}
		}
end

*/
```

# zz_admin-Pro_1.22_modif\global\ac\admincam.scr

```scr
// Admin cam 
// main self is plaer to spec, local.admin is passed admin

main local.admin:

	if(local.admin == NIL)
	{
		exec global/ac/console_feedback.scr "You must specify a admin after camme"
		exec global/ac/console_feedback.scr "eg. admin-cmd 1 camme 2"
		end
	}

	local.admin = waitexec global/nagle.scr::find_player local.admin

	if(self == local.admin)
	{
		local.admin iprint "You can not use camme yourself"
		end
	}

	if(level.admincamon == local.admin)
	{
		local.admin iprint "Admin Cam is already being used"
		end
	}

	level.admincamon = local.admin
	
	local.admin nodamage
	local.admin hide
	local.admin notsolid
	local.admin noclip

	local.origin = local.admin.origin

	local.admin iprint "Press Fire to toggle between eye view" 1
	local.admin iprint "Press USE to toggle stay" 1
	
	
	/*
	local.cam = "admincam" + randomint 1000 // make sure it's unique
	local.camera = spawn Camera targetname local.cam
	local.cam_trigger = spawn TriggerCameraUse target local.cam
	local.cam_trigger doUse local.admin
	local.camera targetname ""

	local.camera orbit local.player // self
	*/

//
//	local.player = spawn animate
//	local.player.model = self.brushmodel
//	local.player hide
//	local.player notsolid
//	local.player.origin = self.origin
//	local.player.angles = self.angles
//	local.player show

	
	group.eye = 0
	group.end = 0

	local.player = self

	thread check 

	while(group.end == 0)
	{
		waitframe

		if(group.eye == 0)
		{
			local.admin.origin = local.player.origin - local.player.forwardvector * 56 //distance back
			local.admin.origin +=  ( 0 0 24 ) //dist up
		}
		else
		{
			local.admin.origin = local.player.origin

			local.vertical = (self getcontrollerangles 0)[2] //self.viewangles[2]
	
			local.admin.viewangles = ( self.viewangles[0] self.viewangles[1] local.vertical )
				
		}
	}

	local.admin.origin = local.origin 
	local.admin show
	local.admin takedamage
	local.admin solid
	local.admin noclip
	local.admin iprint "Ending Admin Cam"
	level.admincamon = NIL
end

check:

	while(self != NULL && self != NIL && self.dmteam != "spectator")
	{
		if(self.fireheld == 1 )
		{
			if( group.eye == 1 )
			{
				group.eye = 0
			}
			else
			{
				group.eye = 1
			}
		}

		if(self.useheld == 1)
		{
			group.end = 1
			end
		}

		wait 0.2

	}
end


```

# zz_admin-Pro_1.22_modif\global\ac\broken.scr

```scr
// if this script runs it means u have a broken settings file

main:

	setcvar "g_statefile" "global/mike"
	
	while(1)
	{
		iprintlnbold "ERROR: Their is a big problem with anti camper mod"
		wait 5
		iprintlnbold "ERROR: he problem is probably due to text  settings files"
		wait 5
		iprintlnbold "ERROR: If you can not fix, contact me www.mods-r-us.net"
	}
end
```

# zz_admin-Pro_1.22_modif\global\ac\check_leanbind.scr

```scr
// Check a player for lean bind and displays info in console 

main:

	if(level.run["check_leanbind"] != "1" ){end}

	
	while(level.run["check_leanbind"] == "1")
	{
		wait 1
	
		for(local.i = 1; local.i <= $player.size; local.i++)
		{ 
			$player[local.i] waitthread check_leanbind
			wait 1
		}
	}

end

check_leanbind:

	local.possibilities = waitexec settings/lean_binds/lean_binds.txt

	if(local.possibilities==NIL)
	{
		level.run["check_leanbind"] = "0"
		exec global/ac/console_feedback.scr "ERROR: There was an error searching for lean bindings"
		end
	}
	
	for(local.i= 1; local.i <= local.possibilities.size; local.i++)
	{	
		local.bind = local.possibilities[local.i][1]
		
		if(local.bind == "none" || "None")
		{
			local.bind = local.possibilities[local.i][2]
			local.ikke = 1
		}
		else
		{
			local.ikke = 0
		}

		local.key[1] = getboundkey1 local.bind
		local.key[2] = getboundkey2 local.bind

		iprintln local.key[1]
		iprintln local.key[2]
		wait 1	
		if(local.ikke == 1)
		{
			if(local.key[1] == "Not Bound" && local.key[2] == "Not Bound")
			{
				self thread using_lb
			}
		}
		else
		{
			if(local.key[1] != "Not Bound" || local.key[2] != "Not Bound")
			{
				self thread using_lb
			}
		}
	}
end

using_lb:

if(self.lb == NIL){self.lb = 0 }

self.lb ++
iprintln ("using lean bind " + self.lb )
end
```

# zz_admin-Pro_1.22_modif\global\ac\command_post\commands_with_extra.scr

```scr
// file for the command that has extra stuff. like u can set 3rd param that does soemthing . like hel or reset.
// local.words is a array of the line.
// local.words[1] is the command
//
// also used to turn on and off scripts, 
// end normal, or end 0 - set the command also

main local.words: 

	switch(local.words[1])
	{
	case "imadmin":

		if( local.words[2] == NIL)
		{
			end
		}

		local.words[2] = int local.words[2]
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			if(local.words[2] == $player[local.i].entnum)
			{

				local.player = $player[local.i]
				local.player.admin = 1

				if(level.admins==NIL)
				{
					for(local.k = 1; local.k <= $player.size; local.k++)
					{
						$player[local.i] stufftext ("globalwidgetcommand Admins_list deleteallitems")
					}
					level.admins[0] = local.player
				}
				else
				{
					level.admins[lecel.admins.size + 1] = local.player
				}	

				local.player stufftext ("set admins_inform Player " + local.player.entnum )
				//local.player stufftext ("ui_hud 0")
				local.player stufftext "showmenu inform"
				wait 3
				local.player stufftext "hidemenu inform"
				//local.player stufftext ("ui_hud 1")

				local.player stufftext ("globalwidgetcommand Admins_list additem Admin_"  + string( local.words[2] ))
					
				local.player exec global/ac/track_admins.scr
				break
			}
		}
	break
	case "inputtype":
		if( local.words[2] == "windows")
		{
			game.input_type = "linux"
		}
		else if( local.words[2] == "windows")
		{
			game.input_type = "windows"
		}
		else
		{
			exec global/ac/console_feedback.scr "Input-type must be either windows or linux"
		}
	break
	case "setcvar":
		setcvar local.words[2] local.words[3]
		exec global/ac/console_feedback.scr ( local.words[2] + " set to " + local.words[3 ])
	break
	case "help":
		if(local.words[2]=="reset")
		{			
			exec global/ac/console_feedback.scr (  "Reset is set to: " + game.reset ) 
		}
		else
		{
			local.is_script = waitthread check_isscript local.words

			if(local.is_script != 1)
			{
				exec global/help.scr::help local.words[2]
			}
		}
	break
	case "teamwin":
		teamwin local.words[2]
	break
	case "reset":
		if(local.words[2]=="reset")
		{
			setcvar "AP_scripts" ""
			exec global/ac/admin_feedback.scr "Admin-Pro Mod Reset"
			exec global/ac/console_feedback.scr "Admin-Pro Mod Reset"

			exec global/reset_settings.scr
		}
	break
	case "music":

		if(local.words[2] == "0" || local.words[2] == "1")
		{
			local.return = waitthread turnoff local.words

			if(local.return == 0 )
			{
				end 0
			}
			else
			{
				end
			}
		}
		else
		{
			for(local.i = 1; local.i <= game.scripts.size; local.i++)
			{
				if(local.words[1] == game.scripts[local.i][1])
				{
					local.thread = waitexec global/settings.scr::getcmd local.words[1] 4 
					
					if(local.words[2]=="track")
					{
						exec local.thread local.words[2] local.words[3]
					}
					else
					{
						exec local.thread local.words[2]
					}				
					end 1
				}
			}
			
			exec global/ac/console_feedback.scr "bad music command"	
		}
		
	break
	case "all":
		local.actual = waitexec global/strings.scr::Combine local.words 3

		local.said = 0
		for(local.i=1; local.i <= $player.size; local.i++) 
		{   
			local.player = $player[local.i]
			local.mhm = waitexec global/ac/command_post/console.scr 2 local.words local.actual local.player
	
			if(local.mhm != 1 )
			{	
				if(local.said ==0 )
				{
					local.said = 1
					exec global/ac/console_feedback.scr "Bad command "
					exec global/ac/console_feedback.scr "All must be followed by a valid player commands."
				}
			}	
		}

	break
	case "axis":
	case "allies":
	case "spectator":
	case "spectators":


		if(local.words[1] == "spectators")
		{
			local.words[1] = "spectator"
		}

		local.actual = waitexec global/strings.scr::Combine local.words 3

		local.said = 0
		for(local.i=1; local.i <= $player.size; local.i++) 
		{   
			local.player = $player[local.i]

			if(local.player.dmteam== local.words[1])
			{
				local.mhm = waitexec global/ac/command_post/console.scr 2 local.words local.actual local.player
			}

			if(local.mhm != 1 )
			{	
				if(local.said ==0 )
				{
					local.said = 1
					exec global/ac/console_feedback.scr "Bad command "
					exec global/ac/console_feedback.scr "Team must be followed by a valid player commands."
				}
			}	
		}
	break
	case "limitweap":
		self thread limitweapons local.words
	break
	case "jumpheight":

		local.word = int local.words[2]
		if(local.word == 0)
		{
			local.word = 56
			exec global/ac/console_feedback.scr "jump height seemed to be 0, reseting to 56"				
		}
		game.jump_height = local.word

		exec global/ac/console_feedback.scr ( "jump height set to " + local.word )		

	break
	case "dmrespawning":
		level.dmrespawning  = local.words[2]
	break
	case "earthquake":
		earthquake local.words[2] local.words[3] local.words[4] local.words[5]
	break
	case "plantingteam":
		level.planting_team  = local.words[2]
	break
	case "iprintlnbold":
		local.actual = waitexec global/strings.scr::Combine local.words 2
		iprintlnbold_noloc local.actual
	break
	case "iprintln":
		local.actual = waitexec global/strings.scr::Combine local.words 2
		iprintln_noloc local.actual
	break
	default: //not found above so check scripts
		local.return = waitthread turnoff local.words

		if(local.return == 0)
		{
			if (local.words[2] == "1")
			{
				local.onoff = "On"
			}
			else if (local.words[2] == "0")
			{
				local.onoff = "Off"
			}
			else
			{
				local.onoff = local.words[2]
			}

			local.msg = (  local.words[1] + " " +  local.onoff )

			if(local.words[1] == "camper")
			{
				if(level.run["camper"] == "1")
				{
					game.types = waitexec game.file["camper"]::types
				}
			}

			exec global/ac/admin_feedback.scr local.msg 1
			exec global/mod_inform.scr local.msg
			exec global/settings.scr::clear_spawn_scripts_with
			end 1
		}
		else
		{
			end
		}
	}

end 1 //found 

// 1 - found word
// 0 set setting but found word
// nil not found


// end with 0 to set the setting also

turnoff local.words:

	for(local.i = 1; local.i <= game.scripts.size; local.i++)
	{
		if(local.words[1] == game.scripts[local.i][1])
		{	
			game.scripts[local.i][2] = local.words[2]
			level.run[local.words[1]] = local.words[2]


			exec global/ac/console_feedback.scr ( "> Script found " + local.words[1])	
			level.run[local.words[1]] = local.words[2]

			if(game.file[local.words[1]] == NIL)
			{	
				waitexec global/settings.scr::Loadsettings game.scripts[local.i]
			}

			local.APscripts  = ""

			local.thread =  game.scripts[local.i][4] //waitexec global/settings.scr::getcmd local.words[1] 4 //the script path (runs the scr again with new setting
		
			for(local.i=1;local.i <= game.scripts.size;local.i++)
			{	
				local.APscripts += game.scripts[local.i][2] 
			}

			setcvar "AP_scripts" local.APscripts 

			exec local.thread
			end 0
		}
	}
end 

limitweapons local.words:

	for(local.i = 1 ; local.i <= game.limiter_weapons.size;local.i++)
	{
		local.gun = local.words[2]
		local.gun = waitexec global/strings.scr::to_lower local.gun

		if(local.gun == game.limiter_weapons[local.i][1] )
		{
			if(local.words[3] == "2")
			{
				game.limiter_weapons[local.i][2] = local.words[4]
				game.limiter_weapons[local.i][3] = ""
			}
			else if(local.words[3] == "3")
			{
				game.limiter_weapons[local.i][3] = local.words[4]
				game.limiter_weapons[local.i][2] = ""
			}
			else
			{
				exec global/ac/console_feedback.scr "Error; You Can only change the 2nd and 3rd parameters. eg limit bar 2 shotgun"	
			}
			end
		}
	}

	exec global/ac/console_feedback.scr "Weapon not found, incorrect name"
end 


check_isscript local.words:

	for(local.i = 1; local.i <= game.scripts.size; local.i++)
	{
		if(local.words[2] == game.scripts[local.i][1])
		{
			
			local.is_on = game.scripts[local.i][2]
			if (local.is_on == "1")
			{
				local.onoff = "On"
			}
			else if (local.is_on == "0")
			{
				local.onoff = "Off"
			}
			else
			{
				local.onoff = local.words[2]
			}

			exec global/ac/console_feedback.scr ( local.words[2]  + ": currently set " +  local.onoff) 
			end 1
		}
	}
end
```

# zz_admin-Pro_1.22_modif\global\ac\command_post\rindog_themedcommands_sh.scr

```scr
/*
================================================================================
Rindogs_ThemedCommands_MAM_Addon for Medal Of Honor: 
Version 1.0 (10/10/04)

Copyright (c) 2003-2004 Ron Schacht
email: mods@rindog.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
================================================================================
*/
///////////////////////////////////////////////////////////////////////////////

main local.words local.actual local.player:

	switch(local.words[2])
	{
	case "killtrace":
		local.player thread killtrace
	break
	case "rocketsmoke":
		local.player thread rocket_smoke
	break
	case "rocketammo":
		local.player thread rocket_ammo
	break
	case "rocketmod":
		local.player thread rocket_mod local.actual
	break
	case "thrasher":
		local.player thread Thrasher
	case "rindog":
		local.player thread Rindog
	break
	default:
		end
	}
end 1


killtrace:
      local.player = self
  
      if ((level.killtraceing[local.player.entnum] == 0) || (level.killtraceing[local.player.entnum] == NIL))
        {
          local.trig = spawn trigger_multiple
          local.trig.origin = local.player.origin
          local.trig wait .2
          local.trig.targetname = ("killtrace_trig_" + local.player.entnum)
          local.trig setthread killtrace_setthread

          local.effect1 = spawn DamageModel
          local.effect1 model "fx/dummy.tik"
          local.effect1.origin = local.player.origin + local.player.forwardvector * 64 + ( 0 0 50)
          local.effect1.targetname = ("killtrace_effect1_" + local.player.entnum)
          local.effect1 notsolid

          local.obj = spawn script_origin
          local.obj.origin = local.player.origin
          local.obj.targetname = ("killtrace_scr_org_" + local.player.entnum)

          local.trig bind local.obj
          local.obj glue local.player 
          level.killtraceing[local.player.entnum] = 1
          local.player dmmessage 0 "I'M HELPLESS"
          end 
        }

      if (level.killtraceing[local.player.entnum] == 1)  
        {	 
          $("killtrace_trig_" + local.player.entnum) delete
          $("killtrace_effect1_" + local.player.entnum) delete
          $("killtrace_scr_org_" + local.player.entnum) delete
          level.killtraceing[local.player.entnum] = 0
          end 
        } 	
    
end 

killtrace_setthread:
  local.player = parm.other
  $("killtrace_effect1_" + local.player.entnum).origin = local.player.origin + local.player.forwardvector * 64 + ( 0 0 50)
  $("killtrace_effect1_" + local.player.entnum) killtrace ( 0 0 0) local.player.viewangles 10 10000
end 


rocket_smoke:
      local.player = self
  
      if ((level.rocket_smokeing[local.player.entnum] == 0) || (level.rocket_smokeing[local.player.entnum] == NIL))
        {
          local.trig = spawn trigger_multiple
          local.trig.origin = local.player.origin
          local.trig wait 3
          local.trig.targetname = ("rocket_smoke_trig_" + local.player.entnum)
          local.trig setthread rocket_smoke_setthread

          local.obj = spawn script_origin
          local.obj.origin = local.player.origin
          local.obj.targetname = ("rocket_smoke_scr_org_" + local.player.entnum)

          local.trig bind local.obj
          local.obj glue local.player 
          level.rocket_smokeing[local.player.entnum] = 1
          local.player dmmessage 0 "MY ROCKET IS SMOKING"
          end 
        }

      if (level.rocket_smokeing[local.player.entnum] == 1)  
        {	 
          $("rocket_smoke_trig_" + local.player.entnum) delete
          $("rocket_smoke_scr_org_" + local.player.entnum) delete
          level.rocket_smokeing[local.player.entnum] = 0
          local.player dmmessage 0 "MY ROCKET WILL RETURN TO NORMAL WHEN I RESPAWN"
          end 
        } 	
    
end 

rocket_smoke_setthread:
  local.player = parm.other
  if (local.player.dmteam == "axis")
    {
      local.player weaponcommand dual projectile "models/projectiles/nebelhandgranate_primary.tik"
    }
    else
    {
      local.player weaponcommand dual projectile "models/projectiles/M18_Smoke_grenade_primary.tik"
    }
end 

rocket_ammo:
      local.player = self
  
      if ((level.rocket_ammoing[local.player.entnum] == 0) || (level.rocket_ammoing[local.player.entnum] == NIL))
        {
          local.trig = spawn trigger_multiple
          local.trig.origin = local.player.origin
          local.trig wait 3
          local.trig.targetname = ("rocket_ammo_trig_" + local.player.entnum)
          local.trig setthread rocket_ammo_setthread

          local.obj = spawn script_origin
          local.obj.origin = local.player.origin
          local.obj.targetname = ("rocket_ammo_scr_org_" + local.player.entnum)

          local.trig bind local.obj
          local.obj glue local.player 
          level.rocket_ammoing[local.player.entnum] = 1
           end 
        }

      if (level.rocket_ammoing[local.player.entnum] == 1)  
        {	 
          $("rocket_ammo_trig_" + local.player.entnum) delete
          $("rocket_ammo_scr_org_" + local.player.entnum) delete
          level.rocket_ammoing[local.player.entnum] = 0
          end 
        } 	
    
end 

rocket_ammo_setthread:
  local.player = parm.other
  local.player ammo heavy 6
  local.player weaponcommand dual movementspeed .8
  local.player weaponcommand dual maxfiremovement 1
end 


rocket_mod local.actual:

      // whats the client number
      if (local.args == "all")
        {
          if ((level.rocket_mod_all == 0) || (level.rocket_mod_all == NIL))
            {
              level.rocket_mod_all = 1
              thread rocket_mod_all
              end 
            }
          if (level.rocket_mod_all == 1) 
            {
              level.rocket_mod_all = 0
              thread rocket_mod_all
              end 
            }
        } 
      local.clientnumber = int (local.args)

		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			if( local.clientnumber == $player[local.i].entnum)
			{
				local.player =  $player[local.i]
			}
		}
    
  
      if ((level.rocket_moding[local.player.entnum] == 0) || (level.rocket_moding[local.player.entnum] == NIL))
        {
          local.trig = spawn trigger_multiple
          local.trig.origin = local.player.origin
          local.trig wait 5
          local.trig.targetname = ("rocket_mod_trig_" + local.player.entnum)
          local.trig setthread rocket_mod_setthread

          local.obj = spawn script_origin
          local.obj.origin = local.player.origin
          local.obj.targetname = ("rocket_mod_scr_org_" + local.player.entnum)

          local.trig bind local.obj
          local.obj glue local.player 
          level.rocket_moding[local.player.entnum] = 1
         end 
        }

      if (level.rocket_moding[local.player.entnum] == 1)  
        {	 
          $("rocket_mod_trig_" + local.player.entnum) delete
          $("rocket_mod_scr_org_" + local.player.entnum) delete
          level.rocket_moding[local.player.entnum] = 0
          end 
        } 	
 
end 

rocket_mod_all:
  while (level.rocket_mod_all == 1)
    {
      for (local.i = 1 ; local.i <= $player.size ; local.i ++)
      thread rocket_mod_check_weapon $player[local.i]
      wait 3
    }

end 

rocket_mod_setthread:
  local.player = parm.other
  thread rocket_mod_check_weapon local.player
end 

rocket_mod_check_weapon local.player:
  local.player weaponcommand dual targetname ("weapon_" + local.player.entnum)
  if ($("weapon_" + local.player.entnum) == NULL) end 
  if ($("weapon_" + local.player.entnum).model == "models/weapons/bazooka.tik")
    {
      local.player weaponcommand dual ammo_in_clip 99
      local.player weaponcommand dual firedelay 0.0
      local.player weaponcommand dual zoom 20
      local.player weaponcommand dual movementspeed 1
      local.player weaponcommand dual maxfiremovement 1
      $("weapon_" + local.player.entnum).targetname = ""
    }
    else
    {
      // local.player iprint $("weapon_" + local.player.entnum).model 
      if ($("weapon_" + local.player.entnum).model == "models/weapons/m2frag_grenade.tik" ||
          $("weapon_" + local.player.entnum).model == "models/weapons/m18_smoke_grenade.tik" ||
          $("weapon_" + local.player.entnum).model == "models/weapons/mills_grenade.tik" ||
          $("weapon_" + local.player.entnum).model == "models/weapons/nebelhandgranate.tik" ||
          $("weapon_" + local.player.entnum).model == "models/weapons/rdg-1_smoke_grenade.tik" ||
          $("weapon_" + local.player.entnum).model == "models/weapons/russian_f1_grenade.tik" ||
          $("weapon_" + local.player.entnum).model == "models/weapons/steilhandgranate.tik" || 
          $("weapon_" + local.player.entnum).model == "models/weapons/p38.tik" || 
          $("weapon_" + local.player.entnum).model == "models/weapons/nagant_revolver.tik" || 
          $("weapon_" + local.player.entnum).model == "models/weapons/silencedpistol.tik" || 
          $("weapon_" + local.player.entnum).model == "models/weapons/webley_revolver.tik" || 
          $("weapon_" + local.player.entnum).model == "models/weapons/colt45.tik") 
           {
             $("weapon_" + local.player.entnum).targetname = ""
             end 
           }
      local.player take $("weapon_" + local.player.entnum).model
      waitframe
      local.player weapon "models/weapons/bazooka.tik"
      local.player primarydmweapon heavy
      //local.player useweaponclass heavy
    }
end 


Thrasher:
      local.player = self
  
      if ((level.thrashering[local.player.entnum] == 0) || (level.thrashering[local.player.entnum] == NIL))
        {
          local.trig = spawn trigger_multiple
          local.trig.origin = local.player.origin
          local.trig wait .2
          local.trig.targetname = ("thrasher_trig_" + local.player.entnum)
          local.trig setthread thrasher_setthread

          local.obj = spawn script_origin
          local.obj.origin = local.player.origin
          local.obj.targetname = ("thrasher_scr_org_" + local.player.entnum)

          local.effect1 = spawn sentient "model" "models/player/allied_russian_Recon_Scout.tik"
          local.effect1.origin = local.obj.origin + local.player.forwardvector * 160
          local.effect1.angle = local.player.viewangles[1] + 180
          local.effect1.targetname = ("thrasher_effect1_" + local.player.entnum)


          local.effect1 item "weapons/Mosin_Nagant_Rifle.tik" 1
          local.effect1 useweaponclass "rifle" right
          local.effect1 activatenewweapon right
          local.effect1 solid
          local.effect1 takedamage
          local.effect1 anim rifle_stand_idle
          local.effect1 weaponcommand dual bulletdamage 10

          local.trig bind local.obj
          local.obj glue local.player 
          level.thrashering[local.player.entnum] = 1
          local.player dmmessage 0 "I'M BEING THRASHED BECAUSE MY BEHAVIOR STINKS"
          end 
        }

      if (level.thrashering[local.player.entnum] == 1)  
	{	 
	  $("thrasher_trig_" + local.player.entnum) delete
	  $("thrasher_scr_org_" + local.player.entnum) delete
	  $("thrasher_effect1_" + local.player.entnum) delete
	 // $("thrasher_effect2_" + local.player.entnum) delete
          level.thrashering[local.player.entnum] = 0
          end 
	} 	
    
end 

thrasher_setthread:
  local.player = parm.other
  $("thrasher_effect1_" + local.player.entnum) anim rifle_stand_fire
  $("thrasher_effect1_" + local.player.entnum) fire
  $("thrasher_effect1_" + local.player.entnum).origin = local.player.origin + local.player.forwardvector * 160
  $("thrasher_effect1_" + local.player.entnum).angle = local.player.viewangles[1] + 180
  if (level.thrashdir[local.player.entnum] == 1)
    {
      $("thrasher_effect1_" + local.player.entnum) anim rifle_stand_run_left
      level.thrashdir[local.player.entnum] = 0
    }
    else
    {
      $("thrasher_effect1_" + local.player.entnum) anim rifle_crouch_run_right
      level.thrashdir[local.player.entnum] = 1
    }

  if ( local.player.normal_health <= 0 ) //health is at 0 
    { 
      $("thrasher_trig_" + local.player.entnum) delete
      $("thrasher_scr_org_" + local.player.entnum) delete
      $("thrasher_effect1_" + local.player.entnum) delete
     // $("thrasher_effect2_" + local.player.entnum) delete
      level.thrashering[local.player.entnum] = 0
    } 	
end 
////////////////////////////****thrasher****/////////////////////////////////
//////////////////////////// ****disarm**** ////////////////////////
////////////////////////////RINDOG/OTD///////////////////////////
Rindog:
      

  	if(level.Rindoging[self.entnum] != 1) 
	{
		local.obj = spawn script_origin
		local.obj.origin = self.origin

		local.obj glue self 

		cache models/animal/german_shepherd.tik
		local.effect1 = spawn "models/animal/german_shepherd.tik"
		local.effect1.origin = self.origin + self.forwardvector * 96  + ( 0 0 32 )
		local.effect1.angle = (self.angle + 180)
		local.effect1.health = 10000
		local.effect1.noticescale = 5
		local.effect1.fov = 359
		local.effect1 ai_on
		local.effect1.hearing = 10000
		local.effect1.accuracy = 10000
		local.effect1.sight = 10000
		local.effect1.enableEnemy = 1
		local.effect1.painhandler = anim/dog_pain.scr
		local.effect1.deathhandler = anim/dog_killed.scr
		//  local.effect1 safesolid

		self iprint "********* Here comes the Rindog *********"
		level.Rindoging[self.entnum] = 1
		self dmmessage 0 "WHO LET OUT THE DOG?  I'M BEING ATTACKED BY A DOG FOR BREAKING THE RULES!"

		thread with_dog local.effect1
		while(level.Rindoging[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			wait 1
		//	local.effect1.origin = self.origin + self.forwardvector * 96  + ( 0 0 32 )
			local.effect1.angle = ( self.angle + 180)
			self iprint "********* You know he ain't gonna die *********"
			self iprint "********* Yeaaaaaaa........the Rindog *********"

		}

		local.obj delete
		local.effect1 delete
		self dmmessage 0 "The dog is gone!"
          }	
	
	level.Rindoging[self.entnum] = 0



end 

with_dog local.effect1:

while(1)
{	
	wait 1 //waitframe
			if (local.effect1 istouching self)
			{
				local.effect1 setmotionanim dog_bite_leg
				self hurt 5 
				local.effect1 heal 1
				local.effect1 waittill flaggedanimdone
			}
			else
			{
				//chase enemy
				local.effect1 setmotionanim dog_run
				local.effect1.position = self.origin
			///	local.effect1 heal 1
				local.effect1 waittill flaggedanimdone
			}
}
end



```

# zz_admin-Pro_1.22_modif\global\ac\command_post\rindog_themedcommands.scr

```scr
/*	Modified by Elgan to imrpove performance  
================================================================================
Rindogs_ThemedCommands_MAM_Addon for Medal Of Honor: 
Version 1.0 (10/10/04)

Copyright (c) 2003-2004 Ron Schacht
email: mods@rindog.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
================================================================================
*/
///////////////////////////////////////////////////////////////////////////////
main local.words local.actual local.player:

	switch(local.words[2])
	{
	case "rinspin":
		local.player thread Rinspin
	break
	case "ghost":
		local.player thread Ghost
	break
	case "sparks":
		local.player thread Sparks
	break
	case "runt":
		local.player thread Runt local.words[2]
	break
	case "shortstack":
		local.player thread Runt local.words[2]
	break
	case "snype":
		local.player thread Snype
	break
	case "bigpoppa":
		local.player thread Bigpoppa
	break
	case "twister":
		local.player thread Twister
	break
	case "myst":
		local.player thread Myst
	break
	case "wolfpack":
		local.player thread Wolfpack
	break
	case "stonecold":
		local.player thread Stonecold local.words[2]
	break
	case "flip":
		local.player thread flip local.actual
	break
	case "inferno":
		local.player thread Inferno
	break
	case "kickwarn":
		local.player thread kickwarn
	break
	case "disarm":
		local.player thread disarm
	break
	case "jumpglitch":
		local.player thread jumpglitch
	break
	case "track":
		local.player thread track
	break
	case "storm":
		local.player thread storm
	break
	case "yomama":
		local.player thread yo_mama
	break
	case "sheriff":
		local.player thread sheriff
	break
	case "fugitive":
		local.player thread fugitive
	break
	case "rocketdud":
		local.player thread rocket_dud
	break
	case "stackem":
		local.player thread Stackem
	break
	case "crusher":
		local.player thread Crusher
	break
	case "pigpen":
		local.player thread Pigpen
	break
	case "rocket_dud":
		local.player thread rocket_dud
	break
	default:
		end
	}
end 1
////////////////////////////****RINSPIN****////////////////////////////////////
Rinspin:

	if(level.rinspining[self.entnum] != 1) 
	{
		level.rinspining[self.entnum] = 1
		while(level.rinspining[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			waitframe
			self turn 200
		}
        }	

	level.rinspining[self.entnum] = 0

end 




//////////////////////////// ****RINSPIN**** ////////////////////////////////////
//////////////////////////// ****GHOST/STRIKER**** /////////////////////////////
Ghost:
	
	if(level.ghosting[self.entnum] != 1) 
	{
		level.ghosting[self.entnum] = 1
		while(level.ghosting[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			self hurt 10
			self playsound pistol_hit
			wait .3
		}
        }	

	level.ghosting[self.entnum] = 0

end 



//////////////////////////// ****GHOST/STRIKER**** /////////////////////////////
//////////////////////////// ****SPARKS**** ///////////////////////////////////
Sparks:

  	if(level.sparking[self.entnum] != 1) 
	{

		local.obj = spawn script_origin
		local.obj.origin = self.origin

		local.effect1 = spawn "models/emitters/electrical_fire.tik"
		local.effect1.origin = local.obj.origin + ( 0 0 78 )

		local.effect2 = spawn "models/emitters/linger_smoke.tik"
		local.effect2.origin = local.obj.origin + ( 0 0 78 )
	  
		local.effect3 = spawn "models/emitters/electric_arc.tik"
		local.effect3.origin = local.obj.origin + ( 0 0 78 )

		local.effect1 bind local.obj
		local.effect2 bind local.obj
		local.effect3 bind local.obj
		local.obj glue self 

		self dmmessage 0 "I'M BEING ELECTRICUTED FOR BEING INCONSIDERATE AND I NEED TO APOLOGIZE!"	

		level.sparking[self.entnum] = 1

		while(level.sparking[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			self hurt 10
			self playsound alarm_switch
			wait .3
		}


		local.effect1 delete
		local.effect2 delete
		local.effect3 delete

        }	

	level.sparking[self.entnum] = 0

end 



//////////////////////////// ****SPARKS**** ///////////////////////////////////
//////////////////////////// ****RUNT/SHORTSTACK**** /////////////////////////
Runt local.args:
      
	if(level.runting[self.entnum] != 1) 
	{

		if ((local.args == "Runt") || (local.args == "runt"))
		{
			self dmmessage 0 "I HAVE BEEN MADE A RUNT FOR BREAKING THE RULES AND I NEED TO APOLOGIZE!"
		}
		else
		{
			self dmmessage 0 "I HAVE BEEN MADE A SHORTSTACK  BECAUSE OF UNACCEPTABLE BEHAVIOR AND I NEED TO APOLOGIZE!"
		}

		self scale .5

		level.runting[self.entnum] = 1
		while(level.runting[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			self weaponcommand dual bulletcount 0
			self iprint "*****YOU HAVE BEEN MADE A MIDGET BECAUSE OF YOUR IMMATURE BEHAVIOR!*****"
			
			wait .3

			if ((local.args == "Runt") || (local.args == "runt"))
			{
				self hurt 10
				self playsound pistol_hit
			}


		}
        }	

	self weaponcommand dual bulletcount 1
	level.runting[self.entnum] = 0

end 


//////////////////////////// ****RUNT/SHORTSTACK**** /////////////////////////
//////////////////////////// ****SNYPE**** //////////////////////////////////
Snype:

      
      self playsound kar98sniper_snd_fire1
      killent self.entnum 
  
end 



//////////////////////////// ****SNYPE**** //////////////////////////////////
//////////////////////////// ****BIGPOPPA**** ///////////////////////////////
Bigpoppa:

  	if(level.bigpoppaing[self.entnum] != 1) 
	{
		self.scale = 2
		level.bigpoppaing[self.entnum] = 1
		while(level.bigpoppaing[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			self weaponcommand dual bulletcount 0
			self iprint "*****YOU HAVE BEEN MADE A GIANT BECAUSE OF YOUR IMMATURE BEHAVIOR!*****"
			self hurt 10
			self playsound pistol_hit
			wait .5
		}
        }	

	self.scale = 1
	level.bigpoppaing[self.entnum] = 0
   
end 



//////////////////////////// ****BIGPOPPA**** ///////////////////////////////
//////////////////////////// ****TWISTER**** ///////////////////////////////
Twister:

      
    	if(level.twistering[self.entnum] != 1) 
	{
		level.twistering[self.entnum] = 1
		local.rang = 0

		while(level.twistering[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{

			self playsound alarm_switch
			self iprint "*****YOU HAVE BEEN TWISTED FOR BREAKING THE RULES!*****"
			self.viewangles =  ( self.viewangles[0] self.viewangles[1] local.rang )
			local.rang = local.rang + 5

			if (local.rang >= 360) 
			{
				level.twistering[self.entnum] = 0
				end
			}
			wait .3
		}

		self.viewangles =  ( 0 0 0 )
        }	


	level.twistering[self.entnum] = 0

end 


//////////////////////////// ****TWISTER**** ///////////////////////////////
//////////////////////////// ****MYST**** /////////////////////////////////
Myst:

    	if(level.mysting[self.entnum] != 1) 
	{
		local.obj = spawn script_origin
		local.obj.origin = self.origin

		local.effect1 = spawn "models/emitters/higgins_mushroom.tik"
		local.effect1.origin = local.obj.origin + ( 0 -16 0 )

		local.effect2 = spawn "models/emitters/higgins_mushroom.tik"
		local.effect2.origin = local.obj.origin // + ( 16 16 0 )

		local.effect1 bind local.obj
		local.effect2 bind local.obj
		local.obj glue self 

		level.mysting[self.entnum] = 1

		self dmmessage 0 "I'M BEING VAPORIZED ALIVE FOR BAD BEHAVIOR AND I NEED TO APOLOGIZE!"

		while(level.mysting[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			self playsound smokegrenade_air_loop
			self hurt 3
			wait .3
		}

		local.obj delete
		local.effect2 delete
		local.effect1 delete
        }	

	level.mysting[self.entnum] = 0
	
end 


//////////////////////////// ****MYST**** /////////////////////////////////
//////////////////////////// ****WOLFPACK**** ////////////////////////////
Wolfpack:

    	if(level.WolfPacking[self.entnum] != 1) 
	{
		local.obj = spawn script_origin
		local.obj.origin = self.origin

		local.effect1 = spawn "models/fx/dummy.tik"
		local.effect1.origin = local.obj.origin + ( 0 0 78 )

		local.effect2 = spawn "models/fx/dummy.tik"
		local.effect2.origin = local.obj.origin + ( 0 0 78 )

		local.effect3 = spawn "models/fx/dummy.tik"
		local.effect3.origin = local.obj.origin + ( 0 0 78 )

		local.effect1 bind local.obj
		local.effect2 bind local.obj
		local.effect3 bind local.obj
		local.obj glue self 

		level.WolfPacking[self.entnum] = 1

		self dmmessage 0 "I'M BEING MAULED BY THE SPIRIT OF THE WOLF FOR BEING FOR BEING A BAD DOG!"

		while(level.WolfPacking[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			self hurt 3
			self loopsound dog_bite 7
			wait .3
			local.obj loopsound dog_bite 5
			wait .3
			local.effect1 loopsound dog_bite 5
			wait .3
			local.effect2 loopsound dog_bark 5
			wait .3
			local.effect3 loopsound dog_bark 7
		}

		local.obj delete
		local.effect2 delete
		local.effect1 delete
		local.effect3 delete

		self stoploopsound	
        }	

	level.WolfPacking[self.entnum] = 0

end 



//////////////////////////// ****WOLFPACK**** ////////////////////////////

//////////////////////////// ****STONECOLD/GREYSTONE**** ///////////////
Stonecold local.args:
      

    	if(level.stonecolding[self.entnum] != 1) 
	{
		local.obj = spawn script_origin
		local.obj.origin = self.origin

		if ((local.args == "Stonecold") || (local.args == "stonecold"))
		{
		      local.effect1 = spawn script_model
		      local.effect1.model = "models/static/rock_winter_large.tik"
		      local.effect1.origin = self.origin
		      local.effect1 solid
		      local.effect1 show
		}
		else
		{
		      local.effect1 = spawn script_model
		      local.effect1.model =  "models/static/rock_large.tik"
		      local.effect1.origin = self.origin
		      local.effect1 solid
		      local.effect1 show
		}
       
		local.obj glue self 
		level.stonecolding[self.entnum] = 1
		self dmmessage 0 "I'M A ROCKHEAD FOR BREAKING THE RULES"

		while(level.stonecolding[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			self iprint "*****YOU HAVE BEEN TURNED TO STONE FOR BEING A PEBBLE BRAIN!*****"
			self playsound snd_landing_stone1
			self weaponcommand dual bulletcount 0
			local.effect1.origin = self.origin
			wait 2
		}

		local.effect1 delete
		local.obj delete
        }	

	level.stonecolding[self.entnum] = 0
	self weaponcommand dual bulletcount 1

end 


//////////////////////////// ****STONECOLD/GREYSTONE**** ///////////////
//////////////////////////// ****FLIP**** /////////////////////////////
flip local.args:

	local.args = int local.args

	self.viewangles = ( self.viewangles[0] self.viewangles[1] local.args )
	self dmmessage 0 "I'M FLIPPED OUT FOR DISOBEYING AN ADMIN"
	self iprint "*****YOU HAVE BEEN FLIPPED FOR DISOBEYING THE RULES!*****"
	wait 10

	self.viewangles = ( self.viewangles[0] self.viewangles[1] 0 )

end 




//////////////////////////// ****FLIP**** /////////////////////////////
//////////////////////////// ****INFERNO**** /////////////////////////
Inferno:

  	if(level.Infernoing[self.entnum] != 1) 
	{
		local.obj = spawn script_origin
		local.obj.origin = self.origin

		local.effect1 = spawn "models/emitters/explosion_conflagration.tik"
		local.effect1.origin = local.obj.origin + ( 0 0 78 )

		local.effect2 = spawn "models/emitters/fireandsmoke.tik"
		local.effect2.origin = local.obj.origin // + ( 0 0 78 )

		local.effect1 bind local.obj
		local.effect2 bind local.obj
		local.obj glue self 

		level.Infernoing[self.entnum] = 1
		self dmmessage 0 "I'M BEING BURNED ALIVE FOR ANNOYING BEHAVIOR AND I NEED TO APOLOGIZE!"

		while(level.Infernoing[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			self playsound fire_large
			self hurt 3
			wait .3
		}

		local.obj delete
		local.effect2 delete
		local.effect1 delete
        }	

	level.Infernoing[self.entnum] = 0

end


//////////////////////////// ****INFERNO**** /////////////////////////
//////////////////////////// ****kickwarn**** ///////////////////////
kickwarn:
      
      local.tempstr = "set ui_kickwarn YOU ARE ABOUT TO BE KICKED/BANNED UNLESS YOU START OBEYING THE RULES!"
      self stufftext local.tempstr
      local.tempstr = "dialog 0 ui_kickwarn say /q/q 640 480"
      self stufftext local.tempstr // dialog "WARNING ui_kickwarn respawn 500 100"
end 
//////////////////////////// ****kickwarn**** ///////////////////////
//////////////////////////// ****disarm**** ////////////////////////


disarm:
      
  	if(level.disarming[self.entnum] != 1) 
	{
		level.disarming[self.entnum] = 1
		while(level.disarming[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			wait 1
			self takeall
		}
        }	
	
	level.disarming[self.entnum] = 0

end 


////////////////////////////RINDOG/OTD///////////////////////////
//////////////////////////// ****jumpglitch**** ////////////////////////////////////
jumpglitch:

      self.origin = self.origin + ( 0 0 32)

end 
//////////////////////////// ****jumpglitch**** ////////////////////////////////////
//////////////////////////// ****track**** ////////////////////////


track:
      
 	if(level.tracking[self.entnum] != 1) 
	{
		level.tracking[self.entnum] = 1
		while(level.tracking[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			wait 1
			local.tempstr = string(int(self.origin[0])) + " " 
			local.tempstr = local.tempstr + string(int(self.origin[1])) + " "
			local.tempstr = local.tempstr + string(int(self.origin[2])) + " "
			local.tempstr = local.tempstr + string(int(self.viewangles[1]))
			self iprint local.tempstr
		}
        }	
	
	level.tracking[self.entnum] = 0	
end 

//////////////////////////// ****track**** ////////////////////////
//////////////////////////// ****storm**** ////////////////////////
storm:
       
 	if(level.storming[self.entnum] != 1) 
	{

		local.obj = spawn script_origin
		local.obj.origin = self.origin

		local.effect1 = spawn "fx/dummy.tik"
		local.effect1.origin = local.obj.origin + ( 0 0 150 )

		local.effect1 bind local.obj
		local.obj glue self 
		level.storming[self.entnum] = 1

		self loopsound rain_ext
		local.effect1 loopsound rain_ext

		level.beam = spawn func_beam
		level.beam.origin = self.origin
		level.beam.angles = ( -90 0 0 )
		level.beam scale 1.5
		level.beam minoffset 30
		level.beam maxoffset 90
		level.beam color ( 0.75 0.75 1)
		level.beam numsegments 5

		//   $world farclipoverride -1

		local.rin_rain = spawn func_rain // "classname" "func_rain"
		local.rin_rain.model = "fx/dummy.tik"

		local.rin_rain.origin = self.origin + (0 0 150)
		local.rin_rain setsize ( -32 -32 0 ) ( 32 32 64)
		local.rin_rain notsolid
		local.rin_rain show
	
		level.rinsave_rain_shader = level.rain_shader
		level.rinsave_rain_numshaders = level.rain_numshaders
		level.rinsave_rain_width = level.rain_width
		level.rinsave_rain_min_dist = level.rain_min_dist
		level.rinsave_rain_density = level.rain_density
		level.rinsave_rain_speed = level.rain_speed
		level.rinsave_rain_speed_vary = level.rain_speed_vary
		level.rinsave_rain_length = level.rain_length
		level.rinsave_rain_slant = level.rain_slant

		level.rain_shader = "textures/rain"
		level.rain_numshaders = 1
		level.rain_width = "0.4"
		level.rain_min_dist = 64
		level.rain_density = 20
		//   level.startedrainsound2 = 1
		level.rain_speed = "256"
		level.rain_speed_vary = "16"
		level.rain_length = "2"
		level.rain_slant = "30"

		level.storming[self.entnum] = 1
		while(level.storming[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			//local.rin_rain.origin = self.origin + (0 0 150)
			local.rin_rain.origin = self.origin
			
			level.beam activate
			local.effect2 = spawn "models/emitters/electric_arc.tik"
			local.effect2.origin = self.origin + ( 0 0 78 )

			local.effect2 playsound thunder1
		
			self hurt 5

			wait .001
			
			level.beam deactivate
			wait 1
			self playsound thunder
			local.effect2 delete
		}

		level.rain_shader = level.rinsave_rain_shader 
		level.rain_numshaders = level.rinsave_rain_numshaders
		level.rain_width = level.rinsave_rain_width
		level.rain_min_dist = level.rinsave_rain_min_dist
		level.rain_density = level.rinsave_rain_density
		level.rain_speed = level.rinsave_rain_speed
		level.rain_speed_vary = level.rinsave_rain_speed_vary
		level.rain_length = level.rinsave_rain_length
		level.rain_slant = level.rinsave_rain_slant

		local.effect2 delete
		local.rin_rain delete
		local.obj delete
		local.effect1 delete
		self stoploopsound
		level.storming[self.entnum] = 0
        }	
	
	level.storming[self.entnum] = 0	  






end 


//////////////////////////// ****storm**** ////////////////////////
//////////////////////////// ****yo_mama**** ////////////////////////


yo_mama:
      
        
 	if(level.yo_mamaing[self.entnum] != 1) 
	{
		self dmmessage 0 "I'M BEING KILLED WITH KINDNESS FOR BEING UNKIND"

		local.effect1 = spawn script_model "model" "models/static/flowerpainting.tik"
		local.effect1 notsolid
		local.effect1.scale = 2

		local.effect2 = spawn script_model "model" "models/static/flowerpainting.tik"
		local.effect2 notsolid
		local.effect2.scale = 2

		level.yo_mamaing[self.entnum] = 1
		while(level.yo_mamaing[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{


			for(local.i = 0;local.i <= 4;local.i = local.i + 0.05)
			{

				local.vectoradd  =  angles_toforward self.viewangles
				local.vectoradd = self.origin + local.vectoradd * 72 + ( 0 0 45 )
				local.effect2.origin =  local.vectoradd 
				local.effect2.angles = ((self.viewangles[0] * -1) (self.viewangles[1] + 180) (self.viewangles[2] * -1))
				
				local.effect1.origin =  local.vectoradd 
				local.effect1.angles = self.viewangles// + ( 0 180 0 )
				waitframe
			}

			self iprint "Roses are red"
			self iprint "Violets are blue"
			self iprint "You're making it hard"
			self iprint "To be nice to you"
			self iprint "(Please Obey the Rules)"
			self hurt 1

		}

		local.effect2 delete
		local.effect1 delete
        }	

end



//////////////////////////// ****yo_mama**** ////////////////////////
//////////////////////////// ****sheriff**** ////////////////////////
sheriff:
      
	if (self.dmteam == "spectator")
	{
		self iprint "You can not be in spectator mode to turn this command on or off!" 
		end 
	} 
         
 	if(level.sheriffing[self.entnum] != 1) 
	{


		local.effect2 = spawn "models/statweapons/mg42_gun.tik"
		local.effect2.origin = self.origin + self.leftvector * 100 + ( 0 0 85 )
		local.effect2.angles = self.viewangles + ( 0 -3 0 )
		local.effect2 bulletdamage .001
		local.effect2.throughwood = 1000
		local.effect2.throughmetal = 1000
		local.effect2 notsolid
		local.effect2 hide
		

		local.effect3 = spawn "models/statweapons/mg42_gun.tik"
		local.effect3.origin = self.origin - self.leftvector * 100 + ( 0 0 85 ) 
		local.effect3.angles = self.viewangles + ( 0 3 0 )
		local.effect3 bulletdamage .001
		local.effect3.throughwood = 1000
		local.effect3.throughmetal = 1000
		local.effect3 notsolid
		local.effect3 hide
		cache "models/statweapons/mg42_gun.tik"  

		if (self.dmteam == "axis")
		{
			local.effect1 = spawn animate model "vehicles/fockwulffly.tik"
			local.effect1.origin = self.origin  + ( 0 0 20 )
			local.effect3 attach local.effect1 "tag_barrel02"
		}
		else
		{
			local.effect1 = spawn animate model  "models/vehicles/p47fly.tik"
			local.effect1.origin = self.origin - self.forwardvector * 20  + ( 0 0 20 )
			local.effect3 attach local.effect1 "tag_barrel04"
		}
	
		local.effect2 attach local.effect1 "tag_barrel01"

		local.effect1 scale .75
		local.effect1 solid

		local.effect1 loopsound fly_snd
		self noclip
		self hide
		self forcetorsostate PLANE_TORSO

		level.sheriffing[self.entnum] = 1

		while(level.sheriffing[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{


			for(local.i = 0;local.i <= 1;local.i = local.i + 0.05)
			{
				waitframe
				local.effect1.origin = self.origin  + ( 0 0 20 )
				local.effect1.angles = self.viewangles 

				if(self.fireheld == 1)
				{
					local.effect3.angles = self.viewangles
					local.effect2.angles = self.viewangles

					local.effect3 anim fire
					local.effect2 anim fire
					local.effect1 playsound mg42_gun_snd_fire1
				}
			}

			if(self.useheld == 1)
			{
				thread bombdrop
			}


		}	


		local.effect1 delete
		local.effect2 delete
		local.effect3 delete
		self respawn
		self.forcespawn = 1
	}	
	
	level.sheriffing[self.entnum] = 0	
end 



bombdrop:

	local.bomb = spawn script_model "targetname" "bomb"
	local.bomb.origin = self.origin - ( 0 0 20 )
	local.bomb model "ammo/us_bomb.tik"
	local.bomb.angles = ( 0 (self.viewangles[1] + 90) 0 )
	local.bomb notsolid
	local.bomb playsound leadinmp2
	local.bomb physics_on
	local.bomb waittill touch

	local.Exp3 = spawn "fx/scriptbazookaexplosion.tik"
	local.Exp4 = spawn "animate/fx_mortar_dirt.tik"
	local.Exp3 radiusdamage 0
	local.Exp3.origin = local.bomb.origin
	local.Exp4.origin = local.bomb.origin
	local.Exp3 anim start
	local.Exp4 anim start

	wait 1
	local.Exp3 remove	
	local.Exp4 remove
 
	local.bomb immediateremove
	
end 


//////////////////////////// ****sheriff**** ////////////////////////
//////////////////////////// ****fugitive**** ////////////////////////

fugitive:
      
    	if(level.fugitiveing[self.entnum] != 1) 
	{
		self light 1.0 1.0 0.0 200.0
		self lighton
		self dmmessage 0 "I'M A FUGITIVE"

		level.fugitiveing[self.entnum] = 1
		thread sound_phone   
		while(level.fugitiveing[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			wait 1
		}
		self lightoff
		self dmmessage 0 "I HAVE BEEN CAUGHT AND BROUGHT TO JUSTICE"
        }	
	
	level.fugitiveing[self.entnum] = 0
end 

sound_phone:
	while (level.fugitiveing[self.entnum] == 1)
	{
		self stufftext "play sound/mechanics/Mec_PhoneRing_01.wav"
		wait 3
	}
end 


//////////////////////////// ****fugitive**** ////////////////////////
//////////////////////////// ****killtrace**** ////////////////////////


//////////////////////////// ****killtrace**** ////////////////////////
//////////////////////////// ****rocket_dud**** ////////////////////////


rocket_dud:
       
	if(level.rocket_duding[self.entnum] != 1) 
	{
		self stufftext say "Im helpless"

		level.rocket_duding[self.entnum] = 1
		while(level.rocket_duding[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			waitframe
			self weaponcommand dual projectile "models/projectiles/bazookashell.tik"
		}
        }	

	level.rocket_duding[self.entnum] = 0
end


//////////////////////////// ****rocket_mod**** ////////////////////////
//////////////////////////// ****stackem**** ////////////////////////
Stackem:
      
       
	if(level.stackeming[self.entnum] != 1) 
	{
		self dmmessage 0 "WHACKEM STACKEM...I'M A BAAAADDDDDD BOY"

		level.stackeming[self.entnum] = 1

		self physics_off
		
		while(level.stackeming[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			
			for(local.i = 0 ;local.i <= 5;local.i++)
			{	
				local.bomb[local.i] = spawn script_model "targetname" "bomb"
				local.bomb[local.i].origin = self.origin + self.forwardvector * 30 + ( 0 0 200 )
				local.bomb[local.i] model "ammo/us_bomb.tik"
				local.bomb[local.i] solid
				local.bomb[local.i] physics_on
				local.bomb[local.i].velocity = (0 0 -10000)
				local.bomb[local.i].mass = 10000
				local.bomb[local.i].gravity = 10000
				//local.spot = trace local.bomb.origin (local.bomb.origin + ( 0 0 -10000))

				local.bomb[local.i] playsound leadinmp2
				local.bomb[local.i] speed 10000
				wait .5
			}

			wait 1

			for(local.i = 0 ;local.i <= 5;local.i++)
			{	
				local.exp = spawn script_model 
				local.exp.model = "models/fx/barrel_gas_destroyed.tik"
				//local.exp.targetname = "bomb_exp"
				local.exp.origin = local.bomb[local.i].origin
				local.exp solid
				local.exp show

				self hurt 20
				wait 1
				local.bomb[local.i] delete
				local.exp delete
			}
		}

		self physics_on
        }	

	level.stackeming[self.entnum] = 0
end 


//////////////////////////// ****stackem**** ////////////////////////
//////////////////////////// ****crusher**** ////////////////////////
Crusher:
      
	self physics_off
	self dmmessage 0 "THAT'S ALL FOLKS"
	local.origin = self.origin + ( 0 0 256)
	local.angles = ( 0 (self.viewangles[1]) 0 )
	local.piano = spawn script_model 
	local.piano.model = "models/static/piano_d.tik"
	local.piano.origin = local.origin
	local.piano.angles = local.angles
	local.piano solid
	local.piano show
	local.piano physics_on
	local.piano.velocity = (0 0 -100)
	local.piano.mass = 100
	local.piano playsound leadinmp2
	local.piano.gravity = 100
	local.piano waittill touch
	self hurt 100
	self stufftext "play sound/mechanics/MOH_Piano3.wav"
	self physics_on
	wait 10
	local.piano delete
    
end 

//////////////////////////// ****crusher**** ////////////////////////
//////////////////////////// ****pigpen**** /////////////////////////////////
Pigpen:
      
 	if(level.pigpening[self.entnum] != 1) 
	{

		local.obj = spawn script_origin
		local.obj.origin = self.origin

		local.effect1 = spawn "models/fx/gas_mushroom_column.tik"
		local.effect1.origin = local.obj.origin //+ ( 0 -16 0 )

		local.effect2 = spawn "models/emitters/lightswarmers_large.tik"
		local.effect2.origin = local.obj.origin  + ( 0 0 90 )

		local.effect3 = spawn "models/emitters/lightswarmers_small.tik"
		local.effect3.origin = local.obj.origin  + ( 0 0 90 )

		local.effect1 bind local.obj
		local.effect2 bind local.obj
		local.effect3 bind local.obj
		local.obj glue self 
		self dmmessage 0 "I'M A PIGPEN BECAUSE MY BEHAVIOR STINKS"

		level.pigpening[self.entnum] = 1
		while(level.pigpening[self.entnum] == 1 && self.health > 0 && self.dmteam != "spectator") 
		{
			wait 3
			self stufftext "play sound/mechanics/WoodGateOpen_m4l32.wav"
			self hurt 10
		}

		local.effect1 delete
		local.effect2 delete
		local.effect3 delete
		local.obj delete

        }	
	
	level.pigpening[self.entnum] = 0	

    
end 


```

# zz_admin-Pro_1.22_modif\global\ac\console_feedback.scr

```scr
// this script just messages the server console (or admin menu.

main local.message local.error:

	if(local.message == NIL || local.message == "")
	{
		end
	}

	if(level.admins)
	{
		for(local.i = 0 ; local.i <= level.admins.size ; local.i++)
		{

			if(level.admins[local.i] != NIL && level.admins[local.i] != NULL)
			{
				level.admins[local.i] stufftext ("echo " + local.message)
			}	
		}
	}
	else
	{	if(local.error)
		{
			if(level.errorlog == NIL)
			{
				local.i = 0
				thread errorlog
			}
			else
			{
				local.i = level.errorlog.size
			}

			level.errorlog[local.i] = local.message
		}

		println local.message

	}


end 


errorlog:

		while !(level.admins)
		{
			wait 2
		}


		if(level.admins)
		{
			for(local.i = 0;local.i <= level.errorlog.size - 1; local.i++)
			{
				exec global/ac/console_feedback.scr ("ERROR LOG: " + level.errorlog[local.i])
			}
		}
end
```

# zz_admin-Pro_1.22_modif\global\ac\cvar_forcer.scr

```scr
// this script foces cvars

main:

	if(level.run["cvar-forcing"]!="1"){end}
		
	
	local.cvars = waitexec game.file["cvar-forcing"]::cvar_force

	if!(local.cvars.size)
	{
		end
	}

	while(level.run["cvar-forcing"] =="1")
	{
		wait 1
		for(local.i= 1; local.i <= $player.size; local.i ++)
		{
			wait 1
			for(local.c = 1; local.c <= local.cvars.size; local.c++)
			{
				wait 1
				if($player[local.i] != NULL) 
				{
					$player[local.i] stufftext (local.cvars[local.c][1] + " " + local.cvars[local.c][2])
				}
				if(level.run["cvar-forcing"]!="1"){end}
			}
		}
	}
end
```

# zz_admin-Pro_1.22_modif\global\ac\cvarscheck.scr

```scr
//handles all the input through console.

main:
	thread setupadmins

	while(1)
	{
		wait 1
		local.help = getcvar "admin_cmd"

		if(local.help!="")
		{	
			setcvar "admin_cmd" ""

			exec global/ac/console_feedback.scr " "
			exec global/ac/console_feedback.scr "> searching for command. Please wait to enter cvars again."
			exec global/ac/console_feedback.scr " "

			thread split_cmd local.help	

		}
	}
	
end

setupadmins:
	
	if (game.scan_at_start == 1)
	{
		local.rcon = getcvar "rconpassword"
		
		if(local.rcon == "")
		{
			local.text = ("admin_cmd")
		}
		else
		{
			local.text = ("rcon admin_cmd")
		}
		
		while(1)
		{
			waitframe
			for(local.i = 1; local.i <= $player.size ; local.i++)
			{
				if($player[local.i].admin == NIL)
				{
					local.textt = local.text + " `imadmin_" + $player[local.i].entnum
					$player[local.i] stufftext (  local.textt)
					$player[local.i].admin = 0
				}

				wait 3
			}
		}
	}
end



// This section is when a admin_cmd is enterd. 
split_cmd local.info:

	if (game.input_type == "linux")
	{
		local.info =  waitexec global/strings.scr::Format_replace local.info "_" " "
	}

	local.wordsarray = waitexec global/strings.scr::split_line local.info
	local.actual = local.wordsarray[3]
	waitthread split_cmds local.wordsarray local.actual
	exec global/ac/console_feedback.scr ( "> Finished " + local.actual)
end

split_cmds local.wordsarray local.actual:

	local.words = local.wordsarray[1]
	local.wordcount = local.wordsarray[2]
	
	for(local.i=1;local.i<= game.all_commands.size;local.i++)
	{
		if(local.words[1] == game.all_commands[local.i][1])	//run through commands to check agaisnt what was enterd
		{
			if(local.words[2])				// found a command to be the same
			{
				//first check scripts
				
				local.mhm = waitexec global/ac/command_post/console.scr 3 local.words

				if(local.mhm != 1 ) //if its 1 it was found and not asked to be changed
				{
					if(local.words[3])			// if a given index has been specified
					{
						local.j = int local.words[3]	//if its a valid index
						local.j = int local.j 
						if(local.j == 0 )
						{
							local.j  = 2	//no? use index 2
						}
					}
					else
					{
						local.j  = 2	// no index so use 2 
					}

					// Change the settings
					local.print = game.all_commands[local.i][local.j]
					local.print2 = local.words[2]
					local.print =( local.print + " changed to ")
					game.all_commands[local.i] [local.j] = local.words[2]
					exec global/ac/console_feedback.scr ( "Changing parameters of " + game.all_commands[local.i][1]) 
					exec global/ac/console_feedback.scr ( local.print + local.print2 )
				}

				end
			}
			else
			{
				// check the command list first
				local.mhm = waitexec global/ac/command_post/console.scr 1 local.words[1]
				// if a cmd was enterd that also a setting but no cmd was found for the setting it must be wrong.
				if(local.mhm != 1 )
				{
					exec global/ac/console_feedback.scr  "2nd param seems to be NIL. Make sure you have quotes around your line" 
				//	exec global/ac/console_feedback.scr '"' 1
			//		exec global/ac/console_feedback.scr " around your line."
					exec global/ac/console_feedback.scr  " ------------------------------- "
					exec global/ac/console_feedback.scr  " If only the first word is being detected then change the input type by typing "
					exec global/ac/console_feedback.scr  " rcon admin_cmd input_toggle"
					exec global/ac/console_feedback.scr  " You can then use a space as a spacer or _ as a spacer"
					exec global/ac/console_feedback.scr  " ------------------------------- "
				}
				end
			}
		}
	}

	local.maybeplayer = int local.words[1]

	if(local.maybeplayer== 0 && local.words[1].size > 1)	// is it a player?, no?
	{
		if(local.words[2])				// found a command to be the same
		{
			//first check scripts
			local.mhm = waitexec global/ac/command_post/console.scr 3 local.words

			if(local.mhm == 0 ) //if its 1 it was found and not asked to be changed
			{
				if(local.words[3])			// if a given index has been specified
				{
					local.j = int local.words[3]	//if its a valid index
					local.j = int local.j 
					if(local.j == 0 )
					{
						local.j  = 2	//no? use index 2
					}
				}
				else
				{
					local.j  = 2	// no index so use 2 
				}

				// Change the settings
				local.print = game.all_commands[local.i][local.j]
				local.print2 = local.words[2]
				local.print =( local.print + " changed to ")
				game.all_commands[local.i] [local.j] = local.words[2]
				exec global/ac/console_feedback.scr ( "Changing parameters of " + game.all_commands[local.i][1]) 
				exec global/ac/console_feedback.scr ( local.print + local.print2 )
			}
			else if(local.mhm != 1 )
			{
				exec global/ac/console_feedback.scr "Bad command"
				end
			}
		}
		else
		{
			// check the command list first
			local.mhm = waitexec global/ac/command_post/console.scr 1 local.words[1]
			if(local.mhm != 1 )
			{		
				exec global/ac/console_feedback.scr "Bad command "
			}
		}


		end
	}


	if(local.words[2] == NIL)
	{
		exec global/ac/console_feedback.scr "Bad command"
		end
	}

	
	local.actual = waitexec global/strings.scr::Combine local.words 3

	// its  a console cmd so find what one and do what is asked!

	for(local.i=1; local.i <= $player.size; local.i++) //loop through and find the player
	{   
		if(local.maybeplayer == $player[local.i].entnum) //if the number is what was enterd into console then work
		{
			local.player = $player[local.i]
			exec global/ac/console_feedback.scr ("> " + local.words[2] + " " + local.actual )

			local.mhm = waitexec global/ac/command_post/console.scr 2 local.words local.actual local.player
	
			if(local.mhm != 1 )
			{		
				exec global/ac/console_feedback.scr "Bad command "
			}
			end
		}         
	}   

	exec global/ac/console_feedback.scr "Possible Bad player ID"
end


```

# zz_admin-Pro_1.22_modif\global\ac\hello_world.scr

```scr
local.hello = makearray
	"hello world"
	Norwegian_Nynorsk_Norway_________________Goddag
	Norwegian_Bokmaal_Norway_________________Hei
	Norwegian_Bokmaal_Norway_________________Heisann
	Norwegian_Bokmaal_Norway_________________God_dag
	Norwegian_Bokmaal_Norway_________________Morn
	Norwegian_Bokmaal_Norway_________________Hallo
	Norwegian_Nordmrsk_Norway_______________Goddg
	Norwegian_Nordmrsk_Norway_______________Goddjen
	Norwegian_Nordmrsk_Norway_reply_old__Sing_G_______________
	Norwegian_Nordmrsk_Norway_old_________Godt_mt
	Norwegian_Nordmrsk_Norway_reply_______Godt_mt_att
	Norwegian_Nordmrsk_Norway_informal____Hia
	Norwegian_Nordmrsk_Norway_informal____Hia
	Norwegian_Nordmrsk_Norwayto_p.working_Sng_rbeia
	Norwegian_Bergensk_Bergen_Norway_________Halloen
	Norwegian_Sortlandsk_Sortland_Norway_____Goda
	Norwegian_Sortlandsk_Sortland_Norway_____Ka_farsken,_e_det_du?

endarray

end local.hello

// did have 800 languages but mohaa wouldnt let me have any fun:(
```

# zz_admin-Pro_1.22_modif\global\ac\jump.scr

```scr
// just makes player jump

main:
	if(game.jump_height == NIL || game.jump_height == NULL)
	{
		game.jump_height =  56
	}

	self jump game.jump_height
	
end
```

# zz_admin-Pro_1.22_modif\global\ac\medics\hold_check.scr

```scr
// 22/11/2005 17:48 changed wait time from .5 to 1

main:

	// local.player = parm.other
	// if (local.player.rankbonus["medic"] != 1 && level.running_ranking == 1)
	// {
		// end
	// }
	
	if(level.run["medics"] != "1")
	{
		end
	}

	local.replenish = waitexec global/settings.scr::getcmd "medic-replenish"

	if(self.medic_health == NIL || local.replenish != "0")
	{
		local.replenish = waitexec global/settings.scr::getcmd "health"
		local.replenish = int local.replenish
		self.medic_health = local.replenish
	}
	
	// On vrifie le rang du joueur
	local.player = parm.other
	if (local.player.rankbonus["medic"] != 1 && level.running_ranking == 1)
	{
		end
	}

	if(self.medic_health <= 0)
	{
		end
	}

	local.weaponscheck = waitexec global/settings.scr::getcmd "medic-weapons"

	if(local.weaponscheck == "1")
	{
		local.end =  waitthread check_weapon self

		if(local.end == "0")
		{
			end
		}

	}

	local.team = self.dmteam

	while(level.run["medics"] == "1" && self != NULL && self != NIL && isalive self  && self.dmteam == local.team)
	{
		wait 1 //wait 1 second

		if(self == NULL || self == NIL)
		{
			end
		}

		local.skip = (self.no_usemedic == 1 || self.ARMED || self.WALKIETALKIED || self.DETONATORED || self.flying || self.dmteam == "spectator")

		if(self.medic_health <= 0)
		{
			self iprint "Out of medic health" 1
			end
		}
	
		if(local.skip != 1)
		{	
			if(self.useheld == 1)
			{
				local.player = waitthread check_players 

				if(local.player != NIL)
				{
					self.no_usemine = 1

					local.health = local.player.health 
					local.health = int local.health 

					if(local.player.health < 100)
					{
						thread fakehealth
						self stufftext ("subtitle3 Healing-Player")
						
						local.player stufftext ("locationprint 32 43 Being-Healed 1.0")
						
						local.is_near = 1

						while(self.useheld == 1 && local.health <= 100 && self.medic_health > 0 && local.is_near == 1)
						{
							waitframe
							local.health = local.player.health 
							local.health = int local.health 
					
							self stufftext ("set dmplayerhealth " + local.health)
							
							self.medic_health = self.medic_health - 5 // original self.medic_health--
							local.health = local.health + 5 // ++

							local.player.healthonly  = local.health

							self stufftext ("globalwidgetcommand healthnumber fgcolor 1.0 1.0 1.0 1.0")
							self stufftext ("globalwidgetcommand healthnumber title Medic-" + self.medic_health)
							local.is_near = waitthread is_near self local.player
						}
					}
					else
					{
						self stufftext ("subtitle3 Player-Has-Full-health")
					}

					if(game.game == "AA")
					{
						self stufftext "hidemenu dday1"
						self stufftext "hidemenu dday2"
					}
					else
					{
						self stufftext "hidemenu bastogne2"
						self stufftext "hidemenu bastogne1"
					}
					wait 1
					self.no_usemine = 0

					self stufftext ("globalwidgetcommand healthnumber fgcolor 0.70 0.60 0.05 1.00")
					self stufftext ("globalwidgetcommand healthnumber title Health")
							
					//self stufftext ("subtitle3 " + self.medic_health + "-medic-health")
					//self stufftext ("locationprint 32 43 Players-Health=" + local.health + "1.0")
				}
			
			}
		}
	}	

end

fakehealth:

	if(game.game != "AA")
	{
		thread fakehealth_sh
		end
	}

	self stufftext "globalwidgetcommand dday1 shader townhallwindow"
	self stufftext "globalwidgetcommand dday1 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday1 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand dday1 fadein 0"
	self stufftext "globalwidgetcommand dday1 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday1 virtualres 1" 
	self stufftext "globalwidgetcommand dday1 fullscreen 1" 

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar dmplayerhealth"
	self stufftext "globalwidgetcommand june6 statbar vertical 0 100"
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"


	self stufftext "globalwidgetcommand dday2 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday2 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand dday2 fadein 0"
	self stufftext "globalwidgetcommand dday2 menu dday2 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday2 virtualres 1" 
	self stufftext "globalwidgetcommand dday2 fullscreen 1" 

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left " 
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar dmplayerhealth"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	self stufftext "showmenu dday2"
	self stufftext "showmenu dday1"
end


fakehealth_sh:

	self stufftext "globalwidgetcommand bastogne1 shader townhallwindow"
	self stufftext "globalwidgetcommand bastogne1 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand bastogne1 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand bastogne1 fadein 0"
	self stufftext "globalwidgetcommand bastogne1 menu bastogne1 640 480 NONE 0"
	self stufftext "globalwidgetcommand bastogne1 virtualres 1" 
	self stufftext "globalwidgetcommand bastogne1 fullscreen 1" 

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar dmplayerhealth"
	self stufftext "globalwidgetcommand june6 statbar vertical 0 100"
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"


	self stufftext "globalwidgetcommand bastogne2 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand bastogne2 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand bastogne2 fadein 0"
	self stufftext "globalwidgetcommand bastogne2 menu bastogne2 640 480 NONE 0"
	self stufftext "globalwidgetcommand bastogne2 virtualres 1" 
	self stufftext "globalwidgetcommand bastogne2 fullscreen 1" 

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left " 
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar dmplayerhealth"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	self stufftext "showmenu bastogne2"
	self stufftext "showmenu bastogne1"

end

is_near local.player local.medic:

	local.vector_dist = ( local.player.origin - local.medic.origin )	// get vector between distance?
	local.dist_sqr = local.vector_dist * local.vector_dist			// get square distance

	local.radius = 50.0 * 50.0						// 50.0 close
	if(local.dist_sqr <= local.radius)					// is they within 50 things
	{
		local.is_fwd = local.vector_dist * local.medic.forwardvector		
		local.is_fwd =  local.is_fwd >= 20.0 && local.is_fwd <= 50.0	// is the number thing between 20 and 50. thats like 30 in which the person is in view.

		if(local.is_fwd)						
		{
			end 1
		}
	}

end 0

check_players:

	local.radius = 30.0 * 30.0

	for(local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if(local.player.dmteam == self.dmteam && isalive local.player)
		{
			if(local.player != self)
			{
				local.vector_dist = ( local.player.origin - self.origin )	// get vector between distance?
				local.dist_sqr = local.vector_dist * local.vector_dist		// get square distance
		
				local.radius = 50.0 * 50.0					// 50.0 close
				if(local.dist_sqr <= local.radius)				// is they within 50 things
				{
					local.is_fwd = local.vector_dist * self.forwardvector		
					local.is_fwd =  local.is_fwd >= 20.0 && local.is_fwd <= 50.0	// is the number thing between 20 and 50. thats like 30 in which the person is in view.
				
					if(local.is_fwd)
					{
						end local.player
					}
				}
			}
		}
	}
end

check_weapon local.player:

	if(local.player.dmteam=="spectator" || local.player == NIL || local.player == NULL)
	{
		end
	}

	if(game.medic_weapons==NIL)
	{
		waitthread load_weapons 
	}

	self.weapon = NIL	

	self waitexec global/get_weapon.scr

	local.true = 1
	for(local.true =0;local.true <= 1; local.true++)
	{
		wait 1
		if(self.weapon==NIL)
		{
			while(self.weapon==NIL)
			{
				if(self == NULL || self == NIL)
				{
					end
				}
				waitframe
			}
		}

		if(self.weapon != "models/weapons/unarmed.tik")
		{
			local.true = 2
		}

		waitexec global/get_weapon.scr

	}

	for(local.load=game.medic_weap_start;local.load<=game.all_commands.size;local.load++)
	{
		if((self.weapon + "-medic") == ("models/weapons/" + game.all_commands[local.load][1]))
		{
			local.medics = game.all_commands[local.load] [2]
			end local.medics
		}
	}

end local.medics

load_weapons:

	switch(game.game)
	{
	case "AA":
		game.medic_weapons =  waitexec game.file["medics"]::weaponsaa
	break
	case "SH":
		game.medic_weapons =  waitexec game.file["medics"]::weaponssh
	break
	case "BT":
		game.medic_weapons =  waitexec game.file["medics"]::weaponsbt
	break
	}

	local.i = game.all_commands.size
	game.medic_weap_start = local.i

	for(local.n=1;local.n<=game.medic_weapons.size;local.n++)
	{
		local.i++
		for(local.s=1;local.s <= game.medic_weapons[local.n].size; local.s++ )
		{
			if(local.s == 1)
			{
				game.all_commands[local.i][local.s] = (game.medic_weapons[local.n][local.s] + ".tik-medic")
			}
			else
			{
				game.all_commands[local.i][local.s] = (game.medic_weapons[local.n][local.s])
			}
		}
	}
end


```

# zz_admin-Pro_1.22_modif\global\ac\medics\setup.scr

```scr
main:
	if(level.run["medics"] != "1")
	{
		end
	}
	
	if (level.mef_gametype == "ft" || level.mef_gametype == "ftobj" || level.mef_gametype == "fttow" || level.mef_gametype == "ftctf" || level.mef_gametype == "ftdem")
	{
		end
	}

//	if(level.medics_setup != 1)
//	{
//		level.medics_setup = 1
//
//		exec global/ac/spawn_detect.scr global/ac/medics/hold_check.scr
//
//	}

end
```

# zz_admin-Pro_1.22_modif\global\ac\messaging\messages_fade.scr

```scr
// 04/12/2005 23:18 Changed Hud draw index to 71, from 51 to fix conflict with FT

// print the adverts
main local.msg local.delay local.colour:

	if(level.msginginuse==1)
	{
		while(level.msginginuse==1)
		{
			wait 1
		}
	}

	local.delay = int local.delay

	level.msginginuse=1


	local.lengh = 0
	local.lengh =  ( local.lengh - local.msg.size )

	local.font = waitexec global/settings.scr::getcmd  "advert-font" 
	local.virt = waitexec global/settings.scr::getcmd  "virtualsize" 
	local.virt = int local.virt

	local.wordcount = 0

	if(local.font == NIL)
	{
		local.font = "facfont-20"
	}

	if(local.colour == "none" )
	{
		local.lightcolour = waitexec global/settings.scr::getcmd  "advert-colour" 
		if(local.lightcolour == NIL)
		{
			local.light[1] = 1
			local.light[2] = 0
			local.light[3] = 1
		}
		else
		{
			if(local.lightcolour == "random")
			{
				local.light = waitexec global/nagle.scr::random_light
			}
			else
			{
				local.light = waitexec global/nagle.scr::light_from_string local.lightcolour
			}
		}
	}
	else
	{
		if(local.colour == "random")
		{
			local.light = waitexec global/nagle.scr::random_light
		}
		else
		{
			local.light = waitexec global/nagle.scr::light_from_string local.colour
		}
	}


	if(local.delay == NIL)
	{
		local.delay = 2
	}

	local.lengh = local.lengh * 3
	// draw the overlay coloured string
	huddraw_virtualsize 71 local.virt
	huddraw_rect 71 local.lengh 200 0 0
	huddraw_color 71 local.light[1] local.light[2] local.light[3]
	huddraw_font 71 local.font
	huddraw_string 71 local.msg 
	huddraw_align 71 "center" "center"

	// display a fade-in
	for(local.i = 0; local.i <= 1; local.i += .1)
	{
     		huddraw_alpha 71 local.i
		waitframe
	}
   
	wait local.delay
   
	// display a fade-out
	for (local.i = 1; local.i >= 0; local.i -= .1)
	{
		huddraw_alpha 71 local.i
		waitframe
	}
	
	level.msginginuse=0
end 
```

# zz_admin-Pro_1.22_modif\global\ac\messaging\messages_scroll.scr

```scr
// 04/12/2005 23:18 Changed Hud draw index to 71, from 51 to fix conflict with FT

// print the adverts
main local.msg local.delay local.colour:

	if(level.msginginuse==1)
	{
		while(level.msginginuse==1)
		{
			wait 1
		}
	}

	local.delay = int local.delay

	level.msginginuse=1

	local.font = waitexec global/settings.scr::getcmd  "advert-font" 
	local.scroll_speed = waitexec global/settings.scr::getcmd  "scroll-speed" 
	local.scroll_dir = waitexec global/settings.scr::getcmd "scroll-dir"
	local.virt = waitexec global/settings.scr::getcmd  "virtualsize" 
	local.virt = int local.virt

	local.wordcount = 0

	if(local.font == NIL)
	{
		local.font = "facfont-20"
	}

	if(local.colour == "none" )
	{
		local.lightcolour = waitexec global/settings.scr::getcmd  "advert-colour" 
		if(local.lightcolour == NIL)
		{
			local.light[1] = 1
			local.light[2] = 0
			local.light[3] = 1
		}
		else
		{
			if(local.lightcolour == "random")
			{
				local.light = waitexec global/nagle.scr::random_light
			}
			else
			{
				local.light = waitexec global/nagle.scr::light_from_string local.lightcolour
			}
		}
	}
	else
	{
		if(local.colour == "random")
		{
			local.light = waitexec global/nagle.scr::random_light
		}
		else
		{
			local.light = waitexec global/nagle.scr::light_from_string local.colour
		}
	}



	if(local.delay == NIL)
	{
		local.delay = 2
	}

	if(local.scroll_speed == NIL)
	{
		local.scroll_speed = 2
	}
	else
	{
		local.scroll_speed = int local.scroll_speed
	}

	if(local.scroll_dir == NIL)
	{
		local.scroll_dir = "left"
	}

	if(local.scroll_dir == "left")
	{
		local.lengh = 300
		local.to = ( -300 -  ( local.msg.size * 10 ) )
	}
	else
	{
		local.lengh = ( -300 -  ( local.msg.size * 10 ) )
		local.to = ( 300 +  ( local.msg.size * 10 ) )
	}

	local.ended  = 1
	while(local.ended == 1)
	{
		// draw the overlay coloured string
		huddraw_virtualsize 71 local.virt
		huddraw_rect 71 local.lengh 200 0 0
		huddraw_color 71 local.light[1] local.light[2] local.light[3]
		huddraw_font 71 local.font
		huddraw_string 71 local.msg 
		huddraw_align 71 "center" "center"
		huddraw_alpha 71 1.0


		if(local.scroll_dir == "left")
		{
			local.lengh -= local.scroll_speed
			local.ended = (local.to < local.lengh)
		}
		else
		{
			local.lengh += local.scroll_speed
			local.ended = (local.to > local.lengh)
		}

	
		waitframe
	}
   
	level.msginginuse=0
end 
```

# zz_admin-Pro_1.22_modif\global\ac\messaging\messages_typewriter.scr

```scr
// 04/12/2005 23:18 Changed Hud draw index to 71, from 51 to fix conflict with FT

// print the adverts
main local.msg local.delay local.colour:

	if(level.msginginuse==1)
	{
		while(level.msginginuse==1)
		{
			wait 1
		}
	}

	local.delay = int local.delay

	level.msginginuse=1

	local.font = waitexec global/settings.scr::getcmd  "advert-font" 
	local.virt = waitexec global/settings.scr::getcmd  "virtualsize" 
	local.virt = int local.virt

	local.wordcount = 0

	if(local.font == NIL)
	{
		local.font = "facfont-20"
	}


	if(local.colour == "none" )
	{
		local.lightcolour = waitexec global/settings.scr::getcmd  "advert-colour" 
		if(local.lightcolour == NIL)
		{
			local.light[1] = 1
			local.light[2] = 0
			local.light[3] = 1
		}
		else
		{
			if(local.lightcolour == "random")
			{
				local.light = waitexec global/nagle.scr::random_light
			}
			else
			{
				local.light = waitexec global/nagle.scr::light_from_string local.lightcolour
			}
		}
	}
	else
	{
		if(local.colour == "random")
		{
			local.light = waitexec global/nagle.scr::random_light
		}
		else
		{
			local.light = waitexec global/nagle.scr::light_from_string local.colour
		}
	}


	if(local.delay == NIL)
	{
		local.delay = 2
	}



	local.type = ""
	local.click = waitexec global/settings.scr::getcmd "typewriter-click"
	
	local.bl = 0
	for(local.i= 0; local.i <=  local.msg.size - 1; local.i++)
	{
		wait .1

		if(local.click=="1")
		{
			$player playsound objective_text2
		}

		if(local.bl == 0 )
		{
			local.blink = "_"
			local.bl = 1
		}
		else
		{
			local.blink = ""
			local.bl = 0
		}

		local.type = ( local.type + local.msg[local.i] )

		local.lengh = 0
		local.lengh =  ( local.lengh - local.msg.size )


		local.lengh = local.lengh * 3
		// draw the overlay coloured string
		huddraw_virtualsize 71 local.virt
		huddraw_rect 71 local.lengh 200 0 0
		huddraw_color 71 local.light[1] local.light[2] local.light[3]
		huddraw_font 71 local.font
		huddraw_string 71 ( local.type + local.blink )
		huddraw_align 71 "center" "center"
		huddraw_alpha 71 1
	}	

	huddraw_string 71 ( local.type + "")

	wait local.delay

	// display a fade-out
	for (local.i = 1; local.i >= 0; local.i -= .1)
	{
		huddraw_alpha 71 local.i
		waitframe
	}

	level.msginginuse=0
end 
```

# zz_admin-Pro_1.22_modif\global\ac\mines\chuck.scr

```scr
main local.player local.model local.scale:

	local.player safeholster 1
	wait 1
/*
	local.player useweaponclass grenade
	local.player weaponcommand duel model "items/explosive.tik"
	wait 1
	local.player weaponcommand duel model "items/explosive.tik"

	local.player weaponcommand duel model "items/explosive.tik"
	local.player weaponcommand duel dmprojectile "items/explosive.tik"
*/
	local.player attachmodel local.model "tag_weapon_right" 1.0 "mdlattach" 1 -1 -1 -1 -1 ( 0 0 0 )
	$mdlattach.angles = ( 0 0 90 )

	//local.player viewmodelanim multiplayer/mp_grenade_throw.skc		crossblend 0.05

	local.player forcetorsostate MINE
	wait .1
	local.player playsound m2frag_snd_grenade_throw weapon
	wait 1

	local.player safeholster 0

	local.start = self gettagposition "eyes bone" //"tag_weapon_right"
	local.fwd_vec = angles_toforward self.viewangles
	local.start =  local.start + local.fwd_vec * 32

	local.mine = spawn script_model "targetname" ("mine") "model" local.model
	local.mine solid
	local.mine.scale =  1 //local.scale

	local.mine.origin = local.start
	local.mine physics_on
	local.mine.velocity = local.fwd_vec * 300 + ( 0 0 250 )

	
	local.mine rotateX 50
	local.isplayer =1
	while(local.isplayer ==1 )
	{
		local.mine waittill touch

		if!(parm.other==local.player)
		{
			local.mine.gravity = 4
			local.mine rotateX 0
			local.mine.angles = ( 0 0 0 )
			local.isplayer = 0
		}
	}

end local.mine

```

# zz_admin-Pro_1.22_modif\global\ac\mines\explode.scr

```scr

main local.explosionplace local.mine local.shot:

	local.radius = 300.00 * 300.00
	
	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		local.player= $player[local.i]
		local.distance = (local.player.origin - local.explosionplace) * (local.player.origin - local.explosionplace)

		//local.distance = local.distance * local.distance

		if(local.distance <= local.radius)
		{
			if(local.shot != 1)
			{
				local.end_or_not = waitthread team_check local.player self
		
				if(local.end_or_not==1)
				{
					end //end if same team and team team killing is not on
				}
			}

			local.exploded = 1

			local.dmg_fact = 1 - local.distance / local.radius
			local.dmg = 100 * local.dmg_fact + 35

			local.player damage self local.dmg self (0 0 0) (0 0 0) (0 0 0) 1 1 9 -1
		}

	}
	
	if(local.exploded == 1 ||  local.shot == 1)
	{
		thread bang local.explosionplace
		local.mine.shot delete
		local.mine.walk delete
		local.mine delete
	}

end local.exploded


bang local.origin:

	local.exp1 = spawn "models/emitters/explosion_mine.tik" 
	local.exp1.origin = local.origin 
	local.exp1 scale 2

	local.exp = spawn "models/emitters/explosion_mine_shockwave.tik" 
	local.exp.origin = local.origin 
	local.exp scale 2
	//local.exp1 radiusdamage 0
	//local.exp radiusdamage 0
	local.exp1 anim start
	local.exp anim start
	wait 1
	local.exp delete
	local.exp1 delete
 
end


team_check local.player local.shooter:
	
	local.gametype = getcvar "g_gametype"
	
	if(local.gametype=="1")
	{
		end 0
	}
	
	local.ff =  getcvar "g_teamdamage"

	if(local.ff=="0")
	{
		if(local.player.dmteam == local.shooter.dmteam)
		{
			end 1
		}
	}

end 0

```

# zz_admin-Pro_1.22_modif\global\ac\mines\hold_check.scr

```scr
// 22/11/2005 17:48 changed wait time from .5 to 1

main:
			
	if(level.run["mines"] != "1")
	{
		end
	}

	local.replenish = waitexec global/settings.scr::getcmd "mine-replenish"

	if(self.mines == NIL || local.replenish != "0")
	{
		self.mines = 1
	}

	local.weaponscheck = waitexec global/settings.scr::getcmd "mine-weapons"
	
	if(local.weaponscheck == "1")
	{
		local.end =  waitthread check_weapon self

		if(local.end == "0")
		{
			end
		}

	}

	local.holdtime = waitexec global/settings.scr::getcmd "mine-holdtime"
	local.holdtime = int local.holdtime

	local.team = self.dmteam

	while(level.run["mines"] == "1" && self != NULL && self != NIL && isalive self  && self.dmteam == local.team)
	{

		wait 1 //wait 1 second

		if(self == NULL || self == NIL)
		{
			end
		}

		local.skip = (self.no_usemine == 1 || self.ARMED || self.WALKIETALKIED || self.DETONATORED || self.flying || self.dmteam == "spectator")

		if(local.skip != 1)
		{	
			if(self.useheld == 1)
			{
				local.held_for = local.holdtime
				while(self.useheld == 1)
				{
					for(local.i=0;local.i<=1;local.i = local.i + 0.05)
					{
						waitframe

						if(self.useheld == 0)
						{
							local.held_for = 3
							break
						}
					}
					
					local.skip = (self.no_usemine == 1 || self.ARMED || self.WALKIETALKIED || self.DETONATORED || self.flying || self.dmteam == "spectator")

					if( local.skip != 1)
					{
						self stufftext ("subtitle3 Mine-in-" + local.held_for )

						local.held_for--

						if(local.held_for == 0)
						{
							self stufftext ("subtitle3 Using-Mine")
							waitexec level.hold_script
							local.held_for = 3
						}
					}
					else
					{
						local.held_for = 3
						break
					}

				}
			}
		}
	}	

end


check_weapon local.player:

	if(local.player.dmteam=="spectator" || local.player == NIL || local.player == NULL)
	{
		end
	}

	if(game.mine_weapons==NIL)
	{
		waitthread load_weapons 
	}

	self.weapon = NIL	

	self waitexec global/get_weapon.scr

	local.true = 1
	for(local.true =0;local.true <= 1; local.true++)
	{
		wait 1
		if(self.weapon==NIL)
		{
			while(self.weapon==NIL)
			{
				if(self == NULL || self == NIL)
				{
					end
				}
				waitframe
			}
		}

		if(self.weapon != "models/weapons/unarmed.tik")
		{
			local.true = 2
		}

		waitexec global/get_weapon.scr

	}

	for(local.load=game.mine_weap_start;local.load<=game.all_commands.size;local.load++)
	{
		if((self.weapon + "-mine") == ("models/weapons/" + game.all_commands[local.load][1]))
		{
			local.mines = game.all_commands[local.load] [2]
			end local.mines
		}
	}

end local.mines

load_weapons:

	switch(game.game)
	{
	case "AA":
		game.mine_weapons =  waitexec game.file["mines"]::weaponsaa
	break
	case "SH":
		game.mine_weapons =  waitexec game.file["mines"]::weaponssh
	break
	case "BT":
		game.mine_weapons =  waitexec game.file["mines"]::weaponsbt
	break
	}

	local.i = game.all_commands.size
	game.mine_weap_start = local.i

	for(local.n=1;local.n<=game.mine_weapons.size;local.n++)
	{
		local.i++
		for(local.s=1;local.s <= game.mine_weapons[local.n].size; local.s++ )
		{
			if(local.s == 1)
			{
				game.all_commands[local.i][local.s] = (game.mine_weapons[local.n][local.s] + ".tik-mine")
			}
			else
			{
				game.all_commands[local.i][local.s] = (game.mine_weapons[local.n][local.s])
			}
		}
	}
end


```

# zz_admin-Pro_1.22_modif\global\ac\mines\mines_main.scr

```scr

main:

	local.player = self

	if (local.player.rankbonus["mines"] != 1 && level.running_ranking == 1) // Excute le script seulement si le joueur a atteint le bon rang
		end	
		
	level.limit = waitexec global/settings.scr::getcmd "mines-ammo"
	level.limit = int  level.limit

	if(local.player.mines >  level.limit )
	{
		self iprint "Out of mines" 1
		end
	}

	local.player iprint ( "Mine: " + local.player.mines + "/" + level.limit)
	local.player.mines++

	switch(level.mine_script)
	{
	case "proximity-chuck":
		local.wait = 1
		local.mine = waitexec global/ac/mines/chuck.scr local.player "items/explosive.tik" 1
	break
	case "proximity-plant":
		local.wait = 5
		local.mine = spawn script_model  "targetname" ("mine")
		local.mine model  "items/explosive.tik"
		local.mine.origin = local.player.origin + local.player.forwardvector * 16
		local.mine notsolid
	break
	default:
		local.wait = 1
		local.mine = waitexec global/ac/mines/chuck.scr local.player "items/explosive.tik" 1
	}

	local.mine_trig = spawn trigger_multiple "spawnflags" "128"  "targetname" ("minetrig_shot")
	local.mine_trig.origin = local.mine.origin
	local.mine_trig setsize ( -15 -15 -15 ) ( 15 15 15 )
	local.mine_trig setthread shot
	local.mine_trig glue local.mine
	local.mine_trig.mine = local.mine

	local.mine_trig_walk = spawn trigger_multiple  "targetname" ("minetrig_walk")
	local.mine_trig_walk.origin = local.mine.origin
	local.mine_trig_walk setsize ( -15 -15 -15 ) ( 15 15 15 )
	local.mine_trig_walk setthread stepped_on
	local.mine_trig_walk glue local.mine
	local.mine_trig_walk.mine = local.mine

	local.mine_trig_walk nottriggerable
	local.mine.shot = local.mine_trig
	local.mine.walk = local.mine_trig_walk
	local.mine.player = local.player


	if(level.mine_script != "proximity-chuck")
	{
		local.watch = waitexec global/settings.scr::getcmd "stopwatch" 
		if(local.watch=="1")
		{
			local.player stopwatch local.wait
		}
	}
	
	for(local.i = 0; local.i <=  local.wait; local.i++)
	{
		wait 1
		if(local.mine == NULL)
		{
			local.player stopwatch 0
			end
		}
	}

	if(local.mine != NULL)
	{
		local.mine_trig_walk triggerable

		local.player iprint "Mine Activated"

		local.hide = waitexec global/settings.scr::getcmd "hide-mines"

		if (local.hide == "1")
		{
			local.mine hide
		}

		local.player playsound plantbomb1
	}

end

stepped_on:

	local.player = parm.other
		
	local.mine = self.mine
	local.end_or_not = waitexec global/ac/mines/explode.scr::team_check local.player local.mine.player
	
	if(local.end_or_not==1)
	{
		if(local.player.dmteam=="axis")
		{
			self.mine light 1 0 0 50
		}
		else
		{
			self.mine light 0 0 1 50
		}

		wait 3

		if(self && self.mine)
		{
			local.mine light 0 0 0 0
		}

		end //end if same team and team team killing is not on
	}

	local.end_or_not = waitexec global/settings.scr::getcmd "disarmable"

	if(local.end_or_not == "1")
	{
		self nottriggerable

		self.no_usemine = 1

		local.end_or_not = waitthread disarm local.player local.mine.origin

		if(local.end_or_not==1)
		{
			local.mine.player exec global/ac/mines/explode.scr local.mine.origin local.mine
		}
		else
		{
			local.mine.shot delete
			local.mine.walk delete
			local.mine delete
		}

		wait 1
		local.player.no_usemine = 0
	}
	else
	{
		local.mine.player exec global/ac/mines/explode.scr local.mine.origin local.mine
	}


end
	
shot:
	local.player = parm.other
				
	local.mine = self.mine

	local.player exec global/ac/mines/explode.scr local.mine.origin local.mine 1
end


disarm local.player local.origin:

	local.player.no_usemine = 1
	//local.origin = local.mine.origin
	local.camper_radius = 150

	local.camper_radius = int local.camper_radius

	local.time = 0

	local.tick = waitexec global/settings.scr::getcmd "disarm-tick"
	local.hold_time = waitexec global/settings.scr::getcmd "disarm-time"

	local.tick = int local.tick
	local.hold_time = int local.hold_time

	local.player  iprint ( "You have " + local.hold_time + " seconds to disarm the mine. If you move to far it will explode" ) 1
	local.player  iprint "Hold USE (E) To disarm the mine"

	for(local.i = local.tick;local.i != 0;local.i--)
	{
		for(local.t = 0;local.t <= 1;local.t = local.t + 0.05)
		{
			local.inradius =  vector_within local.origin local.player.origin local.camper_radius  
			
			if(local.inradius == 0)
			{
				end 1
			}
			waitframe
		}

		if(local.player.useheld == 1)
		{
			local.time++
		}

		if(local.time >= local.hold_time)
		{
			local.player iprint "Mine disarmed" 1
			end 0

		}
	}

end 1

```

# zz_admin-Pro_1.22_modif\global\ac\mines\mines.scr

```scr


main:


	if(level.run["mines"] != "1")
	{
		end
	}
	
	if (level.mef_gametype == "ft" || level.mef_gametype == "ftobj" || level.mef_gametype == "fttow" || level.mef_gametype == "ftctf" || level.mef_gametype == "ftdem")
	{
		end
	}

	if(level.mines_serup != 1)
	{
		level.mines_serup = 1
		//exec global/killed.scr "global/ac/mines/dead.scr" 1
		//exec global/ac/spawn_detect.scr global/ac/mines/hold_check.scr

		local.master = spawn ScriptMaster
		local.master aliascache plantbomb1 sound/items/Item_BangaloreAssemble_01.wav soundparms 1.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train"

	}

	
	local.mines = waitexec game.file["mines"]::mines

	local.numscripts = 0

	for(local.i=1;local.i<= local.mines.size;local.i++)
	{
		if (local.mines[local.i][2] == "1")
		{
			local.numscripts++
			local.scripts[local.numscripts] = local.mines[local.i][1]
		}
	}

	local.randnum = randomint(local.numscripts) + 1

	//local.howmany = waitexec global/settings.scr::getcmd "mine-type"

	level.mine_script  = local.scripts[local.randnum]

	level.hold_script = global/ac/mines/mines_main.scr

	switch(local.scripts[local.randnum])
	{
	case "proximity-chuck":
		local.msg = makearray
			"By holding USE down you can chuck proximity mines"
			" You must hold E (USE) down for 3 seconds to chuck a mine"
		endarray
	
	break
	case "proximity-plant":

		local.msg = makearray
			"By holding USE down you can plant proximity mines"
			" You must hold E (USE) down for 3 seconds to  plant proximity mines"
		endarray
	break
	case "sticky-bombs":
		level.hold_script = global/ac/mines/stickybombs.scr
		local.msg = makearray
			"By holding USE down you can chuck sticky bombs"
			" You must hold E (USE) down for 3 seconds to chuck sticky bombs"
		endarray
	break
	default:

		local.msg = makearray
			"By holding USE down you can chuck proximity mines"
			" You must hold E (USE) down for 3 seconds to chuck a mine"
		endarray
	}
		

	while(1)
	{
		waitframe
		for(local.i=1;local.i<=local.msg.size;local.i++)
		{
			wait 300 //five mins
			waitexec global/ac/messaging/messages_fade.scr local.msg[local.i][1] 3 "fade"

		}
	}

		

end
```

# zz_admin-Pro_1.22_modif\global\ac\mines\readme.txt

```txt
modif 1re ligne hold_check.scr pour bonus de rang
```

# zz_admin-Pro_1.22_modif\global\ac\mines\sticky_chuck.scr

```scr
main local.player local.model local.scale:


	local.vertical = (local.player getcontrollerangles 0)[0] //local.player.viewangles[2]

	local.player safeholster 1

	local.vertical = 0 - local.vertical 
	wait 1

	local.player attachmodel local.model "tag_weapon_right" 1.0 "mdlattach" 1 // 1.0 // 1.0  1.0 1.0 ( 0 0 0 )
	//local.player viewmodelanim multiplayer/mp_grenade_throw.skc		crossblend 0.05

	local.player forcetorsostate MINE
	wait .1
	local.player playsound m2frag_snd_grenade_throw weapon
	wait 1

	local.player safeholster 0

	local.start = self gettagposition "eyes bone" //"tag_weapon_right"
	local.fwd_vec = angles_toforward local.player.viewangles
	local.hit_location =  local.start + local.fwd_vec * 16

	local.dest = trace (local.start + local.fwd_vec * 64) (local.start + local.fwd_vec * 500) 1

	local.mine = spawn script_model "targetname" ("mine") "model" local.model
	local.mine solid
	local.mine.scale =  local.scale

	local.org = local.player.origin
	local.org[2] = 	local.org[2] + 90

	local.mine.origin = local.hit_location //local.org
	local.vect = (local.dest - local.player.origin)
	local.vect = vector_normalize (local.vect)

	local.dist = vector_length (local.player.origin - local.dest)
	
	local.vect[0] = 	local.vect[0] * (local.dist / 1.5) * 3
	local.vect[1] = 	local.vect[1] * (local.dist / 1.5) * 3
	local.vect[2] = 	local.vect[2] * local.dist * ( local.vertical / 5 )

			//local.vect[2] = local.vect[2] + 300

	local.vect[2] = local.vect[2] + local.vertical

	local.mine physics_on

	local.mine rotateX (local.vect[0] / 3)

	local.mine physics_velocity local.vect

	local.isplayer =1

	while(local.isplayer ==1 )
	{
		local.mine waittill touch

		local.hit  =parm.other

		if!(local.hit==local.player)
		{
			local.isplayer = 0
			local.mine rotateX 0
			local.mine.angles = ( 0 0 0 )
			local.mine physics_off
			local.mine.velocity = ( 0 0 0 )
		}
		
	}

	if (local.hit == $player)
	{
		local.mine attach local.hit "Bip01 Head"
	}

end local.mine

```

# zz_admin-Pro_1.22_modif\global\ac\mines\stickybombs.scr

```scr

main:

	local.player = self

	level.limit = waitexec global/settings.scr::getcmd "mines-ammo"
	level.limit = int  level.limit

	if(local.player.mines >  level.limit )
	{
		self iprint "Out of mines" 1
		end
	}

	local.player iprint ( "Sticky bomb: " + local.player.mines + "/" + level.limit)
	local.player.mines++

	local.wait = 3
	local.mine = waitexec global/ac/mines/sticky_chuck.scr local.player "items/explosive2.tik" 2.5

	local.mine_trig = spawn trigger_multiple "spawnflags" "128"  "targetname" ("minetrig_shot")
	local.mine_trig.origin = local.mine.origin
	local.mine_trig setsize ( -15 -15 -15 ) ( 15 15 15 )
	local.mine_trig setthread shot
	local.mine_trig glue local.mine
	local.mine_trig.mine = local.mine

	local.mine_trig_walk = spawn trigger_multiple  "targetname" ("minetrig_walk")
	local.mine_trig_walk.origin = local.mine.origin
	local.mine_trig_walk setsize ( -15 -15 -15 ) ( 15 15 15 )
	local.mine_trig_walk setthread stepped_on
	local.mine_trig_walk glue local.mine
	local.mine_trig_walk.team = local.player.dmteam
	local.mine_trig_walk.mine = local.mine

	local.mine_trig_walk nottriggerable
	local.mine.shot = local.mine_trig
	local.mine.walk = local.mine_trig_walk
	local.mine.player = local.player


	if(level.mine_script != "proximity-chuck")
	{
		local.watch = waitexec global/settings.scr::getcmd "stopwatch" 
		if(local.watch=="1")
		{
			local.player stopwatch local.wait
		}
	}

	local.player playsound plantbomb1

	for(local.i = 0; local.i <=  local.wait; local.i++)
	{
		wait 1
		if(local.mine == NULL)
		{
			local.player stopwatch 0
			end
		}
	}

	if(local.mine != NULL)
	{
		local.mine_trig_walk triggerable

		local.player thread explode local.mine.origin

		local.mine.shot delete
		local.mine.walk delete
		local.mine delete
	}
end

stepped_on:

	local.player = parm.other
	
	local.mine = self.mine			
	local.end_or_not = waitthread team_check local.player local.mine.player
	
	if(local.end_or_not==1)
	{
		if(self.team=="axis")
		{
			self.mine light 1 0 0 50
		}
		else
		{
			self.mine light 0 0 1 50
		}

		wait 3
		if(self.mine )
		{
			local.mine light 0 0 0 0
		}

		end //end if same team and team team killing is not on
	}

	local.mine.player thread explode local.mine.origin

	local.mine.shot delete
	local.mine.walk delete
	local.mine delete
		
end
	
shot:
	local.player = parm.other
				
	local.mine = self.mine

	local.player thread explode local.mine.origin

	local.mine.shot delete
	local.mine.walk delete
	local.mine delete
		

end


explode local.explosionplace local.shot:

	thread bang local.explosionplace
	local.radius = 300.00 * 300.00

	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		local.player= $player[local.i]
		local.distance = local.player.origin - local.explosionplace

		local.distance = local.distance * local.distance

		if(local.distance <= local.radius)
		{
			local.end_or_not = waitthread team_check local.player self
	
			if(local.end_or_not==1)
			{
				end //end if same team and team team killing is not on
			}

			local.dmg_fact = 1 - local.distance / local.radius
			local.dmg = 150 * local.dmg_fact + 30

			local.player damage self local.dmg self (0 0 0) (0 0 0) (0 0 0) 1 1 9 -1
		}

	}


end

team_check local.player local.shooter:
	
	local.gametype = getcvar "g_gametype"
	
	if(local.gametype=="1")
	{
		end 0
	}
	
	local.ff =  getcvar "g_teamdamage"

	if(local.ff!="0")
	{
		if(local.player.dmteam == local.shooter.dmteam)
		{
			end 1
		}
	}

end 0

bang local.origin:

	local.exp1 = spawn "models/emitters/explosion_mine.tik" 
	local.exp1.origin = local.origin 
	local.exp1 scale 2

	local.exp = spawn "models/emitters/explosion_mine_shockwave.tik" 
	local.exp.origin = local.origin 
	local.exp scale 2
	local.exp1 anim start
	local.exp anim start
	wait 1
	local.exp delete
	local.exp1 delete
 
end
```

# zz_admin-Pro_1.22_modif\global\ac\music.scr

```scr
// modified phil{sfx} spec music.scr into a scr for playing music to spec or all . 

main local.cmd local.tracknum:

	if(level.run["music"] != "1"){end}

	switch(local.cmd)
	{
	case "next":
		level.music_run = 0
		waitthread turn_music_off
		level.track++
	break
	case "prev":
		waitthread turn_music_off
		level.music_run = 0
		level.track--
	break
	case "random":
		waitthread turn_music_off
		level.music_run = 0
		level.track = randomint( 44+1)
	break
	case "track":
		waitthread turn_music_off
		level.music_run = 0
		level.track = int local.tracknum
	break
	default:
		level.track = randomint( 44+1)
	}


	if(level.music_run !=1)
	{
		level.music_run = 1
	}
	else
	{
		end
	}

	if(level.track < 0)
	{
		level.track =  44
	}
	else if(level.track > 44 )
	{
		level.track =  0
	}

	switch (level.track)
	{
	case "0":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3")
	break
	case "1":
		local.SMUSIC = ("main/sound/music/mus_03c_suspense.mp3")
	break
	case "2":
		local.SMUSIC = ("main/sound/music/mus_NorthAfrica_01a.mp3") 
	break
	case "3":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3") 
	break
	case "4":
		local.SMUSIC = ("main/sound/music/mus_01a_suspense.mp3") 
	break
	case "5":
		local.SMUSIC = ("main/sound/music/mus_04f_suspense.mp3")
	break
	case "6":
		local.SMUSIC = ("main/sound/music/mus_17b_mystery.mp3")
	break
	case "7":
		local.SMUSIC = ("main/sound/music/mus_17a_mystery.mp3")
	break
	case "8":
		local.SMUSIC = ("main/sound/music/mus_11a_surprise.mp3")
	break
	case "9":
		local.SMUSIC = ("main/sound/music/mus_10a_action.mp3")
	break
	case "10":
		local.SMUSIC = ("main/sound/music/mus_06a_mystery.mp3")
	break
	case "11":
		local.SMUSIC = ("main/sound/music/mus_03c_suspense.mp3")
	break
	case "12":
		local.SMUSIC = ("main/sound/music/mus_NorthAfrica_01a.mp3") 
	break
	case "13":
		local.SMUSIC = ("main/sound/music/mus_NorthAfrica_01a.mp3") 
	break
	case "14":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3") 
	break
	case "15":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3") 
	break
	case "16":
		local.SMUSIC = ("main/sound/music/mus_01a_suspense.mp3") 
	break
	case "17":
		local.SMUSIC = ("main/sound/music/mus_04f_suspense.mp3")
	break
	case "18":
		local.SMUSIC = ("main/sound/music/mus_17b_mystery.mp3")
	break
	case "19":
		local.SMUSIC = ("main/sound/music/mus_17a_mystery.mp3")
	break
	case "210:
		local.SMUSIC = ("main/sound/music/mus_11a_surprise.mp3")
	break
	case "21":
		local.SMUSIC = ("main/sound/music/mus_10a_action.mp3")
	break
	case "22":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3")
	break
	case "23":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3")
	break
	case "24":
		local.SMUSIC = ("main/sound/music/mus_17a_mystery.mp3")
	break
	case "25":
		local.SMUSIC = ("main/sound/music/mus_06a_mystery.mp3")
	break
	case "26":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3")
	break
	case "27":
		local.SMUSIC = ("main/sound/music/mus_03c_suspense.mp3")
	break
	case "28":
		local.SMUSIC = ("main/sound/music/mus_04a_suspense.mp3")
	break
	case "29":
		local.SMUSIC = ("main/sound/music/mus_15a_mystery.mp3")
	break
	case "30":
		local.SMUSIC = ("main/sound/music/mus_SniperTown_01a.mp3")
	break
	case "31":
		local.SMUSIC = ("main/sound/music/mus_SniperTown_01b.mp3")
	break
	case "32":
		local.SMUSIC = ("main/sound/music/mus_TigerTank_01a.mp3")
	break
	case "33":
		local.SMUSIC = ("main/sound/music/mus_TigerTank_01a.mp3")
	break
	case "34":
		local.SMUSIC = ("main/sound/music/mus_11b_action.mp3")
	break
	case "35":
		local.SMUSIC = ("main/sound/music/mus_02b_suspense.mp3")
	break
	case "36":
		local.SMUSIC = ("main/sound/music/mus_02b_suspense.mp3")
	break
	case "37":
		local.SMUSIC = ("main/sound/music/mus_Schmerzen_01a.mp3")
	break
	case "38":
		local.SMUSIC = ("main/sound/music/mus_01a_suspense.mp3") 
	break
	case "39":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3") 
	break
	case "40":
		local.SMUSIC = ("main/sound/music/mus_14a_action.mp3")
	break
	case "41":
		local.SMUSIC = ("main/sound/music/mus_Schmerzen_01a.mp3")
	break
	case "42":
		local.SMUSIC = ("main/sound/music/mus_Schmerzen_01a.mp3")
	break
	case "43":
		local.SMUSIC = ("main/sound/music/mus_Schmerzen_01f.mp3")
	break
	case "44":
		local.SMUSIC = ("main/sound/music/mus_Schmerzen_01a.mp3")
	break
	default:
		local.SMUSIC = ("main/sound/music/mus_Schmerzen_01a.mp3")
	}

	thread music local.SMUSIC
end

music local.track:

	local.players = waitexec global/settings.scr::getcmd "play-for"

	local.track = ("playmp3 " + local.track )
	while(level.run["music"] == "1")
	{
		if(local.players== "spectator")
		{	
			for(local.p=1;local.p <= $player.size; local.p++)
			{
				if(level.run["music"] != "1"){end}
				if($player[local.p].dmteam == "spectator" && $player[local.p].playingmusic != 1)
				{
					$player[local.p].playingmusic = 1
					$player[local.p] stufftext (local.track)
					$player[local.p] thread while_spec
					$player[local.p] iprint ("Type stopmp3 into console to stop music ,It will auto stop when u join a team") 1
				}
			}
		}
		else
		{
	
			for(local.p=1;local.p <= $player.size; local.p++)
			{
				if(level.run["music"] != "1"){end}
				if($player[local.p].dmteam == "spectator" && $player[local.p].playingmusic != 1)
				{
					$player[local.p].playingmusic = 1
					$player[local.p] stufftext ("" + local.track)
				}
			}
		}
		
		wait 1
	}

end

while_spec:

	while(self.dmteam == "spectator")
	{		
		wait 1
	}

	self stufftext ("stopmp3")	
	self.playingmusic = 0
end
	
turn_music_off:

	level.run["music"] = "0" //temp turn it all off.

	for(local.p=1;local.p <= $player.size; local.p++)
	{
		if($player[local.p].playingmusic == 1)
		{
			$player[local.p].playingmusic = 0
			$player[local.p] stufftext ("stopmp3")
		}
	}

	level.run["music"] = "1" //turn it back on this instant!

end
```

# zz_admin-Pro_1.22_modif\global\ac\norecoil.scr

```scr
main:

	if(level.hit == NIL)
	{
			level.hit = 0
	}
	else if(level.hit > 0)
	{
		iprintln "you must wait"
		end
	}

	self takeall
	self tele ( 302 899 50 )

	self forcetorsostate NO_RECOIL_PREP
	self forcelegsstate NO_RECOIL
	
	level.dude = self
	self.viewangles = ( 0 0 0 )

	waitframe

	local.fwd_vec = angles_toforward self.viewangles
	local.start = self gettagposition "eyes bone"
	local.far = 100.00
	local.hit = trace (local.start) (local.start + local.fwd_vec * local.far ) 1
	
	local.dist = vector_length( local.start - local.hit) 
	
	//local.far = local.far * local.far

	if(local.dist < local.far )
	{
		iprintlnbold  "Player is too close to a wall"
		self resetstate
		self respawn
		self.forcespawn = 1
		end
	}


	self nodamage
	self notsolid
	self hide

	self give "models/weapons/mp44.tik"
	self use "models/weapons/mp44.tik"
	
	self iprint ("Please be patient while you are tested for no recoil") 5

	local.trig = spawn trigger_multiple spawnflags 129
	local.trig.origin = local.hit
	local.trig setsize ( -5 -5 -5 ) ( 5 5 5 )
	local.trig setthread shot 
	
	//	exec showbox.scr::setsize local.hit ( -5 -5 -5 ) ( 5 5 5) ( 1 0 0 )

	self.viewangles = ( 0 0 0 )

	wait 5

	local.trig delete
	
	iprintlnbold ( "Player scored " + level.hit )
	iprintlnbold ( "Avarage with recoil is 1-16" )
	iprintlnbold ( "Above 15 is potentialy norecoil" )

	if(level.hit > 15)
	{
		iprintlnbold "this dude probably most likely is using a no recoil hack"
	}
	
	self respawn
	self resetstate
	self.forcespawn = 1
	level.hit = 0

end

shot:
	local.p = parm.other
	if(local.p == level.dude )
	{
		level.hit++
	}
end


/*
//////
//no recoil check

state NO_RECOIL
{

	states
	{
		STAND			: KILLED
	}
}





//////
//no recoil check

state NO_RECOIL_PREP
{
	movetype absolute

	action
	{
		none : default // stop torso animation
	}

	states
	{
		RAISE_NORECOIL			: NEW_WEAPON
	}
}


state RAISE_NORECOIL
{
	movetype absolute

	action
	{
		mp44_crouch_raise	: IS_NEW_WEAPON "mainhand" "StG 44" POSITION_TYPE "crouching"
		mp44_stand_raise	: IS_NEW_WEAPON "mainhand" "StG 44"

		mg_crouch_raise	: POSITION_TYPE "crouching"
		mg_stand_raise	: default
	}
	
	states
	{
		
		NO_RECOIL	 			: ANIMDONE_TORSO
		
	}
}

state NO_RECOIL
{
	movetype absolute

	entrycommands
	{
		viewmodelanim fire 1
	}

	action
	{
		none : default // stop torso animation
	}

	states
	{
		STAND			: KILLED
		ATTCK_CHECK		: IS_WEAPON_READY_TO_FIRE "mainhand"
	}
}

state ATTCK_CHECK
{
	entrycommands
	{
		viewmodelanim fire 1
	}

	action
	{
		mp40_stand_run_fire		: IS_WEAPON_ACTIVE "mainhand" "MP40" POSITION_TYPE "standing" MOVEMENT_TYPE "running"
		mp40_crouch_run_fire	: IS_WEAPON_ACTIVE "mainhand" "MP40" POSITION_TYPE "crouching" MOVEMENT_TYPE "running"
		mp40_crouch_fire		: IS_WEAPON_ACTIVE "mainhand" "MP40" POSITION_TYPE "crouching"
		mp40_stand_fire			: IS_WEAPON_ACTIVE "mainhand" "MP40"

		smg_stand_run_fire		: POSITION_TYPE "standing" MOVEMENT_TYPE "running"
		smg_crouch_run_fire		: POSITION_TYPE "crouching" MOVEMENT_TYPE "running"
		smg_crouch_fire			: POSITION_TYPE "crouching"
		smg_stand_fire			: default
	}

	states
	{

		NO_RECOIL							: IS_WEAPON_READY_TO_FIRE "mainhand" //ANIMDONE_TORSO // !IS_WEAPON_READY_TO_FIRE "mainhand"
	}
}

//	
//		CHECK_PRIMARY_ATTACK_SEMIAUTO	: +ATTACK_PRIMARY IS_WEAPON_SEMIAUTO "mainhand" IS_WEAPON_READY_TO_FIRE "mainhand"
//		CHECK_PRIMARY_ATTACK_FULLAUTO	: ATTACK_PRIMARY !IS_WEAPON_SEMIAUTO "mainhand" IS_WEAPON_READY_TO_FIRE "mainhand"
//		CHECK_SECONDARY_ATTACK			: +ATTACK_SECONDARY
//	}
//
//
//state CHECK_PRIMARY_ATTACK_FULLAUTO
//{
//	movetype legs
//
//	action
//	{
//		none : default // stop torso animation
//	}
//
//	states
//	{
//		STAND					: KILLED
////		PAIN					: PAIN
//	
//		STAND					: NEW_WEAPON
//		STAND					: RELOAD
//		STAND					: !IS_WEAPON_READY_TO_FIRE "mainhand"
//		
////		ATTACK_PISTOL_PRIMARY	: IS_WEAPONCLASS_READY_TO_FIRE "mainhand" "pistol"
////		ATTACK_RIFLE_PRIMARY	: IS_WEAPONCLASS_READY_TO_FIRE "mainhand" "rifle"
////		CHARGE_ATTACK_GRENADE	: IS_WEAPONCLASS_READY_TO_FIRE "mainhand" "grenade"
//		ATTACK_SMG_PRIMARY		: IS_WEAPONCLASS_READY_TO_FIRE "mainhand" "smg"
//		ATTACK_MG_PRIMARY		: IS_WEAPONCLASS_READY_TO_FIRE "mainhand" "mg"
////		ATTACK_ITEM_PRIMARY		: IS_WEAPONCLASS_READY_TO_FIRE "mainhand" "item"
//		
////		STAND					: IS_WEAPON_ACTIVE "Error"  // Generates an error if no appropriate
//															// attack state is chosen
//		STAND					: !ATTACK_PRIMARY
//	}
//}
//
//state ATTACK_SMG_PRIMARY
//{
//	movetype legs
//
//	entrycommands
//	{
//		viewmodelanim fire 1
//	}
//
//	action
//	{
//		mp40_stand_run_fire		: IS_WEAPON_ACTIVE "mainhand" "MP40" POSITION_TYPE "standing" MOVEMENT_TYPE "running"
//		mp40_crouch_run_fire	: IS_WEAPON_ACTIVE "mainhand" "MP40" POSITION_TYPE "crouching" MOVEMENT_TYPE "running"
//		mp40_crouch_fire		: IS_WEAPON_ACTIVE "mainhand" "MP40" POSITION_TYPE "crouching"
//		mp40_stand_fire			: IS_WEAPON_ACTIVE "mainhand" "MP40"
//
//		smg_stand_run_fire		: POSITION_TYPE "standing" MOVEMENT_TYPE "running"
//		smg_crouch_run_fire		: POSITION_TYPE "crouching" MOVEMENT_TYPE "running"
//		smg_crouch_fire			: POSITION_TYPE "crouching"
//		smg_stand_fire			: default
//	}
//
//	states
//	{
//		STAND							: KILLED
////		PAIN							: PAIN
//
//		STAND							: !ATTACK_PRIMARY ANIMDONE_TORSO 
//		STAND							: ANIMDONE_TORSO !IS_WEAPON_READY_TO_FIRE "mainhand"
////		STAND							: RELOAD !ATTACK_PRIMARY IS_WEAPON_READY_TO_FIRE "mainhand"
//		STAND							: RELOAD !ATTACK_PRIMARY
////		STAND							: RELOAD !HAS_AMMO_IN_CLIP "mainhand" IS_WEAPON_READY_TO_FIRE "mainhand"
//		
//		CHECK_PRIMARY_ATTACK_FULLAUTO	: ATTACK_PRIMARY +IS_WEAPON_READY_TO_FIRE "mainhand"
//		CHECK_PRIMARY_ATTACK_FULLAUTO	: +ATTACK_PRIMARY IS_WEAPON_READY_TO_FIRE "mainhand"
//	}
//}

*/
```

# zz_admin-Pro_1.22_modif\global\ac\punishment.scr

```scr
// Anti camper punishment script by Elgan Sayer
// version 0.00
//
// Questions should go to www.mods-r-us.net forums or elgan.sayer@gmail.com
//
// feel free to pass or tamper with this mod as its for u!
// 
// www.mods-r-us.net
//
//
// **************************************************************************************************************************************


// This is the punishment for max camps. it simply kicks the player.

main:
	
	self iprint "You are being kicked for camping" 1 //tell him/her

	wait 5

	self stufftext "connect 0 0 0" //kick player
	wait 3

	if(self)
	{
		self stufftext "disconnect" //kick player
	}
end
```

# zz_admin-Pro_1.22_modif\global\ac\server_messages.scr

```scr
// run the adverts
// run them how user sets. message printing is in messages.scr - this is so u cna edit how it displays easier

main:
	
	if(level.run["message-center"] != "1"){end}

	level waittill spawn

	level.msginginuse=0

	//load the messages
	local.messages = waitexec game.file["message-center"]::messages

	while(level.run["message-center"] == "1")
	{
		local.msgtime = waitexec global/settings.scr::getcmd "advert-time"
		local.msgtime = int local.msgtime

		if(local.msgtime < 0.05 || local.msgtime == NIL)
		{
			local.msgtime = 1
		}

		local.msgdelay = waitexec global/settings.scr::getcmd "advert-delay"
		local.msgdelay = int local.msgdelay

		if(local.msgdelay < 0.05 || local.msgdelay == NIL)
		{
			local.msgdelay = 1
		}

		wait local.msgtime	

		for(local.i=1;local.i<=local.messages.size;local.i++)
		{
			if(level.run["message-center"] != "1"){end}

			if(local.messages[local.i].size == 4)
			{
				local.colour = local.messages[local.i][4]
			}
			else
			{
				local.colour = "none"	
			}

			switch(local.messages[local.i][3])
			{
			case "fade":
				waitexec global/ac/messaging/messages_fade.scr local.messages[local.i][1] local.messages[local.i][2] local.colour
			break
			case "typewriter":
				waitexec global/ac/messaging/messages_typewriter.scr local.messages[local.i][1] local.messages[local.i][2] local.colour
			break
			case "scroll":
				waitexec global/ac/messaging/messages_scroll.scr local.messages[local.i][1] local.messages[local.i][2] local.colour
			break		
			default:
				waitexec global/ac/messaging/messages_fade.scr local.messages[local.i][1] local.messages[local.i][2] local.colour
			}

			wait local.msgdelay
		}	
	}

end
```

# zz_admin-Pro_1.22_modif\global\ac\spawn_detect.scr

```scr
// This is a global ac script for detecting spawning.
// exec once! with the path for your script. eg
//
//	if(level.spawnpotect!=1)
//	{
//		level.spawnpotect=1
//		exec global/ac/spawn_detect.scr global/ac/spawn_protection.scr // exec with this script path
//	}	
//
// 24/08/2005

main local.fr:

	if(local.fr == "1")
	{

		if(self.spawned == NIL)
		{

		//	self.spawned=1
		//	wait 1 // 0.15 to allow for all scripts to load, God slloow
			//self.spawnedcheck=1
			//self thread follow
			thread spawned

		}
		else
		{
			self.spawned = 1
		}

		end
	}
	else if(local.fr != "")
	{
		if(level.spawn_scripts==NIL)
		{
			level.spawn_scripts[1] = local.fr
		}
		else
		{
		//	//some odd reason it wont let me get the size. so get it using a loop.
		//	// errors when trying ?:S
		//	for(local.i = 1; local.i <= ; local.i++)
		//	{
		//	}
			local.i = level.spawn_scripts.size
			local.i++
			level.spawn_scripts[local.i] = local.fr
		}
	}
end

/*
setup:

iprintlnbold "work"
	while(1)
	{
		println "J"
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			if($player[local.i].spawnedcheck !=1 && $player[local.i] != NIL && $player[local.i] != NULL) //\`\`\`\`\`\` && $player[local.i].dmteam !="spectator")
			{	
				$player[local.i].spawnedcheck=1
				$player[local.i] thread follow
			}
		}

		waitframe
	}
end
*/

follow:

	if(self.spawned != NIL)
	{
		local.team = self.dmteam
		self.forcespawn = 0
		while(isalive self && self.dmteam == local.team && self.forcespawn == 0 ) 
		{
			waitframe
			if(self == NIL || self == NULL)
			{
				end
			}
		}
	}

	self.spawned=0	

	while(self.spawned==0)
	{
		waitframe
		if(self == NIL || self == NULL)
		{
			end
		}
	}

	spawned:

	//iprintlnbold  "spawned"

	self.spawned=1
	//run the script that want spawn detection

	for(local.i = 1; local.i <= level.spawn_scripts.size; local.i++)
	{
	//	iprintln  level.spawn_scripts[local.i][1]

		if(self.forcespawn == 1)
		{
			//iprintln level.spawn_scripts[local.i][3]
			if(level.spawn_scripts[local.i][3] == "1")
			{
				self exec level.spawn_scripts[local.i][1]
			}
		}
		else
		{
			self exec level.spawn_scripts[local.i][1]
		}
	}
			
	self.forcespawn = 0
	//end of run the script that want spawn detection

	//self.spawnedcheck = 0
	thread follow
end

```

# zz_admin-Pro_1.22_modif\global\ac\spawn_protection_setup.scr

```scr
main:

	if(game.game != "AA")
	{
		if(game.run_spawn_protect_on_sh_and_bt != 1)
		{
			level.run["spawn-protection"] = 0
		}
		
	}

//
//	if(level.spawnpotect!=1)
//	{
//		level.spawnpotect=1
//		exec global/ac/spawn_detect.scr global/ac/spawn_protection.scr // exec with this script path
//	}	

end
```

# zz_admin-Pro_1.22_modif\global\ac\spawn_protection.scr

```scr
main:


	if(self.dmteam == "spectator")
	{
		end
	}

	if(level.run["spawn-protection"]!="1"){end}


	local.team = waitexec global/settings.scr::getcmd  "spawn-team" //returns command parameter two

	if(local.team != "both")
	{
		if(self.dmteam != local.team)
		{
			end
		}
	}

	local.print = waitexec global/settings.scr::getcmd "print-sp"

	if(local.print == "1")
	{
		self stufftext "locationprint 500 60 Spawn-Protect-On 1"	
	}

	local.time = waitexec global/settings.scr::getcmd "invulnerabletime"

	local.time = int local.time

	local.lightn = waitexec global/settings.scr::getcmd  "spawn-light" //returns command parameter two

	if(local.lightn=="1")
	{
		local.lightcolour = waitexec global/settings.scr::getcmd  "spawn-lightcolour" //returns command parameter two

		local.wordcount = 0

		for(local.i=0;local.i<=local.lightcolour.size - 1;local.i++)
		{	
			if(local.lightcolour[local.i]!=" ")
			{
				if(local.light[local.wordcount]==NIL)
				{
					local.light[local.wordcount]=""
				}

				local.light[local.wordcount] += local.lightcolour[local.i]
			}
			else
			{	
				local.wordcount++
			}
		}	

		self light local.light[0] local.light[1] local.light[2] local.light[3] 
	}


	self nodamage
	for(local.i = 0; local.i <= local.time	; local.i = local.i + .1)
	{
		wait .1
		
		if(self == NULL || self.fireheld == 1 || self.dmteam == "spectator")
		{
			break
		}
		
	}

	if (self == NULL)
		end
		
	if(local.print == "1")
	{
		self stufftext "locationprint 500 50 Spawn-Protect-Off 1"	
	}

	self takedamage
	self light 0 0 0 0 
end
```

# zz_admin-Pro_1.22_modif\global\ac\spec_eye.scr

```scr
// edited version of phils spec eye



main:

	if(level.run["spec-eye"] == "1")
	{
		thread SPEC_EYE_ON
	}
	else
	{

		thread SPEC_EYE_OFF
	}
end

SPEC_EYE_ON:

         setcvar "g_spectatefollow_forward" "40"
         setcvar "g_spectatefollow_pitch" "-2"
         setcvar "g_spectatefollow_right" "3"
         setcvar "g_spectatefollow_up" "2"
end

SPEC_EYE_OFF:

         setcvar "g_spectatefollow_forward" "-56"
         setcvar "g_spectatefollow_right" "0"
         setcvar "g_spectatefollow_pitch" "2"
         setcvar "g_spectatefollow_up" "24"
end
```

# zz_admin-Pro_1.22_modif\global\ac\team_balance.scr

```scr
// 22 November 2005 17:31:00 removed the team count code and added it to nagle.scr

main:

	if(level.run["team-balance"]!="1"){end}

	//local.is_teams = getcvar "g_gametype"
	
	//if(local.is_teams == "1")
	//{
	//	end //no ppint in running on a ffa match
	//}

	while(level.run["team-balance"]=="1")
	{
		local.scantime = waitexec global/settings.scr::getcmd "scan-wait"
		wait local.scantime

		if($player.size > 1 )
		{
			local.team = waitexec global/nagle.scr::team_count

			if(local.team[allies] !=  local.team[axis] ) 
			{
				if(local.team[allies] - local.team[axis] > 1 || local.team[allies] - local.team[axis] < -1) //if they are more then 1 ahead then u can equal out
				{
					if(local.team[allies] > local.team[axis])
					{
						local.menneske = waitthread pick_random_player "allies" 
						local.menneske waitthread swap_team
					}
					else
					{
						local.menneske = waitthread pick_random_player "axis" 
						local.menneske waitthread swap_team
					}
				}
			}
		}
	}
end


pick_random_player local.team:

	local.nummer = $player.size

	local.er = 0	//didnt get player

	while(local.er == 0)
	{		
		local.kanskje = randomint( local.nummer )  + 1

		//find a dead player to swap
		if($player[local.kanskje].dmteam == local.team && !(isalive $player[local.kanskje]))
		{
			local.er = 1
			end $player[local.kanskje]
		}
		
		wait 1
	}
end

	
swap_team:
	local.team = self.dmteam
	self auto_join_team	//use anyway. 
	wait 1
	if (self.dmteam != local.team)
	{
		self iprint "You were randomly picked to swap teams to even them out" 1
	}
end
	

```

# zz_admin-Pro_1.22_modif\global\ac\time_alive_count.scr

```scr

main:

	if(level.run["time-alive"] =="1")
	{
		local.time[seconds] = 0
		local.time[minutes] = 0
		local.time[hours] = 0

		local.team = self.dmteam

		while(isalive self && self.dmteam == local.team ) //&& self.forcespawn != 1 ) 
		{
			
//			for(local.wait = 0;local.wait <= 1;local.wait += 0.05)
//			{
//				waitframe
//				if(self.forcespawn == 1 ) 
//				{
//					break
//				}
//			}


			wait 1

			local.time[seconds]++

			if(self==NULL || self == NIL ||  self.dmteam == spectator )
			{
				end	
			}

			if(local.time[seconds]==60)
			{
				local.time[minutes]++
				local.time[seconds] = 0
			}

			if(local.time[minutes]==60)
			{
				local.time[hours]++
				local.time[minutes] = 0
			}
		}
	
		local.timestr[1] = "seconds"
		local.timestr[2] = "minutes"
		local.timestr[3] = "hours"
		
		local.time_total = ""

		if(game.time_alive_type == 1)
		{
			for(local.i = 1; local.i <= local.timestr.size; local.i++)
			{
				local.yey = local.timestr[local.i]

				local.time[local.yey] = string local.time[local.yey]
				
				if(local.time[local.timestr[local.i]].size < 2)
				{
					local.time[local.timestr[local.i]] = ("0" + local.time[local.timestr[local.i]])
				}
			}
				
				
			local.time_total = ( local.time[hours] + ":" + local.time[minutes] + ":" + local.time[seconds] )
		}
		else
		{
			if(local.time[hours] != 0)
			{
				if(local.time[hours] > 1)
				{
					local.time_total =  local.time_total + (local.time[hours] + " hours ")
				}
				else
				{
					local.time_total =  local.time_total + (local.time[hours] + " hour ")
				}	
			}

			if(local.time[minutes] != 0)
			{
				if(local.time[minutes] > 1)
				{
					local.time_total =  local.time_total + (local.time[minutes] + " minutes ")
				}
				else
				{
					local.time_total =  local.time_total + (local.time[minutes] + " minute ")
				}			
			}
			
			if(local.time[seconds] != 0)
			{
				local.time_total =  local.time_total + (local.time[seconds] + " seconds ")	
			}
		}
			
		self iprint ("Time alive: " + local.time_total ) 1
	}

end
```

# zz_admin-Pro_1.22_modif\global\ac\track_admins.scr

```scr

main:

	local.adminslot = NULL

	for(local.i = 0;local.i <= level.admins.size; local.i++)
	{
		if(self == level.admins[local.i])
		{
			local.adminslot = local.i
		}
	}

	while(self != NULL || self != NIL)
	{
		wait 5
	}

	level.admins[local.adminslot] = NIL


	for(local.i = 0;local.i <= level.admins.size; local.i++)
	{
		if(level.admins[local.i] != NULL)
		{
			level.admins[local.i] stufftext ("globalwidgetcommand Admins_list deleteallitems")
			level.admins[local.i] stufftext ("globalwidgetcommand Admins_list additem Admin_"  + level.admins[local.i].entnum)
		}
	}

end
```

# zz_admin-Pro_1.22_modif\global\ac\types.scr

```scr
// Anti camper script by Elgan Sayer
// 
// version 1.00
//
// Questions should go to www.mods-r-us.net forums or elgan.sayer@gmail.com
//
// feel free to pass or tamper with this mod as its for u!
// 
// www.mods-r-us.net
//
//
// **************************************************************************************************************************************






// -------------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------------------------------
// ********************************************************************************************************************************************************************************************************************************************************************


main local.duration local.thread local.camping:
	
	if(local.camping==1)
	{
		if(self.camps==NIL)
		{
			self.camps=0
		}

		self.camps++ 

		local.max =  waitexec global/settings.scr::getcmd "maxcamps" // get index 2 
		local.maxthread =  waitexec global/settings.scr::getcmd "maxcamps" 4 // get index 4 
		
		local.max = int local.max

		if(self.camps==local.max) // if playr has reached max camps
		{
			self exec local.maxthread	// run the punishment script
			self.camps=0 //reset the max camps for this player
			end	//end player is punished
		}
	}
	
	if(local.duration == NIL)
	{
		local.duration   = waitexec global/settings.scr::getcmd  "duration" //returns command parameter two
	}

	self waitthread getwhile local.duration local.camping //get the settings
	

	if(local.thread == NIL)
	{
		local.camper_type = waitexec global/settings.scr::getcmd "type" 
		for(local.t=1;local.t<=game.types.size;local.t++)
		{
			if(local.camper_type == game.types[local.t] [1])
			{
				local.thread_type = game.types[local.t] [2]
				self exec local.thread_type 
				end
			}
				
		}
	}
	else
	{
		for(local.t=1;local.t<=game.types.size;local.t++)
		{
			if(local.thread  == game.types[local.t] [1])
			{
				local.thread = game.types[local.t] [2]
				self exec local.thread 
				end
			}
		}	
	
		for(local.i=0;local.i <= local.thread.size;local.i++)
		{
			for(local.t=1;local.t<=game.types.size;local.t++)
			{	
				if(local.thread[local.i]  == game.types[local.t] [1])
				{
					local.thread_path = game.types[local.t] [2]
					self exec local.thread_path
				}
			}	
		}					
	}

end


getwhile local.duration  local.camping:

	self.end_type = 0	

	if( local.camping == 0 && local.duration == "spot") //dont kill guy and dont have a radius
	{
		self thread global/anti_camper.scr::getradius //has no radius check and needs one to suit settings so make one.
	}

	self thread duration local.duration	
end 


duration local.duration:
	
	local.time = 0
	while(self.dmteam != "spectator" && self != NIL && self != NULL )
	{
		wait 1
		local.time++

		if!(isalive self) 
		{
			if(local.duration=="death" || local.duration=="spot" )
			{
				self.end_type = 1
				end
			}
		}
		else if(self.in_radius==0 && local.duration=="spot")
		{
			self.end_type = 1
			end
		}
		else if(local.time >= (int  local.duration) && local.duration!="death" && local.duration!="spot")
		{
			self.end_type = 1
			end
		}
		
	}
	self.end_type = 1

end

// ********************************************************************************************************************************************************************************************************************************************************************
// -------------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------------------------------




bomb:

	local.bomb_mdl = waitexec global/settings.scr::getcmd  "bomb-mdl"  // get the bomb model

	local.player = self
	local.mine = spawn script_model 
	local.mine model local.bomb_mdl 
	local.mine.origin = ( local.player gettagposition "Bip01 R Forearm")//local.player.origin//
	local.mine notsolid

	local.mine attach local.player "Bip01 R Forearm" 
	
	local.silent = waitexec global/settings.scr::getcmd  "silent"  //returns command parameter two
	local.ticktime = waitexec global/settings.scr::getcmd  "ticktime"  //returns command parameter two
	
	local.ticktime = int local.ticktime

	local.player stopwatch local.ticktime
	

	if(local.silent=="0" && local.ticktime > 5)
	{	
		self loopsound camper_bombtick 
	}
	
	if(local.ticktime==5 && local.silent!="1")
	{
		self loopsound camper_final_countdown 
	}


	while(local.player.dmteam!= "spectator" && local.player != NIL)
	{
		wait 1
		local.ticktime--

		if(local.ticktime==5  && local.silent!="1" )
		{
			self stoploopsound camper_bombtick 
			self loopsound camper_final_countdown 
		}
		else if(local.ticktime==0)
		{
			break
		}

		//if(self.end_type==1)
		//{
		//	break
		//}


		if(self.end_type==1)
		{
			self stoploopsound camper_bombtick 
			self stoploopsound camper_final_countdown 
			local.player stopwatch 0
			local.mine remove
			end
		}
	}

	self stoploopsound camper_bombtick 
	self stoploopsound camper_final_countdown 

	local.player stopwatch 0
	
	local.bomb_exp_mdl2 = waitexec global/settings.scr::getcmd  "bomb-exp-mdl2"  // get the exp bomb model
	local.bomb_exp_mdl = waitexec global/settings.scr::getcmd  "bomb-exp-mdl"  // get the exp bomb model

	local.Exp1 = spawn local.bomb_exp_mdl
	local.Exp2 = spawn local.bomb_exp_mdl2
	local.Exp1 notsolid
	local.mine remove

	local.Exp1.origin = local.mine.origin
	local.Exp1 anim start
	local.Exp2.origin = local.mine.origin
	local.Exp2 anim start

	local.player hurt 100

	wait 1

	local.Exp1 remove
	local.Exp2 remove	 						
	
end


fire:



	local.player = self // The player is the self object

	local.fire_mdl  = waitexec global/settings.scr::getcmd  "fire-mdl" 

	local.fire = spawn script_model 
	local.fire model local.fire_mdl
	local.fire.origin = local.player.origin
	local.fire notsolid

	local.fire glue local.player
	
	local.hurt  = waitexec global/settings.scr::getcmd  "hurt" //returns command parameter two
	local.hurt_delay  = waitexec global/settings.scr::getcmd  "hurt-delay" //returns command parameter two
	
	local.hurt = int local.hurt //make it a number
	local.hurt_delay = int local.hurt_delay //make it a number
	
	while(local.player.end_type==0)
	{
		local.player playsound fire_large
		local.player hurt local.hurt
		wait local.hurt_delay
	}


	local.fire remove
end
		
light:



	local.player = self // The player is the self object
	
	local.lightcolour = waitexec global/settings.scr::getcmd  "lightcolour" //returns command parameter two

	
	local.wordcount = 0

	for(local.i=0;local.i<=local.lightcolour.size - 1;local.i++)
	{	

		if(local.lightcolour[local.i]!=" ")
		{
			if(local.light[local.wordcount]==NIL)
			{
				local.light[local.wordcount]=""
			}

			local.light[local.wordcount] += local.lightcolour[local.i]
		}
		else
		{	
			local.wordcount++
		}
	}	

	local.player light local.light[0] local.light[1] local.light[2] local.light[3] 

	while(local.player.end_type==0)
	{
		waitframe
	}

	local.player light 0 0 0 0
end


bleed:



	local.player = self // The player is the self object
	
	local.hurt  = waitexec global/settings.scr::getcmd  "hurt" //returns command parameter two
	local.hurt_delay  = waitexec global/settings.scr::getcmd  "hurt-delay" 2 //returns command parameter two
	
	local.hurt = int local.hurt //make it a number
	local.hurt_delay = int local.hurt_delay //make it a number

	while(local.player.end_type==0)
	{
		local.player hurt local.hurt
		wait local.hurt_delay
	}


end
		
	


scale:

	// this does not  use perfect bounding box.



	local.player = self // The player is the self object
	
	local.scalesize  = waitexec global/settings.scr::getcmd  "scalesize" //returns command parameter two
	local.scalesize = int local.scalesize //make it a number

	local.player.scale = local.scalesize

	while(local.player.end_type==0)
	{
		waitframe
	}

	
	local.player.scale = 1
end 	

takeall: //will take away players weapon constantly deonding on duration setting



	local.player = self // The player is the self object
	
	while(local.player.end_type==0)
	{
		local.player takeall
		waitframe
	}


end 	

	

viewtwist: //will take away players weapon constantly deonding on duration setting



	local.player = self // The player is the self object
	
	while(local.player.end_type==0)
	{
		local.viewsize = 100
		local.view = 1
		for(local.anglez =0;local.anglez <=360;local.anglez +=.5)
		{
			local.viewsize = randomint(100) + 1
		
			if(local.viewsize<30)
			{
				local.viewsize = 30
			}

			waitframe
			local.player.viewangles += ( 0 0 local.anglez )
			local.player stufftext ("viewsize " + local.viewsize )

			if(local.player.end_type==1)
			{
				local.player.viewangles = ( 0 0 0 )
				local.player stufftext ("viewsize " + 100 )
				end
			}
		}
		waitframe
	}

	local.player.viewangles = ( 0 0 0 )
	local.player stufftext ("viewsize " + 100 )

end 	
	

tent:

	local.tent_mdl = waitexec global/settings.scr::getcmd  "tent-mdl"  // get the tent model



	local.player = self // The player is the self object

	local.tent = spawn script_model 
	local.tent model local.tent_mdl
	local.tent.origin = local.player.origin
	local.tent notsolid
	local.tent.scale = .5

	local.tent glue local.player
	local.player hide

	
	while(local.player.end_type==0)
	{
		waitframe

		local.player holster //dont let them use the gun
	}

	local.tent remove
	local.player show

end



random:

	local.num = randomint( 1 + game.types.size )

	local.thread = game.types[local.num] [2]
	self exec local.thread 
end

tele:
	
	local.spot  = waitexec global/settings.scr::getcmd  "tele-spot" 
	self tele local.spot
end



spin:

	local.player = self


	local.speed = waitexec global/settings.scr::getcmd  "spin-speed"  // get the speed

	local.speed = int local.speed 

	while(local.player.end_type==0)
	{
		waitframe
		local.player turnupdate local.speed 1
	}

end


plyometrics:

	local.player = self


	local.omg = spawn script_origin
	local.omg.origin = local.player.origin
	local.omg solid

	local.player notsolid
	local.omg physics_on	

	local.player glue local.omg 

	local.start = local.player.origin + local.player.forwardvector * 100
	local.start += ( 0 0 200 )

	local.fwd_vec = angles_toforward local.player.viewangles
	local.hit_location =  local.start - local.fwd_vec 

	local.dest = trace (local.start + local.fwd_vec * 64) (local.start + local.fwd_vec * 150) 1
	local.vect = (local.dest - local.player.origin)
	local.vect = vector_normalize (local.vect)

	local.dist = vector_length (local.player.origin - local.dest)
			
	local.vect[0] = local.vect[0] * (local.dist / 1)
	local.vect[1] = local.vect[1] * (local.dist / 1)
	local.vect[2] = local.vect[2] * local.dist

	local.vect[0] = local.vect[0] * 4
	local.vect[1] = local.vect[1] * 4

	local.vect[2] = local.vect[2] + 800


	//local.vect[0] = local.vect[0] * 100
	//local.vect[1] = local.vect[1] * 100
//
	//local.vect[2] = local.vect[2] * 100

	local.omg.angles = local.player.angles
	local.omg.velocity = local.vect
	local.player.velocity = local.vect
	
	local.damage = self.health
	local.damage --


	local.damage = int local.damage
	local.player takedamage
	local.player damage local.player local.damage local.player local.player.origin local.player.forwardvector (0 0 0) 10 1 18 -1

	while(local.player.end_type==0)
	{
		waitframe
		local.player.viewangles = local.omg.angles
		local.omg.angles += ( 10 0 00 )

		if (local.player.origin == local.last || !isalive local.player)
		{
			self.end_type = 1 //if the player is stuck exit the type.
		}

		local.last = local.player.origin

	}

	local.omg remove

end


corona:

	local.player = self

	local.corona = spawn script_model
	local.corona model "models/fx/corona_red.tik"
	local.corona.origin = self.origin + ( 0 0 100 )
	local.corona notsolid
	local.corona scale 2.5

	while(local.player.end_type==0)
	{
		waitframe
		local.corona.origin = self.origin + ( 0 0 100 )
	}
		
	local.corona remove
end


```

# zz_admin-Pro_1.22_modif\global\ambient.scr

```scr
main local.music:
	if (getcvar "modematch" != "1")
	{
		// from breakthrough
		if(level.loaded_settings !=1)
		{
			level.loaded_settings=1
			waitexec global/settings.scr

			if(level.run["camper"]=="1")
			{
				exec global/libmef/mapdesc.scr::setup_map level.map_shortname

				level.camps[allies] = 0
				level.camps[axis] = 0

			}
		}

			// set our gametype
		// done in settings file
		//	level.gametype = int( getcvar( g_gametype ) )

		if(level.gametype == 0)
		{
			exec global/savenames.scr
		}
	}
	else
	{
		exec global/savenames.scr
	}

	level waittill spawn

	if (getcvar "modematch" != "1")
	{
		//Admin-Pro stuff
		exec global/mod_inform.scr
		exec global/ac/cvarscheck.scr
		//Admin-Pro stuff

		if ( level.ambient_script_run == 1 )
		{
			end
		}
	}

	if ( local.music != NIL )
	{
		if ( level.music == NIL )
		{
			level.music = local.music
		}
	}

	if ( level.music != NIL )
	{
		local.string = ("music/" + level.music + ".mus")
		soundtrack local.string
		println ("playing " + local.string)
		forcemusic normal normal
	}

	level.gamma = 1
	level.hazerange = 0
	level.newhazerange = 0
	level.haze = 0
	if (level.gammacap == NIL)
	level.gammacap = 0
	level.farplanerate = 0.015
	


	println "Loading Ambient.scr"

	if ($interior == NULL)
		level.interiors = 0
		else
		level.interiors = $interior.size

	if (level.interiors > 0)
	{
		level.interior = exec global/makearray.scr $interior

		for (local.i=1;local.i<level.interiors+1;local.i++)
		{
			level.interior[local.i] thread interior

			if (level.interior[local.i].set == NIL)
			{
				println ("Warning, interior at " + level.interior[local.i].origin + " has no #set")
				level.interior[local.i].set = 1
			}
				else
				println ("Spawned interior " + local.i)

			if (level.interior[local.i].haze == NIL)
				level.interior[local.i].haze = -1

		}
	}

	if ($exterior == NULL)
		level.exteriors = 0
		else
		level.exteriors = $exterior.size

	if (level.exteriors > 0)
	{
		level.exterior = exec global/makearray.scr $exterior

		for (local.i=1;local.i<level.exteriors+1;local.i++)
		{
			level.exterior[local.i] thread exterior

			if (level.exterior[local.i].set == NIL)
			{
				println ("Warning, exterior at " + level.exterior[local.i].origin + " has no #set")
				level.exterior[local.i].set = 1
			}
				else
				println ("Spawned exterior " + local.i)

			if (level.exterior[local.i].haze == NIL)
				level.exterior[local.i].haze = -1

		}
			
//		thread lightlevel
		thread musiclevel
	}

//	thread exec global/door_locked.scr::lock


	exec global/ambience.scr
	level.ambient_script_run = 1
end

interior:

	if (getcvar(notrigger) == "1")
	{
		wait 4
		self delete
		end
	}

	while (1)
	{
		self waittill trigger

		/*
		if (self.set == 1)
			forcemusic aux2 aux2
		else
		if (self.set == 2)
			forcemusic aux4 aux4
		else
		if (self.set == 3)
			forcemusic aux6 aux6
		*/

		/*
		if (self.haze != -1)
			level.newhazerange = self.haze
		else
			level.newhazerange = level.gammacap

		level.haze = 1
		*/

		level.current_music = ("int" + self.set)
//		while ($player istouching self)
//			waitframe

	}
	
end



exterior:
	if (getcvar(notrigger) == "1")
	{
		wait 4
		self delete
		end
	}

	while (1)
	{
		self waittill trigger

		/*
		if (self.set == 1)
			forcemusic aux1 aux1
		else
		if (self.set == 2)
			forcemusic aux3 aux3
		else
		if (self.set == 3)
			forcemusic aux5 aux5
		*/

		/*
		if (self.haze != -1)
			level.newhazerange = self.haze
		else
			level.newhazerange = level.gammacap

		level.haze = -1
		*/
		
		level.current_music = ("ext" + self.set)
//		while ($player istouching self)
//			waitframe

	}


end

musiclevel:
//	level waittill spawn

	local.lastmusic = -1
	level.current_music = -1
	while (1)
	{
		if (level.current_music != local.lastmusic)
		{
			local.break = 0
			local.current_music = level.current_music

			for (local.i=0;local.i<6;local.i++)
			{
				if (level.current_music == local.lastmusic)
					local.break = 1	

				waitframe
			}
		
			if (local.break == 0)
			if (level.current_music != local.lastmusic)
			{
				
				if (level.current_music == "ext1")
					forcemusic aux1 aux1
				else
				if (level.current_music == "ext2")
					forcemusic aux3 aux3
				else
				if (level.current_music == "ext3")
					forcemusic aux5 aux5
				else
				if (level.current_music == "int1")
					forcemusic aux2 aux2
				else
				if (level.current_music == "int2")
					forcemusic aux4 aux4
				else
				if (level.current_music == "int3")
					forcemusic aux6 aux6

				println ("forced music " + level.current_music)
				local.lastmusic = local.current_music
			}
		}

		wait 0.1
	}
end


lightlevel:
	level waittill spawn
	while (1==1)
	{
		if ((level.haze == 1) && (level.hazerange < level.newhazerange))
		{
			level.hazerange = level.hazerange + level.farplanerate
			if (level.hazerange > level.newhazerange)
			{
				level.hazerange = level.newhazerange
				level.haze = 0
			}
		}
		else
		if ((level.haze == -1) && (level.hazerange > 0))
		{
			level.hazerange = level.hazerange - level.farplanerate

			if (level.hazerange < 0.1)
			{
				level.hazerange = 0
				level.haze = 0
			}
		}
		
		if (level.hazerange > level.newhazerange)
			level.hazerange = level.newhazerange
			else
		if (level.hazerange < 0)
			level.hazerange = 0
		
//		println ("hazerange is " + level.hazerange)

//		local.farplanecolor = level.farplanecolor + ( level.hazerange level.hazerange level.hazerange )
//		$world farplane_color local.farplanecolor
//		setcvar r_farplane_color local.farplanecolor
//		local.gamma = level.gamma + level.hazerange
		setcvar r_gammabias (level.hazerange + 1)

		waitframe
	}
	

end



lighten:
	while ((level.haze == 1) && (level.hazerange < level.farplanerange))
	{
		local.farplanecolor = level.farplanecolor + ( level.hazerange level.hazerange level.hazerange )
		$world farplane_color local.farplanecolor
		setcvar r_farplane_color local.farplanecolor
		level.hazerange = level.hazerange + level.farplanerate
		wait 0.1
	}
		level.hazerange = 0.3
		local.farplanecolor = level.farplanecolor + ( level.hazerange level.hazerange level.hazerange )
		$world farplane_color local.farplanecolor
		setcvar r_farplane_color local.farplanecolor

		level.haze = 0
end

darken:
	while ((level.haze == -1) && (level.hazerange > 0.0))
	{
		local.farplanecolor = level.farplanecolor + ( level.hazerange level.hazerange level.hazerange )
		$world farplane_color local.farplanecolor
		setcvar r_farplane_color local.farplanecolor
		level.hazerange = level.hazerange - level.farplanerate
		wait 0.1
	}
		level.hazerange = 0
		local.farplanecolor = level.farplanecolor + ( level.hazerange level.hazerange level.hazerange )
		$world farplane_color local.farplanecolor
		setcvar r_farplane_color local.farplanecolor

		level.haze = 0

end

```

# zz_admin-Pro_1.22_modif\global\anti_camper.scr

```scr
// Anti camper script by Elgan Sayer
// Anti camper SFX camper script
// version 1.01
//
// Questions should go to www.mods-r-us.net forums or elgan.sayer@gmail.com
//
// feel free to pass or tamper with this mod as its for u!
// 
// www.mods-r-us.net
//
// I have decided not to comment the code because you do not need to play with it. only settings files need to be altered.
//
// **************************************************************************************************************************************


main:
	if(self ==  NULL || self == NIL)																// If the player has vanished
	{
		end																	// end the script
	}

	//check if camper mod is on
	if(level.run["camper"]!="1")
	{
		//uh oh not laoded:(
		if(level.loaded_settings !=1)
		{
			level.loaded_settings=1
			// Something whent horribly wrong with loading ambient.scr, SO load the settings again
			println "ERROR: Admin-Pro Is being loaded incorrectly"
			exec global/ac/console_feedback.scr "Admin-Pro Is being loaded incorrectly - Please fix" 1

			waitexec global/settings.scr
			
			// load the cvar handling stuff
			exec global/ac/cvarscheck.scr
			
			//Check the mod is on 
			if(level.run["camper"]=="1")
			{
				exec global/libmef/mapdesc.scr::setup_map level.map_shortname

				level.camps[allies] = 0
				level.camps[axis] = 0
				
//				if(local.counter == "1")
//				{
//					thread hud 1
//				}

			}

			exec global/mod_inform.scr
//			else
//			{
////				thread hud 0
//			}

			//everything is wrong, This means the spawn detection would be too slow. So activate the spawn detection for players
			
//			for(local.i= 1;local.i <= $player.size; local.i++)
//			{
//				for(local.o = 1; local.o <= level.spawn_scripts.size; local.o++)
//				{
//					if($player[local.i].dmteam != "spectator")
//					{
//					//iprintln  level.spawn_scripts[local.i][1]
//						$player[local.i] exec level.spawn_scripts[local.o][1]
//					}
//				}
//			}
		}
		end 
	}
//	else
//	{
////		if(game.informed==1)
////		{
////			game.informed=0 //sets so this so it will run if(game.informed!=1) and not this 	
////			iprintln_noloc  "Camper Mod On"//the mod is on again
////			
////			local.counter = waitexec global/settings.scr::getcmd "counter"
////
////			if(local.counter == "1")
////			{
////				thread hud 1
////			}
////		}
//	}


	if(level.gametype == 0)
	{
		level.run["camper"] = 0
		end
	}

	//if checking camping already or spec end

	if(self.campinfcheck==1 || self.dmteam=="spectator" || self.mef_spectator == 1)
	{
		end
	}

	//check if the player is in a jail for lib mode
	if(self.injail == 1 || self.locked == 1 )
	{
		self.campinfcheck=0
		end
	}	

	//if player is dead end
	if!(isalive self)
	{
		end
	}	


	local.camper_time = waitexec global/settings.scr::getcmd "time"

	//reset if camper settings are Not there.
	if(local.camper_time==NIL)
	{
		level.run["camper"] = 0
		exec global/ac/console_feedback.scr ("Settings for anti camper are missing, mod being turned off") 1		
		end
	}

	//end if they are using turret
	local.turret_camp = waitexec global/settings.scr::getcmd "turret-camp"

	if(local.turret_camp == "1")
	{
		if(self.using_turret == 1)
		{
			end
		}
	}

	self.campinfcheck=1

	local.camper_message = waitexec global/settings.scr::getcmd "message"
	local.camper_radius = waitexec global/settings.scr::getcmd "radius"
	local.camper_saysound = waitexec global/settings.scr::getcmd "saysound"

	//get users weapons check settings
	local.weapons_check =  waitexec global/settings.scr::getcmd "weaponscheck" 

	//if user wants to check weapons then do so
	if(local.weapons_check=="1")
	{
		local.camper_time =  waitthread check_weapon self
	}

	//if time is not there find it!
	if(local.camper_time==NIL)
	{
		local.camper_time =  waitexec global/settings.scr::getcmd  "time"
	}

	//turn into #
	local.camper_time = int local.camper_time

	//if there is no time then end
	if(local.camper_time==0)
	{
		self.campinfcheck=0
		end
	}

	//the players origin
	local.origin = self.origin
	// work out the camping area
	local.inradius =  vector_within local.origin self.origin local.camper_radius
	
  	local.camped_for=1

	self.in_radius=1

	local.camped=0

	//turn camper raduis into a number
	local.camper_radius = int local.camper_radius

	while(local.inradius && isalive self)
	{
		wait 1

		//if(level.run["camper"]!="1")
		//{
		//	end
		//	self.campinfcheck=0
		//}

		if(self==NIL || self == NULL)
		{
			end
		}

		if(self.dmteam == "spectator")
		{
			self.in_radius=0
			self.campinfcheck=0
			end
		}

		local.inradius =  vector_within local.origin self.origin local.camper_radius   
		if(local.camped==0)
		{	
			if(local.camped_for==local.camper_time)
			{
				if(local.counter == "1")
				{
					level.camps[self.dmteam] ++
					thread hud 1
				}

				if(local.camper_message!="")
				{
					self iprint local.camper_message
				}
	
				if(local.camper_saysound=="1")
				{
					self stoploopsound
					self playsound streamed_dfr_scripted_M3L1_016a 
				}

				local.say_pos = waitexec global/settings.scr::getcmd   "say-pos"

				if(level.map_enabled == 1)
				{
					if(local.say_pos == "1")
					{
						local.pos = waitexec global/libmef/mapdesc.scr::get_player_position self.origin
	
						if(local.pos != "" || local.pos != NULL || local.pos != NIL)
						{
							if(game.game == "BT")
							{
								local.pos = (self.netname + " " + "is camping: " + local.pos)
							}
							else
							{
								local.pos =  ("A Camper has been detected: " + local.pos)
							}
						
							iprintlnbold_noloc local.pos
						}
					}
				}

				local.type = waitexec global/settings.scr::getcmd "type" 
				local.duration = waitexec global/settings.scr::getcmd "duration"
				local.camped=1

				local.wordsarray = waitexec global/strings.scr::split_line local.type 1
				
				if(local.wordsarray[2] > 1)
				{
					local.words = local.wordsarray[1]

					for(local.w = 0;local.w <= local.words.size; local.w++)
					{
						for(local.ts = 1; local.ts<=game.types.size;local.ts++)
						{
							if(local.words[local.w] == game.types[local.ts][1])
							{
								local.types[local.w] = local.words[local.w]
							}
						}
					}

					local.type = local.types	
				}

				self exec global/ac/types.scr local.duration local.type 1

				local.counter = waitexec global/settings.scr::getcmd "counter"

				if(local.counter == "1")
				{
					thread hud 1
				}

			}
			local.camped_for++
		}
	}

	self.in_radius=0
	
	self.campinfcheck=0

end


check_weapon local.player:

	if(local.player.dmteam=="spectator" || local.player == NIL || local.player == NULL)
	{
		end
	}

	if(game.loaded_weapons==NIL)
	{
		waitthread load_weapons 
	}

	self.weapon = NIL	

	//self forcetorsostate GET_WEAPON
	
	self waitexec global/get_weapon.scr

	local.true = 1
	for(local.true =0;local.true <= 1; local.true++)
	{
		wait 1
		if(self.weapon==NIL)
		{
			while(self.weapon==NIL)
			{
				if(self == NULL || self == NIL)
				{
					end
				}
				waitframe
			}
		}

		if(self.weapon != "models/weapons/unarmed.tik")
		{
			local.true = 2
		}

		waitexec global/get_weapon.scr

	}
	
	for(local.load=game.weapons_start;local.load<=game.all_commands.size;local.load++)
	{
		if(self.weapon == ("models/weapons/" + game.all_commands[local.load][1] + ".tik"))
		{
			local.camper_time = game.all_commands[local.load] [2]
			local.camper_time = int local.camper_time
			end local.camper_time
		}
	}

end local.camper_time

load_weapons:

	switch(game.game)
	{
	case "AA":
		game.loaded_weapons =  waitexec game.file["camper"]::weaponsaa
	break
	case "SH":
		game.loaded_weapons =  waitexec game.file["camper"]::weaponssh
	break
	case "BT":
		game.loaded_weapons =  waitexec game.file["camper"]::weaponsbt
	break
	}

	game.weapons_start= game.all_commands.size

	exec global/settings.scr::add_cmds game.loaded_weapons
end


// There is no radius so make one for the player ( console commands )
getradius:

	local.origin = self.origin
	local.camper_radius = waitexec global/settings.scr::getcmd  "radius"

	local.camper_radius = int local.camper_radius

	local.inradius =  vector_within local.origin self.origin local.camper_radius  

	self.in_radius=1

	while(local.inradius)
	{
		local.inradius =  vector_within local.origin self.origin local.camper_radius  
		waitframe
	}

	self.in_radius=0
end


hud local.alpha:

	
	huddraw_alpha 5 1
	huddraw_shader 5 "textures/mohmenu/black.tga"

	if (local.alpha == 1)
	{
		huddraw_alpha 5 .45
	}
	else
	{
		huddraw_alpha 5 0
	}

	huddraw_rect 5 -105 53 100 73
	huddraw_align 5 right top

	huddraw_align 4 right top
	huddraw_font 4 facfont-20
	huddraw_rect 4 -100 55 100 100
	huddraw_color 4 1 1 0
	huddraw_alpha 4 local.alpha
	huddraw_string 4 ("Camp Counter")

	huddraw_align 6 right top
	huddraw_font 6 facfont-20
	huddraw_rect 6 -73 80 100 100
	huddraw_color 6 1 1 1
	huddraw_alpha 6 local.alpha
	huddraw_string 6 ( level.camps[allies])

	huddraw_align 30 right top
	huddraw_font 30 facfont-20
	huddraw_rect 30 -73 100 100 100
	huddraw_color 30 1 1 1
	huddraw_alpha 30 local.alpha
	huddraw_string 30 ( level.camps[axis])

	huddraw_shader 31 ("textures/hud/allies")
	huddraw_align 31 right top
	huddraw_rect 31 -100 73 25 25
	huddraw_color 31 1 1 1
	huddraw_alpha 31 local.alpha

	huddraw_shader 33 ("textures/hud/axis")
	huddraw_align 33 right top
	huddraw_rect 33 -100 98 25 25
	huddraw_color 33 1 1 1
	huddraw_alpha 33 local.alpha

end
```

# zz_admin-Pro_1.22_modif\global\anti_shark.scr ( not used )

```scr ( not used )

if(self.sharkcheck==1)
{
	end
}
else
{
	self.sharkcheck=1
}

local.ladder = self.origin

local.within = 1

while(isalive self && local.within == 1)
{
waitframe
		
	local.radius = 10 // 200.0 * 200.0
	local.isin = vector_within self.origin local.ladder local.radius
	
	if(local.isin!=1)
	{
		local.within = 0
	}


}
	local.movement = ( self getmovement )
	local.position = ( self getposition )
		 
	if(local.movement == "standing" && local.position == "standing")
	{
		local.flags=0
		if(self.velocity[0] > 0 ||  self.velocity[0] < 0)
		{
			local.flags++
		}

		if(self.velocity[1] > 0 ||  self.velocity[1] < 0)
		{
			local.flags++
		}

		if(self.velocity[2] > 0 ||  self.velocity[2] < 0)
		{
			local.flags++
		}

		if(local.flags > 1)
		{
			self iprint "You were killed for attempting sharking" 1
			self stufftext "say I TRIED TO SHARK"
			self kill
		}			
	}

	self.sharkcheck=0
end
			
		
```

# zz_admin-Pro_1.22_modif\global\camper_turret.scr

```scr
main local.using:

	self.using_turret = local.using
end
```

# zz_admin-Pro_1.22_modif\global\check_team_swap.scr

```scr
main local.hva:

	if(local.hva=="end")
	{
		self.tss = 0
		end
	}
	
	local.team = self.dmteam
	self.tss = 1

	while(isalive self && self.tss == 1)
	{
		waitframe
		
		if(self.dmteam != "spectator" && self.dmteam != local.team)
		{
			self usestuff
			self unattachfromladder 
			//self kill
		}
	}
end
		
```

# zz_admin-Pro_1.22_modif\global\doornade\doornade_mk2_p.hal

```hal
//***************************************************************************
//global/doornade/doornade_mk2_p.hal
//Scripting: @(...:.:...)@ / Hal
//
//The main script for the doornade fix. Is executed by 
//state files when a player starts to cook a grenade. The 
//script counts while checking if the player is still holding 
//a grenade. If the player get's past the point when a grenade 
//would explode, and is still alive he get's punished (as he 
//must have held the nade into a door/wall to survive).
//****************************************************************************
main:
	if(game.run_bugnadefix == 0)
	{
		end
	}

	self.iscookingnade = "1"
	for(local.counter = 0;local.counter <= 54;local.counter += 1)
	{
		local.iscookingnade = int(self.iscookingnade)
		if(local.iscookingnade == 0)
		{
			end
		}
		wait .1
	}
	local.iscookingnade = int(self.iscookingnade)
//	if(local.iscookingnade == 1 && isalive self)
//	{
////		iprintlnbold "needs punishing 1"
//	}
//	else if(isalive self)
//	{
////		iprintlnbold "needs punishing 2"
//	}
//	
	if( ! (isalive self) )
	{
		end
	}

	//get settings from bugnade.txt
	exec settings/Bugnade.txt
	waitframe
	//level.bugnaderstufftext = level.bugnadesettings[2][1]
	self stufftext ("say "+(level.bugnadesettings[2][1])+"")
	self kill
	self commanddelay 0 addkills level.bugnadesettings[1][1]
	iprintln level.bugnadesettings[3][1]
	self iprint level.bugnadesettings[4][1]


end





















































//I was going to have the player being slapped to death, but I decided a simple suicide would be best :)
/*
//punishment section.
//tell the client and other players what is going on:
	self stufftext "say I was bugnading*, and will now be slapped to death."
	iprintln "Bugnading = blowing up grenades through walls/doors, to either prevent your own death, or kill people on the other side"
	self stufftext "wait 3000" //- wait 3 seconds. Should be the time it takes the client to die from slapping. About 30 seconds?
	self iprint "You have been caught bugnading. E.G you held a grenade in or through a door/wall untill it blew up."
	self iprint "You have lost 2 kills and will now be bitchslapped to death. Don't try to disconnect, because it won't work :D"
	self forcetorsostate "RELEASE_ATTACK_GRENADE"
	wait .5
	self takeall
	self fullhead
	self immune grenade
	self immune bullet
	self immune fast_bullet
	self immune explosion
	self immune rocket
	self immune grenade
	self immune bullet
	self immune fast_bullet
	self immune explosion
	self immune rocket
	self fullheal

//slap the player
	wait 2
	iprintlnbold "Let the slapping commence O_o"
	wait 1
	local.timesslapped = 0
	while(self.health > 2) //after that he falls to crater :)
	{
		local.timesslapped += 1

	//	lots of random numbers needed :D

		local.forwardmove = randomfloat 200
		local.forwardmove += local.timesslapped

		local.sidemove = randomfloat 200
		local.positivenegative = randomint 1

		if(local.positivenegative != 1)
		{
			//should give negative number :)
			local.sidemove1 = local.sidemove
			local.sidemove -= local.sidemove1
			local.sidemove -= local.sidemove1
			local.sidemove -= local.timesslapped
		}
		else
		{
			local.sidemove += local.timesslapped
		}
		local.jumpxyspeed = randomfloat 200
		
		self hurt 1
		self jumpxy local.forwardmove local.sidemove local.jumpxyspeed
		//add sound for slap hit, and perhaps more pain sound

		wait 0.7
	}
*/
```

# zz_admin-Pro_1.22_modif\global\doornade\doornade_mk2_s.hal

```hal
//***************************************************************************
//global/doornade/doornade_mk2_s.hal
//Scripting: @(...:.:...)@ / Hal
//
//The main script for the doornade fix. Is executed by 
//state files when a player starts to cook a grenade. The 
//script counts while checking if the player is still holding 
//a grenade. If the player get's past the point when a grenade 
//would explode, and is still alive he get's punished (as he 
//must have held the nade into a door/wall to survive).
//****************************************************************************
main:
	if(game.run_bugnadefix == 0)
	{
		end
	}

	self.iscookingnade = "1"
	for(local.counter = 0;local.counter <= 54;local.counter += 1)
	{
		local.iscookingnade = int(self.iscookingnade)
		if(local.iscookingnade == 0)
		{
			end
		}
		wait .1
	}
	local.iscookingnade = int(self.iscookingnade)
	if(local.iscookingnade == 1 && isalive self)
	{
		iprintlnbold "needs punishing 1"
	}
	else if(isalive self)
	{
		iprintlnbold "needs punishing 2"
	}
	else if( ! (isalive self) )
	{
		end
	}

	//get settings from bugnade.txt
	exec settings/Bugnade.txt
	waitframe
	//level.bugnaderstufftext = level.bugnadesettings[2][1]
	self stufftext ("say "+(level.bugnadesettings[2][1])+"")
	self kill
	self commanddelay 0 addkills level.bugnadesettings[1][1]
	iprintln level.bugnadesettings[3][1]
	self iprint level.bugnadesettings[4][1]


end
```

# zz_admin-Pro_1.22_modif\global\doornade\notcookingnade.hal

```hal
//global/doornade/NotCookingNade.hal
//Scripting: @(...:.:...)@ / Hal
//
//sets the player as not cooking a grenade so that the main doornade script can tell if a player is still holding a grenade
main:
//	iprintlnbold "stopped cooking nade"
	self.iscookingnade = "0"
end

//that was easy =)
```

# zz_admin-Pro_1.22_modif\global\get_game.scr

```scr

getgame:
	local.game = getcvar "version"
	local.i=15

	if(local.game[local.i]==" ")
	{
		local.i= 16
	}

	switch(local.game[local.i])
	{
	case "A":
		game.game = "AA"
	break 
	case "S":
		game.game = "SH"
	break
	case "B":
		game.game = "BT"
	break
	}

end local.cmdwant 

```

# zz_admin-Pro_1.22_modif\global\get_weapon.scr

```scr
main:

	self weaponcommand dual targetname ("weapon" + self.entnum)
	local.weapon = $("weapon" + self.entnum )

	if(local.weapon != NULL)
	{
		self.weapon = local.weapon.model
		local.weapon targetname ""
	}
	else
	{
		self.weapon = "models/weapons/unarmed.tik"
	}

end 
```

# zz_admin-Pro_1.22_modif\global\help.scr

```scr


help local.help:

	if(local.help==1)
	{
		exec global/ac/console_feedback.scr "--------------------------------------------------------------------"
		exec global/ac/console_feedback.scr "camper settings"
		exec global/ac/console_feedback.scr "Type the cvar on its own to get its settings"
		exec global/ac/console_feedback.scr "Type the cvar camper_help followed by the a cvar to get information on it"
		exec global/ac/console_feedback.scr "E.g camper_help camper_type"
		exec global/ac/console_feedback.scr "===================="
		exec global/ac/console_feedback.scr "Cvars"
		exec global/ac/console_feedback.scr "-----"
			
		for(local.i=1;local.i<=game.campersettings.size;local.i++)
		{
			exec global/ac/console_feedback.scr game.campersettings[local.i][1]
		}

		exec global/ac/console_feedback.scr "===================="
		exec global/ac/console_feedback.scr "Settings"
		exec global/ac/console_feedback.scr "-------"

		for(local.i=1;local.i<=game.all_commands.size;local.i++)
		{
			exec global/ac/console_feedback.scr game.all_commands[local.i] [1]
		}
		
		exec global/ac/console_feedback.scr "===================="	
	//
	//			local.campersettings = level.game
	//iprintlnbold level.game
	//			exec global/ac/console_feedback.scr "===================="
	//			exec global/ac/console_feedback.scr "  "
	//			exec global/ac/console_feedback.scr "Weapon cmd's"
	//			exec global/ac/console_feedback.scr "-------"
	//
	//			for(local.i=1;local.i<=local.campersettings.size;local.i++)
	//			{
	//				exec global/ac/console_feedback.scr local.campersettings[local.i] [1]
	//			}
	//
		exec global/ac/console_feedback.scr ( game.all_commands.size + " Settings") 1
		exec global/ac/console_feedback.scr "Type the settings on its own to get its settings"
		exec global/ac/console_feedback.scr "Type the cvar admin_cmd help followed by the a command/setting to get information on it"
		exec global/ac/console_feedback.scr "E.g admin_cmd help type"
		exec global/ac/console_feedback.scr "--------------------------------------------------------------------"
	}
	else
	{
		waitthread display_help local.help
	}	
end


display_help local.help:

		for(local.t=1;local.t<=3;local.t++)
		{
			if(local.t==1)
			{
				local.info = game.campersettings
			}
			else if(local.t==2)
			{
				local.info = game.all_commands
			}
			else if(local.t==3)
			{
				local.info = level.game
			}

			local.yes=0
			for(local.campset=1;local.campset <= local.info.size; local.campset++)
			{	
				local.maybe = local.info[local.campset] [1]

				if(local.help.size == local.maybe.size)
				{
					for(local.i=0;local.i<= local.maybe.size - 1 ;local.i++)
					{
						if(local.maybe[local.i] == local.help[local.i])
						{
							local.yes++
						}
					}
					if(local.yes==local.maybe.size)
					{
						waitthread foundword local.maybe
						end
					}
					local.yes=0
				}
			}	
		}
		// dont rmemeber why this is here so // it out.:S
		exec global/ac/console_feedback.scr "* Not found"
		exec global/ac/console_feedback.scr "* Please check you enterd everything correctly"
end



foundword local.word:

	for(local.i=1;local.i<=game.campersettings.size;local.i++)
	{		
		local.set = game.campersettings[local.i] [1]
		if(local.set == local.word)
		{
			exec global/ac/console_feedback.scr game.campersettings[local.i][3]
			exec global/ac/console_feedback.scr ( local.set + " Set to " + game.campersettings[local.i] [2] )	
			end
		}
	}

	for(local.i=1;local.i<=game.all_commands.size;local.i++)
	{
		local.set = game.all_commands[local.i] [1]
		if(local.set == local.word)
		{
			exec global/ac/console_feedback.scr game.all_commands[local.i][3]
			local.eq = game.all_commands[local.i] [2]
			exec global/ac/console_feedback.scr ( local.set + " Set to " + game.all_commands[local.i] [2] )	
			end
		}
	}
		
	switch(game.game)
	{
	case "A":
		local.campersettings =  waitexec game.file["camper"]::weaponsaa
	break 
	case "S":
		local.campersettings =  waitexec game.file["camper"]::weaponssh		
	break
	case "B":
		local.campersettings =  waitexec game.file["camper"]::weaponsbt
	break
	}

	for(local.i=1;local.i<=local.campersettings.size;local.i++)
	{
		local.set = local.campersettings[local.i] [1]
		if(local.set == local.word)
		{
			exec global/ac/console_feedback.scr game.campersettings[local.i][3]
			exec global/ac/console_feedback.scr ( local.set + " is set to " + local.campersettings[local.i] [2] )	
			end
		}
	}

end

```

# zz_admin-Pro_1.22_modif\global\killed.scr

```scr
main local.cvar local.script:

	if(local.script == NIL)
	{
		self stufftext ( "add " + local.cvar + " 1" )

		if(local.cvar == "times_killed")
		{
			if(level.killed_scripts!=NIL)
			{
				for(local.i = 1; local.i <= level.killed_scripts.size ;local.i++)
				{
					self exec level.killed_scripts[local.i]
				}
				
			}
		}
	}
	else
	{
		if(level.killed_scripts==NIL)
		{
			level.killed_scripts[1] = local.cvar
		}
		else
		{
			local.i = level.killed_scripts.size
			local.i++
			level.killed_scripts[local.i] = local.cvar
		}
		end
	}



	//exec skill_balancer/dodeath.scr
end
```

# zz_admin-Pro_1.22_modif\global\libmef\mapdesc.scr

```scr
/*
================================================================================
Map Description Library
for Medal Of Honor
Version 1.1.1 (03/01/05)

Copyright (c) 2003-2005 Mark Follett
email: mef123@geocities.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
================================================================================
*/


get_player_position local.origin:
	if (level.map_enabled)
	{
		end level.map_sectors[(waitthread find_position local.origin level.map_bsp)][1]
	}
end ""


get_player_position_abbr local.origin:
	if (level.map_enabled)
	{
		end level.map_sectors[(waitthread find_position local.origin level.map_bsp)][2]
	}
end ""


// indexing starts at 1!!!
find_position local.point local.bsp:
	local.i = ((level.map_chunksize * (local.bsp.size - 1)) + local.bsp[(local.bsp.size - 1)].pd.size)

	while (1)
	{
		local.chunknum = 0
		while (local.i > level.map_chunksize)
		{
			local.i = local.i - level.map_chunksize
			local.chunknum++
		}

		local.chunk = local.bsp[local.chunknum]

		local.ord = local.chunk.ord[local.i]
		local.pd = local.chunk.pd[local.i]

		if (local.ord < 6)
		{
			if (local.ord > 2)
			{
				local.pd = -local.pd
				local.ord = local.ord - 3
			}

			if (local.point[local.ord] > local.pd)
			{
				local.front = 1
			} else
			{
				local.front = 0
			}
		} else
		{
			local.j = local.ord - 6
			local.nachunknum = 0
			while (local.j > level.map_chunksize)
			{
				local.j = local.j - level.map_chunksize
				local.nachunknum++
			}

			local.nachunk = local.bsp[local.nachunknum]

			if ((vector_dot local.point ( local.nachunk.pa[local.j] local.nachunk.pb[local.j] local.nachunk.pc[local.j] )) >= local.pd)
			{
				local.front = 1
			} else
			{
				local.front = 0
			}
		}

		if (local.front == 1)
		{
			if (local.chunk.frontid[local.i] == 0)
			{
				end local.chunk.frontsec[local.i]
			} else
			{
				local.i = local.chunk.frontid[local.i]
			}
		} else
		{
			if (local.chunk.backid[local.i] == 0)
			{
				end local.chunk.backsec[local.i]
			} else
			{
				local.i = local.chunk.backid[local.i]
			}
		}
	}
end


setup_map local.map:
	level.map_chunksize = 50
	
	switch (local.map)
	{
		case "mohdm1":
		case "mohdm2":
		case "mohdm3":
		case "mohdm4":
		case "mohdm5":
		case "mohdm6":
		case "mohdm7":
		case "obj_team1":
			local.mapname = local.map
			break
			
		case "obj_team4":
			local.mapname = "mohdm4"
			break
			
		default:
			break
	}

	if (local.mapname != NIL)
	{
		waitthread ("setup_bsp_" + local.mapname)
	}

	if (level.map_sectors != NIL && level.map_bsp != NIL)
	{
		level.map_enabled = 1
	}
end 1


setup_bsp_mohdm1:
	level.map_sectors[0] = "Center Sector"::"OC"
	level.map_sectors[1] = "Northeast Bldg"::"NE"
	level.map_sectors[2] = "Southeast Bldg Cellar"::"SEC"
	level.map_sectors[3] = "Southeast Bldg Ground Floor"::"SE0"
	level.map_sectors[4] = "Southeast Bldg First Floor"::"SE1"
	level.map_sectors[5] = "Northeast Sector"::"ONE"
	level.map_sectors[6] = "East Bridge"::"BE"
	level.map_sectors[7] = "Center Bldg Ground Floor"::"C0"
	level.map_sectors[8] = "Center Bldg First Floor"::"C1"
	level.map_sectors[9] = "Northwest Bldg"::"NW"
	level.map_sectors[10] = "Northwest Stone House"::"NWS"
	level.map_sectors[11] = "South Bridge"::"BS"
	level.map_sectors[12] = "South Path"::"PS"
	level.map_sectors[13] = "North Path"::"PN"
	level.map_sectors[14] = "West Sector"::"OW"
	level.map_sectors[15] = "East Sector"::"OE"
	level.map_sectors[16] = "Southeast Sector"::"OSE"
	level.map_sectors[17] = "Northwest Sector"::"ONW"

	level.map_bsp[0] = spawn Listener
	level.map_bsp[0].ord = 1::3::1::3::3::1::3::1::2::2::0::2::0::0::1::1::1::2::0::0::1::1::0::2::0::1::1::1::0::1::0::0::1::2::3::3::3::2::0::1::1::2::0::4::0::2::1::3::0::0
	level.map_bsp[0].pd = 2445::350::1655::545::375::2165::375::1655::384::384::1410::608::1335::1335::2230::2345::1925::384::710::515::2755::2345::950::672::515::2165::2985::1655::1030::1525::255::1455::970::528::545::350::525::384::990::1160::10::384::710::70::930::384::10::580::640::1025
	level.map_bsp[0].frontid = 0::0::2::0::3::1::0::0::6::0::0::11::12::0::0::0::16::0::0::0::0::0::22::23::24::25::20::27::17::29::30::0::0::33::0::0::0::36::34::31::0::0::0::0::0::45::43::0::47::41
	level.map_bsp[0].backid = 0::0::0::0::4::5::0::7::8::0::0::0::10::0::14::15::0::0::18::0::0::0::0::0::21::0::26::19::28::13::9::0::32::0::0::35::0::37::38::39::0::0::42::0::44::0::46::0::48::49
	level.map_bsp[0].frontsec = 12::12::12::11::8::14::7::12::11::8::13::8::13::17::17::9::17::8::13::9::12::9::9::9::14::14::9::13::10::13::13::1::13::1::11::0::0::11::13::8::1::1::1::1::15::1::1::15::1::5
	level.map_bsp[0].backsec = 14::11::8::12::11::12::12::7::12::7::8::13::8::10::10::17::13::7::8::12::14::14::14::14::12::13::14::8::13::8::12::13::1::13::12::11::12::0::0::0::5::15::15::15::1::15::15::16::15::15
	level.map_bsp[1] = spawn Listener
	level.map_bsp[1].ord = 3::1::3::0::3::1::3::1::1::1::3::3::0::3::2::3::1::3::0::3::3::1::3::0::1::3::1::3::3::0::1::2::1::1
	level.map_bsp[1].pd = 1145::265::265::710::1270::265::1145::520::635::400::265::580::710::1005::168::1005::400::265::710::580::1145::265::225::640::350::1005::635::225::580::640::595::384::135::885
	level.map_bsp[1].frontid = 0::0::0::0::0::0::0::55::0::0::0::61::0::63::64::0::66::0::0::69::0::0::0::0::70::0::0::0::78::0::80::81::82::40
	level.map_bsp[1].backid = 0::51::52::53::0::0::56::57::58::0::0::60::62::59::54::0::0::0::68::67::0::71::72::73::74::0::76::0::77::79::75::65::50::83
	level.map_bsp[1].frontsec = 2::2::0::1::2::3::3::2::3::3::0::3::1::3::3::3::3::6::1::4::4::4::0::1::6::3::4::0::4::1::0::1::0::12
	level.map_bsp[1].backsec = 16::16::2::0::3::16::16::3::2::4::3::4::0::2::2::4::4::4::6::3::16::16::4::0::0::4::3::4::3::0::6::0::15::4
end


setup_bsp_mohdm2:
	level.map_sectors[0] = "Off The Map - You found a bug!"::"ERR"
	level.map_sectors[1] = "Church Tower"::"CHT"
	level.map_sectors[2] = "Church"::"CH"
	level.map_sectors[3] = "Church Back"::"CHB"
	level.map_sectors[4] = "Center Bldg Northeast Ground Floor"::"CNE0"
	level.map_sectors[5] = "Center Bldg Northeast First Floor"::"CNE1"
	level.map_sectors[6] = "Center Bldg Southeast Ground Floor"::"CSE0"
	level.map_sectors[7] = "Center Bldg Southeast First Floor"::"CSE1"
	level.map_sectors[8] = "Center Bldg Southwest Ground Floor"::"CSW0"
	level.map_sectors[9] = "Center Bldg Southwest First Floor"::"CSW1"
	level.map_sectors[10] = "Center Bldg Northwest Ground Floor"::"CNW0"
	level.map_sectors[11] = "Center Bldg Northwest First Floor"::"CNW1"
	level.map_sectors[12] = "Center Bldg Northwest Second Floor"::"CNW2"
	level.map_sectors[13] = "Barn"::"B"
	level.map_sectors[14] = "South Bldg Ground Floor"::"S0"
	level.map_sectors[15] = "South Bldg First Floor"::"S1"
	level.map_sectors[16] = "South Bldg Second Floor"::"S2"
	level.map_sectors[17] = "East Bldg Ground Floor"::"E0"
	level.map_sectors[18] = "East Bldg Ruins"::"ER"
	level.map_sectors[19] = "West Bldg Ruins"::"WR"
	level.map_sectors[20] = "North Ruins"::"NR"
	level.map_sectors[21] = "Center Sector"::"OC"
	level.map_sectors[22] = "North Sector"::"ON"
	level.map_sectors[23] = "Northeast Sector"::"ONE"
	level.map_sectors[24] = "East Sector"::"OE"
	level.map_sectors[25] = "Southeast Sector"::"OSE"
	level.map_sectors[26] = "South Sector"::"OS"
	level.map_sectors[27] = "Southwest Sector"::"OSW"
	level.map_sectors[28] = "West Sector"::"OW"
	level.map_sectors[29] = "Northwest Sector"::"ONW"

	level.map_bsp[0] = spawn Listener
	level.map_bsp[0].ord = 2::4::3::4::3::3::7::2::3::4::4::2::2::4::3::4::8::4::3::1::3::1::1::4::4::4::3::4::3::3::4::3::4::4::3::3::3::2::3::3::4::3::4::3::4::0::3::3::3::4
	level.map_bsp[0].pa = 0.213::0.213::0.693:: -0.707
	level.map_bsp[0].pb = 0.977::0.977::0.721::0.707
	level.map_bsp[0].pc = 0::0::0::0
	level.map_bsp[0].pd = 240::2185::2425::1730::2760::2600:: -1902.427::240::2510::1050::390::220::476::50::3310::1225:: -1902.427::750::3245::1555::2665::1495::315::1345::2945::3390::1925::2265::690::1060::3460::785::3265::2835::550::1575::690::240::1865::1225::2185::840::1075::175::1600::325::550::1075::320::795
	level.map_bsp[0].frontid = 0::1::0::3::4::0::0::0::8::9::6::0::0::0::0::0::15::14::11::0::0::21::22::23::0::25::26::0::28::0::30::0::29::0::34::35::0::0::38::37::40::0::42::0::0::0::46::0::0::49
	level.map_bsp[0].backid = 0::0::0::2::0::0::0::0::0::7::10::0::12::13::0::0::16::17::18::0::20::0::19::5::0::0::0::0::0::0::0::31::32::0::33::27::0::0::0::39::36::0::0::0::44::45::43::0::48::47
	level.map_bsp[0].frontsec = 7::6::7::7::6::9::26::9::8::8::9::15::16::26::26::14::26::15::26::13::13::13::27::26::24::17::17::20::20::23::23::23::23::20::20::23::20::5::4::23::4::1::1::20::22::22::22::1::22::1
	level.map_bsp[0].backsec = 6::24::25::6::25::26::25::8::26::26::8::14::15::14::14::25::25::14::14::27::27::27::26::7::17::18::24::23::23::18::18::18::18::23::23::24::23::4::24::4::23::21::21::22::20::20::1::21::1::22
	level.map_bsp[1] = spawn Listener
	level.map_bsp[1].ord = 4::9::1::3::10::1::1::3::3::3::1::3::3::4::2::2::1::3::4::3
	level.map_bsp[1].pd = 390:: -19.866::155::1190::951.059::400::795::945::1185::765::1340::445::190::535::240::480::315::1865::1730::2150
	level.map_bsp[1].frontid = 0::0::0::0::53::0::0::57::0::0::60::52::51::63::0::0::0::64::68::69
	level.map_bsp[1].backid = 0::0::0::0::54::0::56::55::0::59::58::61::62::50::0::65::66::67::41::24
	level.map_bsp[1].frontsec = 29::29::28::2::28::3::28::3::19::28::19::29::29::2::11::12::28::28::10::10
	level.map_bsp[1].backsec = 22::2::21::21::2::2::3::28::28::19::28::3::2::1::10::11::10::10::24::8
end


setup_bsp_mohdm3:
	level.map_sectors[0] = "Center Sector"::"OC"
	level.map_sectors[1] = "Pub Ground Floor"::"P0"
	level.map_sectors[2] = "Pub First Floor"::"P1"
	level.map_sectors[3] = "Library"::"L"
	level.map_sectors[4] = "Manor Ground Floor"::"M0"
	level.map_sectors[5] = "Manor First Floor"::"M1"
	level.map_sectors[6] = "Manor Front"::"MF"
	level.map_sectors[7] = "Gallery Entry"::"GE"
	level.map_sectors[8] = "Gallery Lounge"::"GL"
	level.map_sectors[9] = "Gallery Stairs"::"GS"
	level.map_sectors[10] = "Gallery Dining"::"GD"
	level.map_sectors[11] = "Gallery Balcony"::"GB"
	level.map_sectors[12] = "Clock Tower"::"CT"
	level.map_sectors[13] = "South Gate"::"SG"
	level.map_sectors[14] = "South Sector"::"OS"
	level.map_sectors[15] = "Pub Front"::"PF"
	level.map_sectors[16] = "Covered Walkway"::"CW"
	level.map_sectors[17] = "North Sector"::"ON"
	level.map_sectors[18] = "Library Front"::"LF"
	level.map_sectors[19] = "East Sector"::"OE"
	level.map_sectors[20] = "Pub Balcony"::"PB"

	level.map_bsp[0] = spawn Listener
	level.map_bsp[0].ord = 2::4::4::4::2::4::0::7::4::8::4::4::9::0::10::0::4::0::4::2::11::12::0::13::0::0::0::0::0::4::4::2::0::14::15::4::4::0::0::0::2::0::0::16::0::4::4::2::0::0
	level.map_bsp[0].pa = 0.344::0.353:: -0.721:: -0.677::0.995::0.995:: -0.467::0.656::0.447::0.734
	level.map_bsp[0].pb = -0.939::0.935:: -0.693::0.736:: -0.101::0.102:: -0.884:: -0.755:: -0.894::0.679
	level.map_bsp[0].pc = 0::0::0::0::0::0::0::0::0::0
	level.map_bsp[0].pd = 248::3590::2690::1985::144::2615::1950::3277.148::2055:: -1909.298::3520::2615:: -467.571::2740:: -3694.963::2615::2715::2685::2495::208::3671.035::3105.121::3425::343.843::2850::3465::2350::4480::5225::3300::2985::248::5065::3143.620::2681.045::1580::1460::4480::4025::3225::162::1760::1175::848.768::640::750::30::162::390::945
	level.map_bsp[0].frontid = 0::1::0::0::0::5::6::0::0::9::10::0::0::0::14::15::16::0::18::17::0::21::22::23::24::11::26::3::0::29::0::31::32::0::34::35::0::0::38::39::0::0::42::0::44::45::0::47::0::48
	level.map_bsp[0].backid = 0::0::2::0::4::0::0::0::8::0::0::0::0::13::0::12::0::0::0::19::0::0::0::0::20::25::7::27::0::0::30::0::28::0::0::0::0::0::37::36::0::0::41::0::0::0::0::0::0::49
	level.map_bsp[0].frontsec = 5::5::17::8::9::9::9::6::18::6::6::9::9::11::9::11::11::0::9::11::6::6::6::0::0::19::0::17::17::5::17::5::17::18::18::16::3::17::18::3::2::16::15::15::14::13::20::20::15::20
	level.map_bsp[0].backsec = 4::19::5::9::8::12::12::18::6::19::19::11::11::9::11::9::0::9::0::0::0::0::0::18::11::0::12::18::5::17::5::17::19::16::16::18::18::18::3::16::1::15::2::14::13::14::15::15::13::15
	level.map_bsp[1] = spawn Listener
	level.map_bsp[1].ord = 0::4::0::2::0::4::0::4::4::0::1::0::4
	level.map_bsp[1].pd = 1090::220::1950::144::2060::850::1760::555::1510::1670::120::2685::1895
	level.map_bsp[1].frontid = 0::51::0::0::0::55::0::57::58::59::43::40::62
	level.map_bsp[1].backid = 50::46::0::53::0::0::0::56::54::52::60::61::33
	level.map_bsp[1].frontsec = 15::15::8::10::16::16::16::16::7::7::2::16::7
	level.map_bsp[1].backsec = 20::14::7::7::7::7::15::7::8::14::13::7::12
end


setup_bsp_mohdm4:
	level.map_sectors[0] = "Off The Map - You found a bug!"::"ERR"
	level.map_sectors[1] = "West Sniper House"::"WS"
	level.map_sectors[2] = "West Bridge"::"WB"
	level.map_sectors[3] = "Stone House"::"S"
	level.map_sectors[4] = "Rug House Ground Floor"::"R0"
	level.map_sectors[5] = "Rug House First Floor"::"R1"
	level.map_sectors[6] = "Hotel Ground Floor"::"H0"
	level.map_sectors[7] = "Hotel First Floor"::"H1"
	level.map_sectors[8] = "Hotel Second Floor"::"H2"
	level.map_sectors[9] = "Hotel Stairs Ground Floor"::"HS0"
	level.map_sectors[10] = "Hotel Stairs First Floor"::"HS1"
	level.map_sectors[11] = "Hotel Stairs Second Floor"::"HS2"
	level.map_sectors[12] = "Hotel Courtyard"::"HC"
	level.map_sectors[13] = "Church"::"CH"
	level.map_sectors[14] = "Sewer"::"SEW"
	level.map_sectors[15] = "Storage Room"::"ST"
	level.map_sectors[16] = "East Sniper House Ground Floor"::"ES0"
	level.map_sectors[17] = "East Sniper House First Floor"::"ES1"
	level.map_sectors[18] = "South Gate"::"GS"
	level.map_sectors[19] = "Cart"::"C"
	level.map_sectors[20] = "West Gate"::"GW"
	level.map_sectors[21] = "Main Street West"::"MW"
	level.map_sectors[22] = "Church Back Alley"::"CHA"
	level.map_sectors[23] = "North Gate"::"GN"
	level.map_sectors[24] = "Hotel Front"::"HF"
	level.map_sectors[25] = "Bridge"::"B"
	level.map_sectors[26] = "River South"::"RS"
	level.map_sectors[27] = "River North"::"RN"
	level.map_sectors[28] = "Main Street East"::"ME"
	level.map_sectors[29] = "East Gate"::"GE"

	level.map_bsp[0] = spawn Listener
	level.map_bsp[0].ord = 0::0::2::4::3::0::4::2::2::1::0::4::0::1::3::0::0::2::0::3::3::4::2::7::8::1::2::1::2::2::3::3::3::2::3::1::2::2::3::1::3::2::1::3::2::1::3::2::3::1
	level.map_bsp[0].pa = -0.688:: -0.749
	level.map_bsp[0].pb = 0.725::0.663
	level.map_bsp[0].pc = 0::0
	level.map_bsp[0].pd = 360::930::480::1350::1120::330::1995::608::432::715::1290::715::930::845::315::315::0::240::585::1165::1620::865::728::1142.140::1139.771::1285::462::1155::728::472::500::430::455::472::1080::1515::608::432::1620::1530::1165::240::3850::890::532::3915::730::448::950::3270
	level.map_bsp[0].frontid = 0::0::2::3::0::4::6::0::8::9::0::0::12::11::0::0::0::16::14::19::20::21::0::23::0::0::24::0::0::29::27::0::0::32::34::35::0::37::38::0::36::0::42::0::44::0::43::0::0::0
	level.map_bsp[0].backid = 0::0::1::0::0::5::0::0::0::0::0::0::0::13::0::15::0::17::18::10::0::7::0::0::0::25::26::0::0::28::30::0::0::33::0::31::0::0::0::39::40::0::0::0::0::45::46::0::48::49
	level.map_bsp[0].frontsec = 16::16::17::17::28::17::26::11::10::11::27::27::16::15::25::27::27::25::15::26::11::27::8::7::6::6::7::6::8::7::24::21::21::5::4::4::11::10::11::12::12::19::19::1::1::19::1::2::18::1
	level.map_bsp[0].backsec = 28::17::28::28::26::28::29::10::9::26::15::16::27::27::26::25::26::27::27::11::26::28::7::24::24::24::6::24::7::24::7::5::4::4::12::6::10::9::12::11::11::14::1::19::19::1::19::18::2::18
	level.map_bsp[1] = spawn Listener
	level.map_bsp[1].ord = 3::3::1::1::3::3::2::3::3::3::2::3::1::3::1::1::0::0::1::1::0::0::1::0::1::1::1::0::0::1::0::1::2::3::1
	level.map_bsp[1].pd = 455::760::3350::3770::1195::840::448::1410::430::455::448::455::2530::735::2850::2405::455::585::2445::1400::585::1290::1660::760::3415::3255::3415::455::1290::1400::585::2445::240::305::870
	level.map_bsp[1].frontid = 0::51::0::47::54::0::0::57::0::0::59::0::62::63::55::65::0::0::0::0::70::0::69::0::0::75::0::76::0::0::80::78::82::83::84
	level.map_bsp[1].backid = 0::50::52::53::0::0::56::0::0::0::60::0::61::58::64::41::0::67::68::0::0::71::72::0::0::74::0::77::0::79::0::81::73::66::22
	level.map_bsp[1].frontsec = 21::18::1::19::2::18::3::3::21::21::5::21::18::18::18::18::21::23::14::14::15::15::23::22::20::22::20::22::23::23::23::22::23::21::23
	level.map_bsp[1].backsec = 18::1::18::1::18::3::18::18::5::18::18::18::5::3::3::4::14::21::23::15::14::14::14::13::22::13::21::21::15::15::21::23::15::6::27
end


setup_bsp_mohdm5:
	level.map_sectors[0] = "North Sector"::"N"
	level.map_sectors[1] = "River West"::"RW"
	level.map_sectors[2] = "River Center"::"RC"
	level.map_sectors[3] = "River East"::"RE"
	level.map_sectors[4] = "West Bridge"::"BW"
	level.map_sectors[5] = "Center Bridge"::"BC"
	level.map_sectors[6] = "East Bridge"::"BE"
	level.map_sectors[7] = "West Sector"::"W"
	level.map_sectors[8] = "East Sector"::"E"
	level.map_sectors[9] = "Southeast Sector"::"SE"
	level.map_sectors[10] = "Southwest Sector"::"SW"
	level.map_sectors[11] = "South Sector"::"S"
	level.map_sectors[12] = "Northeast Sector"::"NE"
	level.map_sectors[13] = "Northwest Sector"::"NW"

	level.map_bsp[0] = spawn Listener
	level.map_bsp[0].ord = 4::0::7::4::0::8::2::4::4::0::9::10::11::0::0::4::4::2::12::13::4::0::14::4::0::15::0::4::4::4::0::0::4::4::4::0::4::2::16::4::17::4::3::18::4::0::0::4::0
	level.map_bsp[0].pa = -0.801::0.164::0.980::0.164:: -0.852::0.993::0.997:: -0.834::0.947::0.993::0.344:: -0.353
	level.map_bsp[0].pb = 0.599:: -0.986::0.198:: -0.986:: -0.524:: -0.117:: -0.082:: -0.552:: -0.321::0.122:: -0.939:: -0.936
	level.map_bsp[0].pc = 0::0::0::0::0::0::0::0::0::0::0::0
	level.map_bsp[0].pd = 5895::3720:: -6200.770::5130::2515::5838.630::112::6730::6445::2620::1376.639::5838.630::1473.041::2055::2515::4660::5000::112::3081.980::3150.380::4555::4040:: -1042.544::4440::2555::3549.195::2660::3520::5100::3520::1085::1505::5100::4555::4025::1050::2565::112::729.519::2850::3958.421::4585::395::5042.758::5250::520::200::5465::1735
	level.map_bsp[0].frontid = 0::0::2::0::4::0::0::7::6::0::5::0::0::11::0::0::16::17::15::0::0::0::22::23::24::0::0::27::28::0::30::0::32::0::31::0::0::37::36::39::0::0::41::0::43::40::0::46::29
	level.map_bsp[0].backid = 0::1::0::3::0::0::0::0::8::9::10::0::12::13::0::0::0::0::18::0::20::0::0::21::19::0::26::25::14::0::0::0::0::33::34::0::0::0::38::35::0::0::42::0::44::45::0::47::48
	level.map_bsp[0].frontsec = 0::12::0::0::0::3::6::6::3::12::12::3::8::6::5::2::5::5::5::0::0::13::0::13::5::13::13::13::5::7::7::5::5::11::1::7::1::4::7::4::11::10::11::9::11::1::8::11::2
	level.map_bsp[0].backsec = 12::0::12::12::2::2::3::3::6::6::3::2::3::8::2::5::2::2::2::5::5::0::13::0::2::7::7::0::0::1::1::11::11::5::11::1::4::1::1::1::10::11::10::11::9::10::9::8::8
end


setup_bsp_mohdm6:
	level.map_sectors[2] = "Courtyard"::"C"
	level.map_sectors[3] = "West Bldg First Story South Side"::"W1S"
	level.map_sectors[4] = "West Bldg Second Story South Side"::"W2S"
	level.map_sectors[5] = "West Bldg Ground Floor"::"W0"
	level.map_sectors[6] = "West Bldg Third Story South Side"::"W3S"
	level.map_sectors[7] = "West Bldg Staircase"::"WS"
	level.map_sectors[8] = "West Bldg First Story North Side"::"W1N"
	level.map_sectors[9] = "West Bldg Second Story North Side"::"W2N"
	level.map_sectors[10] = "West Bldg Third Story North Side"::"W3N"
	level.map_sectors[11] = "North Bldg Roof"::"NR"
	level.map_sectors[12] = "Boiler Room"::"B"
	level.map_sectors[13] = "Locker Room"::"L"
	level.map_sectors[14] = "North Bldg Roof"::"NR"
	level.map_sectors[15] = "East Bldg Ground Floor"::"E0"
	level.map_sectors[16] = "East Bldg First Floor"::"E1"
	level.map_sectors[17] = "East Bldg Second Floor"::"E2"
	level.map_sectors[18] = "East Bldg Staircase"::"ES"
	level.map_sectors[19] = "South Bldg Staircase"::"SS"
	level.map_sectors[20] = "South Bldg First Floor"::"S1"
	level.map_sectors[21] = "South Bldg Second Floor"::"S2"
	level.map_sectors[22] = "South Bldg Third Floor"::"S3"

	level.map_bsp[0] = spawn Listener
	level.map_bsp[0].ord = 0::2::2::2::0::0::1::0::4::0::2::4::0::4::2::1::2::2::2::2::0::1::1::0::2::2::3::3::4::2::4::2::4::3::2::2::1::1::3::2::2::1::3::3::2::2::2::1::3::2
	level.map_bsp[0].pd = 480::272::512::32::780::625::415::785::90::500::32::90::785::235::224::180::272::512::272::512::480::900::512::950::32::272::140::360::670::272::650::32::260::925::256::496::390::650::695::272::512::415::250::25::32::272::512::512::545::256
	level.map_bsp[0].frontid = 0::0::0::3::0::5::6::0::8::0::10::0::12::13::9::7::0::0::0::0::20::18::22::0::0::0::0::27::0::0::30::31::28::33::0::0::36::0::0::0::0::41::42::0::0::0::0::47::48::0
	level.map_bsp[0].backid = 0::0::2::0::4::1::0::0::0::0::0::0::11::0::14::15::0::17::0::19::0::21::16::23::0::25::26::0::0::0::0::29::32::0::0::35::0::37::38::0::40::0::0::43::0::45::46::44::39::0
	level.map_bsp[0].frontsec = 2::9::10::8::2::8::8::2::2::12::13::2::2::13::14::2::9::10::9::10::8::8::8::14::16::17::2::16::15::17::16::16::2::16::21::22::21::2::2::4::6::4::4::2::3::4::6::5::5::21
	level.map_bsp[0].backsec = 7::8::9::2::8::2::2::14::14::13::12::12::12::12::13::13::8::9::8::9::7::7::2::8::2::16::16::2::18::16::18::15::16::19::2::21::2::21::21::2::4::2::2::4::5::3::4::2::2::20
	level.map_bsp[1] = spawn Listener
	level.map_bsp[1].ord = 2::1::3::4::0
	level.map_bsp[1].pd = 496::926::800::145::200
	level.map_bsp[1].frontid = 0::0::49::53::24
	level.map_bsp[1].backid = 50::51::52::34::54
	level.map_bsp[1].frontsec = 22::2::2::20::7
	level.map_bsp[1].backsec = 21::20::20::2::5
end


setup_bsp_mohdm7:
	level.map_sectors[0] = "East Path"::"PE"
	level.map_sectors[1] = "Mosque Courtyard"::"MC"
	level.map_sectors[2] = "Mosque Roof"::"M1"
	level.map_sectors[3] = "Mosque Back"::"MB"
	level.map_sectors[4] = "Mosque Ground Floor"::"M0"
	level.map_sectors[5] = "Mosque Radio"::"MR"
	level.map_sectors[6] = "Secret Passage"::"SP"
	level.map_sectors[7] = "Northwest Bldg"::"NW"
	level.map_sectors[8] = "Northeast Bldg"::"NE"
	level.map_sectors[9] = "East Bldg"::"E"
	level.map_sectors[10] = "Center Bldg Ground Floor"::"C0"
	level.map_sectors[11] = "Center Bldg Roof"::"C1"
	level.map_sectors[12] = "Center Passageway"::"CP"
	level.map_sectors[13] = "Southwest Sector"::"OSW"
	level.map_sectors[14] = "West Path"::"PW"
	level.map_sectors[15] = "Northwest Sector"::"ONW"
	level.map_sectors[16] = "North Sector"::"ON"
	level.map_sectors[17] = "Center Path"::"PC"
	level.map_sectors[18] = "Southeast Path"::"PSE"

	level.map_bsp[0] = spawn Listener
	level.map_bsp[0].ord = 3::3::1::3::3::1::1::3::1::1::1::1::4::1::3::1::3::3::3::4::1::3::1::2::0::0::2::0::3::2::7::4::4::3::5::3::4::3::4::3::0::3::3::1::1::4::3::4::3::0
	level.map_bsp[0].pa[1] = -0.030
	level.map_bsp[0].pb[1] = -1.000
	level.map_bsp[0].pc[1] = 0
	level.map_bsp[0].pd = 2520::2623::1325::2940::2430::1215::1025::2623::550::760::2087::2125::498::2125::3350::1580::2820::3065::2940::498::550::3350::1325::276::635::1247::24::40::10::40::999.846::1000::1008::1175::57::1230::1380::1470::1245::390::1535::1800::1563::1125::695::400::265::620::390::40
	level.map_bsp[0].frontid = 0::0::0::0::0::0::6::7::0::8::2::1::12::0::13::0::0::17::0::0::19::21::18::23::0::0::25::0::0::28::0::30::32::0::34::35::0::0::36::33::0::41::0::0::44::45::0::47::48::0
	level.map_bsp[0].backid = 0::0::0::3::0::5::0::4::0::9::10::11::0::0::14::0::16::0::0::0::20::0::22::15::0::0::26::0::0::29::0::31::27::0::0::0::0::37::38::39::40::0::0::0::43::0::0::0::0::49
	level.map_bsp[0].frontsec = 13::13::4::4::4::13::13::13::4::5::1::1::6::1::18::2::2::5::2::6::5::18::2::2::8::8::8::16::16::11::0::0::16::0::9::0::9::0::9::11::8::0::17::13::12::12::11::10::11::16
	level.map_bsp[0].backsec = 1::1::5::5::13::4::4::4::6::4::4::13::18::3::3::5::5::2::5::18::6::3::5::13::0::0::0::11::0::16::16::16::0::9::0::9::0::9::0::0::16::18::12::12::17::18::10::11::10::11
	level.map_bsp[1] = spawn Listener
	level.map_bsp[1].ord = 3::2::4::3::1::3::2::1::2::1::0::0::3::2::1::0::0::1::1::1::3::1::3::0::4::3
	level.map_bsp[1].pd = 10::40::400::950::1855::645::96::1855::96::2050::625::135::630::96::1405::625::200::895::1350::1545::835::225::1335::1535::810::1935
	level.map_bsp[1].frontid = 0::50::0::52::0::0::56::0::0::0::0::61::62::0::0::0::66::0::67::63::70::71::72::0::74::75
	level.map_bsp[1].backid = 0::51::0::53::0::0::0::57::0::59::0::60::58::0::64::65::0::0::68::69::55::54::46::73::42::24
	level.map_bsp[1].frontsec = 16::11::17::10::14::7::7::14::7::7::15::7::15::7::7::15::7::15::7::7::16::16::17::8::18::18
	level.map_bsp[1].backsec = 10::16::18::18::17::15::15::15::15::15::7::15::14::15::15::7::15::16::15::15::17::10::12::16::0::6
end


setup_bsp_obj_team1:
	level.map_sectors[0] = "Main Street"::"M"
	level.map_sectors[1] = "Main Street Ladder House"::"ML"
	level.map_sectors[2] = "Main Street Tub House"::"MT"
	level.map_sectors[3] = "Main Street East Bldg"::"MBE"
	level.map_sectors[4] = "Main Street Corner Bldg"::"MBC"
	level.map_sectors[5] = "Main Street North Bldg"::"MBN"
	level.map_sectors[6] = "Main Street Northwest Ruins"::"MNW"
	level.map_sectors[7] = "Main Street Southeast Ruins"::"MSE"
	level.map_sectors[8] = "Main Street South Ruins"::"MSR"
	level.map_sectors[9] = "Main Street North"::"MN"
	level.map_sectors[10] = "Main Street West"::"MW"
	level.map_sectors[11] = "Bushes"::"B"
	level.map_sectors[12] = "Alley West"::"AW"
	level.map_sectors[13] = "Alley East"::"AE"
	level.map_sectors[14] = "Alley Sniper House"::"AS"
	level.map_sectors[15] = "Alley West Bldg"::"ABW"
	level.map_sectors[16] = "Alley East Bldg"::"ABE"
	level.map_sectors[17] = "Church Front"::"CF"
	level.map_sectors[18] = "Church Back"::"CB"
	level.map_sectors[19] = "Church Cemetary"::"CC"
	level.map_sectors[20] = "Church Southeast Sector"::"CSE"
	level.map_sectors[21] = "Church Southwest Sector"::"CSW"
	level.map_sectors[22] = "Main Street South"::"MS"
	level.map_sectors[23] = "Alley Center Bldg"::"ABC"
	level.map_sectors[24] = "Bush Ruins"::"BR"

	level.map_bsp[0] = spawn Listener
	level.map_bsp[0].ord = 1::0::0::1::1::1::0::1::7::1::0::1::8::1::0::0::9::10::1::1::11::0::12::0::13::14::1::1::1::0::1::1::0::15::16::17::18::1::19::1::20::0::1::1::1::0::1::0::1::0
	level.map_bsp[0].pa = -0.986:: -0.986:: -0.495::0.527:: -0.878::0.842::0.389::0.514:: -0.243::0.825::0.551::0.966:: -0.250:: -0.227:: -0.765:: -0.631:: -0.692:: -0.692::0.527::0.865:: -0.495:: -0.832:: -0.922
	level.map_bsp[0].pb = -0.167:: -0.167:: -0.869::0.850::0.479:: -0.539::0.921::0.857::0.970::0.565::0.835::0.259::0.968::0.974:: -0.644::0.776::0.722:: -0.722::0.850:: -0.502:: -0.869:: -0.555:: -0.388
	level.map_bsp[0].pc = 0::0::0::0::0::0::0::0::0::0::0::0::0::0::0::0::0::0::0::0::0::0::0
	level.map_bsp[0].pd = 520::3967::5200::1885::2145::1400::4391::1450:: -4912.554::1400::4980::1845:: -4912.554::2430::4410::3445:: -2969.009::2687.163::2720::1005:: -2609.744::3967::724.690::3830::5325.254::5587.424::4265::3360::2870::3755::3265::3300::3445::2170.694::6047.595::5749.808::5742.116::3605::2125.454::2960::1603.267::4135::3900::2760::970::1480::4345::2945::4470::1875
	level.map_bsp[0].frontid = 0::0::0::0::0::0::6::5::0::0::0::9::0::13::14::0::0::17::16::0::19::15::0::0::0::0::24::0::0::0::30::0::32::0::34::0::0::0::36::0::39::41::27::43::44::0::0::0::0::49
	level.map_bsp[0].backid = 0::1::2::0::4::0::0::7::0::0::10::11::0::12::8::0::0::0::18::0::20::21::0::23::0::25::26::0::0::0::29::31::28::0::0::35::0::37::38::0::40::33::42::22::3::0::46::0::48::47
	level.map_bsp[0].frontsec = 13::19::11::12::15::11::11::23::12::11::11::12::12::9::11::12::14::14::3::12::14::15::6::6::6::6::10::9::4::4::9::9::9::6::6::6::5::6::6::5::5::9::6::9::11::22::22::2::10::10
	level.map_bsp[0].backsec = 19::13::19::23::12::24::16::16::11::24::24::11::9::11::23::3::12::13::12::13::13::12::10::10::9::9::9::3::12::9::4::4::3::9::9::9::9::5::5::9::9::4::9::12::19::8::8::10::2::22
	level.map_bsp[1] = spawn Listener
	level.map_bsp[1].ord = 1::4::4::1::0::21::22::0::23::24::0::0::1::0::4::0::0::0::0::1::0::1::1::0::0::1::0::25::1::26::27::1::28::29::1::1::1::1::0
	level.map_bsp[1].pd = 90::860::805::35::1595:: -1820.086:: -2106.665::2550:: -2096.473:: -1544.152::2430::2350::35::635::805::1300::1480::2945::2745::3955::2300::3350::3360::3190::2535::520::3000::2687.163::1230::2076.191:: -2969.009::2720:: -3450.235:: -2990.949::3385::3775::330::4330::3415
	level.map_bsp[1].frontid = 0::51::0::0::54::0::56::0::58::59::60::61::0::63::64::62::0::0::68::69::70::0::0::73::74::0::76::0::0::78::80::75::0::83::84::71::86::50::45
	level.map_bsp[1].backid = 0::0::0::53::52::0::0::0::0::0::57::55::0::0::0::65::0::0::0::0::67::0::0::72::0::0::0::77::0::79::0::81::0::0::82::85::66::87::88
	level.map_bsp[1].frontsec = 21::17::17::21::20::17::17::19::17::17::19::19::21::18::21::17::0::2::10::10::1::0::0::3::0::13::19::14::12::14::14::7::7::7::0::0::13::10::9
	level.map_bsp[1].backsec = 17::20::20::17::17::19::19::17::19::19::17::20::18::21::20::20::8::10::1::0::0::3::3::0::7::19::13::13::13::12::12::12::0::0::7::7::19::1::0
end

```

# zz_admin-Pro_1.22_modif\global\maths.scr

```scr

// big thanx to jv for letting me use his maths functions
// jv wrote this file btw:P

main:

	level.PI = 3.1415926
	//level.PI = 3.14159
end
// sin(x), x in rad
 // sin(x), x in rad
sin local.x:
end (waitthread cos(local.x - 0.5 * level.PI))

// cos(x), x in rad
cos local.x:
	// reduce to [0,2pi]
	if(local.x > 2.0 * level.PI)
	{
	  local.x -= (int (local.x / (2.0 * level.PI))) * 2.0 * level.PI
	}
	else if(local.x < 0.0)
	{
	  local.x += ((int ( -local.x / (2.0 * level.PI))) + 1) * 2.0 * level.PI
	}   

	// reduce to [-pi,pi]
	if(local.x > level.PI)
	{
	  local.x -= 2.0 * level.PI
	}

	local.x2 = local.x * local.x
	local.x4 = local.x2 * local.x2
	local.x6 = local.x4 * local.x2
	local.x8 = local.x6 * local.x2

	// taylor series expansion
	local.cosx = 1.0 - 0.5 * local.x2 + 0.04167 * local.x4 - 0.00139 * local.x6 + 0.00002 * local.x8

	if(local.cosx < -1.0)
	{
	  local.cosx = -1.0
	}
	else if(local.cosx > 1.0)
	{
	  local.cosx = 1.0
	}

end local.cosx

// tan(x), x in rad, undefined for x = (1/2 + k) * PI with k arbitrary int
tan local.x:
end ((waitthread sin local.x) / (waitthread cos local.x))



// transforms vectors to angles (pitch,yaw,roll)
// unlike vector_toangles this also includes roll
vectors_toangles local.vec_fwd local.vec_lf:
   local.base_angles = vector_toangles local.vec_fwd
   
   local.base_fwd = local.vec_fwd
   local.base_lf = -1.0 * (angles_toleft local.base_angles)
   local.base_up = vector_cross local.base_fwd local.base_lf
   
   local.cos = local.vec_lf * local.base_lf
   
   if(abs local.cos < 0.8)
   {
      local.roll_angle = waitthread arccos local.cos
      
      if(local.vec_lf * local.base_up < 0.0)
      {
         local.roll_angle = -local.roll_angle
      }
   }
   else
   {
      // arccos inaccurate here
      // so just use arcsin instead
      // (far more sensitive in this region)
      local.sin = local.vec_lf * local.base_up
      
      local.roll_angle = waitthread arcsin local.sin
      
      if(local.cos < 0.0)
      {
         local.roll_angle = level.PI - local.roll_angle
      }
   }
   
   // convert to degrees
   local.roll_angle = local.roll_angle / level.PI * 180.0
   
   local.angles = local.base_angles
   local.angles[2] = local.roll_angle
end local.angles

// inverse sin
// somewhat inaccurate near +-0.5PI
arcsin local.x:
   if(local.x < -0.857 || local.x > 0.857)
   {
      // some 9th order approximation
      local.x3 = local.x * local.x * local.x
      local.x9 = local.x3 * local.x3 * local.x3
      
      local.out = local.x + (0.5 * level.PI - 1.0) * local.x9
   }
   else
   {
      local.x2 = local.x * local.x
      local.x3 = local.x2 * local.x
      local.x5 = local.x3 * local.x2
   
      // Taylor series expansion
      local.out = local.x + 0.1667 * local.x3 + 0.075 * local.x5
   }
end local.out

// inverse cos
arccos local.rad:
   local.result = 0.5 * level.PI - (waitthread arcsin local.rad)
end local.result 
```

# zz_admin-Pro_1.22_modif\global\mod_inform.scr

```scr
//This script basicaly is to replace the camper mod on message. The admin can tell what mods are on and off so he does not need it.
//however the players might like to know, so this gives a neater hud draw version to all the players at the start of the map.

// Called from ambient.scr after level wait till spawn. Or from anti_camper.scr if the AP mod is not loaded right.

main local.msg:

	if(game.show_on_mods == 1)
	{
		wait 1
		huddraw_align 80 "right" "bottom"
		huddraw_alpha 80 1.0
		huddraw_virtualsize 80 1 
		huddraw_rect 80 -115 -15 0 0
		huddraw_color 80 1 0 1
		huddraw_font 80 verdana-12

		if(local.msg == NIL)
		{
			for(local.i = 1;local.i <= game.scripts.size;local.i++)
			{
				if(game.scripts[local.i][2] == "1")
				{
					local.msg = ( game.scripts[local.i][1] + " " + "On")
				}
				else
				{
					local.msg = ( game.scripts[local.i][1] + " " + "Off")
				}

				huddraw_string 80 local.msg 

				wait 1
			}
		}
		else
		{
			huddraw_string 80 local.msg 
			wait 1
		}

		huddraw_alpha 80 0
	}
end
```

# zz_admin-Pro_1.22_modif\global\modelfix.scr

```scr
// 23/11/2005 19:11 Fixed typo in disconnect will now kick players correctly.
//
// 23/11/2005 19:08 addded cvar_restart to protect other servers

//  Fix for Fps exploit
main:
	//self noclip
	//self physics_off
	local.in = waitexec global/strings.scr::InStr "fps" self.model 

	if(local.in != NIL)
	{
	     	self noclip
		self physics_off
	//	iprintlnbold self.model
		self stufftext "say I am trying to crash the server"
		wait 1
		//self stufftext "cvar_restart"
		wait 1
		self stufftext "disconnect"
		
	}
end
```

# zz_admin-Pro_1.22_modif\global\nagle.scr

```scr
// 07/12/2005 23:12 added nil check for colour generation
//
// 22/11/2005 17:25 added code to count players on team, 

// this is just stuff that might be usefull
//----------------------------------------------------------------------


// find player:
// exec with a id from console or whatever and will return the player
// returns nil if not found
find_player local.maybeplayer:

	for(local.i=1; local.i <= $player.size; local.i++) //loop through and find the player
	{   
		if(local.maybeplayer == string($player[local.i].entnum)) //if the number is what was enterd into console then work
		{
			local.player = $player[local.i]
			end local.player
		}         
	}   

end


// RGB light from string
// Will produce a light from a string
// returns a array of the light as int
light_from_string local.string:


	//split the line
	local.light_array = waitexec global/strings.scr::split_line local.string 1
	// first set is the split words
	local.light = local.light_array[1]
	//convert to int
	local.light = waitexec global/strings.scr::array_to_float local.light
	
	//check the colours are not broken
	for(local.i = 1;local.i < 3;local.i++)
	{
		if(local.light[local.i] == NIL)
		{
			local.light[local.i] = randomfloat(1.0)
			
		}
	}
	
end local.light


// produces a random light 
// returns a array of the light as int
random_light:

	local.colour_is_pretty = 1
	while(local.colour_is_pretty == 1)
	{
		for(local.i = 1;local.i <= 3;local.i++)
		{
			local.light[local.i] = randomfloat(2.0)
		}
		
		local.colour_is_pretty = (int(local.light[1] == 0) && int(local.light[2] == 0) && int(local.light[3] == 0))

		if(local.colour_is_pretty != 1)
		{				
			end local.light
		}

		waitframe
	}

end local.light


// team_count
// returns an array with string index's "allies" , "axis" and "spectator"
// used to count players on a team.
team_count:


	local.team[allies] = 0
	local.team[axis] = 0
	local.team[spectator] = 0
			
	for(local.i = 1 ; local.i <= $player.size ; local.i++)
	{
		local.team[$player[local.i].dmteam] ++
	}

end local.team
```

# zz_admin-Pro_1.22_modif\global\reset_settings.scr

```scr
main:

	//first turn all the scripts off

	for(local.i = 1;local.i <= game.scripts.size ;local.i++)
	{
		if(level.run[game.scripts[local.i][1]] == "1")
		{
			level.run[game.scripts[local.i][1]] = 0
		}
	}
	
	wait 1

	//`level waittill spawn
	//wait 1
	exec settings/Advanced_universal.txt::extra_settings	// Find out reset setting

	game.scripts = waitexec settings/Mods.txt 

	//first sort out spawning
	exec settings/Advanced_universal.txt::spawn_scripts				//Setup Spawn scripts first
	game.spawn_scripts = level.spawn_scripts

	// Sort what mods should run and should not run
	for(local.i = 1;local.i <= game.scripts.size ;local.i++)
	{
		// have to use waitthread because mohaa updates it's memory too damn slow and then the spawn scripts are wrong oh oh , yeah damn mohaa
		waitexec global/settings.scr::on_or_off game.scripts[local.i] local.i
	}

	// Clear spawn scripts that should not run
	exec global/settings.scr::clear_spawn_scripts

	if(game.reset == "1" || game.all_commands == NIL)									// if there are no settings or reset has been set reload the settings
	{ 	
		level.cmd_position = 1
		//Work out the settings and exec the scripts
		for(local.i = 1;local.i <= game.scripts.size ;local.i++)
		{
			waitexec global/settings.scr::getsettings game.scripts[local.i]
		}
		
		// Now get the extra mods
		local.mods = waitexec settings/Mods.txt::extra_settings
		
		for(local.i = 1;local.i <= local.mods.size ;local.i++)
		{
			waitexec global/settings.scr::getextrasettings local.mods[local.i]
		}

		//thread update_allcmds level.cmds	//Update all the commands gained from the settings files
		waitexec global/settings.scr::update_allcmds level.cmds
	}

	//Do advanced.txt
	exec global/settings.scr::advanced
	//setup fixes straight away
	waitexec global/settings.scr::getgame
	
	//Finaly exec all th scripts
	for(local.i = 1;local.i <= game.scripts.size ;local.i++)
	{
		if(game.scripts[local.i][4] != "none")
		{
			exec game.scripts[local.i][4]
		}
	}

	// Now if needed update the AP_Scripts cvar to keep track of the scripts
	if(local.APscripts == "" || local.APscripts == "NIL")
	{
		for(local.i=1;local.i <= game.scripts.size;local.i++)
		{
			local.APscripts += game.scripts[local.i][2] 
		}

		setcvar "AP_scripts" local.APscripts 
	}
	
	//clear this as it wont be used again
	level.cmds = NIL

	game.campersettings =  waitexec game.file["settings/advanced"]::cvars
	waitexec global/settings.scr::register game.campersettings

	if(level.run["camper"] == "1")
	{
		game.types = waitexec game.file["camper"]::types
	}
	
end


```

# zz_admin-Pro_1.22_modif\global\settings.scr

```scr
main:

	if(level.camper_setup!=1)															// if setup is not yet done
	{
//		level waittill spawn
//		wait 1
		exec settings/Advanced_universal.txt::extra_settings	// Find out reset setting

		level.camper_setup=1	

		waitthread get_mapstr			//get map name and map string name
		//waitthread get_mapspecific		// get map specific information

		level.gametype = int(getcvar "g_gametype")

		game.scripts = waitexec settings/Mods.txt 

		local.APscripts = getcvar "AP_scripts"

		if(local.APscripts != "" && local.APscripts != "NIL")
		{
			if(game.reset == 0 || game.reset == 2)
			{
				for(local.i=0;local.i <= game.scripts.size - 1;local.i++)
				{
					game.scripts[local.i + 1][2] = local.APscripts[local.i] 
				}	
			}
		}

		if(game.scripts == NIL)
		{
			exec global/ac/console_feedback.scr ("settings/Mods.txt is missing or broken. Please Fix" ) 1				// message the admins with what is wrong.
			exec global/ac/console_feedback.scr ("Shutting DOwn Admin-Pro" ) 1				// message the admins with what is wrong.
			end
		}

		//first sort out spawning
		exec settings/Advanced_universal.txt::spawn_scripts				//Setup Spawn scripts first
		game.spawn_scripts = level.spawn_scripts

		// Sort what mods should run and should not run
		for(local.i = 1;local.i <= game.scripts.size ;local.i++)
		{
			// have to use waitthread because mohaa updates it's memory too damn slow and then the spawn scripts are wrong oh oh , yeah damn mohaa
			waitthread on_or_off game.scripts[local.i] local.i
		}

		// Clear spawn scripts that should not run
		thread clear_spawn_scripts
	
		if(game.reset == 1 || game.all_commands == NIL)									// if there are no settings or reset has been set reload the settings
		{ 	
			level.cmd_position = 1
			//Work out the settings and exec the scripts
			for(local.i = 1;local.i <= game.scripts.size ;local.i++)
			{
				waitthread getsettings game.scripts[local.i]
			}
			
			// Now get the extra mods
			local.mods = waitexec settings/Mods.txt::extra_settings
			
			for(local.i = 1;local.i <= local.mods.size ;local.i++)
			{
				waitthread getextrasettings local.mods[local.i]
			}
	
			//thread update_allcmds level.cmds	//Update all the commands gained from the settings files
			waitthread update_allcmds level.cmds
		}

		//Do advanced.txt
		thread advanced
		//setup fixes straight away
		waitthread getgame
		
		//Finaly exec all th scripts
		for(local.i = 1;local.i <= game.scripts.size ;local.i++)
		{
			if(game.scripts[local.i][4] != "none")
			{
				exec game.scripts[local.i][4]
			}
		}

		// Now if needed update the AP_Scripts cvar to keep track of the scripts

		if(local.APscripts == "" || local.APscripts == "NIL")
		{
			local.APscripts = ""
			for(local.i=1;local.i <= game.scripts.size;local.i++)
			{
				local.APscripts += game.scripts[local.i][2] 
			}

			setcvar "AP_scripts" local.APscripts 
		}
		
		//clear this as it wont be used again
		level.cmds = NIL

		game.campersettings =  waitexec game.file["settings/advanced"]::cvars
		waitthread register game.campersettings
		
		if(level.run["camper"] == "1")
		{
			game.types = waitexec game.file["camper"]::types
		}
		
	}
end


//****************************************************************************************************************
// Get the settings for the files with no mod related to them that can be turned on and off
//
//****************************************************************************************************************

getextrasettings local.mod:

	if(local.mod[2] != "0")
	{
		if(local.mod[3] != "0")
		{
			local.path = ( local.mod[1] + level.map_specific)
		}
		else
		{
			local.path = ( local.mod[1] + ".txt")
		}
		
		level.cmds[level.cmd_position] =  waitexec local.path

		//check its there
		if(level.cmds[level.cmd_position] == NIL)
		{
			exec global/ac/console_feedback.scr ("Could not find " + local.path )					// message the admins with what is wrong.
			local.path = ( local.mod[1] + ".txt")
			exec global/ac/console_feedback.scr ("Loading " + local.path )	
			// reload normal path
			level.cmds[level.cmd_position] =  waitexec local.path
		}

		level.cmd_position++

		game.file[local.mod[1]] = local.path
//		waitthread add_cmds level.cmds
	}
end

//********************************************************
// Get the settings for the mods
//
//********************************************************

getsettings local.mod:

	if(local.mod[7] != "none" && local.mod[2] == "1")
	{
		if(local.mod[8] != "0")
		{
			local.path = ( local.mod[7] + level.map_specific )
		}
		else
		{
			local.path = ( local.mod[7] + ".txt")
		}
		
		level.cmds[level.cmd_position] =  waitexec local.path

		//check its there
		if(level.cmds[level.cmd_position] == NIL)
		{
			exec global/ac/console_feedback.scr ("Could not find " + local.path )					// message the admins with what is wrong.
			local.path = ( local.mod[7] + ".txt")
			exec global/ac/console_feedback.scr ("Loading " + local.path )	
			// reload normal path
			level.cmds[level.cmd_position] =  waitexec local.path
		}

		level.cmd_position++

		game.file[local.mod[1]] = local.path
//		waitthread add_cmds level.cmds
	}
end

//********************************************************
// Work out if this mod should be on or off
//
//********************************************************

on_or_off local.mod local.gamenum:

	local.modname = local.mod[1]	//what mod is it?

	if(local.mod[2] == "1")	//is the mod initialy ON
	{
		local.end = 0
		// Now check the mod can run in this game type.

		if(local.mod[6] != "all")	//does it run in all or has it got a specified game type list?
		{
			local.has_list = waitexec local.mod[6]	//get the list
			local.end = waitthread check_gametypelist local.has_list	//check the game type list
		}

		// If mod is not to end then check for map in a map array
		if(local.end == 0)
		{
		
			if(local.mod[5] != "all")
			{
				local.has_list = waitexec local.mod[5] //get the list
				local.end = waitthread check_maplist local.has_list	//check the map array
			}


			// Mod is to run!
			if(local.end == 0)
			{
				game.scripts[local.gamenum][2] = "1"
				level.run[local.modname] = "1"		//Set level.run cvar to run mod
	
				println ("AP Running " + local.modname)
				end
			}
		}
	}

	game.scripts[local.gamenum][2] = "0"
	level.run[local.modname] = "0"
	println ("AP Not Running " + local.modname)
end
	
//********************************************************
// Check this mod can run on this game type
//
//********************************************************

check_gametypelist local.list:

	for(local.i = 1; local.i <= local.list.size ; local.i++)
	{
		local.gametype  = int local.list[local.i][1]
		if(local.gametype == level.gametype)
		{
			// gametype found
			end 0
		}
	}
	// game type not found in list
end 1

//********************************************************
// Check this mod can run on this map
//
//********************************************************

check_maplist local.list:

	local.list = waitexec global/strings.scr::Array_to_lower local.list

	for(local.i = 1; local.i <= local.list.size ; local.i++)
	{
		if(local.list[local.i][1] == level.mapname)
		{
			//map found
			end 0
		}
	}
	// Map not found. Dont run
end 1

//********************************************************
// get the map specific information
//
//********************************************************

//get_mapspecific:
//
//	local.map_specific =  waitexec settings/map_specific.txt //load info
//
//	for( local.i = 0;local.i <= local.map_specific.size; local.i++)
//	{
//		group.map_specific[local.map_specific[1][1]] = local.map_specific[1][2]		
//	}
//
//end


//********************************************************
// Advanced.txt sort out thread
//
//********************************************************

advanced:

	local.path = game.file["settings/advanced"]
	exec local.path::extra_settings				// Setup Extra variables
	exec local.path::extra_scripts				// Run Extra scripts
	exec local.path::console_scripts				// Setup Console and punishment script variables

	local.campersettings = waitexec local.path::cvars		// Get cvars and register them as cvars
	thread register local.campersettings					// Create the cvars
end



update_allcmds local.cmds:

	local.n = 0
	for(local.i=1;local.i <= local.cmds.size;local.i++)
	{
		for(local.t=1;local.t <= local.cmds[local.i].size; local.t++ )
		{
			local.n++
			for(local.s=1;local.s <= local.cmds[local.i][local.t].size; local.s++ )
			{
				game.all_commands[local.n][local.s] = local.cmds[local.i][local.t][local.s]
			}
		}
	}

end

add_cmds local.cmds:

	local.n = game.all_commands.size

	if(local.n == -1)
	{
		local.n = 0
	}
	for(local.i=1;local.i <= local.cmds.size;local.i++)
	{
		local.n++
		for(local.t=1;local.t <= local.cmds[local.i].size; local.t++ )
		{
			game.all_commands[local.n][local.t] = local.cmds[local.i][local.t]
		}
	}
end



register local.campersettings:

	for(local.campset=1;local.campset <= local.campersettings.size; local.campset++)
	{
		setcvar local.campersettings[local.campset] [1] local.campersettings[local.campset] [2]
	}	
end


getgame:
	local.game = getcvar "version"
	local.i=15

	if(local.game[local.i]==" ")
	{
		local.i= 16
	}

	local.gamestates = waitexec game.file["settings/advanced"]::statefiles

	for(local.g=1;local.g <= local.gamestates.size;local.g++)
	{
		if(local.game[local.i]==local.gamestates[local.g][1])
		{		
			local.state = local.gamestates[local.g] [2]
			break
		}
	}

	switch(local.game[local.i])
	{
	case "A":
		setcvar "g_statefile" local.state
		game.game = "AA"
	break 
	case "S":
		setcvar "g_statefile" local.state
		game.game = "SH"
	break
	case "B":
		setcvar "g_statefile" local.state
		game.game = "BT"
	break
	}

end


//get a command, thread with cmd and param, will return the info

getcmd local.cmdwant local.index:

	if(local.index==NIL)
	{
		local.index=2
	}

	for(local.i=1;local.i<=game.all_commands.size;local.i++)
	{	
		local.cmdask = game.all_commands[local.i] [1]

		if(local.cmdask == local.cmdwant)
		{
			local.answer = game.all_commands[local.i] [local.index]
					//iprintlnbold local.answer
			end local.answer

		}
	}

end NIL

//set a command, thread with cmd and param
//usage:
// exec setcmd ( command_to_change ) ( new setting ) ( int index )
//

setcmd local.cmdwant local.setting local.index :

	if(local.index==NIL)
	{
		local.index=2
	}

	for(local.i=1;local.i<=game.all_commands.size;local.i++)
	{	
		if(game.all_commands[local.i][1] == local.cmdwant)
		{
			game.all_commands[local.i] [local.index] = local.setting 
			end
		}
	}
end 


// get map str

get_mapstr:

	level.mapname = getcvar "mapname"
	level.map_specific = level.mapname
	local.pos = waitexec global/strings.scr::InStr "/" level.map_specific
	
	if(local.pos != NIL) //single player map
	{
		local.pos = level.map_specific.size - local.pos
		level.map_specific = waitexec global/strings.scr::Right local.pos level.map_specific
	}
	
	level.map_shortname = level.map_specific
	level.map_specific = ("_" + level.map_specific + ".txt" )

end

	
clear_spawn_scripts:
	
	//level.spawn_scripts

	local.scripts = NIL
	local.t = 0
	for(local.i= 1 ;local.i <= game.spawn_scripts.size ; local.i++ )
	{
	//	iprintlnbold ( level.spawn_scripts[local.i][2] + " " + level.run[level.spawn_scripts[local.i][2] ])

		if(level.run[game.spawn_scripts[local.i][2] ] == "1" || game.spawn_scripts[local.i][2] == "none")
		{
			local.t++
			local.scripts[local.t][1] = level.spawn_scripts[local.i][1]
			local.scripts[local.t][2] = level.spawn_scripts[local.i][2]
			local.scripts[local.t][3] = level.spawn_scripts[local.i][3]	
		}
	}

	level.spawn_scripts = NIL
	level.spawn_scripts = local.scripts

end

clear_spawn_scripts_with:
	
	//level.spawn_scripts

	local.scripts = NIL
	local.t = 0
	local.changed = 0
	for(local.i= 1 ;local.i <= game.spawn_scripts.size ; local.i++ )
	{
	//	iprintlnbold ( level.spawn_scripts[local.i][2] + " " + level.run[level.spawn_scripts[local.i][2] ])

		if(level.run[game.spawn_scripts[local.i][2] ] == "1" || game.spawn_scripts[local.i][2] == "none")
		{
			local.changed =1
			local.t++
			local.scripts[local.t][1] = game.spawn_scripts[local.i][1]
			local.scripts[local.t][2] = game.spawn_scripts[local.i][2]
			local.scripts[local.t][3] = game.spawn_scripts[local.i][3]	
		}
	}

	if(local.changed == 1)
	{
		level.spawn_scripts = NIL
		level.spawn_scripts = local.scripts
	}

end



//********************************************************
// Loads settings for mods turned on in console
//
//********************************************************

Loadsettings local.mod:

	if(local.mod[7] != "none" && local.mod[2] == "1")
	{
		exec global/ac/console_feedback.scr ( ">Loading  settings for " + local.mod[1] )

		if(local.mod[8] != "0")
		{
			local.path = ( local.mod[7] + level.map_specific )
		}
		else
		{
			local.path = ( local.mod[7] + ".txt")
		}
		
		local.cmds =  waitexec local.path

		//check its there
		if(local.cmds == NIL)
		{
			exec global/ac/console_feedback.scr ("Could not find " + local.path )					// message the admins with what is wrong.
			local.path = ( local.mod[7] + ".txt")
			exec global/ac/console_feedback.scr ("Loading " + local.path )	
			// reload normal path
			local.cmds =  waitexec local.path
		}


		game.file[local.mod[1]] = local.path
		waitthread add_cmds local.cmds
	}
end


```

# zz_admin-Pro_1.22_modif\global\sounds.scr

```scr
// 23/11/2005 08:55 added jetpack sound

//cache file

main:
	//cache sounds
	local.master = spawn ScriptMaster

	// aliascache (?alias?) snd wavfile soundparms basevol volmod basepitch pitchmod minDist maxDist channel loaded|streamed maps "mapstr1 mapstring2 mapstring3 ..."

	//Camper mod
	local.master aliascache streamed_dfr_scripted_M3L1_016a sound/dialogue/m3l1/A/dfr_scripted_M3L1_016a.wav soundparms 1.5 0.0 1.0 0.0 200 1500 dialog streamed subtitle "You stay in one spot, you're a dead man!" maps level.mapname
	local.master aliascache camper_bombtick sound/items/Item_Timer_01.wav soundparms 0.7 0.0 1.0 0.0 200 500 local loaded maps level.mapname
	local.master aliascache camper_final_countdown sound/items/final_countdown.wav soundparms 1.5 0.0 1.0 0.0 200 500 local loaded maps level.mapname

	// punishments
	local.master aliascache alarm_switch sound/mechanics/Mec_Switch_05.wav soundparms 1.5 0.0 1.0 0.0 800 3000 auto loaded maps level.mapname
	local.master aliascache snd_landing_stone1 sound/characters/fs_stone_land_01.wav soundparms 0.9 0.2 0.9 0.2 200 2500 auto loaded maps level.mapname

	local.master aliascache thunder1 sound/amb/Amb_Thunder_01.wav soundparms 1.0 0.0 1.0 0.0 3000 6000 auto streamed maps level.mapname
	local.master aliascache rain_ext sound/amb/Amb_RainExt_01.wav soundparms 1.0 0.0 1.0 0.0 3000 6000 local streamed maps level.mapname

//	local.master aliascache leadinmp2 sound/weapons/explo/Exp_LeadIn_07.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps level.mapnamestring

	//jetpack stuff
	local.master aliascache jetpack sound/mechanics/Mec_SteamLoop_01.wav soundparms 1.0 0.3 1.0 0.0 320 2200 item loaded maps level.mapname
	//local.master aliascache jetpack sound/mechanics/Mec_SteamLoop_01.wav soundparms 0.1 0.1 0.0 0.0 320 2200 item loaded maps level.mapname
	//local.master aliascache jetpack_boost sound/mechanics/Mec_SteamLoop_01.wav soundparms 9.0 9.3 5.0 5.0 320 2200 item loaded maps level.mapname

end
```

# zz_admin-Pro_1.22_modif\global\strings.scr

```scr


// 11 September 2005 added 3 new functions
// array_to_int
// array_to_str
// array_to_float

/*
Array_to_lower
Array_to_upper
to_lower
to_upper
InStr
Right
left
Mid
Reverse
split_line
Replace
Remove
Format_replace
array_to_int
array_to_str
array_to_float
*/


// Convert a array to lower  case.
// usage: exec global/strings.scr::Array_to_lower (const array of strings)
// returns: Array of lower case strings

Array_to_lower local.strings:

	local.lower = waitthread chardata_lowercase
	local.upper = waitthread chardata_uppercase

	for(local.linni = 1; local.linni <= local.strings.size; local.linni++)
	{	
		for(local.anniken = 1; local.anniken <= local.strings[local.linni].size; local.anniken++)
		{
			local.string = local.strings[local.linni] [local.anniken]

			for(local.i = 0; local.i <= local.string.size - 1; local.i++)
			{
				local.letter = local.string[local.i]
				for(local.t = 1; local.t <= local.upper.size; local.t++)
				{
					if(local.letter == local.upper[local.t])
					{	
						local.letter = local.lower[local.t] 
						local.string[local.i] = local.letter 
					}
				}

			}
			local.strings[local.linni][local.anniken] = local.string
		}
	}

end  local.strings



// Convert a array to upper case.
// usage: exec global/strings.scr::Array_to_upper (const array of strings)
// returns: Array of upper case strings

Array_to_upper local.strings:

	local.lower = waitthread chardata_uppercase 
	local.upper = waitthread chardata_lowercase
 
	for(local.linni = 1; local.linni <= local.strings.size; local.linni++)
	{	
		for(local.anniken = 1; local.anniken <= local.strings[local.linni].size; local.anniken++)
		{
			local.string = local.strings[local.linni] [local.anniken]

			for(local.i = 0; local.i <= local.string.size - 1; local.i++)
			{
				local.letter = local.string[local.i]
				for(local.t = 1; local.t <= local.upper.size; local.t++)
				{
					if(local.letter == local.upper[local.t])
					{	
						local.letter = local.lower[local.t] 
						local.string[local.i] = local.letter 
					}
				}

			}
			local.strings[local.linni][local.anniken] = local.string
		}
	}

end  local.strings


	
//stolen arrays from jv's string handler:D
//of cause by jv

// returns all lowercase chars
chardata_lowercase:
	local.hasharray = makeArray
	a
	b
	c
	d
	e
	f
	g
	h
	i
	j
	k
	l
	m
	n
	o
	p
	q
	r
	s
	t
	u
	v
	w
	x
	y
	z
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	

end local.array

// returns all uppercase chars
chardata_uppercase:
	local.hasharray = makeArray
	A
	B
	C
	D
	E
	F
	G
	H
	I
	J
	K
	L
	M
	N
	O
	P
	Q
	R
	S
	T
	U
	V
	W
	X
	Y
	Z
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	
end local.array


// instr
// Instr will find the position in wich a string is found at.
// Usage: exec global/strings.scr::InStr (string to find \ string)
// returns the position of string_to_find
// eg
// exec global/strings.scr::InStr "\" "hell\o"
// gives 4 because it starts at 0

// If none found it will return NIL
InStr local.char local.string:

	if(local.char.size == 1)
	{
		local.checktype = 0
	}
	else
	{
		local.checktype = 1
	}

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		if(local.checktype == 0)
		{
			local.check =  (local.char ==  local.string[local.i])
		}
		else
		{
			local.check =  (local.char[0] ==  local.string[local.i])
		}

		if(local.check)
		{
			if(local.checktype == 0)
			{
				local.i++
				end local.i
			}
			else
			{
				local.m = local.i
				for(local.t = 0;local.t <= local.char.size - 1 ;local.t++)
				{
					if(local.char[local.t] != local.string[local.m])
					{
						local.no = 1
					}
					local.m++
				}

				if(local.no != 1)
				{
					local.i++
					end local.i
				}
			}

		}
	}
end



// Rightr
// Right will return a string of characters from the right.
// usage: waitexec global/strings.scr::Right ( Number of characters#, STRING STRING )
// Returns a string right from the number given as position
// eg
// local.string = waitexec global/strings.scr::Right 3 "hello"
// local.string will be 'llo'
Right local.pos local.string:

	local.start = local.string.size - local.pos
	local.right = ""

	for(local.i = local.start; local.i <= local.string.size - 1 ; local.i++)
	{
		local.right += local.string[local.i]
	}

end local.right



// Left
// Left will return Left of the string for the given number.
// usage: waitexec global/strings.scr::Right (NUMBER OF CHARACTERS LEFT, STRING STRING )
// Returns a string left from the number given as position
// eg
// local.string = waitexec global/strings.scr::Left 3 "hello" 
// local.string will be 'hell'
// 
Left local.pos local.string:

	local.pos--
	local.left = ""
	for(local.i = 0; local.i <=  local.pos; local.i++)
	{
		local.left += local.string[local.i]
	}

end local.left



//Mid
//mid will return a string from a given position for a given number of characters.
// usage: local.string = waitexec global/strings.scr ( START POS, STRING, COUNT)
// returns: The string from start pos of string along the count.
//
//eg
// local.string = waitexec global/strings.scr 3 "hello" 2 
// local.string would become 'll'
Mid local.start local.string local.count:

	local.start--
	local.mid = ""

	for(local.i = 1; local.i <= local.count;local.i++)
	{
		local.mid += local.string[local.start]
		local.start++
	}

end local.mid




//Reverse
// Reverse will reverse a given string.
//useage:: local.string = waitexec global/strings.scr (STRING STRING)
// result: gives a string that is backwards to the string given.
//
//eg
// local.string = waitexec global/strings.scr::Reverse "hello" 
// local.string would become 'olleh'
Reverse local.string:

	local.left = ""
	for(local.i = local.string.size - 1; local.i >=  0; local.i--)
	{
		local.left += local.string[local.i]
	}

end local.left



// to_lower
// This will convert a given string to lower case
// usage local.string = waitexec global/strings.scr::to_lower (STRING STRING, INDEX TO CONVERT)
// Result: a lower case string
//
//eg
// local.string = waitexec global/strings.scr::to_lower "HELLO" 
// local.string will become 'hello'
//eg2
// local.string = waitexec global/strings.scr::to_lower "HELLO" 0
// local.string will become 'hELLO'
to_lower local.string local.index:

	local.lower = waitthread chardata_lowercase
	local.upper = waitthread chardata_uppercase

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		local.letter = local.string[local.i]

		if(local.i == local.index || local.index == NIL)
		{
			for(local.t = 1; local.t <= local.upper.size; local.t++)
			{
				if(local.letter == local.upper[local.t])
				{	
					local.letter = local.lower[local.t] 
					local.string[local.i] = local.letter 
				}
			}
		}
		else
		{
			local.string[local.i] = local.letter 
		}

	}

end local.string



// to_upper
// This will convert a given string to upper case
// usage local.string = waitexec global/strings.scr::to_upper (STRING STRING, INDEX TO CONVERT)
// Result: a upper case string
//
//eg
// local.string = waitexec global/strings.scr::to_upper "hello" 
// local.string will become 'HELLO'
//eg2
// local.string = waitexec global/strings.scr::to_upper "hello" 0
// local.string will become 'Hello'

to_upper local.string local.index:

	local.upper = waitthread chardata_lowercase
	local.lower = waitthread chardata_uppercase

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		local.letter = local.string[local.i]

		if(local.i == local.index || local.index == NIL)
		{
			for(local.t = 1; local.t <= local.upper.size; local.t++)
			{
				if(local.letter == local.upper[local.t])
				{	
					local.letter = local.lower[local.t] 
					local.string[local.i] = local.letter 
				}
			}
		}
		else
		{
			local.string[local.i] = local.letter 
		}

	}

end local.string



// Used to split a line of words into a array of words. return with word count
// localinfo == line to split
// local.say = say to admins input detected or not, set 1 usualy
// local.spacer = What to use to split the line. If none is set then " " will be used.
// usage local.wordarray = waitexec global/strings.scr::split_line ( STRING STRING , CONSOLE FEEDBACK, STRING SPACER)
//
//eg
//  local.wordarray = waitexec global/strings.scr::split_line "hello_mummy" 1 "_"
// local.wordarray is a const array
//
// local.wordarray[1] = array of words
// local.wordarray[2] word count
// local.wordarray[3] full string with " " spaces
//
// local.wordarray[1][1] is 'hello'
// local.wordarray[1][1] is 'mummy'
//
// local.wordarray[2] is 2 'two words'
//
// local.wordarray[3] is 'hello mummy'
//

split_line local.info local.dont_say local.spacer:

	local.wordcount = 1

	if(local.spacer==NIL)
	{
		if(local.info[0] == "`")
		{
			local.spacer = "_"
			local.start = 1
		}
		else if(local.info[0] == " " || local.info[0] == "")
		{
			local.spacer = " "

			for(local.i = 0;local.i <= local.info.size;local.i++)
			{
				if(local.info[local.i] != " " && local.info[local.i] != "")
				{
					local.start = local.i
					break
				}
			}

		}
		else 
		{
			local.spacer = " "
			local.start = 0
		}
	}
	else
	{
		local.start = 0
		local.altcheck = 1
	}

	for(local.i=local.start;local.i<=local.info.size - 1;local.i++)
	{	
		if(local.info[local.i]!=local.spacer && local.info[local.i] != "`")
		{
			if(local.words[local.wordcount]==NIL)
			{
				local.words[local.wordcount]=""
			}

			local.words[local.wordcount] += local.info[local.i]
		}
		else
		{	
			if(local.altcheck != 1)
			{
				if(local.spacer == "_" && local.info[local.i + 1] == "`")	// if its like ui_hud 1. sud be ui_`hud so it knows:).
				{
					local.words[local.wordcount] += local.info[local.i]			
				}
				else if(local.spacer == "_" && local.info[local.i ] != "`")
				{
					local.wordcount++
				}
				else if(local.spacer == " " && local.info[local.i ] == " ")
				{
					if(local.i != local.info.size - 1)
					{
						if(local.info[local.i + 1] != " " && local.info[local.i + 1] != NIL)
						{
							local.wordcount++
						}
					}
				}
			}
			else
			{
				if(local.info[local.i ] == local.spacer)
				{
					local.wordcount++
				}
			}
		}
	}	

	if(local.spacer == "_")
	{
		local.actual = ""

		for(local.i=3;local.i<=local.words.size;local.i++)
		{
			if(local.i < local.words.size)
			{
				local.space = " "
			}
			else
			{
				local.space = ""
			}
			local.actual += ( local.words[local.i] + local.space )
		}

		if(local.dont_say != 1)
		{
			exec global/ac/console_feedback.scr ( "> Input detected: " + local.actual )
		}
	}
	else
	{
		if(local.dont_say != 1)
		{
			exec global/ac/console_feedback.scr ( "> Input detected: " + local.info)
			local.actual = local.info
		}
	}

end ( local.words::local.wordcount::local.actual) 




// Replace is used just like replace in notepad or any text editor. 
// It will replace any string in a string with a string of any size. 
//
// exec global/strings::Replace ( String string , String String to replace, string string to replace with )
//
// eg
// local.string = waitexec global/strings.scr::Replace "once_upon_a_time_there_was__a_mod" "_" " "
// local.string would become
// "once upon a time there was  a mod" 

Replace local.string local.replace local.replace_with:


	if(local.replace.size == 1)
	{
		local.checktype = 0
	}
	else
	{
		local.checktype = 1
	}
	
	local.new_str = ""

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		if(local.checktype == 0)
		{
			local.check =  (local.replace ==  local.string[local.i])
		}
		else
		{
			local.check =  (local.replace[0] ==  local.string[local.i])
		}

		if(local.check)
		{
			if(local.checktype == 0)
			{
				if(local.replace_with.size == 1)
				{
					local.new_str += local.replace_with
				}
				else
				{
					for(local.t = 0;local.t <= local.replace_with.size - 1 ;local.t++)
					{
						local.new_str += local.replace_with[local.t]
					}
				}

			}
			else
			{
				local.no = 0
				local.m = local.i
				for(local.t = 0;local.t <= local.replace.size - 1 ;local.t++)
				{
					if(local.replace[local.t] != local.string[local.m])
					{
						local.no = 1
					}
					local.m++
				}

				if(local.no != 1)
				{
					for(local.t = 0;local.t <= local.replace_with.size - 1 ;local.t++)
					{
						local.new_str += local.replace_with[local.t]
					}
					local.i += local.replace.size - 1
				}
				else
				{
					local.new_str += local.string[local.i]
				}
				
			}

		}
		else
		{
			local.new_str += local.string[local.i]
		}
	}

end local.new_str 




// Remove is used to remove words or single characters from a line.
//
// exec global/strings::Remove ( String string , String String to replace )
//
// eg
// local.string = waitexec global/strings.scr::Remove "hello you idiot" "idiot"
// local.string would become
// "hello you idiot"

Remove local.string local.string_remove:

	local.string = waitthread Replace local.string local.string_remove ""

end local.string




// Format_replace is used like Replace except it will only replace a single instance in a group of the same character.
// It will only replace single characters.
//
// exec global/strings::Replace ( String string , String String to replace, string string to replace with )
//
// eg
// local.string = waitexec global/strings.scr::Format_replace "once_upon_a_time_there_was__a_mod" "_" " "
// local.string would become
// "once upon a time there was_a mod" 

Format_replace local.string local.replace local.replace_with:

	local.new_str = ""

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{

		local.check =  (local.replace ==  local.string[local.i] && local.replace != local.string[local.i + 1])

		if(local.check)
		{
			if ( local.string[local.i - 1] !=  local.replace)
			{
				local.new_str += local.replace_with
			}
		}
		else
		{
			local.new_str += local.string[local.i]
		}
	}

end local.new_str 


// Combine combines a array of stirngs into one single string of all.
// exec global/strings:;Combine (ARRAY , INT START IN ARRAY)
// 

Combine local.words local.start:

	local.actual = ""

	for(local.i=local.start;local.i<=local.words.size;local.i++)
	{
		if(local.i < local.words.size)
		{
			local.space = " "
		}
		else
		{
			local.space = ""
		}

		local.actual += ( local.words[local.i] + local.space )
	}

end local.actual

// array_to_int
// converts a array into interger
// returns the array as int

array_to_int local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = int local.array[local.i]
	}

end local.array

// array_to_str
// converts a array into string
// returns the array as string
array_to_str local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = string local.array[local.i]
	}

end local.array

// array_to_float
// converts a array into float
// returns the array as float
array_to_float local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = float local.array[local.i]
	}

end local.array

```

# zz_admin-Pro_1.22_modif\global\under_map.scr

```scr
// 24/11/2005 23:44 added null and nil check

//All credit goes to mefy. So ty mefy (Mark Follett). This is his script for detecting players under the map.
// I just fiddled with it some what to make it run.
main:

	if(game.undermap != 1)
	{
		end
	}

	local.numbers = waitthread check_under_map

	if(local.numbers == NIL)
	{
		end
	}

	while(1)
	{
		wait 3
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			wait 1
			if($player[local.i].dmteam != "spectator" && isalive $player[local.i] && $player[local.i].flying != 1 )
			{
				if($player[local.i] waitthread check_player local.numbers[1] local.numbers[2])
				{
					//self stufftext "say I was detected out of bounds!"
					if(self != NULL && self != NIL)
					{
						self respawn
						self.forcespawn = 1
						self iprint "You are not allowed under the map"
					}
				}

			}
		}
	}
	
end


check_under_map:
	// sets the z values of the invisible floor that the player can stand on
	// while under the map

	switch (level.mapname)
	{
		case "dm/mohdm2":
			local.botz = -128.125
			local.topz = -95.875
			break
				
		case "obj/obj_team1":
			local.botz = -520.125
			local.topz = -511.875
			break
				
		case "obj/obj_team3":
			local.botz = -728.125
			local.topz = -719.875
			break
		
		case "dm/mohdm3":
			local.botz = -224.125
			local.topz = -215.875
			break

		case "dm/mohdm4":
		case "obj/obj_team4":
			local.botz = -16.125
			local.topz = 0.125
			break
			
		default:
			end
			break
	}

end (local.botz::local.topz)

check_player local.botz local.topz:

	local.zlow = -8000
	local.zhigh = 8000

	local.orglow = self.origin
	local.orglow[2] = local.zlow
	
	local.orghigh = self.origin
	local.orghigh[2] = local.zhigh
	
	// do a couple traces
	// first one goes down from the players feet to determine the
	// z value of the ground they're standing on
	// second one comes up from the very bottom of the map to
	// determine the lowest z value
	local.down = trace (self.origin + ( 0 0 10 )) local.orglow 1 ( -5 -5 0 ) ( 5 5 0 )
	local.up = trace local.orglow local.orghigh

	// this prints out the two z values
//	println ("BOTZ: " + local.up[2] + " TOPZ: " + local.down[2])

	// check to see if they match the ones for this map, if so, the
	// player is under the map
	if (((abs (local.down[2] - local.topz)) < 0.001) && ((abs (local.up[2] - local.botz)) < 0.001))
	{
		end 1
	}

end


```

# zz_admin-Pro_1.22_modif\global\weapon_skin_fix.scr

```scr
main:
	switch(self.dmteam)
	{
	case "axis":
		switch(self.nationalityprefix)
		{
		case "dfr":
		case "dfrru":
		case "dfruk":
			self stufftext "dm_playergermanmodel german_wehrmacht_soldier"
			self spectator
			self iprint "Please select German or Italian skin."
		break
		}
	break
	case "allies":

		switch(self.nationalityprefix)
		{
		case "den":
		case "denit":
			self stufftext "dm_playermodel american_army"
			self stufftext " cmd spectator"
			self iprint "Please select an American,British or Russian skin."
		break
		
		}
	break
	}
end
```

# zz_admin-Pro_1.22_modif\HTR\camera.scr

```scr
main local.dmteam:

	level.round_times = getcvar "countdown_times"
	level.round_times = int level .round_times
	level.round_times++
	setcvar "countdown_times" level.round_times

	spawn Camera targetname "camera" origin self.origin 
	$camera follow_distance 190
	$camera orbit_height 70
	$camera speed 1.4

	drawhud 0

	letterbox 1
	self waitexec global/get_weapon.scr
	local.player = spawn animate
	local.player.model = self.brushmodel
	local.player hide
	local.player notsolid
	local.player.origin = self.origin
	local.player.angles = self.angles
	local.player show


	//$player noclip	
	self respawn
	$player hide
	
	freezeplayer $player


	if(self.weapon != "models/weapons/unarmed.tik")
	{
		local.player anim unarmed_run_into_wall					
	}
	else
	{
		local.player anim unarmed_stand_idle	 							
	}

	local.gun = spawn animate
	local.gun.model = self.weapon
	local.gun.origin = local.player.origin

	local.gun attach local.player  "tag_weapon_right"
	local.player attachmodel "items/walkietalkie.tik" "Bip01 Pelvis" 0.8 "fake_pelvis_radio" 1 -1 -1 -1 -1 ( 1.5 -4 -10.0 )
	$fake_pelvis_radio.angles = ( 0 90 90 )


	$camera orbit local.player 

	fadein 5.0 0.0 0.0 0.0 1.0

	wait 1
	
	local.gt = getcvar "g_gametype"

	setcvar "g_gametype" "4"

	teamwin local.dmteam

	setcvar "g_gametype" local.gt
	
	wait 2

	cuecamera $camera

	wait 4

	clearletterbox
	cueplayer

	$fake_pelvis_radio delete
	local.player delete

	releaseplayer  $player
	

end


custom_cam:

	spawn Camera targetname "camera" origin self.origin 
	$camera follow_distance 190
	$camera orbit_height 70
	$camera speed 1.4

	drawhud 0

	letterbox 1

	//freeze player
	freezeplayer $player


	// orbit the radio
	$camera orbit $countdown_radio

	//some effects
	fadein 5.0 0.0 0.0 0.0 1.0
	// watch for 5 seconds

	wait 5


	clearletterbox
	cueplayer

	releaseplayer  $player
	$camera delete

end


```

# zz_admin-Pro_1.22_modif\HTR\hud.scr

```scr
main local.team:

	//only do one at a time instead of 2

	local.times[1] = "minutes"
	local.times[2] = "seconds"


	local.total = ""

	for(local.o = 1; local.o <= local.times.size ;local.o++)
	{
		local.time = level.countdown[local.team][local.times[local.o]]
		local.time = string local.time

		if(local.time.size > 1)
		{
			local.total +=local.time 
		}
		else
		{
			local.total += "0" + local.time 
		}

		if (local.o == 1)
		{
			local.total += ":"
		}
	}
	

	if(local.team == "allies")
	{
		thread update_axis local.total
	}
	else
	{
		thread update_allies local.total
	}

end

update_axis local.total:
	//axis

	huddraw_align 61 right top
	huddraw_font 61 facfont-20
	huddraw_rect 61 -50 100 100 100

	if(level.hudcolour["allies"] == 1)
	{
		huddraw_color 61 1 0 0
	}
	else
	{
		if(level.hudyellow  == "allies")
		{
			huddraw_color 61 1 1 0
		}
		else
		{
			huddraw_color 61 1 1 1
		}
	}

	huddraw_alpha 61 1.0
	huddraw_string 61 (local.total)

end

update_allies local.total:
	//allies 
	
	huddraw_align 63 right top
	huddraw_font 63 facfont-20
	huddraw_rect 63 -50 80 100 100

	if(level.hudcolour["axis"] == 1)
	{
		huddraw_color 63 1 0 0
	}
	else
	{
		if(level.hudyellow  == "axis")
		{
			huddraw_color 63 1 1 0
		}
		else
		{
			huddraw_color 63 1 1 1
		}
	}

	huddraw_alpha 63 1.0
	huddraw_string 63 (local.total)

end

countdown:
	//hehehe


	thread main "allies"
	thread main "axis"

	huddraw_align 60 right top
	huddraw_font 60 facfont-20
	huddraw_rect 60 -80 55 80 20
	huddraw_color 60 0.50 0.50 0.25 
	huddraw_alpha 60 1.0
	huddraw_string 60 ("Countdown")

	huddraw_shader 64 ("textures/hud/allies")
	huddraw_align 64 right top
	huddraw_rect 64 -80 73 25 25
	huddraw_color 64 1 1 1
	huddraw_alpha 64 1.0

	huddraw_shader 62 ("textures/hud/axis")
	huddraw_align 62 right top
	huddraw_rect 62 -80 98 25 25
	huddraw_color 62 1 1 1
	huddraw_alpha 62 1.0


end

location local.location local.locate_time:
	//hehehe
	huddraw_align 65 left bottom
	huddraw_font 65 facfont-20
	huddraw_rect 65 15 -110 100 100
	huddraw_color 65 1 0 0
	huddraw_string 65 local.location

	for (local.i = 0; local.i <= 1; local.i += .1)
	{
		huddraw_alpha 65 local.i
		waitframe
	}

	huddraw_alpha 65 1.0
//	huddraw_virtualsize 65 1

	wait 3

	for (local.i = 1; local.i >= 0; local.i -= .1)
	{
		huddraw_alpha 65 local.i
		waitframe
	}
	
end

```

# zz_admin-Pro_1.22_modif\HTR\player_radio.scr

```scr
// 22 November 2005 17:20:57 
// Added code for radio drop. The radio will drop if hgeld too long

main:

	self.flying = 1 //stop them using the plane

	local.team = self.dmteam
	
	level.clockside = local.team

	level.hudyellow = local.team
	
	local.locate_time = waitexec global/settings.scr::getcmd "countdown-locate"
	local.locate_time = int local.locate_time
	
	local.locate = level.countdown[local.team]["seconds"] - local.locate_time

	if(local.locate <= 0 )
	{
		local.locate = local.locate_time - level.countdown[local.team]["seconds"]
		local.locate = 60 - local.locate_time
	}	

	
	local.held_for = 0	//Time help for before the radio is dropped
	local.max_hold_time = int (waitexec global/settings.scr::getcmd "countdown-hold-for") //get the time to hold for

	// if only 1 player per team are in the game dissable the radio drop feature.
	if($player.size <= 2)
	{
		local.team_no = waitexec global/nagle.scr::team_count

		if(local.team_no[local.team] < 2 )
		{
			local.max_hold_time = 0
		}
	}

	if(local.max_hold_time > 0)
	{
		thread display
		self.no_usemine = 1 //stop them using a mine
		self.no_usemedic = 1 //stop medics
	
		self iprint ("You have " + local.max_hold_time + " seconds to pass the radio") 
	}

	local.use_held = 0 // if the player holds use for 2 seconds then pass the radio

	while(isalive self && self.dmteam == local.team && self != NULL && self != NIL)
	{

		local.origin = self.origin
		wait 1
	//	level.countdown_seconds[local.team]--
			
		level.countdown[local.team]["seconds"]--

		if (level.countdown[local.team]["seconds"] <= 0)
		{

			level.countdown[local.team]["minutes"]--

			if(level.countdown[local.team]["minutes"] <= -1 )
			{
				$player stoploopsound final_countdown
				level.countdown[local.team]["minutes"] = 0
				exec HTR/hud.scr local.team

				waitthread blow_up local.team
				$pelvis_bomb delete
				$pelvis_radio delete

				waitexec HTR/camera.scr local.team
	
				
				end
			}

			level.countdown[local.team]["seconds"] = 60
		}
		else if (level.countdown[local.team]["seconds"] <= 10 && level.countdown[local.team]["minutes"] <= 0 && local.ticking != 1)
		{
			$player loopsound final_countdown 
			level.hudcolour[local.team] = 1
			local.ticking = 1
		}

		exec HTR/hud.scr local.team
	
		if(local.locate_time != 0)
		{
			if(level.countdown[local.team]["seconds"] == local.locate)
			{
				local.pos = waitexec global/libmef/mapdesc.scr::get_player_position self.origin

				if(local.pos != "" && local.pos != NULL && local.pos != NIL)
				{
					exec HTR/hud.scr::location ("Radio location: " +  local.pos ) local.locate_time
					local.locate = level.countdown[local.team]["seconds"] - local.locate_time

					if(local.locate <= 0 )
					{
						local.locate = local.locate_time - level.countdown[local.team]["seconds"]
						local.locate = 60 - local.locate_time
					}
				}
			}
			else
			{
			//	exec HTR/hud.scr::location ""
			}


		}

		// Add 1 second to the time the radio was held for.
		local.held_for++

		if( local.max_hold_time  > 0)
		{
			thread display_hold_time (local.max_hold_time - local.held_for)

			if(local.held_for == local.max_hold_time) // IF the player has held this radio for the maximun hold time then drop the radio and dissallow 
			{					  // them to pick it up next.
				local.origin = $pelvis_radio.origin::"hog"	
				level.last_had_radio = self
				break
			}				
			
		}

		//check if we have held use for 2 seconds to pass the radio
		if(self.useheld == 1)
		{
			local.use_held++

			if(local.use_held == 2)
			{
				// if we are next to a player facing them etc 
				local.player = waitexec global/ac/medics/hold_check.scr::check_players

				// pass the radio
				if(local.player != NIL)
				{
					//clear stuff
					$pelvis_radio delete
					self light 0 0 0 0
					
					waitframe

					//give the new player the radio
					exec htr/radio.scr::give_radio local.player
								
					//tell them so they know
					self iprint "You passed the radio"
					local.player iprint "You have been passed the radio"
					
					//exit this
					self.flying = 0 //allow them to use the plane again
					end 
				}
			
				local.use_held = 0
			}		
		}
		else
		{
			local.use_held = 0
		}

		//exec HTR/hud.scr local.team
	}

	self.flying = 0 //allow them to use the plane again

	self stufftext "hidemenu dday1"

	$pelvis_radio delete

	self light 0 0 0 0

	exec HTR/radio.scr local.origin

	if (local.ticking == 1)
	{
		$player stoploopsound final_countdown
	}

	level.hudyellow = "none"

	exec HTR/hud.scr::countdown

	local.locate_time = waitexec global/settings.scr::getcmd "death-location"

	if(local.locate_time == "1")
	{
		local.team  = waitexec global/strings.scr::to_upper local.team  0

		local.pos = waitexec global/libmef/mapdesc.scr::get_player_position self.origin
		
		if(local.pos != "" || local.pos != NULL || local.pos != NIL)
		{
			iprintlnbold_noloc (local.team  + " have dropped the radio! " + local.pos)
		}
		else
		{
			iprintlnbold_noloc (local.team  + " have dropped the radio!")
		}
	}

end

blow_up local.team:

	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		if($player[local.i].dmteam != local.team)
		{
			thread boom $player[local.i].origin
		}
	}
end

boom local.place:

	local.Exp3 = spawn "fx/scriptbazookaexplosion.tik"
	local.Exp4 = spawn "animate/fx_mortar_dirt.tik"
	local.Exp3 radiusdamage 0
	local.Exp3.origin = local.place
	local.Exp4.origin = local.place
	local.Exp3 anim start
	local.Exp4 anim start

	wait 1
	local.Exp3 delete	
	local.Exp4 delete
 
end

display_hold_time local.time:

	self stufftext ("set HTR_secondsleft You must pass the radio, Time Left: " + local.time)

end

display:

	self stufftext "globalwidgetcommand dday1 shader townhallwindow"
	self stufftext "globalwidgetcommand dday1 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday1 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand dday1 fadein 0"
	self stufftext "globalwidgetcommand dday1 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday1 virtualres 1" 
	self stufftext "globalwidgetcommand dday1 fullscreen 1" 

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader townhallwindow" // textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 200 15"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar HTR_secondsleft"

	self stufftext "showmenu dday1"

end

```

# zz_admin-Pro_1.22_modif\HTR\player_scan.scr

```scr
main:
	while(1)
	{	

		for (local.i = 1;local.i <= $player.size; local.i++ )
		{
			if($player[local.i].gotbomb != 1 && $player[local.i].dmteam != "spectator")
			{
				$player[local.i] attachmodel "items/explosive.tik" "Bip01 Pelvis" 0.8 "pelvis_bomb" 0 -1 -1 -1 -1 ( 1.5 -4 10.0 )
				$pelvis_bomb[$pelvis_bomb.size].angles = ( 0 90 90 )
				$player[local.i].gotbomb = 1
				$player playsound plantbomb1
			}
		}

		wait 1
		
		exec HTR/hud.scr::countdown
	}
end
```

# zz_admin-Pro_1.22_modif\HTR\radio.scr

```scr
// 22/11/2005 18:07 added in radio drop features

main local.origin:

	spawn level.radio_model "targetname" "countdown_radio" "classname" "scriptmodel"
	//local.radio model "items/explosive.tik" //"items/walkietalkie.tik"
	local.radio = $countdown_radio
	local.radio notsolid
	local.radio hide

	if(local.origin[2] == "hog")
	{
		local.radio.origin = local.origin[1]
		
		//check if the radio is toching any of the players and wait until it is not to show it.

		while(1)
		{
			wait 1
			
			// if the players are touching it then local.i wont == player size
			for(local.i=1;local.i <= $player.size ;local.i++ )
			{
				if(local.radio istouching $player[local.i])
				{
					break
				}
			}

			if(local.i == ($player.size + 1))
			{
				break
			}

		}
	}
	else
	{
		local.radio.origin = local.origin
	}

	local.radio show
	local.radio solid

	local.radio.angles = ( 0 0 0 )
	local.radio droptofloor 
	local.radio light 1 0 0 50

	local.hit_box = spawn trigger_multiple "spawnflags" 128 "targetname" "radio_box"
	local.hit_box setsize ( -20 -20 -20 ) ( 20 20 20 )
	local.hit_box setthread shot
	local.hit_box.origin = local.radio.origin

	local.use_box = spawn trigger_use  "targetname" "radio_use"
	local.use_box setsize ( -35 -35 -35 ) ( 35 35 35 )
	local.use_box setthread use
	local.use_box.origin = local.radio.origin

	local.radio.use = local.use_box
	local.radio.shot = local.hit_box

	local.use_box glue local.radio
	local.hit_box  glue local.radio

	local.max_idle = waitexec global/settings.scr::getcmd "countdown-idle"

	if(local.max_idle == "")
	{
		local.max_idle = 300
	}
	else
	{
		local.max_idle = int local.max_idle
	}

	if(local.max_idle == 0)
	{
		local.max_idle = -1
	}

	local.idle = 0
	while($countdown_radio)
	{
		wait 1
		local.idle ++
		if(local.idle == 60)
		{

			thread flash
		}

		if(local.idle == local.max_idle && ($countdown_radio))
		{
			$countdown_radio.shot delete 
			$countdown_radio.use delete 
			$countdown_radio delete 
			waitframe
			local.origin = waitexec HTR/setup.scr::getorigin
			exec HTR/radio.scr local.origin
			end
		}
	}

end

flash:	
	local.state =1

	while($countdown_radio)
	{
		wait 1
		if($countdown_radio != NIL && $countdown_radio != NULL)
		{
			if(local.state ==1)
			{
				local.state = 0
				$countdown_radio light 1 0 0 100
			}
			else
			{
				local.state = 1
				$countdown_radio light 0 0 1 100
			}
		}
	}
end

shot:
	local.player = parm.other
	$countdown_radio physics_on
	$countdown_radio.velocity =  ( 0 0 150 ) + local.player.forwardvector * 500 
end

use:

	local.player = parm.other

	//Player waiting for medic attention, he can't pick up the radio
	if (local.player.needrevive == 1)
		end
		
	if(local.player.using_pack == 1)
	{
		local.player iprint "You may not use the radio and jetpack" 1
		end
	}

	if(level.last_had_radio == local.player)
	{
		local.player  iprint "You may not pick up the radio next" 1
		end
	}
	
	//clear the last player who had it.
	local.last_had_radio = NIL
	
	//remove this line, not sure why it's here
	//local.player.target = local.player

	local.team = local.player.dmteam
	local.team  = waitexec global/strings.scr::to_upper local.team  0
	iprintlnbold (local.team  + " have the radio!")

	$countdown_radio.shot delete
	$countdown_radio.use delete
	$countdown_radio delete

	thread give_radio local.player
end

// give radio to the player
give_radio local.player:

	local.player playsound m3l2_radio_pickup
	local.player attachmodel level.radio_model "Bip01 Pelvis" 0.8 "pelvis_radio" 1 -1 -1 -1 -1 ( 1.5 -4 -10.0 )
	$pelvis_radio.angles = ( 0 90 90 )

	local.light = waitexec global/settings.scr::getcmd "countdown-light"

	if(local.light != "0")
	{
		local.player light 1 0 0 100
	}

	local.player exec HTR/player_radio.scr 
end
```

# zz_admin-Pro_1.22_modif\HTR\setup.scr

```scr
main:

	if (level.run["countdown"] != "1"){end}

	if(level.HTR_setup !=1)
	{
		level.HTR_setup = 1

		if (level.run["countdown"] != "1"){end}

		local.gametype = getcvar "g_gametype"

		if(local.gametype == "1" || local.gametype == "0")
		{
			end
		}

		level.round_times = waitexec global/settings.scr::getcmd "countdown-rounds"
		level.round_times = int level.round_times

		thread changemap

		local.gametypestring = getcvar "g_gametypestring"
		setcvar "g_gametypestring" "Countdown"

		setcvar "session" local.gametype
	
		if(level.roundbased)
		{
			level waittill roundstart
		}
		else
		{
			level waittill spawn
		}

		local.origin = waitthread getorigin

		if (local.origin == NIL)
		{
			setcvar "g_gametypestring" local.gametypestring 
			println "ERROR: [Countdown] Map origin script not found. Map may not be supported"
			println "HTR: Map not reacognised. Ending mod"
			end
		}

	
		local.time = waitexec global/settings.scr::getcmd "countdown-time"

		if(local.time == "" || local.time == NIL)
		{
			local.time = "03:00"
		}
		
		local.countdown_time[allies] = local.time
		local.countdown_time[axis] = local.time

		level.hudcolour["axis"] = 0
		level.hudcolour["allies"] = 0

		if(local.countdown_time[allies].size != 5 || local.countdown_time[axis].size != 5 )
		{
			setcvar "g_gametypestring" local.gametypestring 
			println "ERROR: [Countdown] Time format is incorrect. Ending mod"
			end
		}

		setcvar "g_gametypestring" "Countdown"
	
		exec global/libmef/mapdesc.scr::setup_map level.map_shortname

		level.clockside = "draw"

		level.radio_model = waitexec global/settings.scr::getcmd "radio-model"

		level.countdown["allies"]["seconds"] = waitexec global/strings.scr::Right 2 local.countdown_time[allies]
		level.countdown["axis"]["seconds"] = waitexec global/strings.scr::Right 2 local.countdown_time[axis]

		level.countdown["allies"]["minutes"] = waitexec global/strings.scr::Left 2 local.countdown_time[allies]
		level.countdown["axis"]["minutes"] = waitexec global/strings.scr::Left 2 local.countdown_time[axis]
			
		level.countdown["allies"]["seconds"] = int level.countdown["allies"]["seconds"]
		level.countdown["axis"]["seconds"] = int level.countdown["axis"]["seconds"]

		level.countdown["allies"]["minutes"] = int level.countdown["allies"]["minutes"]
		level.countdown["axis"]["minutes"] = int level.countdown["axis"]["minutes"]

		exec HTR/player_scan.scr

		local.master= spawn ScriptMaster
		local.master aliascache snd_binoculars sound/mechanics/Mec_RadioNoise_11.wav soundparms 0.5 0.2 0.9 0.1 160 1600 item auto loaded maps "m moh obj dm team "
		local.master aliascache m3l2_radio_pickup sound/items/Item_ToolBox_01.wav soundparms 1.5 0.0 1.0 0.0 100 2000 item loaded maps "m3l2 dm moh obj train"
		//local.master aliascache plantbomb1 sound/items/Item_BangaloreAssemble_01.wav soundparms 1.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train"

		exec HTR/radio.scr local.origin
		exec HTR/hud.scr::countdown

		setcvar "g_obj_alliedtext1" "Countdown 1.6"
		setcvar "g_obj_alliedtext2" "Find and hold the radio to" 
		setcvar "g_obj_alliedtext3" "Blow up the axis players" 

		setcvar "g_obj_axistext1" "Countdown 1.6"
		setcvar "g_obj_axistext2" "Find and hold the radio to" 
		setcvar "g_obj_axistext3" "Blow up the allied players" 
		
		level.dmrespawning = 1

	}

end

getorigin:
	
	local.map = level.mapname
	local.pos = waitexec global/strings.scr::InStr "/" local.map
	
	if(local.pos != NIL) //single player map
	{
		local.pos = local.map.size - local.pos
		local.map = waitexec global/strings.scr::Right local.pos local.map
	}

	local.spot = waitexec ("countdown/" + local.map + ".scr")
	local.rand = local.spot.size
	local.rand = randomint(local.rand) 
	local.spot = local.spot[local.rand]

end local.spot

changemap:
	
	//level waittill spawn

	local.rounds = waitexec global/settings.scr::getcmd "countdown-rounds"
	local.rounds = int local.rounds

	if(local.rounds != 0)
	{

		level.round_times = getcvar "countdown_times"
		level.round_times = int level.round_times

		if(level.round_times >= local.rounds)
		{
			setcvar "countdown_times" "0"

			while(1)
			{
				local.gametype = getcvar "g_gametype"
				setcvar "g_gametype" "0"
				bsptransition nextmap
				setcvar "g_gametype" local.gametype
				// wait one frame and set all game types again so map changes and doesnt save game
				waitframe
				setcvar "g_gametype" "0"
				bsptransition nextmap
				setcvar "g_gametype" local.gametype
				wait 15
			}
		}
	}
end

/*
changemap:

	
	level waittill spawn

	local.rounds = getcvar "countdown_rounds"
	local.rounds = int local.rounds

	if(local.rounds != 0)
	{

		level.round_times = getcvar "countdown_times"
		level.round_times = int level.round_times

		if(level.round_times >= local.rounds)
		{
			local.frags = getcvar "fraglimit"
			setcvar "countdown_times" local.frags

			if(game.game != "AA")
			{
				setcvar "fraglimit" "1"	
				setcvar "g_tow_winstate" "1"	
				$player[1] auto_join_team
				$player[1] commanddelay 0.0 addkills 1
			}
			else
			{
				setcvar "fraglimit" "-1"
			}

			//setcvar "g_gametype" "4"
			//teamwin axis

		}
	}
end

*/
```

# zz_admin-Pro_1.22_modif\jetpack\airtank.scr

```scr
// Script for adding on air tank to a playee

main:

	//set max fuel
	level.jetpack_max_fuel  = 250

	//end if we have a jetpack
	if(self.using_pack == 1)
	{
		end
	}

	//set using jetpack
	self.using_pack = 1


	//Inform them on how to use the damn thing
	self iprint "Jump and hold USE(E) to use the jetpack"
	self iprint "Hold use key with a direction key to boost in that direction"


	//think i whent a little bit over the top here(A)
	local.model = "models/static/static_airtank.tik"

	self attachmodel local.model "Bip01 Spine" 0.5 ("Pairtank" + self.entnum ) 1 -1 -1 -1 -1 ( 25 -5 3 )
	$("Pairtank" + self.entnum ).angles = ( 270 0 4 )
      	
	self attachmodel local.model "Bip01 Spine" 0.5 ("Pairtank2" + self.entnum ) 1 -1 -1 -1 -1 ( 25 -5 -4 )
	$("Pairtank2" + self.entnum ).angles = ( 270 0 3 )

	 /* causes vertex error , looks gd but cant be botherd with spam
	local.model = "models/static/switch2.tik"

 	self attachmodel local.model "Bip01 Spine" 0.5 "airswitch2" 1 -1 -1 -1 -1 ( 15 -5 -1 )
	$airswitch2.angles = ( 180 90 90 )

	local.model = "models/static/switch1.tik"	   

 	self attachmodel local.model "Bip01 Spine" 0.5 "airswitch" 1 -1 -1 -1 -1 ( 21 -7 -1 )
	$airswitch.angles = ( 180 90 90 )
	*/

	local.model = "emitters/pipe_steam.tik"
 	self attachmodel local.model "Bip01 Spine" 0.1 ("tankemitter" + self.entnum ) 1 -1 -1 -1 -1 ( 0 -10 3 )
	$("tankemitter" + self.entnum ).angles = ( -15 -180 0 )
										    
	local.model = "emitters/pipe_steam.tik"
 	self attachmodel local.model "Bip01 Spine" 0.1 ("tankemitter2" + self.entnum ) 1 -1 -1 -1 -1 ( 0 -10 -4 )
	$("tankemitter2" + self.entnum ).angles = ( 15 -180 0 )
				 
	local.smoke  = $("tankemitter" + self.entnum )
	local.smoke2 = $("tankemitter2" + self.entnum )
	$("Pairtank" + self.entnum ).smoke = ( local.smoke::local.smoke2 )
	
	//associate these models with the tank so we can delete them all later
	//$Pairtank.switches = ( 	$airswitch2::$airswitch )
	
	//associate the second tank with first.
	$("Pairtank" + self.entnum ).twin = $("Pairtank2" + self.entnum )
	
	//associate these models with the player
	self.jetpack = $("Pairtank" + self.entnum )

	//display a widget statebar fuel hud
	thread display
		 
end	

display:

	if(game.game != "AA")
	{
		thread display_sh
		end
	}

	self stufftext "globalwidgetcommand dday1 shader townhallwindow"
	self stufftext "globalwidgetcommand dday1 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday1 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand dday1 fadein 0"
	self stufftext "globalwidgetcommand dday1 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday1 virtualres 1" 
	self stufftext "globalwidgetcommand dday1 fullscreen 1" 

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar fuel"
	self stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.jetpack_max_fuel )
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"


	self stufftext "globalwidgetcommand dday2 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday2 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand dday2 fadein 0"
	self stufftext "globalwidgetcommand dday2 menu dday2 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday2 virtualres 1" 
	self stufftext "globalwidgetcommand dday2 fullscreen 1" 

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left " 
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar fuel"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"

	//clear things just incase
	self stufftext "hidemenu credits1"
	self stufftext "globalwidgetcommand credits2 name credits1"
	//now we deal with credits1
	waitframe
	//setup credits to use the inner credits1
	//first setup the credits1
	self stufftext "globalwidgetcommand credits1 align left bottom" 
	//self stufftext "globalwidgetcommand credits1 virtualres 1" 
	//self stufftext "globalwidgetcommand credits1 fullscreen 1" 
	//self stufftext "globalwidgetcommand credits1 rect 0 0 640 480"
	//self stufftext "globalwidgetcommand credits1 fgcolor 0.00 0.00 0.00 0.00"
	//self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	//change outer name to credits2
	self stufftext "globalwidgetcommand credits1 name credits2"	
	


	//now we can change the inner credits1
	waitframe

	self stufftext "globalwidgetcommand credits1 fgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 shader townhallwindow"
	self stufftext "globalwidgetcommand credits1 textalign left " 
	self stufftext "globalwidgetcommand credits1 rect 10 270 150 20"
	self stufftext "globalwidgetcommand credits1 fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 linkcvar fuel_message"
	self stufftext "globalwidgetcommand credits1 font facfont-20"

	self stufftext "showmenu dday2"
	self stufftext "showmenu dday1"
	self stufftext "showmenu credits1"
					   
	self stufftext ("set fuel_message Jetpack")
	self stufftext ("set fuel " + level.jetpack_max_fuel )


end


display_sh:

	self stufftext "globalwidgetcommand bastogne1 shader townhallwindow"
	self stufftext "globalwidgetcommand bastogne1 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand bastogne1 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand bastogne1 fadein 0"
	self stufftext "globalwidgetcommand bastogne1 menu bastogne1 640 480 NONE 0"
	self stufftext "globalwidgetcommand bastogne1 virtualres 1" 
	self stufftext "globalwidgetcommand bastogne1 fullscreen 1" 

	self stufftext "globalwidgetcommand june6 borderstyle NONE"
	self stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	self stufftext "globalwidgetcommand june6 rect 16 420 16 64"
	self stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand june6 linkcvar fuel"
	self stufftext ("globalwidgetcommand june6 statbar vertical 0 " + level.jetpack_max_fuel )
	self stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	self stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"

	self stufftext "globalwidgetcommand bastogne2 fgcolor 1.00 1.00 1.00 1.00"
	self stufftext "globalwidgetcommand bastogne2 bgcolor 0.50 0.50 0.50 0.00"
	self stufftext "globalwidgetcommand bastogne2 fadein 0"
	self stufftext "globalwidgetcommand bastogne2 menu dday2 640 480 NONE 0"
	self stufftext "globalwidgetcommand bastogne2 virtualres 1" 
	self stufftext "globalwidgetcommand bastogne2 fullscreen 1" 

	self stufftext "globalwidgetcommand charliesector borderstyle NONE"
	self stufftext "globalwidgetcommand charliesector textalign left " 
	self stufftext "globalwidgetcommand charliesector rect 40 470 150 20"
	self stufftext "globalwidgetcommand charliesector fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector linkcvar fuel"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext "globalwidgetcommand charliesector shader townhallwindow"			  
				 
	//clear things just incase
	self stufftext "hidemenu credits1"
	self stufftext "globalwidgetcommand credits2 name credits1"
	//now we deal with credits1
	waitframe
	//setup credits to use the inner credits1
	//first setup the credits1
	self stufftext "globalwidgetcommand credits1 align left bottom" 
	//self stufftext "globalwidgetcommand credits1 virtualres 1" 
	//self stufftext "globalwidgetcommand credits1 fullscreen 1" 
	//self stufftext "globalwidgetcommand credits1 rect 0 0 640 480"
	//self stufftext "globalwidgetcommand credits1 fgcolor 0.00 0.00 0.00 0.00"
	//self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	//change outer name to credits2
	self stufftext "globalwidgetcommand credits1 name credits2"	
	


	//now we can change the inner credits1
	waitframe

	self stufftext "globalwidgetcommand credits1 fgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 shader townhallwindow"
	self stufftext "globalwidgetcommand credits1 textalign left " 
	self stufftext "globalwidgetcommand credits1 rect 10 270 150 20"
	self stufftext "globalwidgetcommand credits1 fgcolor 0.70 0.60 0.05 1.00"
	self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 linkcvar fuel_message"
	self stufftext "globalwidgetcommand credits1 font facfont-20"

	self stufftext "showmenu bastogne2"
	self stufftext "showmenu bastogne1"
	self stufftext "showmenu credits1"
					   
	self stufftext ("set fuel_message Jetpack")
	self stufftext ("set fuel " + level.jetpack_max_fuel )
	

end

 // pERFECT FOR ONE
/*
main:


		iprintln "MODEL"
	local.model = "models/static/static_airtank.tik"

	self attachmodel local.model "Bip01 Spine" 0.5 "Pairtank" 1 -1 -1 -1 -1 ( 25 -5 0 )
	$Pairtank.angles = ( 270 0 10 )

	self.jetpack = $Pairtank
end	
*/
```

# zz_admin-Pro_1.22_modif\jetpack\jetpack_.scr

```scr
main:
	if(level.run["jetpacks"] == "1")
	{
		self exec jetpack/airtank.scr
	}
end
```

# zz_admin-Pro_1.22_modif\jetpack\jetpack_movement.scr

```scr
// 23/11/2005 12:02 deals with input for jetpack
main local.what:

	if(self == NIL && self == NULL )
	{
		end
	}
	
	//if we are on the floor
	if(self.onground == 1)
	{
		self forcelegsstate STAND
		end
	}

	//if left
	if(self == NIL || self == NULL)
	{
		end
	}

	//if dont have a jetpack on
	if(self.using_pack != 1)
	{
		end
	}
		    	
	//remove some fuel
	self.jetpack.fuel--

	//if we have no fuel
	if(self.jetpack.fuel <= 0 )
	{
		self stufftext ("set fuel Empty")
		end
	}		   	

	//send new fuel
  	self stufftext ("set fuel " + self.jetpack.fuel)

	 // play some booster sound if not hit floor
	if(local.what ==  "LAND")
	{

		self gravity 1
		self.onground = 1
		self stopsound jetpack

		end
	}
	//play the sound
	self playsound jetpack

	//what did we press?
	switch(local.what)
	{
	case "MOVEMENT_FORWARD":
	
		self.velocity += self.forwardvector * 15
	break
	case "MOVEMENT_BACKWARD":


		self.velocity -= self.forwardvector * 15

	break
	case "MOVEMENT_LEFT":

		self.velocity += self.leftvector * 15
	break
	case "MOVEMENT_RIGHT":

		self.velocity += self.rightvector * 15

	break
	case "THRUST":

		self.velocity += self.upvector * 15
	break
	default:
	break
	}

	//some effect on smoke, make it big and puffy
	self.jetpack.smoke[1].scale = 1.0
	self.jetpack.smoke[2].scale = 1.0
 
	wait 1

	self.jetpack.smoke[1].scale = 0.2
	self.jetpack.smoke[2].scale = 0.2

	self.jetpack.fuel_time = 1

	//self stoploopsound jetpack_boost
	//self loopsound jetpack
end
```

# zz_admin-Pro_1.22_modif\jetpack\jetpack.scr

```scr
main:
	
	// if they are already using a jetpack,
	// if they are not holding use
	// if they did not yet obtain a yetpack , quit

	if(self.useheld != 1 || self.using_pack != 1)
	{
		end
	}
	 	   
	if(self.using_pack_already == 1)
	{
		//landed so reset soem stuff
		self.onground = 0
		//make them float again
		self gravity .2
		// Set state
		self forcelegsstate JETPACK
		//already running the rest so go home.
		end
	}
			 
	//stop them using mods thta use use
	self.no_usemine = 1 //stop them using a mine
	self.no_usemedic = 1 //stop medics

	//set them to using a jetpack in this script
	self.using_pack_already = 1

	//Tell script we are using pack in the air
	self.onground = 0 

	// set fuel at numbers.
	self.jetpack.fuel = level.jetpack_max_fuel 

	// Set state
	self forcelegsstate JETPACK

	// change their gravity for effect of floating when not using boosts
	self gravity .2

	// start playing steam sound
	//self loopsound jetpack

	//set id to start charging loop
	local.charge_id	= 1

	local.fuelmsgs = makearray
	"set fuel_message Ignition Primed"	    //1
	"set fuel_message Charging"		    //2
	"set fuel_message Charging."		    //3
	"set fuel_message Charging.."		    //4
	"set fuel_message Charging..."		    //5
	"set fuel_message Charged"		    //6
	"set fuel_message Jet Pack deactivated"	    //7
	endarray

	// Set Display
	self stufftext local.fuelmsgs[1][1] //Ignition Primed
			
	// Set team
	local.team = self.dmteam

	//start main loop 
  	while(self.jetpack.fuel > 0 && local.team == self.dmteam &&  ( isalive self == 1))
	{
		wait 1

		if(self.onground == 1)
		{
			if(self.jetpack.fuel < level.jetpack_max_fuel )
			{
				self.jetpack.fuel++
				local.charge_id++

				self stufftext local.fuelmsgs[local.charge_id][1] //charging

				if(local.charge_id ==  5)
				{
					local.charge_id	= 1
				}
			}
			else
			{
				self stufftext local.fuelmsgs[6][1] //Ignition Primed
			}
		}
		else
		{  	
			if(self.jetpack.fuel > 0 )
			{
				self.jetpack.fuel--
			}	
		}

		if(self.jetpack.fuel >= 0 && self.jetpack.fuel <= level.jetpack_max_fuel )
		{
			self stufftext ("set fuel " + self.jetpack.fuel)
		}
		else if(self.jetpack.fuel == 0 )
		{
			self stufftext ("set fuel Empty")
		}

		if(self == NIL && self == NULL )
		{
			end
		}

		
	}
	
	//if player buggerd off
	if(self == NIL || self == NULL)
	{
		end
	}

	self gravity 1
//	self forcelegsstate STAND

	self stufftext local.fuelmsgs[7][1] //Jet Pack deactivated

	if(self.dmteam != "spectator")
	{
		while( self getposition  != "standing")
		{
			wait 1
		}
	}

	thread delete_tank
		
	//self stoploopsound jetpack
	self.using_pack = 0
	self.using_pack_already = 0

	self.no_usemine = 0 //  using a mine
	self.no_usemedic = 0 // medics

	//hide the hud
	if(game.game == "AA")
	{
		self stufftext "hidemenu dday1"
		self stufftext "hidemenu dday2"

		//self stufftext "globalwidgetcommand credits1 virtualres 0" 
		//self stufftext "globalwidgetcommand credits1 fullscreen 0" 
		self stufftext "hidemenu credits1"
		self stufftext "globalwidgetcommand credits2 name credits1"	
	}
	else
	{
		self stufftext "hidemenu bastogne2"
		self stufftext "hidemenu bastogne1"

		//self stufftext "globalwidgetcommand credits1 virtualres 0" 
		//self stufftext "globalwidgetcommand credits1 fullscreen 0" 
		self stufftext "hidemenu credits1"
		self stufftext "globalwidgetcommand credits2 name credits1"	
	}
end

delete_tank:

	self.jetpack.smoke[1] delete
	self.jetpack.smoke[2] delete
	self.jetpack.twin delete
	self.jetpack delete

end

```

# zz_admin-Pro_1.22_modif\jetpack\trigger.scr

```scr
main local.origin local.team:

	//set max fuel
	level.jetpack_max_fuel  = 250

	if(local.origin==NIL)
	{
		println "ERROR: jetpack - no origin"
		end
	}

	if(local.team == NIL)
	{
		local.team = 0
	}

	local.airtank = spawn script_model "targetname" ("airtank_trigger")
	local.airtank model "models/static/static_airtank.tik"

	local.airtank.origin = local.origin 
	local.airtank.scale = .5
	local.airtank light 1 0 0 50
	//local.airtank notsolid
	local.airtank ghost

	local.airtank.shot = 0

	local.airtank_trig = spawn trigger_multiple "targetname" ("airtank_trigger_fly")
	local.airtank_trig.origin = local.origin 
	local.airtank_trig setthread fly
	local.airtank_trig setsize ( -40 -40 -40 ) ( 40 40 40 ) 
	local.airtank_trig.wait = 1
	
	level waittill spawn 

	local.i[0] = 0
	local.i[1] = 0
	local.i[2] = 0

	local.v[0] = 3
	local.v[1] = 4
	local.v[2] = 5

	while(1)
	{
		if(local.minues!=1)
		{
			local.v[0] ++ 
			local.v[1] ++
			local.v[2] ++
		}

		if(local.v[2]==10)
		{
			local.minues=1
		}

		if(local.v[2]==3)
		{
			local.minues=0
		}

		if(local.minues==1)
		{
			local.v[0] -- 
			local.v[1] --
			local.v[2] --
		}


		for(local.p=0;local.p<=10;local.p++)
		{

			waitframe

			local.i[0] += local.v[0]
			local.i[1] += local.v[1]
			local.i[2] += local.v[2]

			if(local.airtank.shot==1)
			{
				local.i[0] += local.v[0]
				local.i[1] += local.v[1]
				local.i[2] += local.v[2]
				local.i[0] += local.v[0]
				local.i[1] += local.v[1]
				local.i[2] += local.v[2]
				local.airtank light 1 0 1 50
			}

			local.airtank.angles = ( local.i[0] local.i[1] local.i[2] )
		}
	}
end

fly:
	local.player = parm.other
	
	if(local.player.using_pack != 1 &&  local.player.OWNS != 1)
	{
		// Give the player a tank
		local.player exec jetpack/airtank.scr
	}
	else if(local.player.using_pack == 1 )
	{
		local.player.jetpack.fuel = level.jetpack_max_fuel 
		local.player stufftext ("set fuel " + level.jetpack_max_fuel )		
	}
end


```

# zz_admin-Pro_1.22_modif\models\emitters\aircraft_explosion.tik

```tik
TIKI
setup
{
	scale 1.0
	path models/fx/dummy
	skelmodel dummy3.skd
}

init
{
	server
	{
		classname effectentity
		notsolid
		rendereffects +dontdraw
	}
	client
	{
			originemitter metalchunk
			(
				spawnrate 2.00
				model models/fx/ibeam_piece.tik
				count 2
				color 1.00 1.00 1.00
				collision
				bouncefactor 0.30
				life 1.00
				radius 10.00
				velocity 400.00
				radialvelocity 10.00 10.00 100.00
				accel 0.00 0.00 -200.00
				offsetalongaxis 0 crandom -40 crandom -30
				angles range -220 -440 crandom -220 range -220 110
				avelocity crandom -400 crandom -400 crandom -300
				scalemin 0.30
				scalemax 1.00
			)
	
			originemitter metal
			(
				spawnrate 2.00
				model models/fx/metal_section.tik
				count 4
				color 1.00 1.00 1.00
				collision
				bouncefactor 0.30
				scale 0.30
				life 2.00
				radius 10.00
				velocity 600.00
				radialvelocity 10.00 10.00 100.00
				randvelaxis crandom -200 crandom -200 crandom -20
				accel 0.00 0.00 -200.00
				friction -1.00
				angles range -220 -440 crandom -220 range -220 110
				avelocity crandom -400 crandom -400 crandom -300
				scalemin 0.30
				scalemax 1.00
			)

			originemitter exploder
			(
			  	spawnrate 1.00
				model models/fx/metal_section.tik
				alpha 0.50
				color 0.40 0.40 0.40
				varycolor
				scale 1.50
				life 0.60
				scalerate 10.00
				scalemin 0.20
				scalemax 2.00
				fade
				align
			)

			originemitter flash
			(
				spawnrate 1.00
				count 1
				model air_explosion.spr
				alpha 0.40
				color 1.00 1.00 1.00
				scale 3.00
				life 0.15
				scalerate 9.00
				offsetalongaxis 0 crandom -64 0
				scalemin 0.50
				scalemax 2.00
				fadedelay 0.00
			)

			originemitter smoke
			(
				spawnrate 10.00
				model vsssource2.spr
				count 10
				alpha 0.70
				color 0.20 0.20 0.20
				life 5.00
				scalerate 7.00
				radius 22.00
				velocity 100.00
				accel 0.00 0.00 333.00
				friction 2.00
				fade
				randomroll
			)
	}
}

animations
{
        idle dummy3.skc
	start dummy3.skc
	{
		client
	        {
			enter emitteron metalchunk
			enter emitteron flash
			enter emitteron exploder
			enter emitteron metal
			enter emitteron smoke
			enter emitteron bolt

	        }
	}
	stop dummy3.skc
	{
		client
	        {
	    		enter emitteroff metalchunk
			enter emitteroff flash
			enter emitteroff exploder
			enter emitteroff metal
			enter emitteroff smoke
			enter emitteroff smoke
		}
	}
}

/*QUAKED fx_exploder_aircraft (0.0 0.5 0.5) (-8 -8 -8) (8 8 8)
airfield
*/

```

# zz_admin-Pro_1.22_modif\NO\flyable-planes.txt

```txt
// If you are going to limit the planes in the air "use-teams must be set to "1"


main:
	local.planesettings = makearray
		"maxspeed"		"90000"		"Max speed of the aircraft"
		"minspeed"		"0"		"minimum speed of the aircraft"
		"startspeed"		"5" 		"Speed the aircraft starts with"
		"plane-bombs"		"6"		"Amount of bombs the plane has"
		"rockets"		"4"		"Plane rocket ammo count"
		"eject"			"1"		"if 1 the player can eject if 0 they cant."
		"acceleration"		"2"		"Amount of acceleration upon key press"
		"deceleration"		"2"		"Amount of deceleration upon key press"
		"plane-hit-dmg"	 	"15"		"Amount of damage a plane takes when shot (any weapon)"
		"max-axis"		"0"		"Amount of axis planes allowed in the air at one time, 0 = Dont care"
		"max-allies"		"0"		"Amount of allies planes allowed in the air at one time, 0 = Dont care"	
		"trig-delay"		"5"		"Delay to wait after a trigger has been used to re-activate it"
		"use-teams"		"0"		"If not set 1 any team can use any trigger else a team can only use triggers that link to that team"
		"uncrashable"		"1"		"If this is set 1 (ON) Then the planes will be not solid and fly through walls.
	endarray
end local.planesettings

instructions:

	local.instructions = makearray
	//message							//duration in seconds
		"You are about to start flying a plane." 			1.5
		"YOU CAN END THIS MESSAGE BY HOLDING USE." 			1
		"This prints each time you first fly a plane on a map" 		1.5
		" "								0.5
		"Use your mouse to steer the plane" 				1.5
		"Forward run - Speed up"					1.5
		"Backward run - Slow down" 					1.5
		"Left run - Roll left" 						1.5
		"Right run - Roll right"					1.5
		"Forward walk - Cam forward" 					1.5
		"Backward walk - Cam back" 					1.5
		"Left run - Cam up"						1.5
		"Right run - Cam down"						1.5
 		"USE- Change weapon" 						1.5
		"Primary fire = Shoot" 						1.5
		"Secondary fire = drop bomb" 					1.5
		"Jump = Bail out" 						1.5
		" "								0.5
		 "Your about to start flying" 					1.5
		"3" 								1
		"2" 								1
		"1"								1
	endarray		

end local.instructions
```

# zz_admin-Pro_1.22_modif\NO\server_planes\angles.scr

```scr

// a convenient way to invoke object rotation
// by jv_map

// rotates self around axis defined by vector local.axis in world space
// the angle of rotation is determined by the length of this vector (in radians, pi rad = 180 deg)
// rotation is right-handed (generally regarded as counter-clockwise,
// but it is clockwise when looking in the direction of the vector)
axisrotate local.axis:

   // define this somewhere, nah:P
   level.PI = 3.1415926
   
   // the angle of rotation
   local.theta = vector_length local.axis
   
   if(local.theta > 0.0)
   {      
      // similar to vector_normalize but as the length is already known
      // this saves a costly calculation
      local.normal_axis = local.axis * (1.0 / local.theta)
      
      local.cos_2 = waitthread cos (0.5 * local.theta)
      local.sin_2 = waitthread sin (0.5 * local.theta)
      
      // this is known as a quaternion representation
      local.a = local.cos_2
      local.b = local.sin_2 * local.normal_axis[0]
      local.c = local.sin_2 * local.normal_axis[1]
      local.d = local.sin_2 * local.normal_axis[2]
      
      local.a2 = local.a * local.a
      local.b2 = local.b * local.b
      local.c2 = local.c * local.c
      local.d2 = local.d * local.d
      
      // make sure we're working with a unit quaternion
      // (this should be the case automatically but in case there's a
      // slight error in the sin or cos function this fixes it)
      local.quat_length_squared = local.a2 + local.b2 + local.c2 + local.d2
      local.quat_length = waitthread sqrt1 local.quat_length_squared
      
      local.a = local.a / local.quat_length
      local.b = local.b / local.quat_length
      local.c = local.c / local.quat_length
      local.d = local.d / local.quat_length
      
      local.a2 = local.a2 / local.quat_length_squared
      local.b2 = local.b2 / local.quat_length_squared
      local.c2 = local.c2 / local.quat_length_squared
      local.d2 = local.d2 / local.quat_length_squared
      
      // these would be the fwd/lf/up vectors of the rotated system, if the initial rotation was zero (angles = (0 0 0))
      // can't really explain this without major effort so best just believe it or look it up in a maths book (or wikipedia) ;)
      local.rot[0] = ( (local.a2 + local.b2 - local.c2 - local.d2) (2 * local.a * local.d + 2 * local.b * local.c) (2 * local.b * local.d - 2 * local.a * local.c) )
      local.rot[1] = ( (2 * local.b * local.c - 2 * local.a * local.d) (local.a2 - local.b2 + local.c2 - local.d2) (2 * local.a * local.b + 2 * local.c * local.d) )
      local.rot[2] = ( (2 * local.a * local.c + 2 * local.b * local.d) (2 * local.c * local.d - 2 * local.a * local.b) (local.a2 - local.b2 - local.c2 + local.d2) )
      
      // these are the vectors of the current coordinate system
      local.fw = self.forwardvector
      local.lf = self.leftvector
      
      // (don't even need up as it is fully defined by fw and lf, but it can be included if you wish)
      //local.up = self.upvector
      
      // transform the current system to the rotated system by premultiplying
      // with the above rotation matrix (fwd lf up)
      local.new_fw = ( (local.rot[0][0] * local.fw[0] + local.rot[1][0] * local.fw[1] + local.rot[2][0] * local.fw[2]) (local.rot[0][1] * local.fw[0] + local.rot[1][1] * local.fw[1] + local.rot[2][1] * local.fw[2]) (local.rot[0][2] * local.fw[0] + local.rot[1][2] * local.fw[1] + local.rot[2][2] * local.fw[2]) )
      local.new_lf = ( (local.rot[0][0] * local.lf[0] + local.rot[1][0] * local.lf[1] + local.rot[2][0] * local.lf[2]) (local.rot[0][1] * local.lf[0] + local.rot[1][1] * local.lf[1] + local.rot[2][1] * local.lf[2]) (local.rot[0][2] * local.lf[0] + local.rot[1][2] * local.lf[1] + local.rot[2][2] * local.lf[2]) )
      
      // (don't even need up as it is fully defined by fw and lf, but it can be included if you wish)
      //local.new_up = ( (local.rot[0][0] * local.up[0] + local.rot[1][0] * local.up[1] + local.rot[2][0] * local.up[2]) (local.rot[0][1] * local.up[0] + local.rot[1][1] * local.up[1] + local.rot[2][1] * local.up[2]) (local.rot[0][2] * local.up[0] + local.rot[1][2] * local.up[1] + local.rot[2][2] * local.up[2]) )
      
      // yikes have to convert new coord system to silly angles
      // this is somewhat sad as first thing mohaa does is
      // probably convert the angles back to a coord system again
      self.angles = waitthread vectors_toangles local.new_fw local.new_lf
   }
end

// transforms vectors to angles (pitch,yaw,roll)
// unlike the script command vector_toangles this also accounts for roll properly
// returns angles in degrees
vectors_toangles local.vec_fwd local.vec_lf:
   local.base_angles = vector_toangles local.vec_fwd
   
   local.base_fwd = local.vec_fwd
   local.base_lf = -1.0 * (angles_toleft local.base_angles)
   local.base_up = vector_cross local.base_fwd local.base_lf
   
   local.cos = local.vec_lf * local.base_lf
   
   if(abs local.cos < 0.8)
   {
      local.roll_angle = waitthread arccos local.cos
      
      if(local.vec_lf * local.base_up < 0.0)
      {
         local.roll_angle = -local.roll_angle
      }
   }
   else
   {
      // arccos getting inaccurate here
      // so just use arcsin instead
      // (far more sensitive in this region)
      local.sin = local.vec_lf * local.base_up
      
      local.roll_angle = waitthread arcsin local.sin
      
      if(local.cos < 0.0)
      {
         local.roll_angle = level.PI - local.roll_angle
      }
   }
   
   // convert to degrees
   local.roll_angle = local.roll_angle / level.PI * 180.0
   
   local.angles = local.base_angles
   local.angles[2] = local.roll_angle
end local.angles

// cheapest square-root approximation ever, but it almost overtakes light :)
// only usuable near x=1
sqrt1 local.x:
   // McLaurin expansion
   local.result = 0.5 + 0.5 * local.x - 0.125 * (local.x - 1.0) * (local.x - 1.0)
end local.result

// sin(x), x in rad
sin local.x:
end (waitthread cos(local.x - 0.5 * level.PI))

// cos(x), x in rad
cos local.x:
   // reduce to [0,2pi]
   if(local.x > 2.0 * level.PI)
   {
      local.x -= (int (local.x / (2.0 * level.PI))) * 2.0 * level.PI
   }
   else if(local.x < 0.0)
   {
      local.x += ((int ( -local.x / (2.0 * level.PI))) + 1) * 2.0 * level.PI
   }   
   
   // reduce to [-pi,pi]
   if(local.x > level.PI)
   {
      local.x -= 2.0 * level.PI
   }
   
   // 10th order Taylor series expansion
   // should be sufficiently accurate
   local.x2 = local.x * local.x
   local.x4 = local.x2 * local.x2
   local.x6 = local.x4 * local.x2
   local.x8 = local.x6 * local.x2
   local.x10 = local.x8 * local.x2
   local.cosx = 1.0 - local.x2 / 2.0 + local.x4 / 24.0 - local.x6 / 720.0 + local.x8 / 40320.0 - local.x10 / 3628800.0
   
   if(local.cosx > 1.0)
   {
      local.cosx = 1.0
   }
   else if(local.cosx < -1.0)
   {
      local.cosx = -1.0
   }
end local.cosx

// inverse sin
// somewhat inaccurate near +-0.5PI
arcsin local.x:
   if(local.x < -0.857 || local.x > 0.857)
   {
      // some empirical 9th order approximation
      // I magically extracted this from the blue blue sky :)
      local.x3 = local.x * local.x * local.x
      local.x9 = local.x3 * local.x3 * local.x3
      
      local.out = local.x + (0.5 * level.PI - 1.0) * local.x9
   }
   else
   {
      local.x2 = local.x * local.x
      local.x3 = local.x2 * local.x
      local.x5 = local.x3 * local.x2
   
      // 5th order Taylor series expansion
      local.out = local.x + 0.1667 * local.x3 + 0.075 * local.x5
   }
end local.out

// inverse cos
arccos local.rad:
   local.result = 0.5 * level.PI - (waitthread arcsin local.rad)
end local.result 
```

# zz_admin-Pro_1.22_modif\NO\server_planes\end_flight.scr

```scr
main:

	self resetstate
	self.flying = 0

	self.no_usemine = 0 //allow use of mines again.
	self.no_usemedic = 0 //allow use of medics again

	self.plane thread plane

	self show
end

plane:

	self.cam remove
	self remove
	
end
```

# zz_admin-Pro_1.22_modif\NO\server_planes\first_flight_instructions.scr

```scr
main local.plane_start:

	self.origin = local.plane_start
	self hide
	self notsolid
	self physics_off


	if(game.plane_instructions == NIL || game.plane_instructions == NULL)
	{
		game.plane_instructions = waitexec game.file["settings/flyable-planes"]::instructions
	}
	
	for(local.i = 1; local.i <= game.plane_instructions.size; local.i++)
	{
		if(self.useheld!=1)
		{
			self waitthread printmsg game.plane_instructions[local.i][1]  game.plane_instructions[local.i][2]
		}
	}

	self physics_on	
	
	self.instructed=1
end	
		

printmsg local.msg local.duration:

	local.duration = int local.duration

	if(self.useheld!=1)
	{	
		self iprint local.msg 1
		wait local.duration
	}	

end
```

# zz_admin-Pro_1.22_modif\NO\server_planes\movement.scr

```scr
// automatically generated by MOH Piler 3
// shell idea stolen from jv:P

main local.t local.arg1 local.arg2:

	//check plane is not dead
	if(self.plane == NULL || self.plane == NIL)
	{
		end
	}
	
	//self becomes plane
	self.plane thread local.t local.arg1 local.arg2

end

angles local.angle:

	
	switch(local.angle)
	{
	case 1:	//pitch down
		local.change = (self.leftvector * 0.05)
	break
	case 2:	//pitch up
		local.change = (self.leftvector * -0.05)// ~25 deg/s
	break
	case 3:	//yaw left
		local.change = (self.upvector * 0.0101)// ~25 deg/
		local.change += (self.forwardvector * -0.10) // ~25 deg/s
	break
	case 4:	//yaw right
		local.change = (self.upvector * -0.0101)// ~25 deg/
		local.change += (self.forwardvector * 0.10) // ~25 deg/s
	break
	}

	exec server_planes/angles.scr::axisrotate local.change
end


speed local.movement:

	switch(local.movement)
	{
	case 2:
		self.speed -= self.deceleration

		if(self.speed < self.minspeed)
		{
			self.speed =  self.minspeed
		}
		
	break
	case 1:

		self.speed += self.acceleration
		if(self.speed > self.maxspeed)
		{
			self.speed =  self.maxspeed
		}
	
	break
	case "LEFT_WALK":
	break
	case "RIGHT_WALK":
	break

	}
end

jump:

	self.pilot.flying = 0
	if(game.game == "AA")
	{
		self.pilot exec server_planes/parachute.scr
	}
	else
	{
		self.pilot exec server_planes/parachute_sh.scr
	}
end

freelook:
	
	if(self.freelook == 1)
	{
		self.freelook = 0
	}
	else
	{
		self.freelook = 1
	}
end 

// Sets new angles for the plane. 
// threaded to like so local.plane thread change_angles ( 0 0 1 )
// WIll add 1 to the z
// used for roll
change_angles local.angles:
//
	self.angles += local.angles
	
end
```

# zz_admin-Pro_1.22_modif\NO\server_planes\parachute_sh.scr

```scr
// Global chute script for allied assault

main:

end

parachute:

	local.eject = waitexec global/settings.scr::getcmd "eject"

	if(local.eject == "0")
	{
		self iprint "Eject dissabled"
		end
	}

	local.player = self

	self.ejecting=1
	
	waitframe
	local.player show
	local.player solid

	local.player.in_para_drop=1

	local.vec = local.player.velocity
	local.velocity_get = -390

	local.player forcelegsstate STAND
	local.player forcetorsostate STAND

	local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

	local.chute = spawn script_model
	local.chute model "models/static/parachute_actors.tik" 
	local.chute.origin =  local.player.origin
	local.chute attach local.player "Bip01 Spine2" 0 (0 0 0)
	local.chute notsolid
	local.chute scale 1

	while(local.player.ejecting==1)
	{
		if(local.player.health>2)
		{
			local.vec[0] = local.player.velocity[0]
			local.vec[1] = local.player.velocity[1]
			local.vec[2] = local.velocity_get

			local.player.velocity = local.vec
		}
		else
		{
			local.player.ejecting=0
		}
		
		if(local.player.dmteam=="spectator")
		{
			local.player.ejecting=0
		}

		if( ( local.player getposition ) == "standing")
		{
			local.player.ejecting=0
		}

		waitframe
	}

	local.chute remove

	self gravity 1
end

```

# zz_admin-Pro_1.22_modif\NO\server_planes\parachute.scr

```scr
// Global chute script for allied assault

main:

	local.eject = waitexec global/settings.scr::getcmd "eject"

	if(local.eject == "0")
	{
		self iprint "Eject dissabled"
		end
	}

	local.player = self

	self.ejecting=1

	waitframe
	local.player show
	local.player solid

	local.player.in_para_drop=1

	local.vec = local.player.velocity
	local.velocity_get = -390

	local.player forcelegsstate STAND
	local.player forcetorsostate STAND

	local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

	local.chute = spawn script_model

	if(local.player.dmteam!="axis)
	{
		local.chute model "static/parachute_white_canvas.tik"
	}
	else
	{
		local.chute model "static/parachute.tik"
	}

	local.chute.origin = ( local.player gettagposition "Bip01 Spine1" )
	local.chute notsolid
	local.chute scale 2
	local.chute.angles = local.player.angles
	//local.chute.angles[1] = local.chute.angles[1]

	local.chute1 = spawn script_origin
	local.chute1.origin = ( local.player gettagposition "Bip01 Spine1" ) + ( 0 0 100)

	local.chute1 attach local.player "Bip01 Spine1"
	local.chute glue local.chute1
	// local.chute attach local.player "Bip01 Spine1"

	while(local.player.ejecting==1)
	{
		if(local.player.health>2)
		{
			local.vec[0] = local.player.velocity[0]
			local.vec[1] = local.player.velocity[1]
			local.vec[2] = local.velocity_get

			local.player.velocity = local.vec
		}
		else
		{
			local.player.ejecting=0
		}
		
		if(local.player.dmteam=="spectator")
		{
			local.player.ejecting=0
		}

		if( ( local.player getposition ) == "standing")
		{
			local.player.ejecting=0
		}

		waitframe
	}

	local.chute remove

	self gravity 1
end

```

# zz_admin-Pro_1.22_modif\NO\server_planes\server_fly.scr

```scr
main local.plane_start:
	
	if(self.flying == 1)
	{
		self.scale = 1
		end
	}

	if(self.OWNS == 1)
	{
		self.scale = 1
		self.flying = 0
		end
	}

	self.no_usemine = 1 //stop them using a mine
	self.no_usemedic = 1 //stop medics

	self.flying = 1
	self takedamage

	local.team = self.dmteam

	if(level.planes_max["allies"]== NIL)
	{
		waitexec server_planes/setup.scr
	}

	level.planes[local.team]++

	local.allies = waitexec global/settings.scr::getcmd "max-allies"
	local.axis = waitexec global/settings.scr::getcmd "max-axis"

	level.planes_max["allies"] = int local.allies 
	level.planes_max["axis"] = int local.axis

	if(level.planes[local.team] == level.planes_max[local.team])
	{
		exec server_planes/trigger.scr::from_fly local.team
	}
	if(self.instructed!=1)
	{
		self waitexec server_planes/first_flight_instructions.scr local.plane_start
	}

	//spawn the plane
	local.plane = spawn script_model "targetname" ("flyingplane")
	if(self.dmteam == "axis")
	{
		local.plane model "vehicles/fockwulffly.tik"
	}
	else
	{
		local.plane model "vehicles/p47fly.tik"	
	}

	// Set the start direction of the plane
	local.plane.angles = self.viewangles

	local.solid = int ( waitexec global/settings.scr::getcmd "uncrashable" )

	if(local.solid == 0)
	{
		local.plane solid
	}
	else
	{
		local.plane notsolid
	}

	// Set up the plane
//	local.plane physics_on
	local.plane.origin = local.plane_start
	local.plane.scale = self.scale 
	local.plane.pilot = self
	
	// Set up the set size for the planes
	if(local.plane.scale == .75)
	{
		local.plane setsize ( -100 -100 -5 ) ( 100 100 30 )
	}
	else if(local.plane.scale == .2)
	{
		local.plane setsize ( -60 -60 -5 ) ( 60 60 10 )
	}

	// Set the seat
	if(self.seat==NIL)
	{
		if(local.plane.scale == .75)
		{
			self.seat[0] = -335 //3
			self.seat[1] = 10
		}
		else if(local.plane.scale == .2)
		{
			self.seat[0] = -215 //3
			self.seat[1] = 45 //-65
		}
		else
		{
			self.seat[1] = -65
		}
	}
		

	// Set up the player

	self notsolid
	self forcetorsostate PLANE_TORSO
	self forcelegsstate PLANE_LEGS
	self hide
	self.scale = 1
	self.plane = local.plane

	//allows use of putawaymain even without a weapon
	self weapnext
	self activatenewweapon lefthand

	local.team = self.dmteam
	//announce Player in plane
	local.team  = waitexec global/strings.scr::to_upper local.team 0
	iprintlnbold (local.team  + " Aircraft Spotted On Radar!!!")
	local.team = self.dmteam

	self glue local.plane

	local.camera = waitthread getcam
	local.camera.origin = local.plane.origin
	
	local.plane.cam = local.camera
	
	// Get speed to start with
	local.plane.speed = int ( waitexec global/settings.scr::getcmd "startspeed" )

	if(local.plane.speed == NIL)
	{
		println "Planes can not start because settings are missing"
		end
	}

	// Get acceleration
	local.plane.acceleration = int ( waitexec global/settings.scr::getcmd "acceleration" )
	// Get deceleration
	local.plane.deceleration = int ( waitexec global/settings.scr::getcmd "deceleration" )
	// Get maxspeed
	local.plane.maxspeed = int ( waitexec global/settings.scr::getcmd "maxspeed" )
	// Get minspeed
	local.plane.minspeed = int ( waitexec global/settings.scr::getcmd "minspeed" )

	local.camera.angles = self.viewangles

	//Set to start using camera view that follows the plane
	local.plane.freelook = 1

	while (self.dmteam == local.team && isalive self && local.plane && self.flying == 1)
	{
		local.origin = local.plane.origin

		if(self == NIL || self == NULL)
		{
			local.plane exec server_planes/end_flight.scr::plane
			end
		}

	//	local.plane.velocity = local.plane.forwardvector * local.plane.speed

		local.plane waitthread move_forward
		local.lean = (self getcontrollerangles 0)[2] //self.viewangles[2]

		//local.lean_old
		if(local.lean != 0 )
		{
			if( local.lean > 0 )
			{
			
				if(local.lean >= local.lean_old)
				{
					local.change = (self.upvector * 0.08)// ~25 deg/
					local.change += (self.forwardvector * -0.02)// ~25 deg/
					local.plane exec server_planes/angles.scr::axisrotate local.change
				}
			}
			else
			{
				if(local.lean <= local.lean_old)
				{
					local.change = (self.upvector * -0.08)// ~25 deg/
					local.change += (self.forwardvector * 0.02)// ~25 deg/
					local.plane exec server_planes/angles.scr::axisrotate local.change
				}

			}

		}
		local.lean_old = local.lean 

		if(local.plane.freelook == 1)
		{
			local.camera.angles = local.plane.angles
		}
		else
		{
			local.camera.angles = self.viewangles
		}

		waitframe

		waitthread camera local.camera local.plane
		if(local.origin == local.plane.origin)
		{
	//		break
		}
	}
	
	
	exec server_planes/end_flight.scr

end

camera local.camera local.plane:
	
	local.camera.origin = local.plane.origin + ( 0 0 self.seat[1] ) + local.plane.forwardvector  * self.seat[0] + 0.05 * local.plane.forwardvector * local.plane.speed

end

getcam:

	local.cam = "cam" + self.entnum
	local.camera = spawn Camera targetname local.cam
	local.cam_trigger = spawn TriggerCameraUse target local.cam
	local.cam_trigger doUse self
	local.cam_trigger remove

end local.camera

// Sets new angles for the plane. 
// threaded to like so local.plane thread change_angles ( 0 0 1 )
// WIll add 1 to the z
// used for roll
change_angles local.angles:
//
	self.angles += local.angles
	
end


move_forward:
	
	self.origin += self.forwardvector * self.speed //* -0.05

end
```

# zz_admin-Pro_1.22_modif\NO\server_planes\setup.scr

```scr
main:
	exec server_planes/sound.scr

	level.planes["allies"] = 0
	level.planes["axis"] = 0
end
```

# zz_admin-Pro_1.22_modif\NO\server_planes\sound.scr

```scr
main:
	local.master = spawn scriptmaster
//30cal
	local.master aliascache jeep_snd_fire sound/weapons/fire/50CalFire2.wav soundparms 1.05 0.2 0.95 0.1 800 4000 weapon loaded maps level.mapname
	local.master aliascache explode_plane_flying sound/weapons/explo/Explo_MetalMed1.wav soundparms 0.9 0.2 0.8 0.2 1000 8000 weapon loaded maps level.mapname
	local.master aliascache leadinmp2 sound/weapons/explo/Exp_LeadIn_07.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps level.mapname
	local.master aliascache fly_snd sound/vehicle/M1_StukaIdle.wav soundparms 1.5 0.5 2.0 0.5 2000 1000 item loaded maps level.mapname


end

```

# zz_admin-Pro_1.22_modif\NO\server_planes\trigger.scr

```scr
main local.origin local.team local.scale local.start_pos:

	if(level.planes == NIL)
	{
		exec server_planes/setup.scr
	}

	if(local.origin==NIL)
	{
		println "no origin"
		end
	}

	if(local.scale==NIL)
	{
		local.scale = .2
	}

	if(local.start_pos==NIL)
	{
		local.start_pos = local.origin + ( 0 0 500 )
	}

	if(local.team == NIL)
	{
		println  "no team"
		local.team = randomint (1) + 1
		
		if(local.team == 0)
		{
			local.team = "axis"
		}
		else
		{
			local.team = "allies"
		}
	}

	local.plane = spawn script_model "targetname" ("plane_trigger" + local.team)
	
	if(local.team =="axis")	
	{
		local.plane model "vehicles/fockwulffly.tik"
	}
	else
	{
		local.plane model "vehicles/p47fly.tik"
	}


	local.plane.origin = local.origin 
	local.plane.scale = .1
	local.plane light 1 0 0 50
	//local.plane notsolid
	local.plane ghost

	local.plane.shot = 0

	local.plane_trig = spawn trigger_multiple "targetname" ("plane_trigger_fly" + local.team)
	local.plane_trig.origin = local.origin 
	local.plane_trig setthread fly
	local.plane_trig setsize ( -40 -40 -40 ) ( 40 40 40 ) 
	local.plane_trig.plane_scale = local.scale
	local.plane_trig.start_pos = local.start_pos
	local.plane_trig.team = local.team
	
	local.plane_trig_shot = spawn trigger_multiple "spawnflags" "128"  "targetname" ("plane_shottrigger" + local.team)
	local.plane_trig_shot.origin = local.origin 
	local.plane_trig_shot setthread shot
	local.plane_trig_shot setsize ( -40 -40 -40 ) ( 40 40 40 ) 
	local.plane_trig_shot.team = local.team
	
	level waittill spawn 

	local.i[0] = 0
	local.i[1] = 0
	local.i[2] = 0

	local.v[0] = 3
	local.v[1] = 4
	local.v[2] = 5

	while(1)
	{
		if(local.minues!=1)
		{
			local.v[0] ++ 
			local.v[1] ++
			local.v[2] ++
		}

		if(local.v[2]==10)
		{
			local.minues=1
		}

		if(local.v[2]==3)
		{
			local.minues=0
		}

		if(local.minues==1)
		{
			local.v[0] -- 
			local.v[1] --
			local.v[2] --
		}


		for(local.p=0;local.p<=10;local.p++)
		{

		waitframe

			local.i[0] += local.v[0]
			local.i[1] += local.v[1]
			local.i[2] += local.v[2]

			if(local.plane.shot==1)
			{
				local.i[0] += local.v[0]
				local.i[1] += local.v[1]
				local.i[2] += local.v[2]
				local.i[0] += local.v[0]
				local.i[1] += local.v[1]
				local.i[2] += local.v[2]
				local.plane light 1 0 1 50
			}

			local.plane.angles = ( local.i[0] local.i[1] local.i[2] )
		}
	}




end

end

fly:
	local.player = parm.other
	
	if(local.player.flying!=1 ||  local.player.OWNS == 1)
	{
		local.team = parm.other.dmteam

		local.use_teams = waitexec global/settings.scr::getcmd "use-teams"

		if (local.use_teams  == "1")
		{	
			if(self.team != local.player.dmteam)
			{
				local.player iprint "You don't have the training for this aircraft"
				local.plane = waitthread find_trig self.team self

				local.plane light 0 0 1 100
				waitframe
				
				local.plane light 1 0 0 50
				end
			}
		}

		local.player scale self.plane_scale 
		local.player exec server_planes/server_fly.scr self.start_pos

		local.trigdelay = waitexec global/settings.scr::getcmd "trig-delay"
		local.trigdelay = int local.trigdelay

		self nottriggerable
		local.trig = waitthread find_trig self.team self
		local.trig hide

		wait local.trigdelay

		local.trig show
		self triggerable
	}
end

shot:
	local.trig = waitthread find_trig self.team self
	local.trig.shot=1
	wait 1 
	local.trig.shot=0
	local.trig light 1 0 0 50
	end
end

find_trig local.team local.trig:

	for(local.i=1;local.i <=  $("plane_trigger" + local.team).size;local.i++)
	{
		if(local.trig.origin ==  $("plane_trigger" + local.team)[local.i].origin)
		{		
			end  $("plane_trigger" + local.team)[local.i]
		}
	}

end

switch__all local.team local.dissable:
	

	for(local.i=1;local.i <=  $("plane_trigger_fly" + local.team).size;local.i++)
	{
		if(local.dissable == 1)
		{
			$("plane_trigger_fly" + local.team)[local.i] nottriggerable
			$("plane_shottrigger" + local.team)[local.i] nottriggerable
			$("plane_trigger" + local.team)[local.i] hide
		}
		else
		{
			$("plane_trigger_fly" + local.team)[local.i] triggerable
			$("plane_shottrigger" + local.team)[local.i] triggerable
			$("plane_trigger" + local.team)[local.i] show
		}
	}
end

from_fly local.team:

	thread switch__all local.team 1

	while(level.planes[local.team] == level.planes_max[local.team])
	{
		wait 1
	}
			
	thread switch__all local.team

end
```

# zz_admin-Pro_1.22_modif\server_planes\avatar.scr

```scr
main:

	local.avatar = spawn func_beam
	local.avatar shader ("textures/hud/" + self.dmteam + ".tga") 
	local.avatar.origin = self.origin

	local.avatar color ( 1.0 1.0 1.0 )
	local.avatar scale 6
	local.avatar numsegments 1

//	local.org = spawn script_origin
//	local.org.origin = self.plane.origin + ( 0 0 100 )
	
//	local.org bind  self.plane
//	local.avatar bind local.org
//
	local.avatar activate


	while(self.plane != NIl || self.plane != NULL)
	{
		waitframe
		local.avatar.origin =  ( self.plane.origin + ( 0 0 50) )
		local.avatar endpoint  ( self.plane.origin + ( 0 0 70) )
	}

	local.avatar remove

end
```

# zz_admin-Pro_1.22_modif\server_planes\damage.scr

```scr
// file for, shooting. being shot, and wepaons


main local.action:

	switch(local.action)
	{
	case "BOMB":
		self zoomoff	
		self waitthread bomb
	break
	case "SHOOT":
		self thread shoot
		self.shooting=1
		wait self.shootdelay
		self.shooting=0
	break
	case "CHANGE_WEAPON":
		self.canchange = 0 
		self thread change_weapon
		wait self.changedelay 
		self.canchange = 1 
	break
	}
end

shoot:

	local.fwd_vec = angles_toforward self.viewangles
	local.start = self gettagposition "eyes bone"
	local.hit = trace (local.start + local.fwd_vec * 64 ) (local.start + local.fwd_vec * 22000 ) 0
	
	switch(self.planeweap)
	{
	case 1: //mg
		self.plane playsound mg42_gun_snd_fire
		self thread checkhit local.hit
	break
	case 2: //30 call
		self.plane playsound jeep_snd_fire
		self thread checkhit local.hit
	break	
	case 3: 
		self thread rocket local.hit
	break
	default:
		self thread checkhit local.hit

	}

/*
	self.plane light 1 1 0 10
	waitframe
	self.plane light 0 0 0 0

	local.dirtleft = spawn script_model
	local.dirtleft model "models/fx/corona_red.tik"
	local.dirtleft.origin = local.hit
	local.dirtleft.scale = .5
	local.dirtleft notsolid
	local.dirtleft commanddelay 1.0 remove
*/
end

checkhit local.place:

	self thread mgeffect local.place

	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		local.player= $player[local.i]	
		if(local.player!=self && local.player != NIL)
		{
			local.end_or_not = waitthread team_check local.player self

			if(local.end_or_not==1)
			{
				end //end if same team and team team killing is not on
			}

			if(local.player.flying==1)
			{

				if(local.player.plane.scale == .75)
				{
					local.hitvec = local.place - local.player.plane.origin

					local.hitvec_fwd = local.hitvec * local.player.plane.forwardvector
					local.hitvec_lf = local.hitvec * local.player.plane.leftvector
					local.hitvec_up = local.hitvec * local.player.plane.upvector 

					local.is_hit_fwd = (abs local.hitvec_fwd) <= 200.0
					local.is_hit_lf = (abs local.hitvec_lf) <= 200.0
					local.is_hit_up = local.hitvec_up >= 0.0 && local.hitvec_up <= 35.0
					local.damage = 20
				}
				else 
				{


					local.hitvec = local.place - local.player.plane.origin

					local.hitvec_fwd = local.hitvec * local.player.plane.forwardvector
					local.hitvec_lf = local.hitvec * local.player.plane.leftvector
					local.hitvec_up = local.hitvec * local.player.plane.upvector 


					local.is_hit_fwd = (abs local.hitvec_fwd) <= 120.0
					local.is_hit_lf = (abs local.hitvec_lf) <= 120.0
					local.is_hit_up = local.hitvec_up >= 0.0 && local.hitvec_up <= 15.0
					local.damage = 30
				}

			}
			else
			{
				local.hitvec = local.place - local.player.origin 

				local.hitvec_fwd = local.hitvec * local.player.forwardvector
				local.hitvec_lf = local.hitvec * local.player.leftvector
				local.hitvec_up = local.hitvec * local.player.upvector 

				local.is_hit_fwd = (abs local.hitvec_fwd) <= 32.0
				local.is_hit_lf = (abs local.hitvec_lf) <= 32.0
				local.is_hit_up = local.hitvec_up >= 0.0 && local.hitvec_up <= 92.0
				local.damage = 45
			}

			if(local.is_hit_fwd && local.is_hit_lf && local.is_hit_up)
			{
				local.player damage self local.damage self.plane local.player.origin self.forwardvector (0 0 0) 10 1 18 -1
			}
		}

	}

end

team_check local.player local.shooter:
	
	local.gametype = getcvar "g_gametype"
	
	if(local.gametype=="1")
	{
		end 0
	}
	
	local.ff =  getcvar "g_teamdamage"

	if(local.ff=="0")
	{
		if(local.player.dmteam == local.shooter.dmteam)
		{
			end 1
		}
	}

end 0
	
mgeffect local.place:

	if(self.spawnedmg==0)
	{
		self.spawnedmg=1
		local.left = ( self.plane gettagposition "tag_barrel01")

		self.plane.gunleft = spawn statweapons/mg42_gun_fake.tik "targetname" ("planesmgleft" + self.entnum)  spawnflags 1
		self.plane.gunleft.angles = self.plane.angles
		self.plane.gunleft.origin = local.left
		self.plane.gunleft attach self.plane "tag_barrel01"
		self.plane.gunleft setPlayerUsable 0

		if(self.dmteam=="axis")
		{
			local.right = ( self.plane gettagposition "tag_barrel02")  
			self.plane.gunright = spawn statweapons/mg42_gun_fake.tik targetname ("planesmgright" + self.entnum) spawnflags 1
			self.plane.gunright.angles = self.plane.angles
			self.plane.gunright.origin = local.right
			self.plane.gunright attach self.plane "tag_barrel02"
			self.plane.gunright setPlayerUsable 0
		}
		else
		{
			local.right = ( self.plane gettagposition "tag_barrel04") 
			self.plane.gunright = spawn statweapons/mg42_gun_fake.tik "targetname" ("planesmgright" + self.entnum)  spawnflags 1
			self.plane.gunright.angles = self.plane.angles
			self.plane.gunright.origin = local.right
			self.plane.gunright attach self.plane "tag_barrel04"
			self.plane.gunright setPlayerUsable 0
		}

		self.plane.gunright hide
		self.plane.gunleft hide
		self.plane.gunright notsolid
		self.plane.gunleft notsolid
	}

		local.org = spawn script_origin 
		local.org.origin = local.place

		self.plane.gunright.angles = self.viewangles
		self.plane.gunleft.angles = self.viewangles

		self.plane.gunright setaimtarget local.org
		self.plane.gunleft setaimtarget local.org

		self.plane.gunleft anim fire
		self.plane.gunright anim fire

		local.org remove
	//self.plane anim blast

end

////////////shot down////////////

shotdown_setup:
	local.shoot = spawn trigger_multiple "spawnflags" "128" "targetname" ("planehit" + self.entnum)
	
	if(self.plane.scale == .75)
	{
		local.shoot setsize ( -100 -100 -5 ) ( 100 100 30 )
	}
	else if(self.plane.scale == .2)
	{
		local.shoot setsize ( -60 -60 -5 ) ( 60 60 10 )
	}

	local.shoot.origin = self.plane.origin
	local.shoot setthread shotdown
	self.shottrig = local.shoot
	local.shoot bind self.plane
end
		
shotdown:

	if(self != parm.other.shottrig && parm.other != $("world"))
	{
		local.player= parm.other

		if(local.player!=NULL || isalive local.player)
		{
			for(local.i = 1; local.i <= $player.size; local.i++)
			{
				if($player[local.i].shottrig == self)
				{

					local.end_or_not = waitthread team_check $player[local.i] local.player
		
					if(local.end_or_not==1)
					{
						end //end if same team and team team killing is not on
					}

					$player[local.i] damage local.player level.plane_hit_damage local.player $player[local.i].origin local.player.forwardvector (0 0 0) 10 1 0 -1
					end
				}
			}
			
		}
	}
end


////////////^^shot down////////////

/*
rocket local.origin:

	self.rocketside++
	if(self.rocketside>2)
	{
		self.rocketside=1
	}

	if(self.rocket_ammo==0)
	{
		self iprint "0 Rockets"
		self playsound bazooka_snd_noammo
		end
	}

	local.org = spawn script_origin "origin" local.origin

	self.rocket_ammo--

	self iprint ("Fired Rocket " + self.rocket_ammo)

	self playsound bazooka_snd_fire 

	if(self.rocketside==1)
	{
		local.place = ( self.plane gettagposition "tag_barrel01")
	}
	else
	{
		if(self.dmteam=="axis")
		{
			local.place = ( self.plane gettagposition "tag_barrel02")
		}
		else
		{
			local.place = ( self.plane gettagposition "tag_barrel04")
		}	
	}

	local.place += self.plane.forwardvector * 200
	local.place += self.plane.upvector * -5
	local.shell = spawn script_model "model" "projectiles/bazookashell_dm.tik" "targetanme "rocket" //"milkshape/missile/missile.tik" //
	local.shell.origin = local.place
//	local.shell notsolid //if they are solid when they hit things like tanks or anyhting that gets in the way it makes bashes it out the way
	local.shell scale .2
	
local.shell light 1 0 0 300
	local.shell.gravity = 0


	local.shell.angles =   self.viewangles
	
		thread whit local.shell
local.shell physics_on
	
	local.speed = self.speed
	while(local.shell.hit != 1)
	{
		waitframe
	local.velocity =  local.shell.forwardvector * ( local.speed  + 100 ) //local.shell.forwardvector * ( self.speed + 5000 )
	//local.velocity = ( local.velocity[0] local.velocity[1] 0.00)
	local.shell.velocity = local.velocity
	}

	self.firingshell=0

	local.shell waittill touch
	local.origin = local.shell.origin

	self waitthread explode local.origin 
	local.shell remove	
end

whit local.shell:

	local.shell waittill touch
	local.shell.hit = 1
end

*/


rocket local.pos:

	self.rocketside++
	if(self.rocketside>2)
	{
		self.rocketside=1
	}

	if(self.rocket_ammo==0)
	{
		self iprint "0 Rockets"
		self playsound bazooka_snd_noammo
		end
	}

	self.rocket_ammo--

	self iprint ("Fired Rocket " + self.rocket_ammo)

	self playsound bazooka_snd_fire 

	if(self.rocketside==1)
	{
		local.place = ( self.plane gettagposition "tag_barrel01")
	}
	else
	{
		if(self.dmteam=="axis")
		{
			local.place = ( self.plane gettagposition "tag_barrel02")
		}
		else
		{
			local.place = ( self.plane gettagposition "tag_barrel04")
		}	
	}


	local.shell = spawn script_model "model" "projectiles/bazookashell_dm.tik" //"milkshape/missile/missile.tik" //
	local.shell.angles = self.angles
	local.shell.origin = local.place
	local.shell notsolid //if they are solid when they hit things like tanks or anyhting that gets in the way it makes bashes it out the way
	local.shell scale .5

	local.shell speed 2000
	local.shell moveto local.pos
	local.shell waitmove	
	self thread explode local.shell.origin
	local.shell remove



end

change_weapon:
	self.planeweap++

	if(self.planeweap > 3)
	{
		self.planeweap=1
	}	

	switch(self.planeweap)
	{
	case 1: //mg
		self iprint ("Using MG") 1	
	break
	case 2:
		self iprint ("Using 30 Cal") 1
	break
	case 3:
		self iprint ("Using Rockets") 1
	break
	default:
		self iprint ("Using MG") 1
	}
	
end

explode local.explosionplace:

	thread bang local.explosionplace
	local.radius = 200.00 * 200.00

	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		local.player= $player[local.i]
		local.distance =  (local.player.origin - local.explosionplace) * (local.player.origin - local.explosionplace)

		//local.distance = local.distance * local.distance

		if(local.distance <= local.radius)
		{
			if(local.player != self)
			{
				local.end_or_not = waitthread team_check local.player self
		
				if(local.end_or_not==1)
				{
					end //end if same team and team team killing is not on
				}

				local.dmg_fact = 1 - local.distance / local.radius
				local.dmg = 150 * local.dmg_fact + 30
				local.player damage self local.dmg self (0 0 0) (0 0 0) (0 0 0) 0 1 15 -1
			}
		}

	}


end

bang local.place:

	local.Exp3 = spawn "fx/scriptbazookaexplosion.tik"
	local.Exp4 = spawn "animate/fx_mortar_dirt.tik"
	local.Exp3 radiusdamage 0
	local.Exp3.origin = local.place
	local.Exp4.origin = local.place
	local.Exp3 anim start
	local.Exp4 anim start

	wait 1
	local.Exp3 remove	
	local.Exp4 remove
 
end

bomb:
	if(self.candrop==0)
	{
		self iprint "No bombs"
		self playsound bazooka_snd_noammo
		end
	}

	self iprint ("Bomb :" + self.candrop)
	self.candrop--

	local.bomb = spawn script_model "targetname" "planebomb"
	local.bomb model "ammo/us_bomb.tik" 
	local.bomb.origin = self.plane.origin - ( 0 0 50 )

	local.bomb.angles = ( self.plane.angles + ( 0 90 0 ) )
	local.bomb notsolid 

	thread bombtwist local.bomb
	local.bomb physics_on

	local.bomb.velocity = self.plane.velocity 
	local.bomb playsound leadinmp2
	local.didnt=1

	while(local.didnt==1)
	{
		local.bomb waittill touch
		if!(parm.other==self || parm.other == self.plane)
		{
			local.didnt=0
		}
	}
	
	self thread explode local.bomb.origin
	local.bomb remove

	
end


bombtwist local.bomb:

	for(local.i=0;local.i<=90 ;local.i+=5)
	{

		waitframe
		if(local.bomb==NULL || local.bomb==NIL)
		{
			end
		}
		else
		{
			local.bomb.angles = (  local.bomb.angles[0] local.bomb.angles[1] local.i )
		}
	}
end

```

# zz_admin-Pro_1.22_modif\server_planes\first_flight_instructions.scr

```scr
main:
	
	self hide
	self notsolid

	self.origin = self.plane_start

	self physics_off

	if(game.plane_instructions == NIL || game.plane_instructions == NULL)
	{
		game.plane_instructions = waitexec game.file["settings/flyable-planes"]::instructions
	}
	
	for(local.i = 1; local.i <= game.plane_instructions.size; local.i++)
	{
		if(self.useheld!=1)
		{
			self waitthread printmsg game.plane_instructions[local.i][1]  game.plane_instructions[local.i][2]
		}
	}

	self physics_on	
	
	self.instructed=1
end	
		

printmsg local.msg local.duration:

	local.duration = int local.duration

	if(self.useheld!=1)
	{	
		self iprint local.msg 1
		wait local.duration
	}	

end
```

# zz_admin-Pro_1.22_modif\server_planes\movement.scr

```scr
main local.movement:

	if(self.plane==NULL || self.plane==NIL)
	{
		end
	}

	switch(local.movement)
	{
	case "BACKWARD_WALK":
		self.seat[0] -= 5		
	break
	case "FORWARD_WALK":
		self.seat[0] += 4		
	break
	case "LEFT_WALK":
		self.seat[1] +=2		
	break
	case "RIGHT_WALK":
		self.seat[1] -=2		
	break
	case "BACKWARD_RUN":
		self.speed -= self.deceleration
	
		if(self.speed < self.minspeed)
		{
			self.speed =  self.minspeed
		}
	break
	case "FORWARD_RUN":
		self.speed += self.acceleration
		if(self.speed > self.maxspeed)
		{
			self.speed =  self.maxspeed
		}
	break
	case "LEFT_RUN":
		if(self.z > -180)
		{
			self.z -= 20
		}
	break
	case "RIGHT_RUN":
		if(self.z < 180)
		{
			self.z += 20
		}
	break
	case "LEVEL_OUT":
		self thread level_out
	break
	case "JUMP":
		if(game.game == "AA")
		{
			self exec server_planes/parachute.scr
		}
		else
		{
			self exec server_planes/parachute_sh.scr
		}
	break
	}
end

/*
level_out:

	while(self.plane.angles[2] != 0.00 && self.plane != NULL)
	{

		if(self.plane.angles[2] < 180 )
		{
			self.extraangle -=5
		}
		else
		{
			self.extraangle +=5
		}	
			
		if(self.extraangle ==5 || self.extraangle == -5 )
		{
			self.extraangle=0
			break	
		}

		if(self.plane.angles[2] == 360.00 ||  self.plane.angles[2] == 0.00)
		{
			self.extraangle=0
			break	
		}

		if(self.plane == NULL || self.plane == NIL || self == NULL || self == NIL )
		{
			break		
		}

		waitframe
	}
	
end

*/
```

# zz_admin-Pro_1.22_modif\server_planes\parachute_sh.scr

```scr
// 26/11/2005 12:33 Added bt anims code by cobra

// Global chute script for allied assault

main:

	local.eject = waitexec global/settings.scr::getcmd "eject"

	if(local.eject == "0")
	{
		self iprint "Eject dissabled"
		end
	}

	local.player = self

	self.ejecting=1
	
	waitframe
	local.player show
	local.player solid

	local.player.in_para_drop=1

	local.vec = local.player.velocity
	local.velocity_get = -390

	local.player forcelegsstate STAND
	local.player forcetorsostate STAND

	local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

	local.chute = spawn script_model

	if(game.game == "BT")
	{
		local.chute model "models/equipment/parachute.tik"
	}
	else
	{
		local.chute model "models/static/parachute_actors.tik" 
	}

	local.chute.origin =  local.player.origin
	local.chute attach local.player "Bip01 Spine2" 0 (0 0 0)
	local.chute notsolid
	local.chute scale 1

	while(local.player.ejecting==1)
	{
		if(local.player.health>2)
		{
			local.vec[0] = local.player.velocity[0]
			local.vec[1] = local.player.velocity[1]
			local.vec[2] = local.velocity_get

			local.player.velocity = local.vec
		}
		else
		{
			local.player.ejecting=0
		}
		
		if(local.player.dmteam=="spectator")
		{
			local.player.ejecting=0
		}

		if( ( local.player getposition ) == "standing")
		{
			local.player.ejecting=0
		}

		waitframe
	}

	if(game.game == "BT")
	{
		local.chute detach local.para1
		local.chute speed 45 //205
		local.chute movedown 64
		local.chute waitmove
		local.chute anim collapse
		local.chute waittill animdone
		wait 5
		local.chute remove
	}
	else
	{
		local.chute detach local.para1
		local.chute speed 50
		local.chute movedown 200
		local.chute waitmove
		local.chute remove
	  
	}
		
	self gravity 1
end

```

# zz_admin-Pro_1.22_modif\server_planes\parachute.scr

```scr
// Global chute script for allied assault

main:

	local.eject = waitexec global/settings.scr::getcmd "eject"

	if(local.eject == "0")
	{
		self iprint "Eject dissabled"
		end
	}

	local.player = self

	self.ejecting=1

	waitframe
	local.player show
	local.player solid

	local.player.in_para_drop=1

	local.vec = local.player.velocity
	local.velocity_get = -390

	local.player forcelegsstate STAND
	local.player forcetorsostate STAND

	local.player.viewangles = ( local.player.viewangles[0] local.player.viewangles[1] 0 )

	local.chute = spawn script_model

	if(local.player.dmteam!="axis)
	{
		local.chute model "static/parachute_white_canvas.tik"
	}
	else
	{
		local.chute model "static/parachute.tik"
	}

	local.chute.origin = ( local.player gettagposition "Bip01 Spine1" )
	local.chute notsolid
	local.chute scale 2
	local.chute.angles = local.player.angles
	//local.chute.angles[1] = local.chute.angles[1]

	local.chute1 = spawn script_origin
	local.chute1.origin = ( local.player gettagposition "Bip01 Spine1" ) + ( 0 0 100)

	local.chute1 attach local.player "Bip01 Spine1"
	local.chute glue local.chute1
	// local.chute attach local.player "Bip01 Spine1"

	while(local.player.ejecting==1)
	{
		if(local.player.health>2)
		{
			local.vec[0] = local.player.velocity[0]
			local.vec[1] = local.player.velocity[1]
			local.vec[2] = local.velocity_get

			local.player.velocity = local.vec
		}
		else
		{
			local.player.ejecting=0
		}
		
		if(local.player.dmteam=="spectator")
		{
			local.player.ejecting=0
		}

		if( ( local.player getposition ) == "standing")
		{
			local.player.ejecting=0
		}

		waitframe
	}

	local.chute remove

	self gravity 1
end

```

# zz_admin-Pro_1.22_modif\server_planes\plane_crash.scr

```scr
main:
	self thread plane_explode
end

plane_crashing:

	if(self.plane==NULL || self.plane==NIL)
	{
		end
	}

	self thread plane_crash

	local.flyingexplosion = spawn "models/emitters/fireandsmoke.tik"			
	local.flyingexplosion glue self.plane
	local.flyingexplosion.origin = self.plane.origin
	local.flyingexplosion.scale = self.plane.scale
	local.flyingexplosion anim start
	local.flyingexplosion notsolid

	local.flyingsmoke = spawn "models/emitters/plane_smoke.tik"			
	local.flyingsmoke glue self.plane
	local.flyingsmoke.origin = self.plane.origin
	local.flyingsmoke.scale = self.plane.scale
	local.flyingsmoke anim start
	local.flyingsmoke notsolid

	local.now = self.plane.angles[0]
	local.end = local.now + 40

	for(local.i=0;local.i<=45 ;local.i+=2)
	{
		waitframe
		if(self.plane==NULL || self.plane==NIL)
		{
			break
		}
		else
		{
			self.plane.angles = ( local.i self.plane.angles[1] self.plane.angles[2] )
		}
	}

	while(self.plane)
	{
		waitframe
	}

	local.flyingsmoke remove
	local.flyingexplosion remove
end	

plane_crash:

	if(self.plane!=NULL)
	{
		local.hitthing=self

		while(local.hitthing==self || local.hitthing.targetname == "planebomb")
		{
			self.plane waittill touch
			local.hitthing = parm.other
		}
		
		self thread plane_explode
	}

end	


plane_explode:

	self solid
	local.plane = self.plane
	local.origin = local.plane.origin 
	self.plane explode
	self.plane  remove

	local.Exp = spawn "emitters/aircraft_explosion.tik" //"fx/scriptbazookaexplosion.tik"
	local.Exp2 = spawn "animate/fx_mortar_dirt.tik"
	local.Exp.origin = local.origin
	local.Exp2.origin = local.origin
	
	if(self.in_para_drop!=1)
	{
		self damage local.Exp2 100 local.Exp2 (0 0 0) (0 0 0) (0 0 0) 0 1 rocket -1
	}

	radiusdamage local.origin 100 300 0

	local.Exp anim start
	local.Exp2 anim start
	wait 1
	local.Exp remove	
	local.Exp2 remove
	
	self.flying = 0

	$("planehit" + self.entnum) remove

end	

```

# zz_admin-Pro_1.22_modif\server_planes\server_fly.scr

```scr
main:
	
	if(self.flying == 1)
	{
		self.scale = 1
		end
	}

	if(self.OWNS == 1)
	{
		self.scale = 1
		self.flying = 0
		end
	}

	self.no_usemine = 1 //stop them using a mine
	self.no_usemedic = 1 //stop medics

	self.flying = 1
	self takedamage

	local.team = self.dmteam

	if(level.planes_max["allies"]== NIL)
	{
		waitexec server_planes/setup.scr
	}

	level.planes[local.team]++

	local.allies = waitexec global/settings.scr::getcmd "max-allies"
	local.axis = waitexec global/settings.scr::getcmd "max-axis"

	level.planes_max["allies"] = int local.allies 
	level.planes_max["axis"] = int local.axis

	if(level.planes[local.team] == level.planes_max[local.team])
	{
		exec server_planes/trigger.scr::from_fly local.team
	}

	self hide
	if(self.instructed!=1)
	{
		self waitexec server_planes/first_flight_instructions.scr
	}

	//spawn the plane
	local.plane = spawn script_model "targetname" ("flyingplane" + self.entnum)
	if(self.dmteam == "axis")
	{
		local.plane model "vehicles/fockwulffly.tik"
	}
	else
	{
		local.plane model "vehicles/p47fly.tik"	
	}

	local.plane.origin = self.plane_start
	local.plane.scale = self.scale 


	if(self.seat==NIL)
	{


		if(local.plane.scale == .75)
		{
			self.seat[0] = -335 //3
			self.seat[1] = 10
		}
		else if(local.plane.scale == .2)
		{
			self.seat[0] = -115 //3
			self.seat[1] = -50 //-65
		}
		else
		{
			self.seat[1] = -65
		}
	}
		
	if(local.plane.scale == .75)
	{
		local.plane setsize ( -100 -100 -5 ) ( 100 100 30 )
	}
	else if(local.plane.scale == .2)
	{
		local.plane setsize ( -60 -60 -5 ) ( 60 60 10 )
	}

	local.plane touchtriggers

	local.plane physics_on
	local.plane.gravity = 0
	
	//set the plane
	self.plane = local.plane

	//hmm
	local.plane takedamage

	self.maxspeed = waitexec global/settings.scr::getcmd "maxspeed"
	self.minspeed = waitexec global/settings.scr::getcmd "minspeed"
	local.speed =  waitexec global/settings.scr::getcmd "startspeed"
	self.candrop =  waitexec global/settings.scr::getcmd "plane-bombs"
	self.rocket_ammo =  waitexec global/settings.scr::getcmd "rockets"
	level.plane_hit_damage =  waitexec global/settings.scr::getcmd "plane-hit-dmg"

	self.acceleration =  waitexec global/settings.scr::getcmd "acceleration"
	self.deceleration =  waitexec global/settings.scr::getcmd "deceleration"


	self.acceleration = int self.acceleration
	self.deceleration = int self.deceleration

	//set start speed
	waitexec server_planes/speedup.scr local.speed self

	self.maxspeed = int self.maxspeed 
	self.minspeed = int self.minspeed 
	self.candrop = int self.candrop
	self.rocket_ammo  = int self.rocket_ammo 

	self notsolid
	self forcetorsostate PLANE_TORSO
	self forcelegsstate STAND
	self hide
	self.scale = 1
	//self gravity 0
	self.planeweap = 1 
	self.rocketside=1
	self.firingrocket=0
	self.spawnedmg = 0
	self.extraangle = 0
	self.in_para_drop=0
	self.shooting=0	
	self.shootdelay = 0.10
	self.changedelay = .3
	self.canchange = 1 
	self.ejecting=0	

	//announce Player in plane
	local.team  = waitexec global/strings.scr::to_upper local.team  0
	iprintlnbold (local.team  + " Aircraft Spotted On Radar!!!")
	local.team = self.dmteam

	local.plane.angles = self.viewangles
//main loop
	self exec server_planes/plane_crash.scr::plane_crash
	self exec server_planes/damage.scr::shotdown_setup //setup shot by trigger

	local.plane loopsound fly_snd

	
	//self exec server_planes/avatar.scr

	self.z = 0

	while(isalive self && self.dmteam == local.team && self.ejecting!=1)
	{
		if(self==NIL || self==NULL)
		{
			end
		}

		self waitthread playerkeep

/// set planes angles



		if(self.viewangles[1] != local.oldangle)
		{
			local.viewvec = angles_toforward self.viewangles
			local.leftdot = vector_dot local.viewvec self.leftvector
			local.right = 0
			local.right -= local.leftdot
			
			self.z = self.z  + local.right * 10

			local.newangle = local.right * 100 // * 200 //350 //400 //50


			local.newangle =  self.viewangles[2] + local.newangle
			local.plane.angles = ( self.viewangles[0]  self.viewangles[1] local.newangle )
			
			local.newangle =  local.newangle / 10

			
			self.viewangles = ( self.viewangles[0]  self.viewangles[1] self.z )

		}
		else
		{
			
			if(self.z > 10 || self.z < -10 )
			{
				if(self.z >=1)
				{ 
					if(self.z > 180)
					{
						self.z += 10
					}
					else
					{
						self.z -= 10
					}
				}
				else if(self.z <= -1)
				{
					if(self.z < -180)
					{
						self.z -= 10
					}
					else
					{
						self.z += 10
					}
				}
			}
			else
			{
				if(self.z >=1)
				{ 
					self.z -= 1
				}
				else if(self.z <= -1)
				{
					self.z+= 1
				}
			}

			self.viewangles = ( self.viewangles[0]  self.viewangles[1] self.z )

			local.plane.angles = 	self.viewangles
			
		}

		local.oldangle = self.viewangles[1]

		if(self.z >= 360)
		{
			self.z = 0
		}
		else if(self.z <= -360)
		{
			self.z = 0
		}


		local.plane.velocity = local.plane.forwardvector * self.speed

		if(self.useheld==1 && self.canchange == 1)
		{
			self exec server_planes/damage.scr "CHANGE_WEAPON"
		}
		
		
		if(self.fireheld==1 && self.shooting != 1)
		{
			//local.move = self getmovement
			//if(local.move != "walking")
			//{
				self exec server_planes/damage.scr "SHOOT"	
			//}
		}
				
		waitframe

//colision

		if(local.origin==self.origin)
		{
			self exec server_planes/plane_crash.scr::plane_explode
			end
		}
		
		local.origin = self.origin
	}
	
	self.no_usemine = 0 //can use a mine again
	self.no_usemedic = 0 //

////// END OF MAIN LOOOP
	level.planes[local.team]--
	self exec server_planes/plane_crash.scr::plane_crashing //crash sequence

	if(self.plane != NIL && self.plane != NULL)
	{	
		waitframe
		self.origin = self.plane.origin + ( 0 10 100 )
	}
end


playerkeep:
	local.offset = self.plane.origin + ( 0 0 self.seat[1] ) + self.plane.forwardvector  * self.seat[0] + 0.05 * self.plane.forwardvector * self.speed
	self.origin = local.offset
end


```

# zz_admin-Pro_1.22_modif\server_planes\setup.scr

```scr
main:
	exec server_planes/sound.scr

	level.planes["allies"] = 0
	level.planes["axis"] = 0
end
```

# zz_admin-Pro_1.22_modif\server_planes\sound.scr

```scr
main:
	local.master = spawn scriptmaster
//30cal
	local.master aliascache jeep_snd_fire sound/weapons/fire/50CalFire2.wav soundparms 1.05 0.2 0.95 0.1 800 4000 weapon loaded maps level.mapname
	local.master aliascache explode_plane_flying sound/weapons/explo/Explo_MetalMed1.wav soundparms 0.9 0.2 0.8 0.2 1000 8000 weapon loaded maps level.mapname
	local.master aliascache leadinmp2 sound/weapons/explo/Exp_LeadIn_07.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps level.mapname
	local.master aliascache fly_snd sound/vehicle/M1_StukaIdle.wav soundparms 1.5 0.5 2.0 0.5 800 4000 item loaded maps level.mapname


end

```

# zz_admin-Pro_1.22_modif\server_planes\speedup.scr

```scr
main local.speed local.player:

	local.speed = waitexec global/strings.scr::split_line local.speed 1 "-"

	self.speed = int local.speed[1][1]
	local.player thread speedup local.speed[1][2] 
end

speedup local.speed:

	local.speed = int local.speed

	while(self.speed < local.speed)
	{
		self.speed += self.acceleration
		waitframe
	}
end
```

# zz_admin-Pro_1.22_modif\server_planes\Template_planes.txt

```txt
exec server_planes/trigger.scr ( ORIGIN_TEMPLATE ) "allies" .2

```

# zz_admin-Pro_1.22_modif\server_planes\trigger.scr

```scr
// 08/12/2005 16:43 Forced player to use pistol before he/she starts to use a plane, this fixed sniper

main local.origin local.team local.scale local.start_pos:

	if(level.planes == NIL)
	{
		exec server_planes/setup.scr
	}

	if(local.origin==NIL)
	{
		println "no origin"
		end
	}

	if(local.scale==NIL)
	{
		local.scale = .2
	}

	if(local.start_pos==NIL)
	{
		local.start_pos = local.origin + ( 0 0 500 )
	}

	if(local.team == NIL)
	{
		println  "no team"
		local.team = randomint (1) + 1
		
		if(local.team == 0)
		{
			local.team = "axis"
		}
		else
		{
			local.team = "allies"
		}
	}

	local.plane = spawn script_model "targetname" ("plane_trigger" + local.team)
	
	if(local.team =="axis")	
	{
		local.plane model "vehicles/fockwulffly.tik"
	}
	else
	{
		local.plane model "vehicles/p47fly.tik"
	}


	local.plane.origin = local.origin 
	local.plane.scale = .1
	local.plane light 1 0 0 50
	//local.plane notsolid
	local.plane ghost

	local.plane.shot = 0

	local.plane_trig = spawn trigger_multiple "targetname" ("plane_trigger_fly" + local.team)
	local.plane_trig.origin = local.origin 
	local.plane_trig setthread fly
	local.plane_trig setsize ( -40 -40 -40 ) ( 40 40 40 ) 
	local.plane_trig.plane_scale = local.scale
	local.plane_trig.start_pos = local.start_pos
	local.plane_trig.team = local.team
	
	local.plane_trig_shot = spawn trigger_multiple "spawnflags" "128"  "targetname" ("plane_shottrigger" + local.team)
	local.plane_trig_shot.origin = local.origin 
	local.plane_trig_shot setthread shot
	local.plane_trig_shot setsize ( -40 -40 -40 ) ( 40 40 40 ) 
	local.plane_trig_shot.team = local.team
	
	level waittill spawn 

	local.i[0] = 0
	local.i[1] = 0
	local.i[2] = 0

	local.v[0] = 3
	local.v[1] = 4
	local.v[2] = 5

	while(1)
	{
		if(local.minues!=1)
		{
			local.v[0] ++ 
			local.v[1] ++
			local.v[2] ++
		}

		if(local.v[2]==10)
		{
			local.minues=1
		}

		if(local.v[2]==3)
		{
			local.minues=0
		}

		if(local.minues==1)
		{
			local.v[0] -- 
			local.v[1] --
			local.v[2] --
		}


		for(local.p=0;local.p<=10;local.p++)
		{

		waitframe

			local.i[0] += local.v[0]
			local.i[1] += local.v[1]
			local.i[2] += local.v[2]

			if(local.plane.shot==1)
			{
				local.i[0] += local.v[0]
				local.i[1] += local.v[1]
				local.i[2] += local.v[2]
				local.i[0] += local.v[0]
				local.i[1] += local.v[1]
				local.i[2] += local.v[2]
				local.plane light 1 0 1 50
			}

			local.plane.angles = ( local.i[0] local.i[1] local.i[2] )
		}
	}




end

end

fly:
	local.player = parm.other
	
	if(local.player.flying != 1 &&  local.player.OWNS != 1)
	{
		local.team = parm.other.dmteam

		if (local.player.rankbonus["planes"] != 1 && level.running_ranking == 1) 
		{
			local.player iprint "You are not a high enough rank to use planes [Staff Sergeant (8 kills) or higher]"
			end
		}

		local.use_teams = waitexec global/settings.scr::getcmd "use-teams"

		if (local.use_teams  == "1")
		{	
			if(self.team != local.player.dmteam)
			{
				local.player iprint "You don't have the training for this aircraft"
				local.plane = waitthread find_trig self.team self

				local.plane light 0 0 1 100
				waitframe
				
				local.plane light 1 0 0 50
				end
			}
		}
		self nottriggerable

		local.player useweaponclass pistol
		wait 1
		local.player.plane_start = self.start_pos	
		local.player scale self.plane_scale 
		local.player exec server_planes/server_fly.scr

		local.trigdelay = waitexec global/settings.scr::getcmd "trig-delay"
		local.trigdelay = int local.trigdelay

		local.trig = waitthread find_trig self.team self
		local.trig hide

		wait local.trigdelay

		local.trig show
		self triggerable
	}
end

shot:
	local.trig = waitthread find_trig self.team self
	local.trig.shot=1
	wait 1 
	local.trig.shot=0
	local.trig light 1 0 0 50
	end
end

find_trig local.team local.trig:

	for(local.i=1;local.i <=  $("plane_trigger" + local.team).size;local.i++)
	{
		if(local.trig.origin ==  $("plane_trigger" + local.team)[local.i].origin)
		{		
			end  $("plane_trigger" + local.team)[local.i]
		}
	}

end

switch__all local.team local.dissable:
	

	for(local.i=1;local.i <=  $("plane_trigger_fly" + local.team).size;local.i++)
	{
		if(local.dissable == 1)
		{
			$("plane_trigger_fly" + local.team)[local.i] nottriggerable
			$("plane_shottrigger" + local.team)[local.i] nottriggerable
			$("plane_trigger" + local.team)[local.i] hide
		}
		else
		{
			$("plane_trigger_fly" + local.team)[local.i] triggerable
			$("plane_shottrigger" + local.team)[local.i] triggerable
			$("plane_trigger" + local.team)[local.i] show
		}
	}
end

from_fly local.team:

	thread switch__all local.team 1

	while(level.planes[local.team] == level.planes_max[local.team])
	{
		wait 1
	}
			
	thread switch__all local.team

end
```

# zz_admin-Pro_1.22_modif\Settings\Admin-Pro Help.url

```url
[InternetShortcut]
URL=http://elgan.funmodsforu.com/
Modified=5085990FA385C5016B

```

# zz_admin-Pro_1.22_modif\Settings\Advanced_universal.txt

```txt
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Advanced_universal.txt
// 
// This file contains the settings that will be used for each map. 
// other files like Advanced.txt can be made map specific. however this file is not.
// Its setitngs will be universal. 
//
// This file is executed first and then depending on the settings found here. Other files
// and information is handled accordingly.
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Extra settings 
//
// These are just quick settings for speed 
// These settings will be executed on load up and will be used for every map. 
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


extra_settings:
		
	// Reset the settings or not
	// game.reset = 0 // Dont reset and keep all of settings. Mods on/off modified will keep.
	// game.reset = 1 // Reset Mods and reload settings. Mods on/off modified will not keep.
	// game.reset = 2 // keep Mods but reload settings. Mods on/off modified will keep. Settings will be reloaded. This allows 
	// 		     you to have map specific settings and not loose settings for Mods on and off value.

	game.reset = 0				 // Reset and reload Admin-Pro when map changes.

end

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Spawn Detection
//
// I found because i do not use the dmprecache file and the state file to exec the script to load the scripts
// the spawn detection does not aquire the scripts needed fast enough. This can be counterd with a wait.
// However i have decided to move all scripts and their paths needed to be executed into this section of advanced.txt.
//	
// The array is worked out first thing. The spawn scripts can then access it. As all the scripts are in this array it will be executing
// scripts that are not needed if the mod the script is linked to is turned off. The mod scripts should have checks in to counter this.
// Last thing the spawn array is remade and useless scripts are removed. You must specify with what mod the scripts are linked with. 
// If "none" is given the script will always be executed.
//
// When manualy respawning players via script or via console with the respawn command. The spawn scripts would run the mods "twice". To counter this
// on the needed scripts only do they get executed if the reload parameter is set 1. Properly scripted mods and respawn commands should not cause problems.
//	
// Even if settings/advanced is map specific the spawn scripts will be loaded from  settings/advanced.txt
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

spawn_scripts:
			//script path				//name to associate with		//reload on forced respawn
	level.spawn_scripts = makearray	
		global/ac/mines/hold_check.scr			"mines"					"0"		// Each time a player spawns the mines are executed
		global/ac/spawn_protection.scr			"spawn-protection"			"1"		// Player Spawn protection script
	        global/ac/time_alive_count.scr			"time-alive"				"0"		// Inform player how long they lived for
		global/ac/medics/hold_check.scr			"medics"				"0"		// Allow players to be medics. USe hold script
		survivor/spawned.scr				"survivor"				"0"		// Survivor game type script to count players
		weapon_limit/radar.scr				"weapons-limiter"			"1"		// Weapons limiter stuff to change weapons etc
		jetpack/jetpack_.scr				"jetpacks"				"1"		// Jetpack mod
	endarray	
end 


```

# zz_admin-Pro_1.22_modif\Settings\Advanced.txt

```txt


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// register cvars
//
// Console variable/Commands. You can enter these straight into the console.
// if you want cvars for your mod you can add them here and they will be created.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	

cvars:
	//creates these cvars
	local.settings = makearray
		//cvars				//setting 			//help
		"admin_cmd"			""  				" This is the main cvar for everything. Entering cmd's into this will allow you to control players, settings and search for help."
	endarray

end local.settings 


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Extra settings 
//
// These are just quick settings for speed 
// level.jump_height sets how high the players jump. settings reset and map specific settigns file up can set diff jump heights for each map.// admin_cmd "jump_height 99" would a new value of 99
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


extra_settings:
	
	game.show_on_mods = 1			 // At start of round's show what mods are on and off under the amom 		
	game.run_bugnadefix =1			 // SH and BT bug nade fix. 1 = ON , 0 = Off
	game.scan_at_start = 1 			 // Scan for admins at level start
	game.input_type = "windows"     	 // windows or linux . set how to split the input "_" linux or " " for windows.
	game.jump_height = 70 //56			 // jump height
	game.run_spawn_protect_on_sh_and_bt = 0	 // run spawn protect on Sh and bt. 1 = yes, 0 or anything else = no
	game.time_alive_type = 1 		 // Either 1 or 0, 1 is in the format of hh/nmm/ss. 0 tells you like "time alive: 19 seconds"
	game.undermap = 1			 // if this is 1 then under map detection will run otherwise it will not.
end



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// State files
//
// For more advanced people who need to change the state files.
// The camper mod checks for it depending on the name string
//
// key
// ---
// aa = allias assault
// ss = spearhead
// bt = breakthrough
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


statefiles:

	local.statepath = makearray
		// Game			// file
		"A" 			global/nagle_aa
		"S" 			global/nagle_sh
		"B" 			global/nagle_bt
	endarray

end local.statepath 

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Console commands
//
// This is in advanced because it is more advanced. the only person who is going to use this is probably me (Elgan).
//
// The following is a list of scripts to search through for commands put intp the console.
// 
// game.player_scripts holds a array of scripts with a switch or list of words and things to do to players. 
// game.one_word_scripts holds an array of scripts that get executed when one word is enterd into console. like campercmd  "help"
// game.commands_with_extra_scripts holds an array of scripts that get executed when more then one word is enterd. it searches for the first word, 
//
// All scripts created should be places ina folder named command_post
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


console_scripts:

	game.player_scripts = makearray
		// script name				// game to load in. AA, SH, BT or "all". You can enclose 2 like so "SH BT".
		"player_cmds.scr"			"all"
		"rindog_themedcommands.scr"		"all"
		"rindog_themedcommands_sh.scr"		"SH BT"
		"player_cmds_sh.scr"			"SH BT"
	//	"punishments.scr"			"all"
	endarray


	game.one_word_scripts = makearray
		// script name				// game to load in. AA, SH, BT or "all"
		"one_word.scr"				"all"
	endarray


	game.commands_with_extra_scripts = makearray
		// script name				// game to load in. AA, SH, BT or "all"
		"commands_with_extra.scr"		"all"
	endarray

end 

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Extra Scripts that seem misfit. Scripts that need executing to set things up i place here. 
// As they are not a mod and dont belong in mods.txt placing them here will get executed each 
// level.
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

extra_scripts:

	exec global/under_map.scr //check for players under the map
	exec global/sounds.scr	  // file with all the possible sounds
	
end


```

# zz_admin-Pro_1.22_modif\Settings\Bugnade.txt

```txt
//
// Bugnade fix settings file
//
//Fix by @(...:.:...)@ / Hal
//
//Bugnading is a word to describe the action of holding a grenade 
//through a door, or sometimes a wall untill it blows up. When it 
//blows up the holder does not get hurt, as the grenade is physicly 
//on the other side of the door/wall. This also means anyone on the 
//other side can get killed by the grenade. This fix detects when a 
//player has 'bugnaded' and imediatley kills the player and removes 
//a set amount of kills. This issue effects Spearhead and Breakthrough 
//only.
//
//You can edit the text/values between quotes ( "" ) below to change some settings.

main:
	level.bugnadesettings = makearray
	// The number of kills to remove from a player who is detected bugnading.
	//The player also looses 1 for suiciding, so -3 in total (if you choose -2).
"-2"
	//
	//The message the player says when he is detected bugnading:
"I was caught bugnading* and it cost me 3 kills."
	//
	//The message displayed to all players on the server, explaining what bugnading is:
"* Bugnading = blowing up grenades through walls/doors, to either prevent your own death, or kill people on the other side"
	//
	//The message displayed on the bugnader's screen after he is caught:
"You have been caught bugnading. E.G you held a grenade in or through a door/wall untill it blew up."
	endarray
end 
```

# zz_admin-Pro_1.22_modif\Settings\camper.txt

```txt
//
// Anti camper SFX camper settings.txt
// version 1.20
//
// Questions should go to www.mods-r-us.net forums or elgan.sayer@gmail.com
//
// www.mods-r-us.net
//
// **************************************************************************************************************************************


main:

	// Commands and Settings
	local.campersettings = makearray
		//command			//setting			//help	
		"type"				"random"			" type - sets whats to do to campers set to random for random"	
		"weaponscheck"   		"0"  				" Check for weapons and use their specified time."
		"time"  			"120"				" Amount of time before they become a camper"				
		"message"			"You were camping"		" Sets the message to send to campers when they camp. If no message is set nothing will be displayed"
		"saysound"       		"1" 				" saysound - Plays the stay still and die sound, 0 - off, 1 - on" 
		"radius"        		"230" 				" radius - Sets the radius size of the camping spot"
		"hurt"				"5"  				" hurt - ammount of health to take away"
		"duration"			"spot" 				" Duration- This will set for how long the camper type runs on the player. eg, set it to 10, it will run for 10 seconds. You can also set it to death and spot. death - run until dead, spot - while in camping radius. duration has replaced to_death"
		"hurt-delay"			"1"				" Time between damage is applied to campers in damagable types.Fire for example. time in seconds"
		"say-pos"			"1"				" This will announce the players position like FT"
		"turret-camp" 			"1"				" Do players using turret weapons camp, 1 - yes, 0 - no"
		"maxcamps"			"0"				" Sets max camp times. If exceeded camper is kicked (this is set by the punishment script in ac)."																					global/ac/punishment.scr	
	//bomb setting commands				
		"silent" 			"1"				" ticktime - set 1 to make the tick not run, 0 makes it run"
		"ticktime"       		"10" 				" ticktime - how long the bomb ticks for before bang"
		"bomb-exp-mdl" 			"animate/fx_mortar_dirt.tik"	" Set the model tik for the bomb explosion"
		"bomb-exp-mdl2"			"fx/scriptbazookaexplosion.tik"	" Set the model tik for the 2nd bomb explosion"
		"bomb-mdl" 			"items/explosive.tik"		" Set the model tik for the bomb"
	//light settings
		"lightcolour"   		"0 0 1 100" 			" lightcolour - RGB radius"
	// giant settings
		"scalesize" 			"3"				" scalesize - sets size of player when camping in scale mode"
	// tent
		"tent-mdl" 			"models/static/tent.tik"	" Set the model tik for the tent"
	// tele
		"tele-spot" 			( 0 0 400 )			" teleport to this location on tele type"
	// fire
		"fire-mdl" 			"static/fire.tik"		" Set the model tik for the fire"
	// spin
		"spin-speed" 			"3"				" Speed for spinning, Tip: DOnt put it too low."
	endarray


end local.campersettings 



// Types are what u can do to the player when camping or when forcing from the console. You can add as many as you wish.

types:
	// types
	local.campersettings = makearray
		//type				//thread or file			//help
		"bomb"				global/ac/types.scr::bomb 		" Spawns a bomb that ticks down to explode on the camper"
		"fire" 				global/ac/types.scr::fire		" set's the camper on fire"
		"light"				global/ac/types.scr::light 		" turn camper into a light"
		"bleed" 			global/ac/types.scr::bleed		" start bleeding."
		"scale" 			global/ac/types.scr::scale		" make the camper a giant/midget."
		"takeall" 			global/ac/types.scr::takeall		" takes all the campers weapons away"
		"viewtwist"			global/ac/types.scr::viewtwist		" should be called dizzy"
		"tent"				global/ac/types.scr::tent  		" turns the camper into a tent"
		"random"			global/ac/types.scr::random  		" randomly pick a type"
		"tele"				global/ac/types.scr::tele  		" teleport to tele_spot (can be map specific using map settings)"
		"spin"				global/ac/types.scr::spin  		" Sping the player"
		"plyometrics"			global/ac/types.scr::plyometrics	" become a athlete"
		"corona"			global/ac/types.scr::corona		" Spawns a corona abopve the players head"
	endarray
	/// When adding types do not put " "'s around the thread/script

end local.campersettings 



// This is the map list. The camper mod  checks this list for maps. if the map is not found the mod turns itself off.
// You can add maps and take maps form the list. for more info see the instructions.

maps:
	//MAPS
	local.maplist = makeArray
		//dm maps
		"dm/mohdm1"
		"dm/mohdm2"
		"dm/mohdm3"
		"dm/mohdm4"
		"dm/mohdm5"
		"dm/mohdm6"	
		"dm/mohdm7"
		//objective maps
		"obj/obj_team1"
		"obj/obj_team2"
		"obj/obj_team3"
		"obj/obj_team4"
		//sh maps
		"dm/mp_bahnhof_dm"
		"dm/mp_bazaar_dm"
		"dm/mp_brest_dm"
		"dm/mp_gewitter_dm"
		"dm/mp_holland_dm"		
		"dm/mp_stadt_dm"
		"dm/mp_unterseite_dm"
		"dm/mp_verschneit_dm"
		//bt only / dm/
		"dm/mp_palermo_dm"
		"dm/mp_malta_dm"
		//sh + bt /obj
		"obj/mp_ardennes_tow"
		"obj/mp_berlin_tow"
		"obj/mp_flughafen_tow"
		"obj/mp_druckkammern_tow"
		//bt only /obj
		"obj/mp_palermo_obj"
		"obj/mp_montecassino_tow"
		"obj/mp_montebattaglia_tow"
		"obj/mp_kasserine_tow"
		"obj/mp_castello_obj"
		"obj/mp_bologna_obj"
		"obj/mp_bizertefort_obj"
		//bt only /lib
		"lib/mp_tunisia_lib"
		"lib/mp_bizerteharbor_lib"
		"lib/mp_anzio_lib"
		"lib/mp_ship_lib"
		//custom maps	
	endArray

end local.maplist




//these game types are what the camper mod will run in. if the game type is not there it will not run! Add or remove them as you wish.

gametypes:
	
	local.gametypes = makeArray
	//game type #	// String- just for refrence
		"1"	//FFA	
		"2"	//TDM
		"3"	//RBM
		"4"	//OBJ
		"5"	//TOW
		"6"	//LIB
	endArray

end local.gametypes



//setting ALLIED ASSAULT weapon times to 0 make them immune to camping
// grenades and pistols use normal time

weaponsaa:
	//if u put them at rediculasly  low times the type will cancel itself out if they camp when camping already
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar" 				"30"			" Sets the camping time for this weapon. 0 = immune to camping"			
		"bazooka" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"kar98" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"kar98sniper" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"m1_garand" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"mp40" 				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"mp44" 				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"panzerschreck" 		"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"shotgun"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"springfield" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"thompsonsmg" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"unarmed" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
	endarray
end local.weapons


//setting SPEARHEAD weapon times to 0 make them immune to camping
// grenades and pistols use normal time
weaponssh:
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar" 				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"bazooka" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"kar98" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"kar98sniper" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"m1_garand" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"mp40" 				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"mp44" 				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"panzerschreck" 		"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"shotgun"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"springfield" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"thompsonsmg" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"enfield" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"g43" 				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"mosin_nagant_rifle" 		"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"ppsh_smg" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"sten" 				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"svt_rifle" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"kar98_mortar" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"unarmed" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
	endarray
end local.weapons



//setting BREAKTHROUGH weapon times to 0 make them immune to camping
// grenades and pistols use normal time

weaponsbt:
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar"				"30"			" Sets the camping time for this weapon. 0 = immune to camping"			
		"bazooka"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"		
		"delisle"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"enfield"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"g43"				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"gr_w_minedetector"		"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"it_w_breda"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"		
		"it_w_carcano"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"2it_w_howitzerdes"		"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"it_w_moschetto"		"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"kar98"				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"kar98sniper"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"kar98_mortar"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"m1_garand"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"mosin_nagant_rifle"		"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"mp40"				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"mp44"				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"panzerschreck"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"ppsh_smg"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"shotgun"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"springfield"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"sten"				"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"svt_rifle"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"thompsonsmg"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"1uk_w_l42a1"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"uk_w_piat"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"uk_w_vickers"			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"us_w_minedetector"		"30"			" Sets the camping time for this weapon. 0 = immune to camping"
		"unarmed" 			"30"			" Sets the camping time for this weapon. 0 = immune to camping"
	endarray
end local.weapons


```

# zz_admin-Pro_1.22_modif\Settings\countdown.txt

```txt
main:
	local.settings = makearray
		//command			//setting				//help	
		"countdown-time"		"03:00"					"Time on countdown clock"
		"death-location"		"1"					"Like FT and AC, Announce the location to where the radio was dropped"
		"countdown-locate"		"5"					"If the time is above 0 the location of the radio is announced at this time period"
		"countdown-light"		"1"					"If 1 the player will glow red when he/she has the radio"
		"countdown-rounds"		"3"					"Number of rounds before the map changes"
		"radio-model"			"items/walkietalkie.tik"		"Model to use for the radio"
		"countdown-idle"		"300"					"Time in seconds the radio waits before respawning"
		"countdown-hold-for"		"20"					"Time in seconds how long the player can hold the radio before he/she is forced to drop it"
	endarray	

end local.settings
		
maps:
	//MAPS
	local.maplist = makeArray
		//dm maps
		"dm/mohdm1"
		"dm/mohdm2"
		"dm/mohdm6"	

	endArray

end local.maplist

```

# zz_admin-Pro_1.22_modif\Settings\cvar-force.txt

```txt

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Cvar Forcing 
//
// This will force cvars on players using stufftext. 
// Add what cvars you want to the list and what setting you want to force. 
// 
// This can be used to force skins and cheat cvars to what you want.
//
//-----------------
// example
//	
//	local.cvar_force = makearray
//		// cvar				// Setting
//     		"dm_playergermanmodel"  	"german_wehrmacht_soldier"
//         	"dm_playermodel" 		"american_ranger"
//       	"cg_forcemodel" 		"1"
//	endarray
//
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


cvar_force:
	
	local.cvar_force = makearray
		// cvar				// Setting
		//"cg_forcemodel" 		"0"
	endarray

end local.cvar_force


```

# zz_admin-Pro_1.22_modif\Settings\flyable-planes.txt

```txt
// If you are going to limit the planes in the air "use-teams must be set to "1"


main:
	local.planesettings = makearray
		"maxspeed"		"2200"		"Max speed of the aircraft"
		"minspeed"		"700"		"minimum speed of the aircraft"
		"startspeed"		"700" 	"Speed the aircraft starts with"
		"plane-bombs"		"4"		"Amount of bombs the plane has"
		"rockets"		"2"		"Plane rocket ammo count"
		"eject"			"1"		"if 1 the player can eject if 0 they cant."
		"acceleration"		"20"		"Amount of acceleration upon key press"
		"deceleration"		"20"		"Amount of deceleration upon key press"
		"plane-hit-dmg"	 	"15"		"Amount of damage a plane takes when shot (any weapon)"
		"max-axis"		"2"		"Amount of axis planes allowed in the air at one time, 0 = Dont care"
		"max-allies"		"2"		"Amount of allies planes allowed in the air at one time, 0 = Dont care"	
		"trig-delay"		"5"		"Delay to wait after a trigger has been used to re-activate it"
		"use-teams"		"1"		"If not set 1 any team can use any trigger else a team can only use triggers that link to that team"
	endarray

end local.planesettings

instructions:

	local.instructions = makearray
	//message							//duration in seconds
		"You are about to start flying a plane." 			1.5
		"YOU CAN END THIS MESSAGE BY HOLDING USE." 			1
		"This prints each time you first fly a plane on a map" 		1.5
		" "								0.5
		"Use your mouse to steer the plane" 				1.5
		"Forward run - Speed up"					1.5
		"Backward run - Slow down" 					1.5
		"Left run - Roll left" 						1.5
		"Right run - Roll right"					1.5
		"Forward walk - Cam forward" 					1.5
		"Backward walk - Cam back" 					1.5
		"Left run - Cam up"						1.5
		"Right run - Cam down"						1.5
 		"USE- Change weapon" 						1.5
		"Primary fire = Shoot" 						1.5
		"Secondary fire = drop bomb" 					1.5
		"Jump = Bail out" 						1.5
		" "								0.5
		 "Your about to start flying" 					1.5
		"3" 								1
		"2" 								1
		"1"								1
	endarray		

end local.instructions
```

# zz_admin-Pro_1.22_modif\Settings\Further Admin-Pro Help.url

```url
[InternetShortcut]
URL=http://www.mods-r-us.net/
Modified=E0C8C019CEF5C5010A

```

# zz_admin-Pro_1.22_modif\Settings\medics.txt

```txt
main:
	local.settings = makearray
		//command			//setting			//help	
		"health"			"100"				" Amount of health a player has to give away"
		"medic-weapons"			"1"				" Use weapon settings for medics. To check if the weapon they have allows medics"
		"medic-replenish"		"1"				" If 1 the players get their medics health replenished when they respawn. Otherwise they only get the medics health over the round"
	endarray

end local.settings

maps:
	//MAPS
	local.maplist = makeArray
		//dm maps
		"dm/mohdm1"
		"dm/mohdm2"
		"dm/mohdm3"
		"dm/mohdm4"
		"dm/mohdm5"
		"dm/mohdm6"	
		"dm/mohdm7"
                "M1L1"
                "M1L2a"
                "M1L2b"
                "M1L3c"
                "M2L1"
                "M2L2a"
                "M2L2c"
                "M3L2"
                "M3L3"
                "M5L1a"
                "M5L3"
		//objective maps
		"obj/obj_team1"
		"obj/obj_team2"
		"obj/obj_team3"
		"obj/obj_team4"
		"DM/MP_Bahnhof_DM"
		"DM/MP_Bazaar_DM"
		"DM/MP_Brest_DM"
		"DM/MP_Gewitter_DM"
		"DM/MP_Holland_DM"		
		"DM/MP_Stadt_DM"
		"DM/MP_Unterseite_DM"
		"DM/MP_Verschneit_DM"
		//BT only / DM/
		"DM/MP_Palermo_DM"
		"DM/mp_malta_dm"
		//SH + BT /OBJ
		"OBJ/MP_Ardennes_TOW"
		"OBJ/MP_Berlin_TOW"
		"OBJ/MP_Flughafen_TOW"
		"OBJ/MP_Druckkammern_TOW"
		//BT only /OBJ
		"OBJ/MP_Palermo_OBJ"
		"OBJ/MP_MonteCassino_TOW"
		"OBJ/MP_MonteBattaglia_TOW"
		"OBJ/MP_Kasserine_TOW"
		"OBJ/mp_castello_obj"
		"OBJ/MP_Bologna_OBJ"
		//BT only /LIB
		"LIB/mp_tunisia_lib"
		"LIB/mp_bizerteharbor_lib"
		"LIB/mp_anzio_lib"
		"LIB/mp_ship_lib"
		//custom maps	
	endArray



end local.maplist


gametypes:
	
	local.gametypes = makeArray
	//game type #	// String- just for refrence
		"1"	//FFA	
		"2"	//TDM
		"3"	//RBM
		"4"	//OBJ
		"5"	//TOW
		"6"	//LIB
	endArray

end local.gametypes

// Allow players to plant medics with these weapons. 1 = allow. 0 = dont allow
// Note: if they holster their weapon or use grenade or pistol it counts as unarmed.

weaponsaa:
	//if u put them at rediculasly  low times the type will cancel itself out if they camp when camping already
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar" 				"1"			" Allows use of medics with this weapon"			
		"bazooka" 			"1"			" Allows use of medics with this weapon"
		"kar98" 			"1"			" Allows use of medics with this weapon"
		"kar98sniper" 			"1"			" Allows use of medics with this weapon"
		"m1_garand" 			"1"			" Allows use of medics with this weapon"
		"mp40" 				"1"			" Allows use of medics with this weapon"
		"mp44" 				"1"			" Allows use of medics with this weapon"
		"panzerschreck" 		"1"			" Allows use of medics with this weapon"
		"shotgun"			"1"			" Allows use of medics with this weapon"
		"springfield" 			"1"			" Allows use of medics with this weapon"
		"thompsonsmg" 			"1"			" Allows use of medics with this weapon"
		"unarmed" 			"1"			" Allows use of medics with this weapon"
	endarray
end local.weapons

// Allow players to plant medics with these weapons. 1 = allow. 0 = dont allow
// Note: if they holster their weapon or use grenade or pistol it counts as unarmed.

weaponssh:
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar" 				"1"			" Allows use of medics with this weapon"
		"bazooka" 			"1"			" Allows use of medics with this weapon"
		"kar98" 			"1"			" Allows use of medics with this weapon"
		"kar98sniper" 			"1"			" Allows use of medics with this weapon"
		"m1_garand" 			"1"			" Allows use of medics with this weapon"
		"mp40" 				"1"			" Allows use of medics with this weapon"
		"mp44" 				"1"			" Allows use of medics with this weapon"
		"panzerschreck" 		"1"			" Allows use of medics with this weapon"
		"shotgun"			"1"			" Allows use of medics with this weapon"
		"springfield" 			"1"			" Allows use of medics with this weapon"
		"thompsonsmg" 			"1"			" Allows use of medics with this weapon"
		"enfield" 			"1"			" Allows use of medics with this weapon"
		"g43" 				"1"			" Allows use of medics with this weapon"
		"mosin_nagant_rifle" 		"1"			" Allows use of medics with this weapon"
		"ppsh_smg" 			"1"			" Allows use of medics with this weapon"
		"sten" 				"1"			" Allows use of medics with this weapon"
		"svt_rifle" 			"1"			" Allows use of medics with this weapon"
		"kar98_mortar" 			"1"			" Allows use of medics with this weapon"
		"unarmed" 			"1"			" Allows use of medics with this weapon"
	endarray
end local.weapons

// Allow players to plant medics with these weapons. 1 = allow. 0 = dont allow
// Note: if they holster their weapon or use grenade or pistol it counts as unarmed.

weaponsbt:
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar"				"1"			" Allows use of medics with this weapon"			
		"bazooka"			"1"			" Allows use of medics with this weapon"		
		"delisle"			"1"			" Allows use of medics with this weapon"
		"enfield"			"1"			" Allows use of medics with this weapon"
		"g43"				"1"			" Allows use of medics with this weapon"
		"gr_w_minedetector"		"1"			" Allows use of medics with this weapon"
		"it_w_breda"			"1"			" Allows use of medics with this weapon"		
		"it_w_carcano"			"1"			" Allows use of medics with this weapon"
		"2it_w_howitzerdes"		"1"			" Allows use of medics with this weapon"
		"it_w_moschetto"		"1"			" Allows use of medics with this weapon"
		"kar98"				"1"			" Allows use of medics with this weapon"
		"kar98sniper"			"1"			" Allows use of medics with this weapon"
		"kar98_mortar"			"1"			" Allows use of medics with this weapon"
		"m1_garand"			"1"			" Allows use of medics with this weapon"
		"mosin_nagant_rifle"		"1"			" Allows use of medics with this weapon"
		"mp40"				"1"			" Allows use of medics with this weapon"
		"mp44"				"1"			" Allows use of medics with this weapon"
		"panzerschreck"			"1"			" Allows use of medics with this weapon"
		"ppsh_smg"			"1"			" Allows use of medics with this weapon"
		"shotgun"			"1"			" Allows use of medics with this weapon"
		"springfield"			"1"			" Allows use of medics with this weapon"
		"sten"				"1"			" Allows use of medics with this weapon"
		"svt_rifle"			"1"			" Allows use of medics with this weapon"
		"thompsonsmg"			"1"			" Allows use of medics with this weapon"
		"1uk_w_l42a1"			"1"			" Allows use of medics with this weapon"
		"uk_w_piat"			"1"			" Allows use of medics with this weapon"
		"uk_w_vickers"			"1"			" Allows use of medics with this weapon"
		"us_w_minedetector"		"1"			" Allows use of medics with this weapon"
		"unarmed" 			"1"			" Allows use of medics with this weapon"
	endarray
end local.weapons


```

# zz_admin-Pro_1.22_modif\Settings\message-center.txt

```txt
main:
	local.settings = makearray
		// advert, message center
		"virtualsize"			"1"				" Sets if the huddraw element should use virutal screen resolution for positioning and size"
		"advert-time"			"30"				" Time between advert messages (hud print) in seconds. 5 * 60 = 500 = 5 minutes"	
		"advert-delay"			"5"				" Time between each message in seconds"
		"advert-colour"			"random" 			" The colour of the advert text RBG"	
		"advert-font"			"verdana-12" 			" Set the font for the advert text"																																	
		"typewriter-click"		"0" 				" make a clicking noise when typing"																																	
		"scroll-speed"			"2" 				" Speed the text scrolls at"																																	
		"scroll-dir"			"left"	 			" Scroll direction, left or right"																																	
	endarray

end local.settings


// advert time and advert-delay
//
// advert-time is the time it waits before showing all the messages again. 
// for example. IT would wait 5 minutes then show all the messages. Then it goes
// back to waiting 5 minutes.
//

// advert-delay is the time between each message shown. So after the advert-time it 
// starts showing the messages. After the message is shown it waits this time before showing the next message
// 


// Advert-colour
// You can set the colour for each message to display in the 4th section of the message. You can either
// set a RBG value or you can set "random". If this 4th section is left blank then the "advert-colour"
// will be used.
//
// Advert-colour is the same as the colour section of the message. It can either be "random" or a RGB colour
// value like "1.0 0 1".
//
// RBG means RED, GREEN, BLUE
// So to make a colour simply use your knowlegde from primary school on mixing the primary colours red, green and blue.
//
// "1 0 0" = red, because it is 1 red, 0 green and 0 blue.
// "0 1 0" = green, because it is 0 red, 1 green and 0 blue.
//
// Because "R G B" stands for red green blue. where a number is set gives the amount of colour. 0 gives no colour.
// so to get purple, that is red and blue we would do "1 0 1".


messages:
	local.messages = makearray
		
		// message					// time to display for		// display style (scroll, fade or typewriter		//Colour
	
		"Running {sfx} Admin-Pro 1.22"																	"3"			"fade"		
		"Download From www.mods-r-us.net"																"3"			"fade"						"1.0 1.0 1.0"
		"Placer des bots : clic droit avec le fusil  pompe"											"5"			"fade"
		"You can kick ennemy's grenade by pressing USE"													"5"			"fade"
		// "You can heal your teammates by pressing USE (Bonus 5)"										"5"			"fade"
		"Ressuscitez vos coquipiers en appuyant sur UTILISER"											"5"			"fade"
		"Renvoyez une grenade en appuyant sur la touche UTILISER"										"5"			"fade"	
		"Plant a proximity mine by holding USE key 2 seconds (Rank : Captain)"							"5"			"fade"
		"Posez une mine en maintenant la touche utiliser 2 secondes (Rang Captain)"						"5"			"fade"
		// "Soignez vos coquipiers en appuyant sur UTILISER prs d'eux (Bonus 5)" 						"5"			"fade"
		"Right clic : smoke grenade"  																	"5"			"fade"			
		"Use your binoculars (7) to call artillery support (aim somewhere and click fire)"  			"5"			"fade"
		"Utilisez vos jumelles (7) et cliquez pour demander un soutien de tirs d'artillerie"			"5"			"fade"
		"Medics get full health and 1 point for healing a teammate"										"5"			"fade"
		"If you see a dead teammate revive him by pressing USE (E)"										"5"			"fade"
		"Vocal alerts : hold use and press fire or secondary fire"										"5" 		"fade"
		"Alertes vocales : maintenez la touche UTILISER et appuyez sur clic droit ou clic gauche"		"5" 		"fade"
		"Press secondary fire with shotgun to spawn a bot"												"5" 		"fade"
		"Server IP : 217.163.22.18:12203"																"5" 		"fade"
		"Les -=[PN]=- recrutent ! contact Xfire : feho22"												"5" 		"fade"
		"Visit us : www.pnclan.fr.cr"																	"5" 		"fade"
	endarray
end local.messages



// Server messaging , Uses hud print to print your messages. 
// i included some suggestions

//-----------------
// example
//
//	local.messages = makearray
//		// message		// time to display for		// Style. So u can display a message different each time.
//		 eg
//		"Elgan Sayer"		"3"				"fade"			"1 0 0"
//		"is"			"3"				"typewriter"		"1 0 1"
//		"{sfx}"			"3"				"scroll""		"random"
//	endarray
//-----------------
```

# zz_admin-Pro_1.22_modif\Settings\mines.txt

```txt
main:
	local.settings = makearray
		//command			//setting			//help	
		"mines-ammo"			"2"				" Count of mines each player is allowed"
		"stopwatch" 			"1"	 			" Display a stopwatch, 0 no, 1 - yes"			
		"hide-mines"			"0"				" When a mine is activated it is then hidden ( not sticky bombs ) "
		"mine-weapons"			"1"				" Use weapon settings for mines. To check if the weapon they have allows mines"
		"mine-replenish"		"1"				" If 1 the players get their mines replenished when they respawn. Otherwise they only get the mines ammo over the round"
		"disarmable"			"1"				" Give the players a chance to disarm the bombs"
		"disarm-time"			"3"				" Time they have to HOLD use to disarm the bomb"
		"disarm-tick"			"4"				" Time they have to disarm the bomb before it explodes"
		"mine-holdtime"			"1"				" Time in seconds the user has to hold USE to plant a mine"
	endarray

end local.settings


mines:
	// 1 = on
	// 0 = off

	//If only one is set on, only that will be used

	local.mines = makearray
		"proximity-plant" 	"1"		"Allow proximity mines you plant to be randomly selected to run"
		"proximity-chuck"	"0"		"Allow proximity mines you throw to be randomly selected to run"
		"sticky-bombs"	        "0"		"Allow proximity mines you plant to be randomly selected to run"
	endarray

end local.mines
	


maps:
	//MAPS
	local.maplist = makeArray
		//dm maps
		"dm/mohdm1"
		"dm/mohdm2"
		"dm/mohdm3"
		"dm/mohdm4"
		"dm/mohdm5"
		"dm/mohdm6"	
		"dm/mohdm7"
                "M1L1"
                "M1l2a"
		"m1l3a"
                "M1l2b"
		"M1l3b"
                "M1l3c"
                "M2l1"
                "M2l2a"
		"m2l2b"
                "M2l2c"
		"m2l3"
		"M3l2"
                "M3l3"
		"m4l0"
		"m4l1"
		"m4l2"
		"m4l3"
                "M5l1a"
		"m5l1b"
		"m5l2a"
                "M5l3"
		"M6l1a"
		"M6l1c"
		"m6l2a"
		"m6l3b"
		"m6l3c"
		"m6l3d"
                //objective maps
		"obj/obj_team1"
		"obj/obj_team2"
		"obj/obj_team3"
		"obj/obj_team4"
		"DM/MP_Bahnhof_DM"
		"DM/MP_Bazaar_DM"
		"DM/MP_Brest_DM"
		"DM/MP_Gewitter_DM"
		"DM/MP_Holland_DM"		
		"DM/MP_Stadt_DM"
		"DM/MP_Unterseite_DM"
		"DM/MP_Verschneit_DM"
		//BT only / DM/
		"DM/MP_Palermo_DM"
		"DM/mp_malta_dm"
		//SH + BT /OBJ
		"OBJ/MP_Ardennes_TOW"
		"OBJ/MP_Berlin_TOW"
		"OBJ/MP_Flughafen_TOW"
		"OBJ/MP_Druckkammern_TOW"
		//BT only /OBJ
		"OBJ/MP_Palermo_OBJ"
		"OBJ/MP_MonteCassino_TOW"
		"OBJ/MP_MonteBattaglia_TOW"
		"OBJ/MP_Kasserine_TOW"
		"OBJ/mp_castello_obj"
		"OBJ/MP_Bologna_OBJ"
		//BT only /LIB
		"LIB/mp_tunisia_lib"
		"LIB/mp_bizerteharbor_lib"
		"LIB/mp_anzio_lib"
		"LIB/mp_ship_lib"
		//custom maps	
	endArray



end local.maplist


gametypes:
	
	local.gametypes = makeArray
	//game type #	// String- just for refrence
		"1"	//FFA	
		"2"	//TDM
		"3"	//RBM
		"4"	//OBJ
		"5"	//TOW
		"6"	//LIB
	endArray

end local.gametypes

// Allow players to plant mines with these weapons. 1 = allow. 0 = dont allow
// Note: if they holster their weapon or use grenade or pistol it counts as unarmed.

weaponsaa:
	//if u put them at rediculasly  low times the type will cancel itself out if they camp when camping already
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar" 				"1"			" Allows use of mines with this weapon"			
		"bazooka" 			"1"			" Allows use of mines with this weapon"
		"kar98" 			"1"			" Allows use of mines with this weapon"
		"kar98sniper" 			"1"			" Allows use of mines with this weapon"
		"m1_garand" 			"1"			" Allows use of mines with this weapon"
		"mp40" 				"1"			" Allows use of mines with this weapon"
		"mp44" 				"1"			" Allows use of mines with this weapon"
		"panzerschreck" 		"1"			" Allows use of mines with this weapon"
		"shotgun"			"1"			" Allows use of mines with this weapon"
		"springfield" 			"1"			" Allows use of mines with this weapon"
		"thompsonsmg" 			"1"			" Allows use of mines with this weapon"
		"unarmed" 			"1"			" Allows use of mines with this weapon"
	endarray
end local.weapons

// Allow players to plant mines with these weapons. 1 = allow. 0 = dont allow
// Note: if they holster their weapon or use grenade or pistol it counts as unarmed.

weaponssh:
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar" 				"1"			" Allows use of mines with this weapon"
		"bazooka" 			"1"			" Allows use of mines with this weapon"
		"kar98" 			"1"			" Allows use of mines with this weapon"
		"kar98sniper" 			"1"			" Allows use of mines with this weapon"
		"m1_garand" 			"1"			" Allows use of mines with this weapon"
		"mp40" 				"1"			" Allows use of mines with this weapon"
		"mp44" 				"1"			" Allows use of mines with this weapon"
		"panzerschreck" 		"1"			" Allows use of mines with this weapon"
		"shotgun"			"1"			" Allows use of mines with this weapon"
		"springfield" 			"1"			" Allows use of mines with this weapon"
		"thompsonsmg" 			"1"			" Allows use of mines with this weapon"
		"enfield" 			"1"			" Allows use of mines with this weapon"
		"g43" 				"1"			" Allows use of mines with this weapon"
		"mosin_nagant_rifle" 		"1"			" Allows use of mines with this weapon"
		"ppsh_smg" 			"1"			" Allows use of mines with this weapon"
		"sten" 				"1"			" Allows use of mines with this weapon"
		"svt_rifle" 			"1"			" Allows use of mines with this weapon"
		"kar98_mortar" 			"1"			" Allows use of mines with this weapon"
		"unarmed" 			"1"			" Allows use of mines with this weapon"
	endarray
end local.weapons

// Allow players to plant mines with these weapons. 1 = allow. 0 = dont allow
// Note: if they holster their weapon or use grenade or pistol it counts as unarmed.

weaponsbt:
	local.weapons =  makearray
		//weapon name			//weapon time			//help
		"bar"				"1"			" Allows use of mines with this weapon"			
		"bazooka"			"1"			" Allows use of mines with this weapon"		
		"delisle"			"1"			" Allows use of mines with this weapon"
		"enfield"			"1"			" Allows use of mines with this weapon"
		"g43"				"1"			" Allows use of mines with this weapon"
		"gr_w_minedetector"		"1"			" Allows use of mines with this weapon"
		"it_w_breda"			"1"			" Allows use of mines with this weapon"		
		"it_w_carcano"			"1"			" Allows use of mines with this weapon"
		"2it_w_howitzerdes"		"1"			" Allows use of mines with this weapon"
		"it_w_moschetto"		"1"			" Allows use of mines with this weapon"
		"kar98"				"1"			" Allows use of mines with this weapon"
		"kar98sniper"			"1"			" Allows use of mines with this weapon"
		"kar98_mortar"			"1"			" Allows use of mines with this weapon"
		"m1_garand"			"1"			" Allows use of mines with this weapon"
		"mosin_nagant_rifle"		"1"			" Allows use of mines with this weapon"
		"mp40"				"1"			" Allows use of mines with this weapon"
		"mp44"				"1"			" Allows use of mines with this weapon"
		"panzerschreck"			"1"			" Allows use of mines with this weapon"
		"ppsh_smg"			"1"			" Allows use of mines with this weapon"
		"shotgun"			"1"			" Allows use of mines with this weapon"
		"springfield"			"1"			" Allows use of mines with this weapon"
		"sten"				"1"			" Allows use of mines with this weapon"
		"svt_rifle"			"1"			" Allows use of mines with this weapon"
		"thompsonsmg"			"1"			" Allows use of mines with this weapon"
		"1uk_w_l42a1"			"1"			" Allows use of mines with this weapon"
		"uk_w_piat"			"1"			" Allows use of mines with this weapon"
		"uk_w_vickers"			"1"			" Allows use of mines with this weapon"
		"us_w_minedetector"		"1"			" Allows use of mines with this weapon"
		"unarmed" 			"1"			" Allows use of mines with this weapon"
	endarray
end local.weapons


```

# zz_admin-Pro_1.22_modif\Settings\Mods.txt

```txt
//************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//
//	Admin-Pro v1.22						Information On This file
//								
//	Created by Elgan Sayer					Since the last version of Admin-Pro, settings files are now linked with the mod. This means only needed settings are loaded.
//	17:15 08/12/2005					Unless you know what you are doing you may only have to change the on and off section of each mod, the game type and map lists
//								and the map specific section. 
//	Elgan.Sayer@gmail.com					
//								Setting the map specific is now also moved to the mod list section for the mods settings files. For more information on the map specific settings
//	www.Mods-R-Us.net					see the online help or contact me.
//								
//
//************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************

//						       Turn
//						    MODS ON-OFF
//						       Here
//							 |					
main:		//					 |
	local.scripts = makearray //                     |
		//				        \|/
		// Mod Name			// ON or Off. ( "1" = ON. "0" = OFF)		//Help and about								//Path	to mod script, Set "none" if none.			//Maps list ("all" for all maps)				// game type list ("all" for all game types.				// Settings file. Specify the path to the settings file				// Map Specific
		//-----1---------------------------------2---------------------------------------------------3-----------------------------------------------------------------------------4-------------------------------------------------------------------5----------------------------------------------------------------------6----------------------------------------------------------------------------7-------------------------------------------------------------8----------------------------------------------------------------------------------------------------------------------------------------------------------------
		"weapons-limiter"			"0"					" limit weapons or just take, swap them"					weapon_limit/weapons_limiter.scr				all								all											settings/weapons-limiter						"0"								
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"spawn-protection"			"1"					" Protect spawning in AA. Wont run in SH or BT"					global/ac/spawn_protection_setup.scr				all								all											settings/spawn-protection 						"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"camper" 				"1"  					" Turns camper on and off 1=On, 0 = OFF"					global/anti_camper.scr						all								all											settings/camper								"0"			
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"cvar-forcing"				"0"					" Turns cvar forcing on or off. 1= on, 0 = off"					global/ac/cvar_forcer.scr					all								all											settings/cvar-force							"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"team-balance"				"0"					" Turns Jim's team balance on or off. 1= on, 0 = off"				global/ac/team_balance.scr					all								settings/team-balance.txt::gametypes							settings/team-balance							"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"music"					"0"					" Play music to players depending on settings"					global/ac/music.scr						all								all											settings/music								"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mines"					"1"					" Random, stickybombs, proimity, plant mines"					global/ac/mines/mines.scr					settings/mines.txt::maps					settings/mines.txt::gametypes								settings/mines								"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"time-alive"				"0"					" Count time alive for"								"none"								all								all											"none"									"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"spec-eye"				"0"					" Spectators use eyes of person they spectate "					global/ac/spec_eye.scr						all								all											"none"									"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"message-center"			"0"					" Server Messages using hud Draw"						global/ac/server_messages.scr					all								all											settings/message-center							"0"		
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"medics"				"0"					" Players can heal other players"						global/ac/medics/setup.scr					all								all											settings/medics								"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"jetpacks"				"0"					" Give each player a jetpack"							"none"								all								all											"none"									"0"																						
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Game types																									
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"countdown"				"0"					" Each team must find and hold the radio"					HTR/setup.scr							settings/countdown.txt::maps								all											settings/countdown							"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"survivor"				"0"					" Battle until you have no lives"						Survivor/setup.scr						all								all											settings/survivor							"0"
	
	endarray
end local.scripts


//************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
//
//	Extra Settings Scripts						
//								
//	This section is for script setting files that contain settings or information used by scripted mods
//	that are not in the mod list. These maybe mods that you execute or map scripts that want extra settings.
//
//	*On or Off
//	By settings the second parameter to either 1 or 0. This tells Admin-Pro to eather load or ignore this setting file.
//
//	*Map Specific
//	You can load map specific settings files by setting this to "1". You must then create map specific files for the mapps
//	you want map specific. do this by created duplicate settings files with the name extension of the map. For more information
//	on this see the online help.

//************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************


extra_settings:
	local.admin_cmds = makearray

		// setting path			// Load or dont  , 1 - load, 0 - ignore.		//Map specific, 1 - find map setting file. 0 use normal. note: Restart must be "1"			
		//-------1----------------------------------------2-----------------------------------------------3-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"settings/advanced"				"1"						"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"settings/flyable-planes"			"1"						"0"								
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	endarray
end local.admin_cmds


```

# zz_admin-Pro_1.22_modif\Settings\music.txt

```txt
main:
	// Commands and Settings
	local.settings = makearray
	// Music
		"play-for"			"spectator"			" The players to play the music for. Usage - spectator or all"
	endarray

end local.settings 
```

# zz_admin-Pro_1.22_modif\Settings\spawn-protection.txt

```txt
main:
	local.settings = makearray
		//command			//setting			//help	
		"invulnerabletime"		"4"				" The time the player is immune for after spawning. In seconds"
		"spawn-team"			"both"				" Set the team that is protected. both = both teams, allies = allies only, axis - axis only"
		"spawn-light"			"0"				" When the player spawns they have a light on them during the time they are immune"
		"spawn-lightcolour"		"0 1 0 100"			" The colour of the spawn light. In RGB"
		"print-sp"			"1"				" Print to players spawn protection is on for them"	
	endarray

end local.settings
		


maps:
	//MAPS
	local.maplist = makeArray
		//dm maps
		"dm/mohdm1"
		"dm/mohdm2"
		"dm/mohdm3"
		"dm/mohdm4"
		"dm/mohdm5"
		"dm/mohdm6"	
		"dm/mohdm7"
                "M1L1"
                "M1L2a"
                "M1L2b"
                "M1L3c"
                "M2L1"
                "M2L2a"
                "M2L2c"
                "M3L2"
                "M3L3"
                "M5L1a"
                "M5L3"
		//objective maps
		"obj/obj_team1"
		"obj/obj_team2"
		"obj/obj_team3"
		"obj/obj_team4"
	endArray


end local.maplist


gametypes:
	
	local.gametypes = makeArray
	//game type #	// String- just for refrence
		"1"	//FFA	
		"2"	//TDM
		"3"	//RBM
		"4"	//OBJ
	endArray

end local.gametypes

```

# zz_admin-Pro_1.22_modif\Settings\survivor.txt

```txt
main:
	local.settings = makearray
		//command			//setting			//help	
		"survivor-lives"		"3"				"How many lives each round a player gets"
		"survivor-warmup"		"5"				"Time in seconds to do a warmup before round starts"
		"survivor-rounds"		"3"				"how many rounds to run before the map changes"
	endarray

end local.settings
		

```

# zz_admin-Pro_1.22_modif\Settings\team-balance.txt

```txt
// This is the settings file for a  modified version of Jim's Skill Balancer.




main:
	local.settings = makearray
		//command			//setting			//help	
		"scan-wait"			"3"				"Time between each team scan"
	endarray

end local.settings




// DOnt run in FFA
gametypes:
	
	local.gametypes = makeArray
	//game type #	// String- just for refrence
		//"1"	//FFA	
		"2"	//TDM
		"3"	//RBM
		"4"	//OBJ
		"5"	//TOW
		"6"	//LIB
	endArray

end local.gametypes
```

# zz_admin-Pro_1.22_modif\Settings\weapons-limiter.txt

```txt
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Settings
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


main:
	local.settings = makearray
		//command			//setting			//help	
		"dropweapons"			"1"				" Can or cant drop weapons"
		"swap-message"			"1"				" Send a message to the player telling them their gun was swapped/disallowed"
	endarray

end local.settings

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Strings
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
// These are the strings that appear in the game. They are in seperate parts. Do not change the order or they will appear wrong.
strings:
	
	local.strings = makeArray
	//swap weapons
		"Your weapon was swapped from " //first section
		" to "				//middle after gun
		" by admin"			//End of sentance
	//disallowed  weapons
		"The admin has set that you are not allowed to use the "
		". Please choose a different weapon"
	//Weapon run out
		" is unavailable as "
		" are already in use"
		"The following weapons are available:"
		" left"`
	endArray

end local.strings

//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Allied Assault
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
weaponsAA:

	// This is the settings file for weapons_limiter mod.
	//Scroll down for more help
	
	local.AAweapons = makearray			


		//	Weapon name					Weapon name to replace weapon with				Amount to limit. Set 0 to disable this weapon ( they will be given the choice to pick another ).									
		//Ally weapons													This should be "" if u are swapping a weapon.
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Springfield '03 Sniper"			""									""	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------					
		"Bar"						"Springfield '03 Sniper"									""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Thompson"					"Springfield '03 Sniper"									""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"bazooka"					"Springfield '03 Sniper"									""	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"M1 Garand"					"Springfield '03 Sniper"									""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Axis
		"kar98"						""									""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"KAR98 - Sniper"				""									""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mp40"						"KAR98 - Sniper"									""
		//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mp44"						"KAR98 - Sniper"									""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Panzerschreck"					"KAR98 - Sniper"									""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//both		
		"Shotgun"					"KAR98 - Sniper"									""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	

	endarray
end local.AAweapons 



secondryweaponsAA:

	// Bombs and pistol info.. Either take of keep. 
	local.AAweapons = makearray			
	//	 Weapon Name					keep or take. 1 - take, 				tik file it takes away 
		//Ally weapons	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"colt45"				"1"							"models/weapons/colt45.tik"
		"m2frag_grenade"			"1"							"models/weapons/m2frag_grenade.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Axis
		"steilhandgranate"			"1"							"models/weapons/steilhandgranate.tik"
		"p38"					"1"							"models/weapons/p38.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//both	or items
		"silencedpistol"			"1"							"models/weapons/silencedpistol.tik"
		"binoculars"				""							"models/items/binoculars.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	endarray

end local.AAweapons 



//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Spearhead 
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	

weaponsSH:

	// This is the settings file for weapons_limiter mod.
	// Scroll down for more help
	
	local.SHweapons = makearray			
	//	Weapon name 					Weapon name to replace weapon with				Amount to limit. Set 0 to disable this weapon ( they will be given the choice to pick another ).									
		//Ally weapons													This should be "" if u are swapping a weapon.
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Springfield '03 Sniper"			""								""	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------					
		"bar"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Thompson"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"bazooka"					""								""	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"M1 Garand"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Lee-Enfield"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Mosin Nagant Rifle"				""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"PPSH SMG"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Sten Mark II"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"SVT 40"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Axis
		"kar98"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"KAR98 - Sniper"				""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mp40"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mp44"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Panzerschreck"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"G 43"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Gewehrgranate"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		//both	
		"Shotgun"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	endarray
	
end local.SHweapons 



secondryweaponsSH:

	// Bombs and pistol info.. Either take of keep. 
	local.SHweapons = makearray			
	//	 Weapon Name					keep or take. 1 - take, 				name file it takes awake 
		//Ally weapons	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"colt45"				""							"models/weapons/colt45.tik"
		"m2frag_grenade"			""							"models/weapons/m2frag_grenade.tik"
		"M18 smoke grenade.tik"			""							"models/weapons/M18_smoke_grenade.tik"	
		"mills grenade"				""							"models/weapons/mills_grenade.tik"
		"webley_revolver"			""							"models/weapons/webley_revolver.tik"
		"Russian_F1_grenade"			""							"models/weapons/Russian_F1_grenade.tik"
		"RDG-1_Smoke_grenade."			""							"models/weapons/RDG-1_Smoke_grenade.tik"
		"nagent_revolver"			""							"models/weapons/nagent_revolver.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Axis
		"steilhandgranate"			""							"steilhandgranate.tik"
		"p38"					""							"models/weapons/p38.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//both	or items
		"silencedpistol"			""							"models/weapons/silencedpistol.tik"
		"binoculars"				""							"models/items/binoculars.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	endarray

end local.SHweapons 




//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Breakthrough
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	

weaponsBT:

	// This is the settings file for weapons_limiter mod.
	// Scroll down for more help
	
	local.BTweapons = makearray			
	//	Weapon name 					Weapon name to replace weapon with				Amount to limit. Set 0 to disable this weapon ( they will be given the choice to pick another ).									
		//Ally weapons													This should be "" if u are swapping a weapon.
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Springfield '03 Sniper"			""								""	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------					
		"Minedetector"					""								""
		"bar"						""								""
		"DeLisle"					""								""
		"Vickers-Berthier"				""								""
		"Enfield L42A1"					""								""
		"PIAT"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Thompson"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"bazooka"					""								""	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"M1 Garand"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Lee-Enfield"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Mosin Nagant Rifle"				""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"PPSH SMG"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Sten Mark II"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"SVT 40"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Axis
		"Mauser KAR 98K"				""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"KAR98 - Sniper"				""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mp40"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mp44"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Panzerschreck"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"G 43"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Gewehrgranate"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		"Minensuchgerat"				""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		"Breda"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Moschetto"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Carcano"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//both	
		"Shotgun"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	endarray
	
end local.BTweapons 



secondryweaponsBT:

	// Bombs and pistol info.. Either take of keep. 
	local.BTweapons = makearray			
	//	 Weapon Name				keep or take. 1 - take, 				tiki file it takes away 
		//Ally weapons	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"colt45"				""							"models/weapons/colt45.tik"
		"m2frag_grenade"			""							"models/weapons/m2frag_grenade.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"M18 smoke grenade.tik"			""							"models/weapons/M18_smoke_grenade.tik"	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mills grenade"				""							"models/weapons/mills_grenade.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"webley_revolver"			""							"models/weapons/webley_revolver.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Russian_F1_grenade"			""							"models/weapons/Russian_F1_grenade.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"RDG-1_Smoke_grenade."			""							"models/weapons/RDG-1_Smoke_grenade.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"nagent_revolver"			""							"models/weapons/nagent_revolver.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Axis
		"steilhandgranate"			""							"steilhandgranate.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"p38"					""							"models/weapons/p38.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Bomba"					""							"models/weapons/It_W_Bomba.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Bomba Breda"				""							"models/weapons/It_W_BombaBreda.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Beretta"				""							"models/weapons/It_W_Beretta.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//both	or items
		"silencedpistol"			""							"models/weapons/silencedpistol.tik"
		"binoculars"				""							"models/items/binoculars.tik"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//
	endarray

end local.BTweapons 


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// All games
//
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
maps:
	//MAPS
	local.maplist = makeArray
		//dm maps
		"dm/mohdm1"
		"dm/mohdm2"
		"dm/mohdm3"
		"dm/mohdm4"
		"dm/mohdm5"
		"dm/mohdm6"	
		"dm/mohdm7"
		//objective maps
		"obj/obj_team1"
		"obj/obj_team2"
		"obj/obj_team3"
		"obj/obj_team4"
		"DM/MP_Bahnhof_DM"
		"DM/MP_Bazaar_DM"
		"DM/MP_Brest_DM"
		"DM/MP_Gewitter_DM"
		"DM/MP_Holland_DM"		
		"DM/MP_Stadt_DM"
		"DM/MP_Unterseite_DM"
		"DM/MP_Verschneit_DM"
		//BT only / DM/
		"DM/MP_Palermo_DM"
		"DM/mp_malta_dm"
		//SH + BT /OBJ
		"OBJ/MP_Ardennes_TOW"
		"OBJ/MP_Berlin_TOW"
		"OBJ/MP_Flughafen_TOW"
		"OBJ/MP_Druckkammern_TOW"
		//BT only /OBJ
		"OBJ/MP_Palermo_OBJ"
		"OBJ/MP_MonteCassino_TOW"
		"OBJ/MP_MonteBattaglia_TOW"
		"OBJ/MP_Kasserine_TOW"
		"OBJ/mp_castello_obj"
		"OBJ/MP_Bologna_OBJ"
		//BT only /LIB
		"LIB/mp_tunisia_lib"
		"LIB/mp_bizerteharbor_lib"
		"LIB/mp_anzio_lib"
		"LIB/mp_ship_lib"
		//custom maps	
	endArray



end local.maplist


gametypes:
	
	local.gametypes = makeArray
	//game type #	// String- just for reference
		"1"	//FFA	
		"2"	//TDM
		"3"	//RBM
		"4"	//OBJ
		"5"	//TOW
		"6"	//LIB
	endArray

end local.gametypes








/*



		This part is for the main weapons that you want to limit or replace. You cant limit and replace a weapon at the same time , Just think about that., It wouldn't work.
		
		Replace a weapon
		----------------
		These are the weapons.:D. TO set a weapon to be replaced. Enter the name of the weapon to replace it with in the second field.
		e.g
		The springfield sniper rifle below is being replaced with the bar.


		disallow a weapon
		----------------
		by setting the 3rd parameter of a weapon to 0. you can stop a weapon being used. When chosen the player will be made to pick another weapon.
		e.g
		The bar below is disabled.


		Limit a weapon
		----------------
		by setting the 3rd parameter of a weapon to any number you wish. You are limiting the amount of this weapon in game. 
		If the weapon is all used up then the player will have to choose a diff weapon and they will be told what is available.
		
		If you limited 1 of each sniper. 1 sniper per team. you would set the springfield to 1 and the KAR98sniper to 1. The first players to pick them will get a sniper. ANy others will have to pick a diff weapon.
		when the player died or goes spectator. The weapon will become available again. When they respawn they will take it auto unless someone else chooses it when they die before they respawn.
	
		e.g
		The thompsonsmg is limited to 6 in the map. (this does not include picking up weapons).
		

		Weapon Name					Weapon name to replace weapon with				Amount to limit. Set 0 to disable this weapon ( they will be given the choice to pick another ).									
		//Ally weapons													This should be "" if u are swapping a weapon.
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Springfield '03 Sniper"					"bar"								""	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------					
		"bar"						""								"0"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Thompson"					""								"6"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"bazooka"					""								""	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		""					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Axis
		"kar98"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"KAR98 - Sniper"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mp40"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"mp44"						""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"Panzerschreck"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//both	
		"Shotgun"					""								""
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	




		Here you set if you want nay of these taken away. you cant limit them. Onlydissable them in this version.

		The first param is just the name. The second is to keep or take the weapon. 	Setting the 2nd param to "1" will remove the weapon from the game.

		the 3rd param is just what tik is used to remove the weapon. This is added so you can add custom items etc to be removed from players.

		 Weapon Name					keep or take. 1 - take, 				tiki file it takes away 
		//Ally weapons	
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		"colt45"					"1"							"colt45"
		"m2frag_grenade"				"1"							"m2frag_grenade"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//Axis
		"steilhandgranate"				"1"							"steilhandgranate"
		"p38"						"1"							"p38"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		//both	or items
		"silencedpistol"				"1"							"silencedpistol"
		"binoculars"					""							"models/items/binoculars"
		//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


























*/



```

# zz_admin-Pro_1.22_modif\Survivor\camera.scr

```scr
main:

	local.d = spawn script_object origin self.origin
	

	//woohooo jv found 1 player cam:D
	while!(isalive self)
	{
		waitframe
	}

	local.cam = "cam" + randomint 1000 // make sure it's unique
	local.camera = spawn Camera targetname local.cam
	local.cam_trigger = spawn TriggerCameraUse target local.cam
	local.cam_trigger doUse self
	local.camera targetname ""

	local.camera lookat self
	local.camera orbit local.d //self
	
	self stufftext "playmp3 main/sound/music/mus_17c_failure.mp3"

	local.h = 0
	while(local.true != 1)
	{
		wait 1
		if(level.roundend == 1 || local.h ==8)
		{
			break
		}
		local.h++
	}
	
	local.d delete

	local.cam_trigger = remove
	local.camera remove

	self stufftext "stopmp3"
end


winner local.dmteam:

	local.cam = spawn Camera "targetname" "endcam"
	local.cam.origin = self.origin 
	local.cam follow_distance 190
	local.cam orbit_height 80
	local.cam speed 1.3

	letterbox 1
	self waitexec GLOBAL/get_weapon.scr
	local.player = spawn animate
	local.player.model = self.brushmodel
	local.player hide
	local.player notsolid
	local.player.origin = self.origin
	local.player.angles = self.angles
	local.player show


	//$player noclip	
	self respawn
	self hide
	
	freezeplayer $player


	if(self.weapon != "models/weapons/unarmed.tik")
	{
		local.player anim unarmed_run_into_wall					
	}
	else
	{
		local.player anim unarmed_stand_idle	 							
	}

	local.gun = spawn animate
	local.gun.model = self.weapon
	local.gun.origin = local.player.origin

	local.gun attach local.player  "tag_weapon_right"

	local.cam orbit local.player 

	fadein 5.0 0.0 0.0 0.0 1.0
	

	if(level.team == 1)
	{
		local.dmmanager = spawn DM_Manager

		if(local.dmteam == "draw")
		{
			
			local.dmmanager doroundtransition  

		}
		else
		{
			setcvar "g_gametype" "4"
			teamwin local.dmteam
			setcvar "g_gametype" level.gt
		}
	}

	wait 2

	cuecamera local.cam

	wait 5


	clearletterbox
	cueplayer

	local.player delete

	releaseplayer  $player

	self show


	self stufftext "stopmp3"
	
	local.cam remove

	local.dmmanager = spawn DM_Manager
	local.dmmanager finishroundtransition   

end
	



```

# zz_admin-Pro_1.22_modif\Survivor\dead.scr

```scr
main:

	if(level.run["survivor"] != "1"){end}

	self.lives--

	if( self.lives == 1 && level.lives > 1)
	{
		self iprint ("1 life left, Your last live") 1
	}
	else
	{
		if(self.lives > 1 || self.lives == 0)
		{
			 local.s = " lives"
		}
		else if(self.lives == 1)
		{
			 local.s = "life"
		}

		self iprint ("You now have " + self.lives + local.s + " left") 1


	}

	if(self.lives <=0)
	{
		self waitexec survivor/camera.scr
		self exec survivor/spectator.scr
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\hud.scr

```scr
main local.string local.hud_while:

	huddraw_align 72 left bottom
	huddraw_font 72 facfont-20
	huddraw_rect 72 130 -25 100 20
	huddraw_color 72 1 0 0
	huddraw_alpha 72 1.0
	huddraw_string 72 local.string
	huddraw_virtualsize 72 1

end

```

# zz_admin-Pro_1.22_modif\Survivor\roundend.scr

```scr
main:


	iprintlnbold "The battle is over"
	
	local.winner = waitthread get_winner

	wait 1
	if(local.winner == NIL)
	{
		exec Survivor/hud.scr ("It was a draw!")
		local.dmmanager = spawn DM_Manager
		local.dmmanager doroundtransition  
	}
	else
	{
		//increase the times the battle has been won
		level.round_times = getcvar "survivor_times"
		level.round_times = int level.round_times
		level.round_times++
		setcvar "survivor_times" level.round_times

		if(level.team != 1)
		{
			exec Survivor/hud.scr ("We have the Survivor")
			local.winner dmmessage 0 "I am the winner!"

			local.winner stufftext "playmp3 main/sound/music/medicdance.mp3"
			local.winner thread playmusicFFA
		}
		else
		{
			thread playmusic local.winner.dmteam
		}
			
		local.winner waitexec survivor/camera.scr::winner local.winner.dmteam
	}

	wait 1
	exec Survivor/hud.scr ("Starting new round")
	wait 1
	waitthread inform_players
	exec survivor/setup.scr::startround

end


get_winner:
	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		wait 1
		local.player = $player[local.i]

		if(local.player.dmteam != "spectator" && local.player.playing == 1)
		{
			end local.player
		}
	}

end

inform_players:
	
	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		local.player = $player[local.i]
	
		if(local.player.dmteam != "spectator" && local.player.playing == 0)
		{
			local.player iprint "You can now join the new round"
		}
	}
end

playmusic local.team:
	
	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		local.player = $player[local.i]
	
		if(local.player.dmteam == local.team && local.player.dmteam != "spectator")
		{
			local.player stufftext "playmp3 main/sound/music/medicdance.mp3"
		}
		else 
		{
			local.player stufftext "playmp3 main/sound/music/mus_17c_failure.mp3"
		}
	}

end

playmusicFFA:
	
	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		local.player = $player[local.i]
	
		if(local.player.dmteam != self)
		{
			local.player stufftext "playmp3 main/sound/music/mus_17c_failure.mp3"
		}
	}

end

stopmusic:

	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		$player[local.i] stufftext "stopmp3"	
	
		//if(level.run["music"] != "1" && local.player.dmteam != "spectator"){end}
		// man sod the spec music on admin-pro:D
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\scan_player.scr

```scr
main:

	local.team = self.dmteam

	while(self != NIL && self != NULL && self.dmteam == local.team && self.lives > 0)
	{
		if(level.run["survivor"] != "1"){end}
		wait 1
	}
	
//level.players--
	if(level.team != 1)
	{
		level.players--
	}
	else
	{
		level.players[local.team]--
	}

	if(self != NULL && self != NIL)
	{
		if(self.dmteam == "spectator" || self.lives <= 0)
		{	
		
			if(self != NIL && self != NULL)
			{
				self iprint "You have been eliminated from the game"
				self.playing = 0
			}

			exec Survivor/hud.scr ("A player has been elimnated")
			wait 2	
		}
		else
		{
			if(level.team != 1)
			{
				self spectator //its FFA and they have 
			}
			else
			{
				//they ahve swapped teams
				level.players[self.dmteam]++
				exec survivor/scan_player.scr
			}
		}
	}


	waitthread double_check


	local.end = 0

	if(level.team == 1)
	{
		if(level.players["axis"] <= 0 || level.players["allies"]  <= 0)
		{
			local.end = 1
		}
		
	}
	else
	{
		if(level.players <= 1)
		{
			local.end = 1
		}

	}

	if(local.end == 1)
	{
		level.roundend = 1
		exec Survivor/hud.scr ("The Battle is over")
		exec survivor/roundend.scr 
	}
/*
	else
	{
		if(self != NIL && self != NULL)
		{
			if(self.lives <=0)
			{
				self waitexec survivor/camera.scr
				self exec survivor/spectator.scr
			}
		}
	}

*/
	if(level.team == 1)
	{
		exec Survivor/hud.scr (  level.players["axis"] + " Axis and " + level.players["allies"] + " Allied " + " left")
	}
	else
	{
		exec Survivor/hud.scr (level.players + " Players left")
	}


end


double_check:

	local.players["axis"] = 0
	local.players["allies"] = 0

	for(local.i = 1; local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if(local.player.dmteam != "spectator")
		{
			if(local.player.playing == 1)
			{
				local.players[local.player.dmteam]++
			}
		}
	}

	if(level.team != 1)
	{
		local.people = local.players["axis"] + local.players["allies"]
	
		if(level.players != local.people)
		{
			println "There seems to be a problem with the player count in FFA"
			level.players = local.people
		}
	}
	else
	{
		if(level.players["axis"] != local.players["axis"] || level.players["allies"] != local.players["allies"])
		{
			println "There seems to be a problem with the player count"
			level.players["axis"] = local.players["axis"] 
			level.players["allies"] = local.players["allies"]
		}
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\setup.scr

```scr
main:
	
	if(level.run["survivor"] != "1")
	{
		huddraw_string 72 "Survivor is Being Shut Down"
		wait 2
		huddraw_alpha 72 0
		end
	}

	if(level.Survivor_setup == 1)
	{
		end
	}

	level.Survivor_setup = 1

	level.gt = getcvar "g_gametype"

	
	if(level.gt == "1")
	{
		group.wording = "Survivor DM" 
	}
	else
	{
		group.wording = "Survivor"
	}

	setcvar "g_gametypestring" group.wording

	local.times = getcvar "survivor_times"

	if(local.times == "")
	{
		setcvar "survivor_times" "0"
	}

	local.rounds = waitexec global/settings.scr::getcmd "survivor-rounds"

	if(local.rounds == "")
	{
		local.rounds = 1
	}

//	level waittill prespawn 
	//exec global/ac/spawn_detect.scr survivor/spawned.scr 1
	exec global/killed.scr Survivor/dead.scr 1

	level waittill spawn
		
	thread startround
end

startround:

	thread changemap

	level.roundend = 0

	exec survivor/roundend.scr::stopmusic

	if($endcam)
	{
		$endcam delete
	}

	local.lives = waitexec global/settings.scr::getcmd "survivor-lives"
	local.warmup_time = waitexec global/settings.scr::getcmd "survivor-warmup"

	if(local.lives == "")
	{
		local.lives = 5
	}

	if(local.warmup_time == "")
	{
		local.warmup_time = 5
	}
	
	local.lives = int local.lives
	local.warmup_time = int local.warmup_time

	//local.lives = 1
	//local.warmup_time = 2

	level.lives = local.lives
	level.warmup_time = local.warmup_time //how long the wait is for warmup
	level.survivor_roundstarted = 0

	level.min_players = 2


	if(level.lives == 1)
	{
		level.word = " life"
	}
	else
	{
		level.word = " lives"
	}

	level.gt = getcvar "g_gametype"

	if(level.gt != "1")
	{
		level.team = 1
		level.dmrespawning = 1
		level.clockside = "kills"
		level.players["axis"] = 0
		level.players["allies"] = 0
	}
	else
	{
		level.players = 0
	}

	exec survivor/warm_up.scr
	
	setcvar "g_obj_alliedtext1" group.wording
	setcvar "g_obj_alliedtext2"  ( level.lives + level.word )
	setcvar "g_obj_alliedtext3" "Become "
	setcvar "g_obj_axistext1" "The last man standing"
	setcvar "g_obj_axistext2" "The Survivor"
	setcvar "g_obj_axistext3" "Survivor 1.6"

end



changemap:
	
	//level waittill spawn

	local.rounds = waitexec global/settings.scr::getcmd "survivor-rounds"
	local.rounds = int local.rounds

	if(local.rounds != 0)
	{

		level.round_times = getcvar "survivor_times"
		level.round_times = int level.round_times

		if(level.round_times >= local.rounds)
		{
			setcvar "survivor_times" "0"

			while(1)
			{
				local.gametype = getcvar "g_gametype"
				setcvar "g_gametype" "0"
				bsptransition nextmap
				setcvar "g_gametype" local.gametype
				// wait one frame and set all game types again so map changes and doesnt save game
				waitframe
				setcvar "g_gametype" "0"
				bsptransition nextmap
				setcvar "g_gametype" local.gametype
				wait 15
			}
		}
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\spawned.scr

```scr
main:

	if(level.run["survivor"] != "1"){end}

	if(level.survivor_roundstarted ==0)
	{
		self.playing = 1
		self thread nodamage

		if(level.team == 1)
		{
			level.players[self.dmteam]++
		}
		else
		{
			level.players++
		}

//		level.players[self.dmteam]++
//		level.players[axis]++
//		iprintlnbold level.players
//		wait 3
//		level.survivor_roundstarted = 1
//		self spectator
//		exec survivor/roundend.scr
//
//		local.object = spawn script_object
//		local.object.lives = 5
//		local.object.dmteam = "axis"
//		local.object.playing = 1
//		local.object exec survivor/scan_player.scr
//
//		local.object2 = spawn script_object
//		local.object2.lives = 5
//		local.object2.dmteam = "axis"
//		local.object2.playing = 1
//		local.object2 exec survivor/scan_player.scr
//
//		wait 10
//		local.object2 delete
//		iprintlnbold "delted"

	}
	else
	{
		if (self.playing != 1)
		{
			if(self.survivor_specmode != 1)
			{
				if(level.team == 1)
				{
					exec Survivor/hud.scr (  level.players["axis"] + " Axis and " + level.players["allies"] + " Allied " + " left")
				}
				else
				{
					exec Survivor/hud.scr (level.players + " Players left")
				}

				self.survivor_specmode = 1
				self spectator
				self iprint "You must wait for the next round" 1
				exec survivor/spectator.scr
			}
		}
	}

end

nodamage:
	
	local.team = self.dmteam

	self takeall
	self give "models/weapons/silencedpistol.tik"
	self use "models/weapons/silencedpistol.tik"

	local.team = self.dmteam

	while(level.survivor_roundstarted ==0)
	{
	//	iprintln "no damamge"

		if(level.run["survivor"] != "1")
		{
			self takedamage
			self respawn
			self.forcespawn = 1
			end
		}

		self nodamage

		waitframe
	
		if(self == NULL || self == NIL)
		{
			end
		}

		if(self.dmteam != local.team )
		{
			self.playing = 0

			if(level.team == 1)
			{
				level.players[local.team]--
			}
			else
			{
				level.players--
			}
			end
		}
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\spectator.scr

```scr
main:
	while(level.survivor_roundstarted == 1)
	{
		wait 1
	
		if(level.run["survivor"] != "1"){end}

		if(self == NULL || self == NIL)
		{
			end
		}

		while(self.dmteam == "spectator")
		{
			wait 1

			if(self == NULL || self == NIL)
			{
				end
			}
		}

		self iprint "You must wait for the next round"

		self spectator
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\camera.scr

```scr
main:

	local.d = spawn script_object origin self.origin
	

	//woohooo jv found 1 player cam:D
	while!(isalive self)
	{
		waitframe
	}

	local.cam = "cam" + randomint 1000 // make sure it's unique
	local.camera = spawn Camera targetname local.cam
	local.cam_trigger = spawn TriggerCameraUse target local.cam
	local.cam_trigger doUse self
	local.camera targetname ""

	local.camera lookat self
	local.camera orbit local.d //self
	
	self stufftext "playmp3 main/sound/music/mus_17c_failure.mp3"

	local.h = 0
	while(local.true != 1)
	{
		wait 1
		if(level.roundend == 1 || local.h ==8)
		{
			break
		}
		local.h++
	}
	
	local.d delete

	local.cam_trigger = remove
	local.camera remove

	self stufftext "stopmp3"
end


winner local.dmteam:

	local.cam = spawn Camera "targetname" "endcam"
	local.cam.origin = self.origin 
	local.cam follow_distance 190
	local.cam orbit_height 80
	local.cam speed 1.3

	letterbox 1
	self waitexec GLOBAL/get_weapon.scr
	local.player = spawn animate
	local.player.model = self.brushmodel
	local.player hide
	local.player notsolid
	local.player.origin = self.origin
	local.player.angles = self.angles
	local.player show


	//$player noclip	
	self respawn
	self hide
	
	freezeplayer $player


	if(self.weapon != "models/weapons/unarmed.tik")
	{
		local.player anim unarmed_run_into_wall					
	}
	else
	{
		local.player anim unarmed_stand_idle	 							
	}

	local.gun = spawn animate
	local.gun.model = self.weapon
	local.gun.origin = local.player.origin

	local.gun attach local.player  "tag_weapon_right"

	local.cam orbit local.player 

	fadein 5.0 0.0 0.0 0.0 1.0
	

	if(level.team == 1)
	{
		local.dmmanager = spawn DM_Manager

		if(local.dmteam == "draw")
		{
			
			local.dmmanager doroundtransition  

		}
		else
		{
			setcvar "g_gametype" "4"
			teamwin local.dmteam
			setcvar "g_gametype" level.gt
		}
	}

	wait 2

	cuecamera local.cam

	wait 5


	clearletterbox
	cueplayer

	local.player delete

	releaseplayer  $player

	self show


	self stufftext "stopmp3"
	
	local.cam remove

	local.dmmanager = spawn DM_Manager
	local.dmmanager finishroundtransition   

end
	



```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\dead.scr

```scr
main:
	self.lives--

	if( self.lives == 1 && level.lives > 1)
	{
		self iprint ("1 life left, Your last live") 1
	}
	else
	{
		if(self.lives > 1 || self.lives == 0)
		{
			 local.s = " lives"
		}
		else if(self.lives == 1)
		{
			 local.s = "life"
		}

		self iprint ("You now have " + self.lives + local.s + " left") 1


	}

	if(self.lives <=0)
	{
		self waitexec survivor/camera.scr
		self exec survivor/spectator.scr
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\hud.scr

```scr
main local.string local.hud_while:

	huddraw_align 72 left bottom
	huddraw_font 72 facfont-20
	huddraw_rect 72 130 -25 100 20
	huddraw_color 72 1 0 0
	huddraw_alpha 72 1.0
	huddraw_string 72 local.string
	huddraw_virtualsize 72 1

end

```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\roundend.scr

```scr
main:


	iprintlnbold "The battle is over"
	
	local.winner = waitthread get_winner

	wait 1
	if(local.winner == NIL)
	{
		exec Survivor/hud.scr ("It was a draw!")
		local.dmmanager = spawn DM_Manager
		local.dmmanager doroundtransition  
	}
	else
	{
		//increase the times the battle has been won
		level.round_times = getcvar "survivor_times"
		level.round_times = int level.round_times
		level.round_times++
		setcvar "survivor_times" level.round_times

		if(level.team != 1)
		{
			exec Survivor/hud.scr ("We have the Survivor")
			local.winner dmmessage 0 "I am the winner!"

			local.winner stufftext "playmp3 main/sound/music/medicdance.mp3"
			local.winner thread playmusicFFA
		}
		else
		{
			thread playmusic local.winner.dmteam
		}
			
		local.winner waitexec survivor/camera.scr::winner local.winner.dmteam
	}

	wait 1
	exec Survivor/hud.scr ("Starting new round")
	wait 1
	waitthread inform_players
	exec survivor/setup.scr::startround

end


get_winner:
	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		wait 1
		local.player = $player[local.i]

		if(local.player.dmteam != "spectator" && local.player.playing == 1)
		{
			end local.player
		}
	}

end

inform_players:
	
	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		local.player = $player[local.i]
	
		if(local.player.dmteam != "spectator" && local.player.playing == 0)
		{
			local.player iprint "You can now join the new round"
		}
	}
end

playmusic local.team:
	
	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		local.player = $player[local.i]
	
		if(local.player.dmteam == local.team && local.player.dmteam != "spectator")
		{
			local.player stufftext "playmp3 main/sound/music/medicdance.mp3"
		}
		else 
		{
			local.player stufftext "playmp3 main/sound/music/mus_17c_failure.mp3"
		}
	}

end

playmusicFFA:
	
	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		local.player = $player[local.i]
	
		if(local.player.dmteam != self)
		{
			local.player stufftext "playmp3 main/sound/music/mus_17c_failure.mp3"
		}
	}

end

stopmusic:

	for (local.i = 1;local.i <= $player.size; local.i++ )
	{	
		$player[local.i] stufftext "stopmp3"	
	
		//if(level.run["music"] != "1" && local.player.dmteam != "spectator"){end}
		// man sod the spec music on admin-pro:D
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\scan_player.scr

```scr
main:

	local.team = self.dmteam

	while(self != NIL && self != NULL && self.dmteam == local.team && self.lives > 0)
	{
		wait 1
	}
	
//level.players--
	if(level.team != 1)
	{
		level.players--
	}
	else
	{
		level.players[local.team]--
	}

	thread double_check

	if(self != NULL && self != NIL)
	{
		if(self.dmteam == "spectator" || self.lives <= 0)
		{	
		
			if(self != NIL && self != NULL)
			{
				self iprint "You have been eliminated from the game"
				self.playing = 0
			}

			exec Survivor/hud.scr ("A player has been elimnated")
			wait 2	
		}
		else
		{
			if(level.team != 1)
			{
				self spectator //its FFA and they have 
			}
			else
			{
				//they ahve swapped teams
				level.players[self.dmteam]++
				exec survivor/scan_player.scr
			}
		}
	}

	local.end = 0

	if(level.team == 1)
	{
		if(level.players["axis"] <= 0 || level.players["allies"]  <= 0)
		{
			local.end = 1
		}
		
	}
	else
	{
		if(level.players <= 1)
		{
			local.end = 1
		}

	}

	if(local.end == 1)
	{
		level.roundend = 1
		exec Survivor/hud.scr ("The Battle is over")
		exec survivor/roundend.scr 
	}
/*
	else
	{
		if(self != NIL && self != NULL)
		{
			if(self.lives <=0)
			{
				self waitexec survivor/camera.scr
				self exec survivor/spectator.scr
			}
		}
	}

*/
	if(level.team == 1)
	{
		exec Survivor/hud.scr (  level.players["axis"] + " Axis and " + level.players["allies"] + " Allied " + " left")
	}
	else
	{
		exec Survivor/hud.scr (level.players + " Players left")
	}


end


double_check:

	local.players["axis"] = 0
	local.players["allies"] = 0

	for(local.i = 1; local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if(local.player.dmteam != "spectator")
		{
			if(local.player.playing == 1)
			{
				local.players[local.player.dmteam]++
			}
		}
	}

	if(level.team != 1)
	{
		local.people = local.players["axis"] + local.players["allies"]
	
		if(level.players != local.people)
		{
			println "There seems to be a problem with the player count in FFA"
			level.players = local.people
		}
	}
	else
	{
		if(level.players["axis"] != local.players["axis"] || level.players["allies"] != local.players["allies"])
		{
			println "There seems to be a problem with the player count"
			level.players["axis"] = local.players["axis"] 
			level.players["allies"] = local.players["allies"]
		}
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\setup.scr

```scr
main:
	
	if(level.Survivor_setup == 1)
	{
		end
	}

	level.Survivor_setup = 1


	local.run = getcvar "survivor"

	if(local.run == "0")
	{
		setcvar "survivor" "0"
		end
	}
	else
	{
		setcvar "survivor" "1"
	}

	level.gt = getcvar "g_gametype"

	
	if(level.gt == "1")
	{
		group.wording = "Survivor DM" 
	}
	else
	{
		group.wording = "Survivor"
	}

	setcvar "g_gametypestring" group.wording

	local.times = getcvar "survivor_times"

	if(local.times == "")
	{
		setcvar "survivor_times" "0"
	}

	local.rounds = getcvar "survivor_rounds"

	if(local.rounds == "")
	{
		setcvar "survivor_rounds" "1"
		local.rounds = 1
	}

//	level waittill prespawn 
	//exec global/ac/spawn_detect.scr survivor/spawned.scr 1
	exec global/killed.scr Survivor/dead.scr 1

	level waittill spawn
		
	thread startround
end

startround:

	thread changemap

	level.roundend = 0

	exec survivor/roundend.scr::stopmusic

	if($endcam)
	{
		$endcam delete
	}

	local.lives = getcvar "survivor_lives"
	local.warmup_time = getcvar "survivor_warmup"

	if(local.lives == "")
	{
		local.lives = 5
		setcvar "survivor_lives" "5"
	}

	if(local.warmup_time == "")
	{
		local.warmup_time = 5
		setcvar "survivor_warmup" "5"
	}
	
	local.lives = int local.lives
	local.warmup_time = int local.warmup_time

	//local.lives = 1
	//local.warmup_time = 2

	level.lives = local.lives
	level.warmup_time = local.warmup_time //how long the wait is for warmup
	level.survivor_roundstarted = 0

	level.min_players = 2


	if(level.lives == 1)
	{
		level.word = " life"
	}
	else
	{
		level.word = " lives"
	}

	level.gt = getcvar "g_gametype"

	if(level.gt != "1")
	{
		level.team = 1
		level.dmrespawning = 1
		level.clockside = "kills"
		level.players["axis"] = 0
		level.players["allies"] = 0
	}
	else
	{
		level.players = 0
	}

	exec survivor/warm_up.scr
	
	setcvar "g_obj_alliedtext1" group.wording
	setcvar "g_obj_alliedtext2"  ( level.lives + level.word )
	setcvar "g_obj_alliedtext3" "Become "
	setcvar "g_obj_axistext1" "The last man standing"
	setcvar "g_obj_axistext2" "The Survivor"
	setcvar "g_obj_axistext3" "Survivor 1.6"

end



changemap:
	
	//level waittill spawn

	local.rounds = getcvar "survivor_rounds"
	local.rounds = int local.rounds

	if(local.rounds != 0)
	{

		level.round_times = getcvar "survivor_times"
		level.round_times = int level.round_times

		if(level.round_times >= local.rounds)
		{
			setcvar "survivor_times" "0"

			while(1)
			{
				local.gametype = getcvar "g_gametype"
				setcvar "g_gametype" "0"
				bsptransition nextmap
				setcvar "g_gametype" local.gametype
				// wait one frame and set all game types again so map changes and doesnt save game
				waitframe
				setcvar "g_gametype" "0"
				bsptransition nextmap
				setcvar "g_gametype" local.gametype
				wait 15
			}
		}
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\spawned.scr

```scr
main:

	if(level.survivor_roundstarted ==0)
	{
		self.playing = 1
		self thread nodamage

		if(level.team == 1)
		{
			level.players[self.dmteam]++
		}
		else
		{
			level.players++
		}

//		level.players[self.dmteam]++
//		level.players[axis]++
//		iprintlnbold level.players
//		wait 3
//		level.survivor_roundstarted = 1
//		self spectator
//		exec survivor/roundend.scr

	}
	else
	{
		if (self.playing != 1)
		{
			if(self.survivor_specmode != 1)
			{
				if(level.team == 1)
				{
					exec Survivor/hud.scr (  level.players["axis"] + " Axis and " + level.players["allies"] + " Allied " + " left")
				}
				else
				{
					exec Survivor/hud.scr (level.players + " Players left")
				}

				self.survivor_specmode = 1
				self spectator
				self iprint "You must wait for the next round" 1
				exec survivor/spectator.scr
			}
		}
	}

end

nodamage:
	
	local.team = self.dmteam

	self takeall
	self give "models/weapons/silencedpistol.tik"
	self use "models/weapons/silencedpistol.tik"

	local.team = self.dmteam

	while(level.survivor_roundstarted ==0)
	{
	//	iprintln "no damamge"
		self nodamage

		waitframe
	
		if(self == NULL || self == NIL)
		{
			end
		}

		if(self.dmteam != local.team )
		{
			self.playing = 0

			if(level.team == 1)
			{
				level.players[local.team]--
			}
			else
			{
				level.players--
			}
			end
		}
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\spectator.scr

```scr
main:
	while(level.survivor_roundstarted == 1)
	{
		wait 1
	
		if(self == NULL || self == NIL)
		{
			end
		}

		while(self.dmteam == "spectator")
		{
			wait 1

			if(self == NULL || self == NIL)
			{
				end
			}
		}

		self iprint "You must wait for the next round"

		self spectator
	}
end
```

# zz_admin-Pro_1.22_modif\Survivor\survivor 1.6 without AP\warm_up.scr

```scr
main:

	//wait for 2 players
	waitthread waitingforplayers
	

	//wait level.warmup-time 
	local.start = waitthread warming

	//if it had players
	if(local.start == 1)
	{
		//start the round
		thread roundstart
	}

end

roundstart:

	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		local.player = $player[local.i]
		if(local.player.playing == 1)
		{
			local.player.lives = level.lives
			local.player exec survivor/scan_player.scr
			local.player respawn
			local.player iprint ( "You have " + level.lives + level.word ) 1
		}
		else
		{
			local.player iprint "You must wait for the next round" 
			local.player.playing = 0
			local.player spectator
		}
	}

	if(level.team == 1)
	{
		exec Survivor/hud.scr ("Starting battle with " +  level.players["axis"] + " Axis and " + level.players["allies"] + " Allied " + " players") 
	}
	else
	{
		exec Survivor/hud.scr ("Starting battle with " + level.players + " players") 
	}

	level.survivor_roundstarted = 1
	wait 3

	if(level.team == 1)
	{
		exec Survivor/hud.scr (  level.players["axis"] + " Axis and " + level.players["allies"] + " Allied " + " left") 
	}
	else
	{
		exec Survivor/hud.scr (level.players + " players left") 
	}
	

end


waitingforplayers:
	
	
	//if(level.roundbased)
	//{
	//	//level waittill roundstart
	//}

	local.exit = 0

	while(local.exit == 0)
	{
		exec Survivor/hud.scr ("Waiting for players") 

		if(level.team == 1)
		{
			if(level.players["axis"] >= 1 && level.players["allies"] >= 1)
			{
				local.exit = 1
			}
			
		}
		else
		{
			if(level.players >=  level.min_players)
			{
				local.exit =1
			}

		}

		wait 1
	}

	if(level.team == 1)
	{
		 exec Survivor/hud.scr ("Found " + level.players["axis"] + " Axis and " + level.players["allies"] + " Allied players") 
	}
	else
	{
		exec Survivor/hud.scr ("Found " + level.players + " players") 
	}

	wait 1
	exec Survivor/hud.scr ("Starting warmup") 
	wait 1
end

warming:

	for(local.i = level.warmup_time; local.i > 0;local.i--)
	{
			if(level.team == 1)
			{
				if(level.players["axis"] < 1 || level.players["allies"] < 1)
				{
					local.exit = 1
				}
				
			}
			else
			{
				if(level.players <  level.min_players)
				{
					local.exit = 1
				}

			}


			if(local.exit)
			{
				thread main
				end 0
			}
			else
			{
				if(local.i > 1)
				{
					 local.s = "s"
				}
				else
				{
					 local.s = ""
				}

				exec Survivor/hud.scr ("Warmup will end in " + local.i + " second" + local.s) 
			}
			wait 1
		}

end 1


```

# zz_admin-Pro_1.22_modif\Survivor\warm_up.scr

```scr
main:

	//wait for 2 players
	waitthread waitingforplayers
	
		
	if(level.run["survivor"] != "1"){end}

	//wait level.warmup-time 
	local.start = waitthread warming

	if(level.run["survivor"] != "1"){end}

	//if it had players
	if(local.start == 1)
	{
		//start the round
		thread roundstart
	}

end

roundstart:

	for(local.i = 1; local.i <= $player.size; local.i++)
	{
		local.player = $player[local.i]
		if(local.player.playing == 1)
		{
			local.player.lives = level.lives
			local.player exec survivor/scan_player.scr
			local.player respawn
			local.player.forcespawn = 1
			local.player iprint ( "You have " + level.lives + level.word ) 1
		}
		else
		{
			local.player iprint "You must wait for the next round" 
			local.player.playing = 0
			local.player spectator
		}
	}

	if(level.team == 1)
	{
		exec Survivor/hud.scr ("Starting battle with " +  level.players["axis"] + " Axis and " + level.players["allies"] + " Allied " + " players") 
	}
	else
	{
		exec Survivor/hud.scr ("Starting battle with " + level.players + " players") 
	}

	level.survivor_roundstarted = 1
	wait 3

	if(level.team == 1)
	{
		exec Survivor/hud.scr (  level.players["axis"] + " Axis and " + level.players["allies"] + " Allied " + " left") 
	}
	else
	{
		exec Survivor/hud.scr (level.players + " players left") 
	}
	

end


waitingforplayers:
	
	
	//if(level.roundbased)
	//{
	//	//level waittill roundstart
	//}

	local.exit = 0

	while(local.exit == 0)
	{
		exec Survivor/hud.scr ("Waiting for players") 

		if(level.run["survivor"] != "1"){end}

		if(level.team == 1)
		{
			if(level.players["axis"] >= 1 && level.players["allies"] >= 1)
			{
				local.exit = 1
			}
			
		}
		else
		{
			if(level.players >=  level.min_players)
			{
				local.exit =1
			}

		}

		wait 1
	}

	if(level.team == 1)
	{
		 exec Survivor/hud.scr ("Found " + level.players["axis"] + " Axis and " + level.players["allies"] + " Allied players") 
	}
	else
	{
		exec Survivor/hud.scr ("Found " + level.players + " players") 
	}

	wait 1
	exec Survivor/hud.scr ("Starting warmup") 
	wait 1
end

warming:

	for(local.i = level.warmup_time; local.i > 0;local.i--)
	{
			if(level.team == 1)
			{
				if(level.players["axis"] < 1 || level.players["allies"] < 1)
				{
					local.exit = 1
				}
				
			}
			else
			{
				if(level.players <  level.min_players)
				{
					local.exit = 1
				}

			}


			if(local.exit)
			{
				thread main
				end 0
			}
			else
			{
				if(local.i > 1)
				{
					 local.s = "s"
				}
				else
				{
					 local.s = ""
				}

				exec Survivor/hud.scr ("Warmup will end in " + local.i + " second" + local.s) 
			}
			wait 1

			if(level.run["survivor"] != "1"){end}
		}

end 1


```

# zz_admin-Pro_1.22_modif\weapon_limit\radar.scr

```scr
main:

	if(level.run["weapons-limiter"] != "1"){end}

	local.player = self

	local.player forcetorsostate GET_WEAPON

	local.team = local.player.dmteam

	while(local.player.DMweapon == NIL || local.player.DMweapon == "none")
	{
		waitframe
	}

	local.weapon = local.player.DMweapon

	while(isalive local.player && local.team == local.player.dmteam && local.player != NULL && local.player != NIL )
	{
		waitframe
	}

	if(level.weapons_inuse[local.weapon] != NIL)
	{
		level.weapons_inuse[local.weapon]--	
	}	


	if ( local.player != NULL && local.player != NIL )
	{
		local.player.DMweapon = "none"
	}

end
```

# zz_admin-Pro_1.22_modif\weapon_limit\secondry_weapons.scr

```scr
// This script is to give the correct weapons and grenades to the player depending on their team and skin.
// 27 March 2005
// player exec script.
//
// 11/08/2005
// changed the nationalities prefix to suit BT prefixes
// 

main: 

	if(game.game == "SH")
	{
		//find the player skin and team
		for(local.i = 1;local.i <= level.skins[allies].size; local.i++)
		{
			if(self.model == ( "models/player/" + level.skins[allies][local.i][1] ) )
			{
				local.team = level.skins[allies][local.i][2] //the team!!
				break //stop from loop
			}	
		}
	}
	else
	{
		local.team = self.nationalityprefix
	}

	//give correct weapons
	if(self.dmteam == "allies")
	{
		switch ( local.team  )
		{
		case "dfrru":
			self give "models/weapons/m2frag_grenade.tik"		//give nade
			self give "models/weapons/M18_smoke_grenade.tik"	//give smoke nade
			self give "models/weapons/colt45.tik"			//give pistol
		break
		case "dfruk":
			self give "models/weapons/mills_grenade.tik"		//give nade
			self give "models/weapons/M18_smoke_grenade.tik"	//give smoke nade
			self give "models/weapons/webley_revolver.tik"		//give pistol
		break
		case "dfr":
			self give "models/weapons/Russian_F1_grenade.tik"	//give nade
			self give "models/weapons/RDG-1_Smoke_grenade.tik"	//give smoke nade
			self give "models/weapons/nagent_revolver.tik"		//give pistol
		break
		default:
			// player not found. give them these to keep em happy
			self give "models/weapons/m2frag_grenade.tik"		//give nade
			self give "models/weapons/M18_smoke_grenade.tTIK"	//give smoke nade
			self give "models/weapons/colt45.tik"			//give pistol
		}
	}
	else //if axis
	{
		if(game.game== "SH")
		{
			self give "models/weapons/steilhandgranate.tik" //give nade
			self give "models/weapons/nebelhandgranate.tik"	//give smoke nade
			self give "models/weapons/p38.tik"		//give pistol
		}
		else
		{
			switch(local.team )
			{
			case "den":
				self give "models/weapons/steilhandgranate.tik" //give nade
				self give "models/weapons/nebelhandgranate.tik"	//give smoke nade
				self give "models/weapons/p38.tik"		//give pistol
			break
			case "denit":
				self give "models/weapons/It_W_Bomba.tik"	 //give nade
				self give "models/weapons/It_W_BombaBreda.tik"	//give smoke nade
				self give "models/weapons/It_W_Beretta.tik"	//give pistol
			break
			default:
				self give "models/weapons/steilhandgranate.tik" //give nade
				self give "models/weapons/nebelhandgranate.tik"	//give smoke nade
				self give "models/weapons/p38.tik"		//give pistol
			}
		}
	}
	
end

load_skins:

	if(game.game == "SH")
	{
		level.skins[allies] = makearray
			"_american_army_cold.tik"				"dfrru"	
			"_american_army_cold_fps.tik"				"dfrru"	
			"_american_army_end.tik"				"dfrru"
			"_american_army_end_fps.tik"				"dfrru"
			"allied_101st_captain.tik"				"dfrru"
			"allied_101st_infantry.tik"				"dfrru"
			"allied_101st_infantry_fps.tik"				"dfrru"
			"allied_101st_scout.tik"				"dfrru"
			"allied_101st_scout_fps.tik"				"dfrru"
			"allied_501st_pir_scout.tik"				"dfrru"
			"allied_501st_pir_scout_fps.tik"			"dfrru"
			"allied_501st_pir_soldier.tik"				"dfrru"
			"allied_501st_pir_soldier_fps.tik"			"dfrru"
			"allied_british_6th_airborne_captain.tik"		"dfruk"
			"allied_british_6th_airborne_paratrooper.tik"		"dfruk"
			"allied_british_6th_airborne_paratrooper_fps.tik"	"dfruk"
			"allied_british_tank_corporal.tik"			"dfruk"
			"allied_british_tank_corporal_fps.tik"			"dfruk"
			"allied_british_tank_corporal_fps.tik"			"dfruk"
			"allied_russian_corporal.tik"				"dfr"
			"allied_russian_corporal_fps.tik"			"dfr"
			"allied_russian_crazy_boris.tik"			"dfr"
			"allied_russian_crazy_boris_fps.tik"			"dfr"
			"allied_russian_recon_scout.tik"			"dfr"
			"allied_russian_recon_scout_fps.tik"			"dfr"
			"allied_russian_recon_soldier.tik"			"dfr"
			"allied_russian_recon_soldier_fps.tik"			"dfr"
			"allied_russian_seaman.tik"				"dfr"
			"allied_russian_seaman_fps.tik"				"dfr"
			"allied_technician.tik"					"dfr"
			"allied_technician_fps.tik"				"dfrru"
			"allied_airborne.tik"					"dfrru"
			"allied_manon.tik"					"dfrru"
			"allied_pilot.tik.tik"					"dfrru"
			"allied_sas.tik"					"dfrru"
			"american_army.tik"					"dfrru"
			"american_ranger.tik"					"dfrru"
			"allied_airborne_fps.tik"				"dfrru"
			"allied_manon_fps.tik"					"dfrru"
			"allied_pilot_fps.tik"					"dfrru"
			"allied_sas_fps.tik"					"dfrru"
			"american_army_fps.tik"					"dfrru"
			"american_ranger_fps.tik"				"dfrru"
		endarray
	}
	else
	{
		level.skins[allies] = makearray
			"allied_101st_captain.tik"				"dfrru"
			"allied_101st_captain_fps.tik"				"dfrru"
			"allied_101st_infantry.tik"				"dfrru"
			"allied_101st_infantry_fps.tik"				"dfrru"
			"allied_101st_scout.tik"				"dfrru"
			"allied_101st_scout_fps.tik"				"dfrru"
			"allied_501st_pir_scout.tik"				"dfrru"
			"allied_501st_pir_scout_fps.tik"			"dfrru"
			"allied_501st_pir_soldier.tik"				"dfrru"
			"allied_501st_pir_soldier_fps.tik"			"dfrru"
			"allied_british_6th_airborne_captain.tik"		"dfruk"
			"allied_british_6th_airborne_captain_fps.tik"		"dfruk"
			"allied_british_6th_airborne_paratrooper.tik"		"dfruk"
			"allied_british_6th_airborne_paratrooper_fps.tik"	"dfruk"
			"allied_british_cmd.tik"				"dfruk"
			"allied_british_cmd_fps.tik"				"dfruk"
			"allied_british_tank.tik"				"dfruk"	
			"allied_british_tank_corporal.tik"			"dfruk"
			"allied_british_tank_corporal_fps.tik"			"dfruk"
			"allied_british_tank_fps.tik"				"dfruk"
			"allied_russian_corporal.tik"				"dfr"
			"allied_russian_corporal_fps.tik"			"dfr"
			"allied_russian_crazy_boris.tik"			"dfr"
			"allied_russian_crazy_boris_fps.tik"			"dfr"
			"allied_russian_recon_scout.tik"			"dfr"
			"allied_russian_recon_scout_fps.tik"			"dfr"
			"allied_russian_recon_soldier.tik"			"dfr"
			"allied_russian_recon_soldier_fps.tik"			"dfr"
			"allied_russian_seaman.tik"				"dfr"
			"allied_russian_seaman_fps.tik"				"dfr"
			"allied_technician.tik"					"dfrru"
			"allied_technician_fps.tik"				"dfrru"
			"allied_us_mask.tik"					"dfrru"
			"allied_us_mask_fps.tik"				"dfrru"
			"allied_us_tank.tik"					"dfrru"
			"allied_us_tank_fps.tik"				"dfrru"
			"allied_wheathers.tik"					"dfrru"
			"allied_wheathers_fps.tik"				"dfrru"
			"_american_army_cold.tik"				"dfrru"
			"_american_army_cold_fps.tik"				"dfrru"
			"_american_army_end.tik"				"dfrru"
			"_american_army_end_fps.tik"				"dfrru"
		endarray

		level.skins[axis] = makearray
			"german_ardennes_artillery_commander.tik"		"den"
			"german_ardennes_artillery_commander_fps.tik"		"den"
			"german_dday_colonel.tik"				"den"
			"german_dday_colonel_fps.tik"				"den"
			"german_panzer_corporal.tik"				"den"
			"german_panzer_corporal_fps.tik"			"den"
			"german_stukageschwader.tik"				"den"
			"it_ax_ital_vol.tik"					"denit"
			"it_ax_ital_vol_fps.tik"				"denit"
			"sc_ax_ital_inf.tik"					"denit"
			"sc_ax_ital_inf2.tik"					"denit"
			"sc_ax_ital_inf2_fps.tik"				"denit"
			"sc_ax_ital_inf_fps.tik"				"denit"
			"sc_ax_ital_para.tik"					"denit"
			"sc_ax_ital_para_fps.tik"				"denit"
		endarray
	}
end



```

# zz_admin-Pro_1.22_modif\weapon_limit\weaponis.scr

```scr
//11/08/2005
// Removed weapon get class 
// added strings

main local.model:

	if(local.model=="UNARMED")
	{
		local.model = "models/weapons/unarmed.tik"
	}

	self.weapon = local.model
	self.DMweapon = local.model
	
	if(level.run["weapons-limiter"] != "1"){end}

	local.drop = waitexec global/settings.scr::getcmd "dropweapons"
	
	if(local.drop != "1")
	{
		self weaponcommand duel notdroppable
	}

	self resetstate

	if(local.model=="models/weapons/unarmed.tik")
	{
		end
	}

	for(local.i = 1 ; local.i <= game.limiter_weapons.size;local.i++)
	{
		local.weapon = waitthread get_weapontik game.limiter_weapons[local.i][1] game.limiter_weapons[local.i][2] 
		local.weaponname = game.limiter_weapons[local.i][1]::game.limiter_weapons[local.i][2] 

		if(local.model == local.weapon[1])
		{
			if(game.limiter_weapons[local.i][2] != "" )
			{

				if(game.game == "AA")
				{
					self take local.model
				}
				else
				{
					self takeall
					self waitexec weapon_limit/secondry_weapons.scr
				}

				self item local.weapon[2] 

				local.print = waitexec global/settings.scr::getcmd "swap-message"

				if(local.print == "1")
				{
					self iprint (game.weapons_strings[1][1] + local.weaponname[1] + game.weapons_strings[2][1] + local.weaponname[2] + game.weapons_strings[3][1]) 1
				}

				//local.weapon_class = waitthread get_weaponclass game.limiter_weapons[local.i][2]
				//self usestuff
				//self useweaponclass local.weapon_class

				self use local.weapon[2]
				end
			}
			else
			{
				local.amount = game.limiter_weapons[local.i][3]

				if(local.amount==""){end}

				local.amount = int local.amount

				if(local.amount==0)
				{

					local.print = waitexec global/settings.scr::getcmd "swap-message"

					/*
					// Dont think this will ever run
					//local.weapon_class = waitthread get_weaponclass game.limiter_weapons[local.i][1]
					if(local.weapon_class == "pistol" || local.weapon_class == "grenade")
					{
						self take local.model

						if(local.print == "1")
						{
							self iprint ("The admin has set that you are not allowed to use the " + local.weaponname[1]) 1
						}
					}
					else
					{
					*/

					if(local.print == "1")
					{
						self iprint (game.weapons_strings[4][1] + local.weaponname[1] + game.weapons_strings[5][1] ) 1
					}

					self thread newgun
					
					//}

					end
				}

				if(level.weapons_inuse[local.model]==NIL)
				{
					level.weapons_inuse[local.model]=0
				}

				level.weapons_inuse[local.model]++
	
				if(level.weapons_inuse[local.model] > local.amount)
				{
					self thread newgun
					self iprint (local.weaponname[1] + game.weapons_strings[6][1] + local.amount + game.weapons_strings[7][1]) 1
					
					self iprint game.weapons_strings[8][1]  1
					
					wait 1

					for(local.w=1;local.w <= game.limiter_weapons.size;local.w++)
					{
						local.weaponname = game.limiter_weapons[local.w][1] 

						if(game.limiter_weapons[local.w][3] != "")
						{
							local.num = int game.limiter_weapons[local.w][3]
			
							if(local.num != 0 )	
							{
								local.name = waitthread get_weapontik game.limiter_weapons[local.w][1] 

								local.say = 1

								if(level.weapons_inuse[local.name[1]] == NIL)
								{
									local.left = local.num 
								}
								else if(level.weapons_inuse[local.name[1]] < local.num)
								{
									local.left = local.num - level.weapons_inuse[local.name[1]]
								}
								else
								{
									local.say = 0
								}
								
								if(local.say == 1)
								{
									self iprint ( "* " + local.weaponname + " " + local.left + game.weapons_strings[9][1] ) 
									wait 1.5
								}
							}
						}
						else
						{
							self iprint ( "* " + local.weaponname ) 
							wait 1.5
						}
			
					}

					end
				}
			}					
		}	
	}
end

get_weapontik local.weapon_one local.weapon_two:
	
	if(level.weaponsinfo == NIL)
	{
		waitthread ( weaponsinfo + game.game )
	}

	for(local.i=1;local.i <= level.weaponsinfo.size;local.i++)
	{
		if(local.weapon_one == level.weaponsinfo[local.i] [2])
		{
			local.weapon_one  = level.weaponsinfo[local.i][1]
		}
		else if(local.weapon_two == level.weaponsinfo[local.i] [2])
		{
			local.weapon_two  = level.weaponsinfo[local.i][1]
		}
	}

end ( local.weapon_one::local.weapon_two )
/*
get_weaponcl/ss local.weapon:
	
	if(level.weaponsinfo == NIL)
	{
		waitthread ( weaponsinfo + game.game )
	}

	for(local.i=1;local.i <= level.weaponsinfo.size;local.i++)
	{
		if(local.weapon == level.weaponsinfo[local.i][2])
		{
			end level.weaponsinfo[local.i] [3]
		}
	}
end
*/

weaponsinfoAA:

	level.weaponsinfo = makearray			
		//Ally weapons									//name						//class								
		"models/weapons/springfield.tik"						"springfield '03 sniper"			"rifle"										
		"models/weapons/bar.tik"							"bar"						"mg"
		"models/weapons/thompsonsmg.tik"						"thompson"					"smg"
		"models/weapons/bazooka.tik"							"bazooka"					"heavy"	
		"models/weapons/m1_garand.tik"							"m1 garand"					"rifle"
		//Axis												
		"models/weapons/kar98.tik"							"kar98"						"rifle"	
		"models/weapons/KAR98sniper.tik"						"kar98 - sniper"				"rifle"	
		"models/weapons/mp40.tik"							"mp40"						"smg"
		"models/weapons/mp44.tik"							"mp44"						"mg"
		"models/weapons/panzerschreck.tik"						"panzerschreck"					"heavy"	
		//both						
		"models/weapons/shotgun.tik"							"shotgun"					"heavy"
	endarray

end

weaponsinfoBT:

	level.weaponsinfo = makearray	
		"models/weapons/bazooka.tik"							"bazooka"					"heavy"	
		"models/weapons/bar.tik"							"bar"						"mg"
		"models/weapons/DeLisle.tik"							"delisle"					"rifle"
		"models/weapons/enfield.tik"							"lee-enfield"					"rifle"
		"models/weapons/enfield_lite.tik"						"lee-enfield"					"rifle"
		"models/weapons/G43.tik"							"g 43"						"rifle"
		"models/weapons/Gr_W_MineDetector.tik"						"minensuchgerat"				"grenade"
		"models/weapons/It_W_Breda.tik"							"breda"						"mg"
		"models/weapons/It_W_Carcano.tik"						"carcano"					"rifle"	
		"models/weapons/It_W_Carcano_lite.tik"						"carcano"					"rifle"	
		"models/weapons/It_W_Moschetto.tik"						"moschetto"					"smg"
		"models/weapons/kar98.tik"							"mauser kar 98k"				"rifle"
		"models/weapons/KAR98sniper.tik"						"kar98 - sniper"				"rifle"
		"models/weapons/kar98_lite.tik"							"mauser kar 98k"				"rifle"
		"models/weapons/kar98_mortar.tik"						"gewehrgranate"					"rifle"
		"models/weapons/Mosin_Nagant_Rifle.tik"						"mosin nagant rifle"				"rifle"	
		"models/weapons/Mosin_Nagant_Rifle_lite.tik"					"mosin nagant rifle"				"rifle"	
		"models/weapons/mp40.tik"							"mp40"						"smg"
		"models/weapons/m1_garand.tik"							"m1 garand"					"rifle"
		"models/weapons/mp44.tik"							"mp44"						"mg"
		"models/weapons/m1_garand_lite.tik"						"m1 garand"					"rifle"
		"models/weapons/panzerschreck.tik"						"panzerschreck"					"heavy"
		"models/weapons/ppsh_smg.tik"							"ppsh smg"					"smg"
		"models/weapons/shotgun.tik"							"shotgun"					"heavy"
		"models/weapons/springfield.tik"						"springfield '03 sniper"			"rifle"	
		"models/weapons/sten.tik"							"sten mark ii"					"smg"
		"models/weapons/svt_rifle.tik"							"svt 40"					"rifle"
		"models/weapons/thompsonsmg.tik"						"thompson"					"smg"
		"models/weapons/Uk_W_L42A1.tik"							"enfield l42a1"					rifle
		"models/weapons/Uk_W_Piat.tik"							"piat"						"heavy"
		"models/weapons/Uk_W_Vickers.tik"						"vickers-berthier"				"mg"
		"models/weapons/US_W_MineDetector.tik"						"minedetector"					"grenade"	
	endarray
end

weaponsinfoSH:

	level.weaponsinfo = makearray			
		"models/weapons/bar.tik"							"bar"						"mg"
		"models/weapons/bazooka.tik"							"bazooka"					"heavy"
		"models/weapons/kar98.tik"							"kar98"						"rifle"
		"models/weapons/KAR98sniper.tik"						"kar98 - sniper"				"rifle"
		"models/weapons/m1_garand.tik"							"m1 garand"					"rifle"
		"models/weapons/mp40.tik"							"mp40"						"smg"
		"models/weapons/mp44.tik"							"mp44"						"mg"
		"models/weapons/panzerschreck.tik"						"panzerschreck"					"heavy"
		"models/weapons/shotgun.tik"							"shotgun"					"heavy"
		"models/weapons/springfield.tik"						"springfield '03 sniper"			"rifle"	
		"models/weapons/thompsonsmg.tik"						"thompson"					"smg"
		"models/weapons/enfield.tik"							"lee-enfield"					"rifle"		
		"models/weapons/G43.tik"							"g 43"						"rifle"	
		"models/weapons/Mosin_Nagant_Rifle.tik"						"mosin nagant rifle"				"rifle"	
		"models/weapons/ppsh_smg.tik"							"ppsh smg"					"smg"
		"models/weapons/sten.tik"							"sten mark ii"					"smg"
		"models/weapons/svt_rifle.tik"							"svt 40"					"rifle"	
		"models/weapons/kar98_mortar.tik"						"gewehrgranate"					"rifle"	
	endarray
end 

newgun:
	//local.dmteam= self.dmteam
	self primarydmweapon ""
	self spectator
	self stufftext "pushmenu SelectPrimaryWeapon"
	//self join_team local.dmteam
end



setup_stuff:

	local.weapons = makearray			
		//Ally weapons				
		"Springfield '03 Sniper"												
		"bar"						
		"Thompson"					
		"bazooka"					
		"m1_garand					
		//Axis														
		"kar98"						
		"KAR98 - Sniper"					
		"mp40"						
		"mp44"						
		"Panzerschreck"					
		//both						
		"shotgun"					
	endarray

	for(local.i=1;local.i <= local.weapons.size;local.i++)
	{
		local.name = local.weapons[local.i][1]
		level.weapons_inuse[local.name] = 0
	}

end

```

# zz_admin-Pro_1.22_modif\weapon_limit\weapons_limiter.scr

```scr
main:

	if(level.run["weapons-limiter"] != "1"){end}

	if(game.file["weapons-limiter"])
	{
		local.threads = "weapons" + game.game
		local.weapons  = waitexec  game.file["weapons-limiter"]::local.threads
		local.weapons = waitthread global/strings.scr::Array_to_lower local.weapons
		game.limiter_weapons = local.weapons	

		local.threads = "secondryweapons" + game.game
		game.secondry_limiter_settings = waitexec game.file["weapons-limiter"]::local.threads

		//get the strings
		game.weapons_strings =  waitexec game.file["weapons-limiter"]::strings

		if(gamegame != "AA")
		{
			if(game.skins == NIL)
			{
				exec weapon_limit/secondry_weapons.scr::load_skins //if not yet done, Load the skins 
			}
		}
	}
	else
	{
		end
	}

	if(game.limiter_weapons == NIL)
	{
		level.run["weapons-limiter"] = "0"
		waitframe
	}

	//exec global/ac/spawn_detect.scr weapon_limit/radar.scr

	thread secondryweapons
end

secondryweapons: //Check to  take pistols or nades or stuff

	if(game.secondry_limiter_settings == NIL)
	{
		level.run["weapons-limiter"] = "0"
		end
	}

	local.found = 0
	for(local.i=1; local.i <= game.secondry_limiter_settings.size; local.i++)
	{
		if( game.secondry_limiter_settings[local.i][2] == "1")
		{	
			if(level.run["weapons-limiter"] != "1"){end}
			local.found++
			local.take[local.found] = game.secondry_limiter_settings[local.i][3]
		}
	}

	if(local.found == 0 ){end} //end if none are to be taken

	while ( 1 )
	{
		for(local.i = 1;local.i <= $player.size;local.i++)
		{
			for(local.p=1;local.p <= local.found; local.p++)
			{
				if(level.run["weapons-limiter"] != "1"){end}
				$player[local.i] take local.take[local.p]
			}
		}
		waitframe
	}
end



```

# zz_bot_spawn\global\bot_spawn.scr

```scr
/*
R-crit par Feho - 2011

Spawn un bot avec sniper, ou bien avec une MG42 selon le rang du joueur

Excut par nagle_aa_torso.st
*/

main local.origin local.angle:

	if (self.useheld == 1)
		end

	if (local.origin == NULL || local.origin == NIL)
	{
		local.origin = self.origin - self.forwardvector * -50 + ( 0 0 30 )
		local.angle = self.angle
	}
	
	if (self.active_bots == NIL)
		self.active_bots = 0
		
	if (self.active_bots == 5)
	{
		self iprint "You can't place more than 5 bots at the same time"
		end
	}
	
	// self.special_bots = 5
	
	if ( (self.special_bots != NIL) && (self.special_bots > 0) )
	{
		self thread fake_dude_MG42 local.origin local.angle
		end
	}
	
	self thread fake_dude local.origin local.angle

end


//***************************************************
//*************** Special bot ************************
//***************************************************

fake_dude_MG42 local.origin local.angle:

	// if (self.special_bots == NIL)
		// self.special_bots = 5
		
	if (self.special_bots == 0)
	{
		self iprint "0 special bots left"
		end
	}
		
	self.special_bots--
	self.active_bots++
	
	self iprint (self.special_bots + " special bots left")
	
	if (self.dmteam == "allies")
	{
		local.bot = spawn animate model "player/american_Army.tik" origin local.origin angle local.angle health 100 nodamage 1 solid 1 anim unarmed_stand_idle
		local.bot.team = "allies"
	}
	else
	{
		local.bot = spawn animate model "player/german_Waffenss_Shutze.tik" origin local.origin angle local.angle health 100 nodamage 1 solid 1 anim unarmed_stand_idle
		local.bot.team = "axis"
	}
	
	// local.bot.origin = local.origin
	// local.bot.angle = local.angle
	// local.bot.health = 100 
	// local.bot.scale = 1.0
	// local.bot solid
	local.bot droptofloor

	local.crate = spawn script_model
	local.crate model static/indycrate.tik
	local.crate.origin = local.bot.origin - local.bot.forwardvector * -45
	local.crate.angle = local.angle
	local.crate.scale = 1.0
	local.crate solid 
	local.crate.health = 500

	local.mg42 = spawn models/statweapons/mg42_gun.tik
	local.mg42.origin = local.bot.origin - local.bot.forwardvector * -50 + ( 0 0 60 )
	local.mg42 svflags "+broadcast"
	local.mg42.angle = local.angle
	local.mg42 yawCenter local.angle
	local.mg42 maxyawoffset 70 
	local.mg42 pitchCaps ( -15 50 0 )
	// local.mg42 dmbulletDamage 10.0
	local.mg42 firetype fakebullet
	local.mg42B = spawn script_model 
	local.mg42B model "statweapons/mg42_bipod.tik" 
	local.mg42B.origin = local.bot.origin - local.bot.forwardvector * -50 + ( 0 0 62 )
	local.mg42B svflags "+broadcast"
	local.mg42B.angle = local.angle
	local.mg42B solid
	
	thread check_team local.bot self
	local.bot thread bot_death self
	local.bot thread setup_kill self
	
	wait 2
	
	local.bot thread special_bots_anims self local.mg42 local.mg42B
						
	while (IsAlive local.bot)
	{
		for(local.dude=1;local.dude <= $player.size;local.dude++)
		{
			if (getcvar "g_gametype" == "1")
			{
				if ( (isAlive $player[local.dude]) && ($player[local.dude] != self) && ($player[local.dude].dmteam != "spectator") && (local.mg42B) && (local.mg42B cansee $player[local.dude] 140 3000) )
				{
					// bots are not allowed to damage players with parachutes
					if ( ($player[local.dude]).is_para == 1)
						break
						
					//locprint 130 70 "ICU"
					// local.bot anim turret_idle
					local.mg42 setaimtarget $player[local.dude]
					local.mg42 waittill ontarget
					if (isAlive $player[local.dude] && local.mg42B cansee $player[local.dude] 140 3000)
					{
					local.mg42 anim fire start
					local.bot exec global/feho/tracerbullet.scr::tracer_bot local.weapon
					local.pain = randomint (10)
					local.pain = (local.pain + 10)
					local.death = randomint (17)
					local.aim_skill = randomint (3)
					if (local.aim_skill == 1)
					{
						$player[local.dude] damage self local.pain $player[local.dude] (0 0 0) (0 0 0) (0 0 0) 10 1 19 local.death
						thread promotion $player[local.dude] self local.bot
					}
					local.mg42 clearAimTarget
					}
					else
					{
					local.mg42 clearAimTarget
					}
				}
			}
			else
			{
				if ( (isAlive $player[local.dude]) && (local.bot.team != $player[local.dude].dmteam) && ($player[local.dude].dmteam != "spectator") && ($player[local.dude].needrevive != 1) && (local.mg42B) && (local.mg42B cansee $player[local.dude] 140 3000) )
				{
					// bots are not allowed to damage players with parachutes
					if ( ($player[local.dude]).is_para == 1)
						break
						
					//locprint 130 70 "ICU"
					// local.bot anim turret_idle
					local.mg42 setaimtarget $player[local.dude]
					local.mg42 waittill ontarget
					if (isAlive $player[local.dude] && local.mg42B cansee $player[local.dude] 140 3000)
					{
						local.mg42 anim fire start
						local.bot exec global/feho/tracerbullet.scr::tracer_bot local.weapon
						local.pain = randomint (10)
						local.pain = (local.pain + 10)
						local.death = randomint (17)
						local.aim_skill = randomint (3)
						if (local.aim_skill == 1)
						{
							$player[local.dude] damage self local.pain $player[local.dude] (0 0 0) (0 0 0) (0 0 0) 10 1 19 local.death
							thread promotion $player[local.dude] self local.bot
						}
						local.mg42 clearAimTarget
					}
					else
					{
						local.mg42 clearAimTarget
					}
				}
			}
		}
		wait .1
	}
	
	local.mg42 firetype bullet
	local.mg42 dmbulletDamage 10.0
	
	wait 30
	
	local.crate immediateremove
	local.mg42 hide
	local.mg42B immediateremove
	
	wait 60
	
	local.mg42 immediateremove
	
end
	
special_bots_anims local.player local.mg42 local.mg42B:

	//local.bot = self
	while(self)
	{
		for(local.dude=1;local.dude <= $player.size;local.dude++)
		{
			if (getcvar "g_gametype" == "1")
			{
				while( (isAlive $player[local.dude]) && ($player[local.dude] != self) && ($player[local.dude].dmteam != "spectator") && (local.mg42B) && (local.mg42B cansee $player[local.dude] 170 3000) )
				{
					if (!IsAlive self)
						end
					
					self.origin = local.mg42.origin - self.forwardvector * 50 + ( 0 0 -60 )
					self.angle = local.mg42.angle
					
					if (self.anim_turret != 1)
					{
						self anim turret_idle
						self.anim_turret = 1
						self.anim_stand = 0
					}
					wait 0.05
				}
				if (self.anim_stand != 1)
				{
					self anim unarmed_stand_idle
					self.anim_stand = 1
					self.anim_turret = 0
				}
			}
			else
			{
				while( (isAlive $player[local.dude]) && (self.team != $player[local.dude].dmteam) && ($player[local.dude].dmteam != "spectator") && ($player[local.dude].needrevive != 1) && (local.mg42B) && (local.mg42B cansee $player[local.dude] 170 3000) )
				{
					if (!IsAlive self)
						end
						
					self.origin = local.mg42.origin - self.forwardvector * 50 + ( 0 0 -60 )
					self.angle = local.mg42.angle
					
					if (self.anim_turret != 1)
					{
						self anim turret_idle
						self.anim_turret = 1
						self.anim_stand = 0
					}
					wait 0.05
				}
				if (self.anim_stand != 1)
				{
					self anim unarmed_stand_idle
					self.anim_stand = 1
					self.anim_turret = 0
				}
			}
		}
		wait 0.05
	}
	
end

bot_death local.player:

	local.fake_dude = self
	
	while (IsAlive local.fake_dude)
		wait .06
	
	iprintln "A bot was killed !"

	if (local.player)
		local.player.active_bots--
	
	local.death_anim = randomint (5)+1
	switch (local.death_anim)
	{
		case 1:
		local.death_anim = death_fall_to_knees
		local.fake_dude playsound player_death01
		break
		case 2:
		local.death_anim = death_fall_back
		local.fake_dude playsound player_death02
		break
		case 3:
		local.death_anim = death_chest
		local.fake_dude playsound player_death03
		break
		case 4:
		local.death_anim = death_choke
		local.fake_dude playsound player_death04
		break
		case 5:
		local.death_anim = death_crotch
		local.fake_dude playsound player_death05
		break
	}
	local.fake_dude anim local.death_anim
	local.fake_dude notsolid
	wait 5
	local.fake_dude immediateremove
	
end

//***************************************************
//*************** Normal bot ************************
//***************************************************

fake_dude local.origin local.angle:

	if (self.bots == NIL)
		self.bots = 15
		
	if (self.bots == 0)
	{
		self iprint "0 bots left"
		end
	}
		
	self.bots--
	self.active_bots++
	
	self iprint (self.bots + " bots left")
	
	if (self.dmteam == "allies")
	{
		local.bot = spawn animate model "player/american_Army.tik" origin local.origin angle local.angle health 100 nodamage 1 solid 1 anim rifle_stand_idle
		local.bot.team = "allies"
		local.id_number = randomint 10000000
		local.bot attachmodel "items/cigarette.tik" "Bip01 head" 1.3 ("cig" + local.id_number) 0 -1 -1 -1 -1 ( 3.6 7.5 2.0 ) spawnflags 1
		$("cig" + local.id_number).angles = ( 100 180 0 )
		local.bot attachmodel "weapons/springfield.tik" "tag_weapon_right" 1.0 ("weapon" + local.id_number) 0 -1 -1 -1 -1 ( 0 0 0 )
	}
	else
	{
		local.bot = spawn animate model "player/german_Waffenss_Shutze.tik" origin local.origin angle local.angle health 100 nodamage 1 solid 1 anim rifle_stand_idle
		local.bot.team = "axis"
		local.id_number = randomint 10000000
		local.bot attachmodel "items/cigarette.tik" "Bip01 head" 1.3 ("cig" + local.id_number) 0 -1 -1 -1 -1 ( 3.6 7.5 2.0 ) spawnflags 1
		$("cig" + local.id_number).angles = ( 100 180 0 )
		local.bot attachmodel "weapons/kar98sniper.tik" "tag_weapon_right" 1.0 ("weapon" + local.id_number) 0 -1 -1 -1 -1 ( 0 0 0 )
	}
	

	local.weapon = $("weapon" + local.id_number)
	
	local.bot droptofloor

	local.mg42 = spawn models/statweapons/mg42_gun.tik
	local.mg42.origin = local.bot.origin - local.bot.forwardvector * -20 + ( 0 0 74 )
	local.mg42 svflags "+broadcast"
	local.mg42.angle = local.angle
	// local.mg42 yawCenter local.angle
	// local.mg42 maxyawoffset 70 
	// local.mg42 pitchCaps ( -15 50 0 )
	// local.mg42 dmbulletDamage 10.0
	local.mg42 hide
	local.mg42B = spawn script_model 
	local.mg42B model "statweapons/mg42_bipod.tik" 
	local.mg42B.origin = local.bot.origin - local.bot.forwardvector * -20 + ( 0 0 76 )
	local.mg42B svflags "+broadcast"
	local.mg42B.angle = local.angle
	local.mg42B hide
	
	thread check_team local.bot self
	local.bot thread bot_death self
	local.bot thread setup_kill self
	
	wait 2
	
	local.bot thread bots_anims self local.mg42 local.mg42B
			
	local.player = self
	
	while (IsAlive local.bot)
	{
		for(local.dude=1;local.dude <= $player.size;local.dude++)
		{
			if (getcvar "g_gametype" == "1")
			{
				if ( (isAlive $player[local.dude]) && ($player[local.dude] != self) && ($player[local.dude].dmteam != "spectator") && (local.mg42B) && (local.mg42B cansee $player[local.dude] 360 3000) )
				{
					// bots are not allowed to damage players with parachutes
					if (($player[local.dude]).is_para == 1)
						break
						
					//locprint 130 70 "ICU"
					local.mg42 setaimtarget $player[local.dude]
					local.mg42 waittill ontarget
					if (isAlive $player[local.dude] && local.mg42B cansee $player[local.dude] 360 3000)
					{
						local.weapon anim fire start
						local.bot exec global/feho/tracerbullet.scr::tracer_bot local.weapon
						// wait .1
						local.pain = randomint (50)
						local.pain = (local.pain + 20)
						local.death = randomint (17)
						local.aim_skills = randomint (2)
						local.sighted_sound = randomint 3
						if (local.aim_skills == 1)
						{
							if (local.sighted_sound == 1)
							{
								if (local.bot.team == "allies")
								{
									local.bot playsound allied_sighted
								}
								else
								{
									local.bot playsound axis_sighted
								}
							}
							$player[local.dude] damage local.player local.pain $player[local.dude] (0 0 0) (0 0 0) (0 0 0) 10 1 19 local.death
							thread promotion $player[local.dude] local.player local.bot
							wait .6
							local.weapon anim rechamber start
						}
					}
					else
					{
						local.mg42 clearAimTarget
					}
				}
			}
			else
			{
				if ( (isAlive $player[local.dude]) && (local.bot.team != $player[local.dude].dmteam) && ($player[local.dude].dmteam != "spectator") && ($player[local.dude].needrevive != 1) && (local.mg42B) && (local.mg42B cansee $player[local.dude] 360 3000) )
				{
					// bots are not allowed to damage players with parachutes
					if (($player[local.dude]).is_para == 1)
						break
						
					//locprint 130 70 "ICU"
					local.mg42 setaimtarget $player[local.dude]
					local.mg42 waittill ontarget
					if (isAlive $player[local.dude] && local.mg42B cansee $player[local.dude] 360 3000)
					{
						local.weapon anim fire start
						local.bot exec global/feho/tracerbullet.scr::tracer_bot local.weapon
						// wait .1
						local.pain = randomint (50)
						local.pain = (local.pain + 20)
						local.death = randomint (17)
						local.aim_skills = randomint (2)
						local.sighted_sound = randomint 3
						if (local.aim_skills == 1)
						{
							if (local.sighted_sound == 1)
							{
								if (local.bot.team == "allies")
								{
									local.bot playsound allied_sighted
								}
								else
								{
									local.bot playsound axis_sighted
								}
							}
							$player[local.dude] damage local.player local.pain $player[local.dude] (0 0 0) (0 0 0) (0 0 0) 10 1 19 local.death
							thread promotion $player[local.dude] local.player local.bot
							wait .6
							local.weapon anim rechamber start
						}
					}
					else
					{
					local.mg42 clearAimTarget
					}
				}
			}
		}
		wait 1.5
	}

	local.mg42B immediateremove	
	local.mg42 immediateremove
	
end

bots_anims local.player local.mg42 local.mg42B:

	//local.bot = self
	while(self)
	{
		for(local.dude=1;local.dude <= $player.size;local.dude++)
		{
			if (getcvar "g_gametype" == "1")
			{
				while( (isAlive $player[local.dude]) && ($player[local.dude] != self) && ($player[local.dude].dmteam != "spectator") && (local.mg42B) && (local.mg42B cansee $player[local.dude] 360 3000) )
				{
					if (!IsAlive self)
						end
					
					self.angle = local.mg42.angle
					
					wait 0.05
				}
			}
			else
			{
				while( (isAlive $player[local.dude]) && (self.team != $player[local.dude].dmteam) && ($player[local.dude].dmteam != "spectator") && ($player[local.dude].needrevive != 1) && (local.mg42B) && (local.mg42B cansee $player[local.dude] 360 3000) )
				{
					if (!IsAlive self)
						end
						
					self.angle = local.mg42.angle
					
					wait 0.05
				}
			}
		}
		wait 0.05
	}

end

/*
fake_dude local.origin local.angle:

	if (self.bots == NIL)
		self.bots = 15
		
	if (self.bots == 0)
	{
		self iprint "0 bots left"
		end
	}
		
	self.bots--
	
	self iprint (self.bots + " bots left")
	
	if (self.dmteam == "allies")
	{
		local.fake_dude = spawn animate model "player/american_Army.tik" origin local.origin angle local.angle health 100 takedamage 1 solid 1 anim rifle_stand_idle
		local.fake_dude droptofloor
		local.fake_dude.team = "allies"
		local.id_number = randomint 10000000
		local.fake_dude attachmodel "items/cigarette.tik" "Bip01 head" 1.3 ("cig" + local.id_number) 0 -1 -1 -1 -1 ( 3.6 7.5 2.0 ) spawnflags 1
		$("cig" + local.id_number).angles = ( 100 180 0 )
		local.fake_dude attachmodel "weapons/springfield.tik" "tag_weapon_right" 1.0 ("weapon" + local.id_number) 0 -1 -1 -1 -1 ( 0 0 0 )
	}
	else
	{
		local.fake_dude = spawn animate model "player/german_Waffenss_Shutze.tik" origin local.origin angle local.angle health 100 takedamage 1 solid 1 anim rifle_stand_idle
		local.fake_dude droptofloor
		local.fake_dude.team = "axis"
		local.id_number = randomint 10000000
		local.fake_dude attachmodel "items/cigarette.tik" "Bip01 head" 1.3 ("cig" + local.id_number) 0 -1 -1 -1 -1 ( 3.6 7.5 2.0 ) spawnflags 1
		$("cig" + local.id_number).angles = ( 100 180 0 )
		local.fake_dude attachmodel "weapons/kar98.tik" "tag_weapon_right" 1.0 ("weapon" + local.id_number) 0 -1 -1 -1 -1 ( 0 0 0 )
	}
	local.weapon = $("weapon" + local.id_number)
	
	//trick to move the bot :P
	local.mg42 = spawn models/statweapons/mg42_gun.tik
	local.mg42.origin = local.fake_dude.origin - local.fake_dude.forwardvector * -10 + ( 0 0 60 )
	local.mg42 svflags "+broadcast"
	local.mg42.angle = local.angle
	local.mg42 hide
	local.mg42B = spawn script_model 
	local.mg42B model "statweapons/mg42_bipod.tik" 
	local.mg42B.origin = local.fake_dude.origin - local.fake_dude.forwardvector * -10 + ( 0 0 62 )
	local.mg42B svflags "+broadcast"
	local.mg42B.angle = local.angle
	local.mg42B hide
	
	thread check_team local.fake_dude self
	thread fake_dude_anims local.fake_dude local.weapon self
	while (isalive local.fake_dude)
	{
		waitframe
	}
	iprintln "A bot was killed !"
	local.death_anim = randomint (5)+1
	switch (local.death_anim)
	{
		case 1:
		local.death_anim = death_fall_to_knees
		local.fake_dude playsound player_death01
		break
		case 2:
		local.death_anim = death_fall_back
		local.fake_dude playsound player_death02
		break
		case 3:
		local.death_anim = death_chest
		local.fake_dude playsound player_death03
		break
		case 4:
		local.death_anim = death_choke
		local.fake_dude playsound player_death04
		break
		case 5:
		local.death_anim = death_crotch
		local.fake_dude playsound player_death05
		break
	}
	local.fake_dude anim local.death_anim
	local.fake_dude notsolid
	local.smoke = spawn script_model "model" "items/cigarette.tik" scale 2.0 origin $("cig" + local.id_number).origin angles $("cig" + local.id_number).angles spawnflags 1
	$("cig" + local.id_number) immediateremove
	local.smoke physics_on
	local.smoke.velocity = local.fake_dude.forwardvector * 100 + local.fake_dude.leftvector * 0 + local.fake_dude.upvector * 150
	local.smoke notsolid
	local.healthbox = spawn health "model" items/50_healthbox.tik origin (local.fake_dude.origin + ( local.fake_dude.forwardvector * 60) + ( 0 0 60 ))
	local.healthbox.velocity = local.fake_dude.forwardvector * 200 + local.fake_dude.leftvector * 0 + local.fake_dude.upvector * 200
	local.healthbox amount 50
	local.healthbox set_respawn_time 30
	local.healthbox droptofloor
	thread life local.smoke local.fake_dude local.healthbox
	wait 4
	
end

life local.smoke local.fake_dude local.healthbox:

	wait (randomint (6)+4)
	local.smoke immediateremove
	local.fake_dude immediateremove
	local.healthbox immediateremove
	
end

fake_dude_anims local.fake_dude local.weapon local.player:

	wait 2
	
	while (local.fake_dude.health > 0)
	{
		for(local.dude=1;local.dude <= $player.size;local.dude++)
		{
			//if ( (isAlive $player[local.dude]) && (local.fake_dude cansee $player[local.dude] 90 3000) && (local.fake_dude.health > 0) )
			if (getcvar "g_gametype" == "1")
			{
				if ( ($player[local.dude].needrevive != 1) && ($player[local.dude] != self) && (isAlive $player[local.dude]) && (local.fake_dude cansee $player[local.dude] 90 3000) && (local.fake_dude.health > 0))
				{
					{
					}
					local.distance = vector_length (local.fake_dude.origin - $player[local.dude].origin)
					if ( (local.fake_dude cansee $player[local.dude] 90 3000 == 1) && (local.fake_dude.health > 0) )
					{
						local.weapon anim fire start
						wait .1
						local.pain = randomint (50)
						local.pain = (local.pain + 50)
						local.death = randomint (17)
						local.aim_skills = randomint (3)+1
						local.sighted_sound = randomint 3
						if (local.aim_skills < 3)
						{
							if (local.sighted_sound == 1)
							{
								if (local.fake_dude.team == "allies")
								{
									local.fake_dude playsound allied_sighted
								}
								else
								{
									local.fake_dude playsound axis_sighted
								}
							}
							$player[local.dude] damage local.player local.pain $player[local.dude] (0 0 0) (0 0 0) (0 0 0) 10 1 19 local.death
							thread promotion $player[local.dude] local.player
							wait .6
							local.weapon anim rechamber start
							if (!IsAlive $player[local.dude])
							{
								local.player addkills 1
							}
						}
					}
				}			
			}
			if (local.fake_dude.team == "allies")
			{
				if ( ($player[local.dude].needrevive != 1) && ($player[local.dude].dmteam == axis) && (isAlive $player[local.dude]) && (local.fake_dude cansee $player[local.dude] 90 3000) && (local.fake_dude.health > 0))
				{
					{
					}
					local.distance = vector_length (local.fake_dude.origin - $player[local.dude].origin)
					if ( (local.fake_dude cansee $player[local.dude] 90 3000 == 1) && (local.fake_dude.health > 0) )
					{
						local.weapon anim fire start
						wait .1
						local.pain = randomint (50)
						local.pain = (local.pain + 50)
						local.death = randomint (17)
						local.aim_skills = randomint (3)+1
						local.sighted_sound = randomint 3
						if (local.aim_skills < 3)
						{
							if (local.sighted_sound == 1)
							{
								local.fake_dude playsound allied_sighted
							}
							$player[local.dude] damage local.player local.pain $player[local.dude] (0 0 0) (0 0 0) (0 0 0) 10 1 19 local.death
							thread promotion $player[local.dude] local.player
							wait .6
							local.weapon anim rechamber start
						}
					}
				}
			}
			else
			{
				if ( ($player[local.dude].needrevive != 1) && ($player[local.dude].dmteam == allies) && (isAlive $player[local.dude]) && (local.fake_dude cansee $player[local.dude] 90 3000) && (local.fake_dude.health > 0))
				{
					{
					}
					local.distance = vector_length (local.fake_dude.origin - $player[local.dude].origin)
					if ( (local.fake_dude cansee $player[local.dude] 90 3000 == 1) && (local.fake_dude.health > 0) )
					{
						local.weapon anim fire start
						wait .1
						local.pain = randomint (50)
						local.pain = (local.pain + 50)
						local.death = randomint (17)
						local.aim_skills = randomint (3)+1
						local.sighted_sound = randomint 3
						if (local.aim_skills < 3)
						{
							if (local.sighted_sound == 1)
							{
								local.fake_dude playsound axis_sighted
							}
							$player[local.dude] damage local.player local.pain $player[local.dude] (0 0 0) (0 0 0) (0 0 0) 10 1 19 local.death
							thread promotion $player[local.dude] local.player
							wait .6
							local.weapon anim rechamber start
						}
					}
				}
			}
		}
		if (local.fake_dude.health > 0)
		{
			wait 1.2
		}
	}
	
end
*/

check_team local.fake_dude local.player:

	while (local.player && local.fake_dude.team == local.player.dmteam && IsAlive local.fake_dude)
	{		
		wait 0.5
	}
	local.fake_dude takedamage
	local.fake_dude hurt 200
	
end

promotion local.victim local.botowner local.bot:

if (!IsAlive local.victim)
{
	// local.botowner addkills 1
	if (local.botowner.dmteam == "allies") {
		local.bot playsound allied_gotone
	}
	else {
		local.bot playsound axis_gotone
	}	
}

end

setup_kill local.player:

	self.detect = spawn trigger_multipleall "spawnflags" "128"
	self.detect.origin = self.origin
	self.detect.angle = self.angle
	self.detect glue self
	self.detect.player = self
	self.detect.alive = 1
	self.detect.attacker = NIL
	self.detect setsize ( -17 -17 0 ) ( 17 17 72 )
	self.detect solid

	while(self.detect)
	{
		self.detect waittill trigger
		// iprintln "test"
		local.murderer = parm.other // Celui qui tire sur le bot

		if (self.team != local.murderer.dmteam)
			self takedamage
		
		if (!IsAlive self)
		{
			if (getcvar "g_gametype" != "1")
			{
				if (self.team != local.murderer.dmteam)
				{
					local.murderer.killcount++
					// local.player.name = netname local.player
					local.murderer iprint ("You killed a bot") 1
				}
				else
				{
					local.murderer.killcount--
					local.murderer iprint ("Don't kill your team's bots soldier!")
					local.murderer damage local.murderer 50 local.murderer (0 0 0) (0 0 0) (0 0 0) 0 1 0 -1
				}
			}
			else // FFA
			{
				if (local.murderer != local.player)
				{
					local.murderer.killcount++
				}
			}
			self.detect immediateremove
		}
			
		waitframe
		
	}
	
end

```

# zz_fake_doors\global\fake_door.scr

```scr
// Fausse porte qui tlporte  une autre position

main local.location local.dest local.spawn_door: 
  
	if (local.spawn_door == 1)
	{
	   local.marker = spawn script_model 
	   local.marker model "static/dummy.tik" 
	   local.marker.origin = (local.location)
    }
	if (local.spawn_door == "metal")
		local.sound = "metal"
		
   local.trig = spawn trigger_use 
   local.trig.origin = (local.location) 
   local.trig setsize ( -20 -20 -20 ) ( 20 20 60 ) 
   thread teleport2 local.trig local.dest local.sound

end 

teleport2 local.trig local.dest local.sound: 

   local.trig waittill trigger
   local.player = parm.other 
   local.player stufftext "holster"
   thread door_sound local.trig local.sound
   wait 1
   local.player tele (local.dest)
   ///   iprintlnbold_noloc "exit !!"
   ///   local.trig message "exit !!"
   local.player stufftext "holster"
   thread teleport2 local.trig local.dest local.sound
   wait 0.7
	if (local.sound == "metal")
	{
		local.trig playsound door_metal_close_stop
	}
	else
	{
		local.player playsound door_wood_close_stop3
	}
   // thread teleport2 local.trig local.dest 
	
end

door_sound local.trig local.sound:

	wait 0.6
	if (local.sound == "metal")
	{
		local.trig playsound door_metal_open_move
	}
	else
	{
		local.trig playsound door_wood_open_move
	}

end
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\binoculars_fire.scr

```scr
// This is a simple hack that allows calling artillery through the state file
main:
		self thread global/fire_for_effect/root.scr::binocular_fire
end
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\binoculars_fire2.scr

```scr
// This is a simple hack that allows calling artillery through the state file
main:
		self thread global/fire_for_effect/root.scr::binocular_fire2
end
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\map_presets\dm\mohdm1.scr

```scr
level.ffe_method = "skybox" // can be skybox, zones (bounds of zones where fire support cannot be called) or xzones (bounds of the only zones where fire support can be called) or a number for tracing the specified number of units up from the call location
end 1 // this is to indicate that the preset ran OK
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\map_presets\dm\mohdm2.scr

```scr
level.ffe_method = "skybox" // can be skybox, zones (bounds of zones where fire support cannot be called) or xzones (bounds of the only zones where fire support can be called) or a number for tracing the specified number of units up from the call location
end 1 // this is to indicate that the preset ran OK
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\map_presets\dm\mohdm3.scr

```scr
level.ffe_method = "skybox" // can be skybox, zones (bounds of zones where fire support cannot be called) or xzones (bounds of the only zones where fire support can be called) or a number for tracing the specified number of units up from the call location
end 1 // this is to indicate that the preset ran OK
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\map_presets\dm\mohdm4.scr

```scr
level.ffe_method = "skybox" // can be skybox, zones (bounds of zones where fire support cannot be called) or xzones (bounds of the only zones where fire support can be called) or a number for tracing the specified number of units up from the call location
end 1 // this is to indicate that the preset ran OK
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\map_presets\dm\mohdm5.scr

```scr
level.ffe_method = "skybox" // can be skybox, zones (bounds of zones where fire support cannot be called) or xzones (bounds of the only zones where fire support can be called) or a number for tracing the specified number of units up from the call location
end 1 // this is to indicate that the preset ran OK
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\map_presets\dm\mohdm6.scr

```scr
level.ffe_method = "skybox" // can be skybox, zones (bounds of zones where fire support cannot be called) or xzones (bounds of the only zones where fire support can be called) or a number for tracing the specified number of units up from the call location
end 1 // this is to indicate that the preset ran OK
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\map_presets\dm\mohdm7.scr

```scr
level.ffe_method = "zones" // can be skybox, zones (bounds of zones where fire support cannot be called) or xzones (bounds of the only zones where fire support can be called) or a number for tracing the specified number of units up from the fire mission call location

// zone definitions
level.ffe_zones[1] = ( -3056 -784 -104 )::( -3272 -528 -104 )
level.ffe_zones[2] = ( -3768 -528 -104 )::( -2312 704 -104 )
level.ffe_zones[3] = ( -1896 1160 -96 )::( -1224 680 -96 )
level.ffe_zones[4] = ( -1544 680 -96 )::( -1544 704 -96 )
level.ffe_zones[5] = ( -980 -436 -104 )::( -8 232 -104 )
level.ffe_zones[6] = ( -8 -436 -104 )::( -416 -640 40 )
level.ffe_zones[7] = ( -392 -896 -104 )::( -32 -976 -104 )
level.ffe_zones[8] = ( -32 -896 -104 )::( -24 -968 -104 )
level.ffe_zones[9] = ( 640 -992 -312 )::( 2120 -1800 -312 )
level.ffe_zones[10] = ( 1488 -1024 -312 )::( 1824 -688 -312 )
level.ffe_zones[11] = ( 192 1392 -144 )::( 624 1544 -144 )
level.ffe_zones[12] = ( 624 1544 -144 )::( 128 2008 -144 )
level.ffe_zones[13] = ( -1768 -1384 -296 )::( -1464 -904 -296 )
level.ffe_zones[14] = ( -1464 -904 -296 )::( -1220 -1252 -296 )
end 1 // this is to indicate that the preset ran OK
```

# zz_Fire_For_Effect-v093_CORE\global\fire_for_effect\root.scr

```scr
// Fire-For-Effect! Modification
// Written by Rookie One
// Artillery support partially based on Bjarne Grnnevik's Rjukan Project scout mod (credits below)

// Scout modification
// ARCHITECTURE: Bjarne Grnnevik
// SCRIPTING: Bjarne Grnnevik
// LINK: http://www.planetmedalofhonor.com/rjukanproject/
// VERSION: 1.3

main:
	if (level.ffe_running == 1) // allow only one instance of the script
		end
	else
		level.ffe_running = 1
	
	level.ffe_version = "0.9.3"
	level.ffe_version_date = "22.05.2005"

	println "[FIRE-FOR-EFFECT]: Initializing Fire-For-Effect! script (version " level.ffe_version " [" level.ffe_version_date "])..."
	thread player_watcher
	
	level.the_gametype = int(getcvar(g_gametype))
	
	level.ffe_settings = waitexec ffe_settings.txt
	level.ffe_localization = waitthread ffe_settings.txt::localize
	level.ffe_airstrike = waitexec global/fire_for_effect/smokeys.scr
	
	if (level.ffe_settings["artillery"] != 1 && level.ffe_airstrike != 1)
	{
		println "[FIRE-FOR-EFFECT]: Both airstrikes and artillery disabled. Terminating."
		end
	}
	
	local.presetname = ("global/fire_for_effect/map_presets/" + (waitthread lowercase (getcvar(mapname))) + ".scr")
	println ("[FIRE-FOR-EFFECT]: Attempting to load preset "  + local.presetname + "...")
	local.preset = waitexec local.presetname
	if (local.preset != 1)
	{
		println ("[FIRE-FOR-EFFECT]: WARNING!!! Loading map preset "  + getcvar(mapname) + " failed! Falling back to skybox tracing method!")
		level.ffe_method = "skybox"
	}
	else
		println ("[FIRE-FOR-EFFECT]: Loading map preset "  + local.presetname + " succeeded.")
	if ((level.ffe_method == "zones" || level.ffe_method == "xzones") && level.ffe_zones.size < 1)
	{
		println "[FIRE-FOR-EFFECT]: WARNING!!! " level.ffe_method " method selected but no zones specified! Falling back to skybox tracing!"
		level.ffe_method = "skybox"
	}
	println "[FIRE-FOR-EFFECT]: " level.ffe_method " tracing method selected."
	
	if (!(level.ffe_settings["artillery_number"] > 0))
		level.ffe_settings["artillery_number"] = 4
	if (!(level.ffe_settings["artillery_radius"] > 0))
		level.ffe_settings["artillery_radius"] = 400
	if (!(level.ffe_settings["artillery_damage"] > 0))
		level.ffe_settings["artillery_damage"] = 400
	if (!(level.ffe_settings["artillery_spread"] > 0))
		level.ffe_settings["artillery_spread"] = 250
	if (!(level.ffe_settings["artillery_delayfixed"] > 0))
		level.ffe_settings["artillery_delayfixed"] = 2.2
	if (!(level.ffe_settings["artillery_delayrandom"] > 0))
		level.ffe_settings["artillery_delayrandom"] = 1.6
	if (!(level.ffe_settings["spotter_damage"] > 0))
		level.ffe_settings["spotter_damage"] = 90
	if (!(level.ffe_settings["spotter_radius"] > 0))
		level.ffe_settings["spotter_radius"] = 50
	if (!(level.ffe_settings["spotter_spread"] > 0))
		level.ffe_settings["spotter_spread"] = 50
	if (!(level.ffe_settings["airstrike_number"] > 0))
		level.ffe_settings["airstrike_number"] = 10
	if (!(level.ffe_settings["airstrike_radius"] > 0))
		level.ffe_settings["airstrike_radius"] = 400
	if (!(level.ffe_settings["airstrike_damage"] > 0))
		level.ffe_settings["airstrike_damage"] = 400
	if (!(level.ffe_settings["airstrike_step"] > 0))
		level.ffe_settings["airstrike_step"] = 150
	if (!(level.ffe_settings["airstrike_delay"] > 0))
		level.ffe_settings["airstrike_delay"] = 0.1
	if (!(level.ffe_settings["airstrike_spread"] > 0))
		level.ffe_settings["airstrike_spread"] = 64
	
	level waittill prespawn
	
	local.master = spawn ScriptMaster
	local.master aliascache steamloop sound/mechanics/Mec_SteamLoop_01.wav soundparms 1.0 0.3 1.0 0.0 320 2200 item loaded maps "m dm obj"
	local.master alias airstrike_invalid_target1 sound/dialogue/M3L2/A/dfr_m3l3_344k.wav soundparms 1.0 0.0 1.0 0.0 80 112 dialog streamed subtitle "That's not a target. Over." maps "m dm obj"
	local.master alias airstrike_invalid_target2 sound/dialogue/M3L3/A/dfr_m3l3_345o.wav soundparms 1.0 0.0 1.0 0.0 80 112 dialog streamed subtitle "Give me a target. Over." maps "m dm obj"
	local.master alias airstrike_valid_target1 sound/dialogue/M3L2/A/dfr_m3l3_346k.wav soundparms 1.0 0.0 1.0 0.0 80 112 dialog streamed subtitle "Roger. Target acquired." maps "m dm obj"
	local.master alias airstrike_valid_target2 sound/dialogue/M3L3/A/dfr_m3l3_347o.wav soundparms 1.0 0.0 1.0 0.0 80 112 dialog streamed subtitle "Roger. Consider it done." maps "m dm obj"
	local.master alias airstrike_already_enroute1 sound/dialogue/M3L2/A/dfr_m3l3_348k.wav soundparms 1.0 0.0 1.0 0.0 80 112 dialog streamed subtitle "Target already acquired. Over." maps "m dm obj"
	local.master alias airstrike_already_enroute2 sound/dialogue/M3L3/A/dfr_m3l3_349o.wav soundparms 1.0 0.0 1.0 0.0 80 112 dialog streamed subtitle "Already enroute to a target. Over." maps "m dm obj"
	local.master aliascache arty_leadinmp1 sound/weapons/explo/Exp_LeadIn_06.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm obj"
	local.master aliascache arty_leadinmp2 sound/weapons/explo/Exp_LeadIn_07.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm obj"
	local.master aliascache arty_leadinmp3 sound/weapons/explo/Exp_LeadIn_08.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm obj"
	local.master aliascache arty_leadinmp4 sound/weapons/explo/Exp_LeadIn_09.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm obj"
	local.master aliascache arty_leadinmp5 sound/weapons/explo/Exp_LeadIn_10.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm obj"
	local.master aliascache arty_leadinmp6 sound/weapons/explo/Exp_LeadIn_11.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm obj"
	local.master aliascache arty_leadinmp7 sound/weapons/explo/Exp_LeadIn_12.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm obj"
	local.master aliascache arty_leadinmp8 sound/weapons/explo/Exp_LeadIn_13.wav soundparms 0.8 0.2 0.7 0.5 160 3000 auto loaded maps "m dm obj"

	println "[FIRE-FOR-EFFECT]: Caching models..."
	cache models/animate/fx_mortar_dirt.tik
	cache models/emitters/linger_smoke.tik
	cache models/items/binoculars.tik
	
	level waittill spawn
	
	println ("[FIRE-FOR-EFFECT]: Instruction frequency: " + level.ffe_settings["instruction_frequency"])

	if ($world.farplane == NIL )
		level.ffe_sight_max = 22000
	else
	{
		if ($world.farplane < 1)
			level.ffe_sight_max = 22000
		else
			level.ffe_sight_max = $world.farplane
	}
	println ("[FIRE-FOR-EFFECT]: Farplane is " + $world.farplane + ", maximum artillery support calling range is " + level.ffe_sight_max + ".")
	
	if (level.the_gametype == 1)
		thread firemission_timer freeforall
	else
	{
		thread firemission_timer allies
		thread firemission_timer axis
	}
	if (level.ffe_airstrike == 1)
		thread smokegrenade_handler
	// thread print_instructions level.ffe_settings["instruction_frequency"]
end

print_instructions local.inst_freq:
	wait (local.inst_freq / 2)
	huddraw_align 102 left bottom
	huddraw_color 102 0.5 0.25 1.0
	huddraw_font 102 handle-22
	huddraw_alpha 102 0.0
	local.text = ("Server IP : 77.109.78.28:12204") // Fire For Effect! v" + level.ffe_version + " modification by Rookie One\nhttp://www.moh.gamesnet.pl/rookieone")
	huddraw_rect 102 16 -185 0 0
	huddraw_string 102 local.text
	if (level.ffe_settings["artillery"] == 1 || level.ffe_airstrike == 1)
	{
		if (level.ffe_settings["artillery"] == 1)
			local.text = level.ffe_localization["Use your binoculars (7) to call artillery support (aim somewhere and click fire)."]
		if (level.ffe_airstrike == 1)
			local.text = local.text + "\n" + level.ffe_localization["Use smoke grenades (Stielhandgranaten) to call airstrikes."]
		local.text = local.text + "\n" + level.ffe_localization["One fire mission can be called each "] + level.ffe_settings["powertimer"]+ level.ffe_localization[" seconds."]
		huddraw_rect 103 16 -135 0 0
		huddraw_align 103 left bottom
		huddraw_alpha 103 0.0
		huddraw_color 103 0.75 0.75 0.75
		huddraw_font 103 facfont-20
		huddraw_string 103 local.text
	}
	while (1)
	{
		
		for (local.alpha = 0.0; local.alpha <= 1.0; local.alpha += 0.1)
		{
			huddraw_alpha 102 local.alpha
			if (level.ffe_settings["artillery"] == 1 || level.ffe_airstrike == 1)
				huddraw_alpha 103 local.alpha
			wait 0.1
		}
		wait 14
		for (local.alpha = 1.0; local.alpha >= 0.0; local.alpha -= 0.1)
		{
			huddraw_alpha 102 local.alpha
			if (level.ffe_settings["artillery"] == 1 || level.ffe_airstrike == 1)
				huddraw_alpha 103 local.alpha
			wait 0.1
		}
		wait (local.inst_freq - 10)
	}
end

binocular_fire:
	if (level.ffe_settings["artillery"] != 1)
		end
	if (self.calling_firemission == 1)
		end
	self.calling_firemission = 1
	if (self.haspower == 1)
	{
		if ((self waitthread can_call_fire_mission) == 1)
		{
			if (level.the_gametype == 1)
				local.team = freeforall
			else
				local.team = self.dmteam
			local.hit_location = trace ((self gettagposition "Bip01 Head") + (angles_toforward self.viewangles) * 64) ((self gettagposition "Bip01 Head") + (angles_toforward self.viewangles) * level.ffe_sight_max)
			local.marker_location = trace (local.hit_location + ( 0 0 16 )) (local.hit_location + ( 0 0 -16384 ))
			local.checker_location = waitthread trace_surface local.marker_location
			if (local.checker_location != NIL)
			{
				if (local.checker_location != local.marker_location)
				{
					if (self != NIL && self != NULL)
					{
						self thread play_a_sound airstrike_invalid_target
						self iprint (level.ffe_localization["ARTILLERY SUPPORT: Cannot see target!"]) 1
						self.calling_firemission = 0
					}
				}
				else
				{
					if (self != NIL && self != NULL)
					{
						// self take weapons/steilhandgranate.tik *** Feho modif (mis en commentaire pour ne pas enlever les steilhandgranate aprs appel artillerie) ***
						self.haspower = 0
						self.power_timer = 0
					}
					level.ffe_firemissiontimer[local.team] += 10
					local.marker_spot = waitthread get_random_origin local.marker_location 32
					self thread play_a_sound airstrike_valid_target
					self iprint (level.ffe_localization["ARTILLERY SUPPORT: Firing for effect!"]) 1
					self.calling_firemission = 0
					wait 2 //wait 5
					// local.artillery_marker_boom = spawn models/animate/fx_mortar_dirt.tik scale 0.39 origin local.marker_spot
					// local.artillery_marker_boom notsolid
					// local.artillery_marker_boom thread marker_go_boom self
					// wait 1
					// local.artillery_marker1 = spawn models/emitters/linger_smoke.tik origin local.marker_spot
					// local.artillery_marker1 notsolid
					// local.artillery_marker1 anim start
					// local.artillery_marker2 = spawn models/emitters/linger_smoke.tik origin local.marker_spot
					// local.artillery_marker2 notsolid
					// local.artillery_marker2 anim start
					wait 5
					// local.artillery_marker1 anim stop
					// local.artillery_marker1 delete
					// local.artillery_marker2 anim stop
					// local.artillery_marker2 delete
					
					waitthread artillery_volley local.marker_location self
				}
			}
			else
			{
				if (self != NIL && self != NULL)
				{
					self thread play_a_sound airstrike_invalid_target
					self iprint (level.ffe_localization["ARTILLERY SUPPORT: Cannot see target!"]) 1
					self.calling_firemission = 0
				}
			}
		}
		else
		{
			if (self != NIL && self != NULL)
			{
				self thread play_a_sound airstrike_already_enroute
				local.timeleft = self waitthread get_next_fire_mission
				self iprint (level.ffe_localization["ARTILLERY SUPPORT: Insufficient fire support! Next fire mission available in "] + local.timeleft + level.ffe_localization[" seconds!"]) 1
				self.calling_firemission = 0
			}
		}
	}
	else
	{
		if (self != NIL && self != NULL)
		{
			local.timeleft = self waitthread get_power_time
			self iprint (level.ffe_localization["Not enough power to call fire support! Charging will take "] + local.timeleft + level.ffe_localization[" more seconds!"])
			self.calling_firemission = 0
		}
	}
end
	
get_random_origin local.areacentre local.radius:
	local.randomorigin = local.areacentre
	local.x = local.areacentre[0]
	local.y = local.areacentre[1]
	local.x = local.x + (randomfloat(local.radius * 2) - local.radius)
	local.y = local.y + (randomfloat(local.radius * 2) - local.radius)
	local.temporigin = waitthread trace_surface ( local.x local.y local.areacentre[2] )
	if (local.temporigin == NIL)
	{
		local.x = local.x + (randomfloat(local.radius * 2) - local.radius)
		local.y = local.y + (randomfloat(local.radius * 2) - local.radius)
		local.temporigin = waitthread trace_surface ( local.x local.y local.areacentre[2] )
	}
	if (local.temporigin == NIL)
	{
		local.x = local.x + (randomfloat(local.radius * 2) - local.radius)
		local.y = local.y + (randomfloat(local.radius * 2) - local.radius)
		local.temporigin = waitthread trace_surface ( local.x local.y local.areacentre[2] )
	}
	if (local.temporigin == NIL)
	{
		local.temporigin = local.areacentre
		local.x = local.areacentre[0]
		local.y = local.areacentre[1]
	}
	local.z = local.temporigin[2]
	local.randomorigin[0] = local.x
	local.randomorigin[1] = local.y
	local.randomorigin[2] = local.z
end local.randomorigin

trace_surface local.location:
	switch (level.ffe_method)
	{
		case "skybox":
			local.skybox = waitthread trace_skybox_height local.location
			local.tracedorigin = trace ( local.location[0] local.location[1] (local.skybox - 1) ) ( local.location[0] local.location[1] -16384 )
			end local.tracedorigin
		case "zones":
			for (local.i = 1; local.i <= level.ffe_zones.size; local.i++)
			{
				local.zone = level.ffe_zones[local.i]
				local.inbound = waitthread in_bounds_of local.location local.zone
				if (local.inbound == 1)
					end NIL
			}
			local.skybox = waitthread trace_skybox_height local.location
			local.tracedorigin = trace ( local.location[0] local.location[1] (local.skybox - 1) ) ( local.location[0] local.location[1] -16384 )
			break
		case "xzones":
			local.tracedorigin = NIL
			for (local.i = 1; local.i <= level.ffe_zones.size; local.i++)
			{
				local.zone = level.ffe_zones[local.i]
				local.inbound = waitthread in_bounds_of local.location local.zone
				if (local.inbound == 1)
				{
					local.skybox = waitthread trace_skybox_height local.location
					end (trace ( local.location[0] local.location[1] (local.skybox - 1) ) ( local.location[0] local.location[1] -16384 ))
				}
			}
			break
		default:
			local.tracedorigin = trace ( local.location[0] local.location[1] (local.location[2] + level.ffe_method) ) ( local.location[0] local.location[1] -16384 )
	}
end local.tracedorigin

firemission_timer local.team:
	level.ffe_firemissiontimer[local.team] = 0
	while (1)
	{
		wait 1
		if (level.ffe_firemissiontimer[local.team] > 0)
		{
			level.ffe_firemissiontimer[local.team]--
		}
	}
end

power_timer:
	self.power_timer = level.ffe_settings["powertimer"] - level.ffe_settings["powertimerdelay"]
	self.haspower = 0
	while (isAlive(self) && self.dmteam != spectator)
	{
		if (self.haspower == 0)
		{
			if (self.power_timer <= level.ffe_settings["powertimer"])
				self.power_timer++
			if (self.power_timer == level.ffe_settings["powertimer"])
			{
				if (level.ffe_airstrike == 1)
					self item weapons/steilhandgranate.tik
				self.haspower = 1
				self.power_timer = 0
				self iprint (level.ffe_localization["Charging complete!"])
			}
		}
		wait 1
	}
end

//Feho ------------>
power_timer2:
	self.power_timer2 = level.ffe_settings["powertimer2"] - level.ffe_settings["powertimerdelay2"]
	self.haspower2 = 0
	while (isAlive(self) && self.dmteam != spectator)
	{
		if (self.haspower2 == 0)
		{
			if (self.power_timer2 <= level.ffe_settings["powertimer2"])
				self.power_timer2++
			if (self.power_timer2 == level.ffe_settings["powertimer2"])
			{
				if (level.ffe_airstrike == 1)
					self item weapons/steilhandgranate.tik
				self.haspower2 = 1
				self.power_timer2 = 0
				self iprint (level.ffe_localization["Air Support ready to go!"])
			}
		}
		wait 1
	}
end
//<---------------------

go_boom local.caller:
	self playsound arty_leadinmp
	wait 1
	self stopsound
	self anim start
	waitthread scored_radiusdamage self.origin local.caller level.ffe_settings["artillery_damage"] level.ffe_settings["artillery_radius"]
	if (level.ffe_settings["earthquakes"] == 1)
		thread boom_earthquake
	wait 1
	self delete
end

marker_go_boom local.caller:
	self playsound arty_leadinmp
	wait 1
	self stopsound
	self anim start
	waitthread scored_radiusdamage self.origin local.caller level.ffe_settings["spotter_damage"] level.ffe_settings["spotter_radius"]
	if (level.ffe_settings["earthquakes"] == 1)
		thread boom_earthquake 1
	wait 1
	self delete
end

artillery_volley local.location local.caller:
	for (local.i = 1; local.i <= level.ffe_settings["artillery_number"]; local.i++)
		local.explosionorigins[local.i] = waitthread get_random_origin local.location level.ffe_settings["artillery_spread"]
	for (local.i = 1; local.i <= level.ffe_settings["artillery_number"]; local.i++)
	{
		local.explosions[local.i] = spawn models/animate/fx_mortar_dirt.tik scale 1.0 origin local.explosionorigins[local.i]
		local.explosions[local.i] thread go_boom local.caller
		wait (level.ffe_settings["artillery_delayfixed"] + randomfloat(level.ffe_settings["artillery_delayrandom"]))
	}
end

trace_skybox_height local.location:
	local.newloc = trace ( local.location[0] local.location[1] 16384 ) ( local.location[0] local.location[1] -16384 )
end local.newloc[2]

player_watcher:
	level waittill spawn
	println "[FIRE-FOR-EFFECT]: Starting the player watcher"
	while (1)
	{
		for (local.i = 1; local.i <= $player.size; local.i++)
		{
			if (isAlive($player[local.i]) && $player[local.i].dmteam != spectator && $player[local.i].done != 1)
			{
				$player[local.i].done = 1
				$player[local.i] thread equip_at_join
			}
		}
		waitframe
	}
end

equip_at_join:
	local.trg = spawn trigger_multiple origin self.origin
	local.trg glue self
	local.trg.player = self
	local.trg setthread global/fire_for_effect/root.scr::player_join_trigger
	while (self != NIL && self != NULL && local.trg != NIL && local.trg != NULL)
		waitframe
	if (local.trg != NIL && local.trg != NULL)
		local.trg delete
end

player_join_trigger:
	if (parm.other == self.player)
	{
		self.player item items/binoculars.tik
		if (level.ffe_airstrike == 1)
		{
			if (self.player.dmteam == axis)
			{
				self.player take weapons/steilhandgranate.tik
				self.player item weapons/m2frag_grenade.tik
			}
		}
		self.player thread reset_at_death
		if (level.ffe_settings["artillery"] == 1 || level.ffe_airstrike == 1)
			self.player thread power_timer
			self.player thread power_timer2 //feho
		self delete
	}
end

reset_at_death:
		
	if (self.dmteam != spectator)
	{
		local.team = self.dmteam
		while (isAlive(self) && self.dmteam == local.team)
			waitframe
	}
	
	if (self == NULL)
		end
		
	self.done = 0
	self.haspower = 0
end

scored_radiusdamage local.org local.attacker local.dmg local.radius:
	if (local.attacker == NIL || local.attacker == NULL)
		local.attacker = $world
	local.ent = waitthread spawn_nobroadcast script_origin (local.org + ( 0 0 8 ))
	for (local.i = 1; local.i <= $player.size; local.i++)
	{
		if (isAlive($player[local.i]) && $player[local.i].dmteam != spectator)
		{
			if (vector_within local.ent.origin $player[local.i].origin (local.radius + 1))
			{
				if (local.ent cansee $player[local.i] 360 local.radius)
				{
					local.actualdamage = int(local.dmg - (float(local.dmg) / float(local.radius) * (vector_length ($player[local.i].origin - local.ent.origin))))
					//               damage (attacker,     damage,            inflictor,     position, direction,                                                                     normal,   knockback,    damageflags, meansofdeath, location)
					$player[local.i] damage local.attacker local.actualdamage local.attacker ( 0 0 0 ) ((angles_toforward(angles_pointat local.ent local.ent $player[local.i])) * -1) ( 0 0 0 ) (local.actualdamage * 1.5) 0 9 -1
				}
			}
		}
	}
	if (level.jvbot_jv_mp_ai_running == 1 && level.botlastid != NIL) // jv_bot support
	{
		for (local.i = 1; local.i <= level.botlastid; local.i++)
		{
			if (isAlive(level.actualbots[local.i]))
			{
				if (vector_within local.ent.origin level.actualbots[local.i].origin (local.radius + 1))
				{
					if (local.ent cansee level.actualbots[local.i] 360 local.radius)
					{
						local.actualdamage = int(local.dmg - (float(local.dmg) / float(local.radius) * (vector_length (level.actualbots[local.i].origin - local.ent.origin))))
						level.actualbots[local.i] damage local.attacker local.actualdamage local.attacker ( 0 0 0 ) ((angles_toforward(angles_pointat local.ent local.ent level.actualbots[local.i])) * -1) ( 0 0 0 ) (local.actualdamage * 1.5) 0 9 -1
					}
				}
			}
		}
	}
	if (level.ffe_damageable != NIL && level.ffe_damageable != NULL)
	{
		for (local.i = 0; local.i <= level.ffe_damageable.size; local.i++)
		{
			if (isAlive(level.ffe_damageable[local.i]))
			{
				if (vector_within local.ent.origin level.ffe_damageable[local.i].origin (local.radius + 1))
				{
					if (local.ent cansee level.ffe_damageable[local.i] 360 local.radius)
					{
						local.actualdamage = int(local.dmg - (float(local.dmg) / float(local.radius) * (vector_length (level.ffe_damageable[local.i].origin - local.ent.origin))))
						level.ffe_damageable[local.i] damage local.attacker local.actualdamage local.attacker ( 0 0 0 ) ((angles_toforward(angles_pointat local.ent local.ent level.ffe_damageable[local.i])) * -1) ( 0 0 0 ) (local.actualdamage * 1.5) 0 9 -1
					}
				}
			}
		}
	}
	//radiusdamage local.ent.origin local.dmg local.radius
	local.ent delete
end

smokegrenade_handler:
	local.trg = spawn trigger_multipleall spawnflags 20 origin ( 0 0 0 )
	local.trg setsize ( -16384 -16384 -16384 ) ( 16384 16384 16384 )
	local.trg setthread smokegrenade_trigger_fire
end

smokegrenade_trigger_fire:
	local.projectile = parm.other
	local.player = parm.owner
	if (local.projectile.done == 1)
		end
	local.projectile.done = 1
	waitframe
	if (local.projectile.model == models/projectiles/steilhandgranate.tik || local.projectile.model == models/projectiles/steilhandgranate_primary.tik)
	{
		local.player.haspower = 0
		local.player.power_timer = 0
		local.projectile thread smokegrenade_fire local.player
		local.projectile thread make_smoke
		local.projectile nodamage
	}
end

smokegrenade_fire local.caller:
	if (local.caller.calling_firemission == 1)
		end
	local.caller.calling_firemission = 1
	local.caller take weapons/steilhandgranate.tik
	local.caller uselast
	wait 3.5
	local.ent = spawn script_origin origin self.origin
	local.ent playsound airplane
	local.ent thread remove_after 10
	wait 1.5
	if ((local.caller waitthread can_call_fire_mission) == 1)
	{
		if (level.the_gametype == 1)
			local.team = freeforall
		else
			local.team = local.caller.dmteam
		level.ffe_firemissiontimer[local.team] += 10
		local.marker_location = trace (self.origin + ( 0 0 8 )) (self.origin + ( 0 0 -16384 ))
		local.checker_location = waitthread trace_surface local.marker_location
		if (local.checker_location != NIL)
		{
			if (local.checker_location != local.marker_location)
			{
				if (local.caller != NIL && local.caller != NULL)
				{
					local.caller thread play_a_sound airstrike_invalid_target
					local.caller iprint (level.ffe_localization["AIR SUPPORT: Aborting, cannot see target!"]) 1
					local.caller.calling_firemission = 0
				}
				wait 1
				self explode
			}
			else
			{
				if (local.caller != NIL && local.caller != NULL)
				{
					local.caller thread play_a_sound airstrike_valid_target
					local.caller iprint (level.ffe_localization["AIR SUPPORT: Affirmative! On my way!"]) 1
					local.caller.calling_firemission = 0
				}
					self explosionmodel models/fx/dummy.tik
				
				wait 1
				self stoploopsound
				self delete
				waitthread airstrike_volley local.marker_location local.caller
			}
		}
		else
		{
			if (local.caller != NIL && local.caller != NULL)
			{
				local.caller thread play_a_sound airstrike_invalid_target
				local.caller iprint (level.ffe_localization["AIR SUPPORT: Aborting, cannot see target!"]) 1
				local.caller.calling_firemission = 0
			}
			wait 1
			self explode
		}
	}
	else
	{
		if (local.caller != NIL && local.caller != NULL)
		{
			local.caller thread play_a_sound airstrike_already_enroute
			local.timeleft = local.caller waitthread get_next_fire_mission
			local.caller iprint (level.ffe_localization["AIR SUPPORT: Too many airstrikes requested! Next fire mission available in "] + local.timeleft + level.ffe_localization[" seconds!"]) 1
			local.caller.calling_firemission = 0
		}
		wait 1
		self explode
	}
end

make_smoke:
	local.smoke1 = spawn models/emitters/linger_smoke.tik origin self.origin
	local.smoke2 = spawn models/emitters/linger_smoke.tik origin self.origin
	local.smoke1 glue self
	local.smoke2 glue self
	local.smoke1 anim start
	local.smoke2 anim start
	self loopsound steamloop
	while (isAlive(self))
		waitframe
	local.smoke1 delete
	local.smoke2 delete
end

in_bounds_of local.location local.zone:
	local.result = 0
	if (local.zone[1][0] < local.zone[2][0])
	{
		local.temp = local.zone[1][0]
		local.zone[1][0] = local.zone[2][0]
		local.zone[2][0] = local.temp
	}
	if (local.zone[1][1] < local.zone[2][1])
	{
		local.temp = local.zone[1][1]
		local.zone[1][1] = local.zone[2][1]
		local.zone[2][1] = local.temp
	}
	if (local.location[0] <= local.zone[1][0] && local.location[0] >= local.zone[2][0])
	{
		if (local.location[1] <= local.zone[1][1] && local.location[1] >= local.zone[2][1])
			local.result = 1
	}
end local.result

airstrike_volley local.location local.caller:
	local.fwd_vec = angles_toforward ( 0 (randomint(4) * 90) 0 )
	local.offset = ((level.ffe_settings["airstrike_step"] * level.ffe_settings["airstrike_number"]) / 2 - level.ffe_settings["airstrike_step"] / 2) * -1
	for (local.i = 1; local.i <= level.ffe_settings["airstrike_number"]; local.i++)
	{
		local.explosionorigins[local.i] = waitthread get_random_origin (local.location + local.fwd_vec * local.offset) level.ffe_settings["airstrike_spread"]
		local.offset += level.ffe_settings["airstrike_step"]
	}
	for (local.i = 1; local.i <= level.ffe_settings["airstrike_number"]; local.i++)
	{
		if (local.explosionorigins[local.i] != NIL)
		{
			local.explosions[local.i] = spawn models/animate/fx_mortar_dirt.tik scale 0.75 origin local.explosionorigins[local.i]
			local.explosions[local.i] thread airstrike_go_boom local.caller
		}
		wait level.ffe_settings["airstrike_delay"]
	}
end

airstrike_go_boom local.caller:
	self anim start
	waitthread scored_radiusdamage self.origin local.caller level.ffe_settings["airstrike_damage"] level.ffe_settings["airstrike_radius"]
	if (level.ffe_settings["earthquakes"] == 1)
		thread boom_earthquake 1
	wait 1
	self delete
end

play_a_sound local.sound:
	self playsound local.sound
	/*if (self.radioent == NIL || self.radioent == NULL)
	{
		self.radioent = spawn script_model model models/fx/dummy.tik origin (self gettagposition "eyes bone")
		self.radioent notsolid
		self.radioent rendereffects "+dontdraw"		
		self.radioent attach self "eyes bone"
	}
	self.radioent playsound local.sound*/
end

can_call_fire_mission:
//	local.result = 0
	if (level.the_gametype == 1)
		local.team = freeforall
	else
		local.team = self.dmteam
	if (local.team == spectator)
		end 0
	if ((level.ffe_firemissiontimer[local.team] + 10) <= (level.ffe_settings["firemissions"] * 10))
		end 1
	end 0
end

get_next_fire_mission:
	if (level.the_gametype == 1)
		local.team = freeforall
	else
		local.team = self.dmteam
	end (level.ffe_settings["firemissions"] * 10 - level.ffe_firemissiontimer[local.team])
end

get_power_time:
	local.result = level.ffe_settings["powertimer"] - self.power_timer
end local.result

//feho --------->
get_power_time2:
	local.result = level.ffe_settings["powertimer2"] - self.power_timer2
end local.result
//<-------------

remove_after local.time:
	wait local.time
	self delete
end

spawn_nobroadcast local.entityclassname local.origin:
	local.ent = spawn local.entityclassname origin local.origin
	local.ent svflags "-broadcast"
end local.ent

lowercase local.text:
	for (local.i = 0; local.i < local.text.size; local.i++)
	{
		switch (local.text[local.i])
		{
			case "A":
				local.text[local.i] = "a"
				break
			case "B":
				local.text[local.i] = "b"
				break
			case "C":
				local.text[local.i] = "c"
				break
			case "D":
				local.text[local.i] = "d"
				break
			case "E":
				local.text[local.i] = "e"
				break
			case "F":
				local.text[local.i] = "f"
				break
			case "G":
				local.text[local.i] = "g"
				break
			case "H":
				local.text[local.i] = "h"
				break
			case "I":
				local.text[local.i] = "i"
				break
			case "J":
				local.text[local.i] = "j"
				break
			case "K":
				local.text[local.i] = "k"
				break
			case "L":
				local.text[local.i] = "l"
				break
			case "M":
				local.text[local.i] = "m"
				break
			case "N":
				local.text[local.i] = "n"
				break
			case "O":
				local.text[local.i] = "o"
				break
			case "P":
				local.text[local.i] = "p"
				break
			case "Q":
				local.text[local.i] = "q"
				break
			case "R":
				local.text[local.i] = "r"
				break
			case "S":
				local.text[local.i] = "s"
				break
			case "T":
				local.text[local.i] = "t"
				break
			case "U":
				local.text[local.i] = "u"
				break
			case "V":
				local.text[local.i] = "v"
				break
			case "W":
				local.text[local.i] = "w"
				break
			case "X":
				local.text[local.i] = "x"
				break
			case "Y":
				local.text[local.i] = "y"
				break
			case "Z":
				local.text[local.i] = "z"
				break
		}
	}
end local.text

boom_earthquake local.type:
	if (local.type == 1)
	{
		earthquake .175 2 0 0
		earthquake .115 1 0 0
		// earthquake .15 .5 0 0
		// earthquake .15 .625 0 1
		//----
		// earthquake .175 5 0 0
		// earthquake .115 3 0 0
		// earthquake .15 .5 0 0
		// earthquake .15 .625 0 1
	}
	else
	{
		earthquake .2 1 0 0
		earthquake .16 .8 0 0
		// earthquake .45 .4 0 0
		// earthquake .32 .1 0 1
		//----
		// earthquake .2 9 0 0
		// earthquake .16 5 0 0
		// earthquake .45 .8 0 0
		// earthquake .32 .3 0 1
	}
end

clickitem_fail:

	exec global/fire_for_effect/root.scr::binocular_fire
	
end

//Feho ------------------------------------------------------->
binocular_fire2:
	if (level.ffe_settings["artillery"] != 1)
		end
	if (self.calling_firemission == 1)
		end
	self.calling_firemission = 1
	if(self.rankbonus["airsupport"] == 1)
	{
		if (self.haspower2 == 1)
		{
			if ((self waitthread can_call_fire_mission) == 1)
			{
				if (level.the_gametype == 1)
					local.team = freeforall
				else
					local.team = self.dmteam
				local.hit_location = trace ((self gettagposition "Bip01 Head") + (angles_toforward self.viewangles) * 64) ((self gettagposition "Bip01 Head") + (angles_toforward self.viewangles) * level.ffe_sight_max)
				local.marker_location = trace (local.hit_location + ( 0 0 16 )) (local.hit_location + ( 0 0 -16384 ))
				local.checker_location = waitthread trace_surface local.marker_location
				if (local.checker_location != NIL)
				{
					if (local.checker_location != local.marker_location)
					{
						if (self != NIL && self != NULL)
						{
							self thread play_a_sound airstrike_invalid_target
							self iprint (level.ffe_localization["AIR SUPPORT: Cannot see target!"]) 1
							self.calling_firemission = 0
						}
					}
					else
					{
						if (self != NIL && self != NULL)
						{
							// self take weapons/steilhandgranate.tik *** Feho modif (mis en commentaire pour ne pas enlever les steilhandgranate aprs appel artillerie) ***
							self.haspower2 = 0
							self.power_timer2 = 0
						}
						level.ffe_firemissiontimer[local.team] += 10
						local.marker_spot = waitthread get_random_origin local.marker_location 32
						self thread play_a_sound airstrike_valid_target
						self iprint (level.ffe_localization["AIR SUPPORT: Affirmative! On my way!"]) 1
						self.calling_firemission = 0
						wait 7
						local.ent = spawn script_origin origin local.marker_location
						local.ent playsound airplane
						local.ent thread remove_after 10
						wait 3.0
						waitthread airstrike_volley local.marker_location self
					}
				}
				else
				{
					if (self != NIL && self != NULL)
					{
						self thread play_a_sound airstrike_invalid_target
						self iprint (level.ffe_localization["AIR SUPPORT: Cannot see target!"]) 1
						self.calling_firemission = 0
					}
				}
			}
			else
			{
				if (self != NIL && self != NULL)
				{
					self thread play_a_sound airstrike_already_enroute
					local.timeleft = self waitthread get_next_fire_mission
					self iprint (level.ffe_localization["AIR SUPPORT: Too many airstrikes requested! Next fire mission available in "] + local.timeleft + level.ffe_localization[" seconds!"]) 1
					self.calling_firemission = 0
				}
			}
		}
		else
		{
			if (self != NIL && self != NULL)
			{
				local.timeleft = self waitthread get_power_time2
				self iprint (level.ffe_localization["Not enough power to call air support! Charging will take "] + local.timeleft + level.ffe_localization[" more seconds!"])
				self.calling_firemission = 0
			}
		}
	}
	else
	{
		self iprint "You must have a higher rank to call air support" 1
		self.calling_firemission = 0
	}
end
//<--------------------------------------------------------------------
```

# zz_kicknades\Grenades\Trigger.scr

```scr
main:

	if(self.kick)
		end

	self.kick = 1
	local.origin = self.origin
	local.id = spawn trigger_use origin local.origin
	local.id glue self
	local.id setsize ( -50 -50 -50 ) ( 50 50 50 )
	local.id.nade = self
	local.id setthread KickNade
	
	//feho
	local.hit_nade = spawn trigger_multiple "spawnflags" 128 "targetname" "hit_nade"
	local.hit_nade glue self
	local.hit_nade setsize ( -4 -4 -4 ) ( 4 4 4 )
	local.hit_nade.nade = self
	local.hit_nade setthread shot
	//local.hit_nade.origin = local.radio.origin
	//<---------------

	while(self != NULL)
		waitframe
	if(local.id != NULL)
		local.id remove
		local.hit_nade remove //feho

end

KickNade:
	local.player = parm.other
	// if (local.player.rankbonus["nades"] != 1 && level.running_ranking == 1)
			// end
			
	local.randomNbr = randomint(450)+100
	self nottriggerable

	local.angles = angles_toforward local.player.angles
	self.nade.velocity = local.angles * 600 + ( 0 0 local.randomNbr ) //450
	local.player iprint "Good Kick!"
	// local.player addkills 10
	// pour re-kick la nade
	wait .2
	self triggerable
	// if(self != NULL)
		// self remove
		
end
	
shot:
	local.player = parm.other
	
	self nottriggerable
	self.nade.velocity =  ( 0 0 80 ) + local.player.forwardvector * 500 
	wait .2

	if (self)
		self triggerable
end

```

# zz_lance-grenade\global\nadeattach.scr

```scr
main:
local.master = spawn scriptmaster
local.master aliascache mountG sound/mechanics/lockpick2.wav soundparms 1.5 0.2 0.8 0.2 160 1000 weapon loaded maps "dm obj t m"
self weaponcommand dual targetname getme
local.weapon = $getme
local.weapon.targetname = ""

if(local.weapon.hasscope==2 && local.weapon.hasnade!=1 && local.weapon.nades>0)
{
self weaponcommand dual dmammorequired 0
if(local.weapon.model=="models/weapons/m1_garand.tik")
{
local.weapon.nade = spawn animate model weapons/m2frag_grenade.tik
local.weapon.nade notsolid
local.weapon.nade attach local.weapon "tag_barrel" 1 ( 0 0.4 1 )
local.weapon.nade angles ( 110 0 0 )
}
else
{
local.weapon.nade = spawn animate model weapons/steilhandgranate.tik
local.weapon.nade notsolid
local.weapon.nade attach local.weapon "tag_barrel" 1 ( 0 0.4 0 )
local.weapon.nade angles ( -75 -6 0 )
local.weapon.nade scale 0.8
}
self weaponcommand dual firetype projectile
local.weapon.hasnade=1
local.weapon playsound mountG
}
else if(local.weapon.hasscope==2 && local.weapon.nades>0)
{
self weaponcommand dual dmammorequired 1
local.weapon.nade remove
self weaponcommand dual firetype bullet
local.weapon.hasnade=0
local.weapon playsound mountG
}
end

```

# zz_lance-grenade\global\naderemove.scr

```scr
main:
// local.master = spawn scriptmaster
// local.master aliascache launch sound/weapons/fire/Flak88Fire4.wav soundparms 1.5 0.0 1.0 0.0 2000 4000 weapon loaded maps "dm obj t m"
self weaponcommand dual targetname getme
local.weapon = $getme
local.weapon.targetname = "" 
if(local.weapon.hasscope==2 && local.weapon.hasnade==1)
{
waitframe
self weaponcommand dual firetype bullet
local.weapon.nade remove
local.weapon.hasnade=0
local.weapon.nades=local.weapon.nades-1
// local.weapon playsound launch
self weaponcommand dual dmammorequired 1
}
end

```

# zz_lance-grenade\global\weapontrade.scr

```scr

main:
	wait .1

	self weaponcommand dual targetname getme

	local.weapon = $getme
	
	if(local.weapon)
		local.weapon.targetname = ""


	if(local.weapon && local.weapon.model=="models/weapons/m1_garand.tik" && local.weapon.hasscope!=2 && local.weapon.hasscope!=1)
	{
		local.weapon.nades=1
		self weaponcommand dual dmprojectile models/projectiles/panzerIVshell.tik //bazookashell.tik
		local.weapon.hasscope=2
	}

	if(local.weapon && local.weapon.model=="models/weapons/kar98.tik" && local.weapon.hasscope!=2 && local.weapon.hasscope!=1)
	{
		local.weapon.nades=1
		self weaponcommand dual dmprojectile models/projectiles/panzerIVshell.tik
		local.weapon.hasscope=2
	}

	waitframe
end

```

# zz_PHIL_{SFX}_DETONATORS\global\DETONATOR_SOUND.scr

```scr
/*
PHIL {SFX} FISHER - 2005

E-MAIL: MOHAA.MODS@NTLWORLD.COM

WEBSITE: WWW.MODS-R-US.NET
*/

main:

local.MASTER = spawn scriptmaster

local.MASTER aliascache plantbomb1 sound/items/Item_BangaloreAssemble_01.wav soundparms 1.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train"
local.MASTER aliascache radiobomb sound/items/RadioBomb.wav soundparms 1.0 0.0 1.0 0.0 100 2000 item loaded maps "m dm moh obj train"
local.MASTER aliascache plunger sound/items/Item_DetonatorPlunger_01.wav soundparms 1.5 0.0 1.0 0.0 320 2200 item loaded maps "m dm moh obj train"
local.MASTER aliascache activate sound/mechanics/shortwave4.wav soundparms 0.7 0.0 1.0 0.0 100 900 auto streamed maps "m dm moh obj train"
local.MASTER aliascache boom sound/weapons/explo/Explo_Mine1.wav soundparms 0.8 0.3 0.7 0.4 1000 8000 weapon loaded maps "m dm moh obj train "
end
```

# zz_PHIL_{SFX}_DETONATORS\global\RB_DETONATORS.scr

```scr
/*
PHIL {SFX} FISHER - 2005

E-MAIL: MOHAA.MODS@NTLWORLD.COM

WEBSITE: WWW.MODS-R-US.NET
*/


/*

Usage: exec global/RB_DETONATORS.scr::DETONATOR <plunger origin> <plunger angles> before level waittill spawn. 


IE: map dm/mohdm1: exec global/RB_DETONATORS.scr::DETONATOR ( 298.64 475.75 384.13 ) ( 0 0 0 )

*/


DETONATOR local.D_ORIGIN local.D_ANGLES:

             local.FAKE_WALKIETALKIE = spawn script_object
             local.FAKE_WALKIETALKIE model "models/items/walkietalkie.tik"
             local.FAKE_WALKIETALKIE.origin = local.D_ORIGIN
             local.FAKE_WALKIETALKIE.angles = local.D_ANGLES
             local.FAKE_WALKIETALKIE rotatey 55
             local.FAKE_WALKIETALKIE notsolid

             local.WALKIETALKIE_TRIGGER = spawn trigger_use
             local.WALKIETALKIE_TRIGGER.origin = local.D_ORIGIN
             local.WALKIETALKIE_TRIGGER.angles = local.D_ANGLES
             local.WALKIETALKIE_TRIGGER setsize "-20 -20 0" "20 20 20"
             local.WALKIETALKIE_TRIGGER setthread GIVE_WALKIETALKIE
             local.WALKIETALKIE_TRIGGER message "REMOTE DETONATOR & RADIO-BOMB OBTAINED!"
             end

GIVE_WALKIETALKIE:
             
             local.PLAYER = parm.other

             if (local.PLAYER.OWNS==1)
             {
               local.PLAYER iprint "YOU ARE A DOG!, YOU CANT USE EXPLOSIVES!" 1   // PHIL {SFX} SMART HOUND PROTECTION
               end
             }

             if ((local.PLAYER.ARMED==1) || (local.PLAYER.WALKIETALKIED==1))
             {
               local.PLAYER iprint "YOU HAVE A REMOTE DETONATOR & RADIO-BOMB ALREADY!" 1
               end
             }

             if ((local.PLAYER.NF==1) && (local.PLAYER.ARMED==0) && (local.PLAYER.DETONATORED==0))
             {
               local.PLAYER iprint "YOU HAVE NOT DETONATED THE BOMB YOU HAVE PLACED ALREADY!" 1
               end
             }

             local.PLAYER iprint "HOLD USE TO PLANT RADIO-BOMB!" 1

             local.PLAYER.DEATH_SPEC = 0
             local.PLAYER.ARMED = 1
             local.PLAYER.WALKIETALKIED = 1
             local.PLAYER.NF = 1

             thread MONITOR_WALKIETALKIED local.PLAYER
             thread DEAD_OR_ALIVE local.PLAYER
             end

MONITOR_WALKIETALKIED local.PLAYER:

             while ((isalive local.PLAYER) && (local.PLAYER.ARMED==1) && (local.PLAYER.WALKIETALKIED==1))
             {
               if (local.PLAYER.useheld==1)
               {
                wait 1
                if (local.PLAYER.useheld==1)
                {
                 local.RB_NUMBER = randomint 5000
                 local.RB = spawn script_model
                 local.RB.targetname = ("RB" + local.RB_NUMBER) 
                 $("RB" + local.RB_NUMBER) model "models/animate/radiobomb.tik"
                 $("RB" + local.RB_NUMBER) physics_on
                 $("RB" + local.RB_NUMBER) scale 1
                 $("RB" + local.RB_NUMBER).origin = local.PLAYER.origin - local.PLAYER.forwardvector * -40 + ( 0 0 2 )
                 $("RB" + local.RB_NUMBER).angles = ( 0 0 0 )
                 $("RB" + local.RB_NUMBER) notsolid
                 local.PLAYER.RB = $("RB" + local.RB_NUMBER)

                 local.PLAYER.RB playsound plantbomb1
                 wait 0.1
                 local.PLAYER.RB playsound radiobomb

                 thread MONITOR_RB local.PLAYER

                 local.PLAYER iprint "RADIO-BOMB PLANTED!" 1
                 local.PLAYER iprint "HOLD USE TO DETONATE BOMB!" 1
                 local.PLAYER.ARMED = 0
               }
             }
               wait 0.1
             }
             end

MONITOR_RB local.PLAYER:

              while ((isalive local.PLAYER) && (local.PLAYER.WALKIETALKIED==1))
              {
                 if (local.PLAYER.useheld==1)
                 {
                   wait 0.5
                   if (local.PLAYER.useheld==1)
                   {
                   local.PLAYER safeholster 1 putaway
                   wait 1

                   local.WALKIETALKIE_NUMBER = randomint 5000
                   local.WALKIETALKIE = spawn Animate model models/items/walkietalkie.tik
                   local.WALKIETALKIE.targetname = ("WALKIETALKIE" + local.WALKIETALKIE_NUMBER)
                   $("WALKIETALKIE" + local.WALKIETALKIE_NUMBER).origin = (local.PLAYER gettagposition "tag_weapon_right")
                   $("WALKIETALKIE" + local.WALKIETALKIE_NUMBER) attach local.PLAYER  "tag_weapon_right"
                   $("WALKIETALKIE" + local.WALKIETALKIE_NUMBER).angles = ( 0 180 180 )
                   $("WALKIETALKIE" + local.WALKIETALKIE_NUMBER) scale 0.8
                   $("WALKIETALKIE" + local.WALKIETALKIE_NUMBER) notsolid

                   local.PLAYER.WALKIETALKIE = $("WALKIETALKIE" + local.WALKIETALKIE_NUMBER)
                   local.PLAYER.WALKIETALKIE playsound plantbomb1                   

                   thread RB_TRIGGER_CHECK local.PLAYER
                   local.PLAYER.WALKIETALKIED = 0
                 } 
               }  
                 wait 0.1  
               }

               end

RB_TRIGGER_CHECK local.PLAYER:

    local.PLAYER playsound activate
    local.PLAYER.RB playsound activate
    wait 0.5
    local.PLAYER.RB hide

    for (local.PNM=1;local.PNM <= $player.size;local.PNM++)
    {
      if ((vector_within $player[local.PNM].origin local.PLAYER.RB.origin 200) && ($player[local.PNM].dmteam != local.PLAYER.dmteam))
      {
        $player[local.PNM] damage local.PLAYER 100 local.PLAYER.RB (0 0 0) (0 0 0) (0 0 0) 0 1 rocket -1
      }
    }

    exec global/model.scr local.PLAYER.RB.origin "models/emitters/explosion_bombdirt.tik" 

    local.PLAYER.RB playsound boom
    local.PLAYER.RB delete
    wait 3
    local.PLAYER.WALKIETALKIE delete
    local.PLAYER.DEATH_SPEC = 1
    local.PLAYER.NF = 0

end  
                  
DEAD_OR_ALIVE local.PLAYER:

    while ((isalive local.PLAYER) && (local.PLAYER.dmteam!="spectator"))
    waitframe

    if (local.PLAYER.DEATH_SPEC!=1)
   {
      local.PLAYER.NF = 0
      local.PLAYER.ARMED = 0
      local.PLAYER.WALKIETALKIED = 0
      local.PLAYER.WALKIETALKIE delete                                     
      local.PLAYER.RB delete
    }

end
```

# zz_PHIL_{SFX}_DETONATORS\global\SOUND_README.txt

```txt
PHIL {SFX} FISHER - 2005

E-MAIL: MOHAA.MODS@NTLWORLD.COM

WEBSITE: WWW.MODS-R-US.NET

_____________________________________


Add the line of txt below before "level waittill spawn" in the map scr to get DETONATOR sound.

exec global/DETONATOR_SOUND.scr
```

# zz_PHIL_{SFX}_DETONATORS\global\TNT_DETONATORS.scr

```scr
/*
PHIL {SFX} FISHER - 2005

E-MAIL: MOHAA.MODS@NTLWORLD.COM

WEBSITE: WWW.MODS-R-US.NET
*/


/*

Usage: exec global/TNT_DETONATORS.scr::DETONATOR <origin> <angles> before level waittill spawn. 


IE: map dm/mohdm1: exec global/TNT_DETONATORS.scr::DETONATOR ( 298.64 475.75 384.13 ) ( 0 0 0 )

To use press use on static plunger, then anywhere in map hold use for 3 seconds to plant bomb, then hold use anywhere for 3 
seconds again to drop plunger. Press use on plunger to setoff your bomb. Planter can only use plunger !

*/


DETONATOR local.D_ORIGIN local.D_ANGLES:

             local.FAKE_DETONATOR = spawn script_model
             local.FAKE_DETONATOR model "models/miscobj/detonator.tik"
             local.FAKE_DETONATOR.origin = local.D_ORIGIN
             local.FAKE_DETONATOR.angles = local.D_ANGLES
             local.FAKE_DETONATOR rotatey 55
             local.FAKE_DETONATOR notsolid

             local.FAKE_DETONATOR_TRIGGER = spawn trigger_use
             local.FAKE_DETONATOR_TRIGGER.origin = local.D_ORIGIN
             local.FAKE_DETONATOR_TRIGGER.angles = local.D_ANGLES
             local.FAKE_DETONATOR_TRIGGER setsize "-20 -20 0" "20 20 20"
             local.FAKE_DETONATOR_TRIGGER setthread GIVE_DETONATOR
             local.FAKE_DETONATOR_TRIGGER message "DETONATOR & TNT OBTAINED!"
             end

GIVE_DETONATOR:
             
             local.PLAYER = parm.other

             if (local.PLAYER.OWNS==1)
             {
               local.PLAYER iprint "YOU ARE A DOG, YOU CANT USE EXPLOSIVES!" 1   // PHIL {SFX} SMART HOUND PROTECTION
               end
             }

             if ((local.PLAYER.ARMED==1) || (local.PLAYER.DETONATORED==1))
             {
               local.PLAYER iprint "YOU HAVE A DETONATOR & TNT ALREADY!" 1
               end
             }

             if ((local.PLAYER.NF==1) && (local.PLAYER.ARMED==0) && (local.PLAYER.DETONATORED==0))
             {
               local.PLAYER iprint "YOU HAVE NOT USED THE TNT YOU HAVE PLACED ALREADY!" 1
               end
             }

             local.PLAYER iprint "HOLD USE TO PLANT TNT!" 1

             local.PLAYER.DEATH_SPEC = 0
             local.PLAYER.ARMED = 1
             local.PLAYER.DETONATORED = 1
             local.PLAYER.NF = 1

             thread MONITOR_ARMED local.PLAYER
             thread DEAD_OR_ALIVE local.PLAYER
             end

MONITOR_ARMED local.PLAYER:

             while ((isalive local.PLAYER) && (local.PLAYER.ARMED==1) && (local.PLAYER.DETONATORED==1))
             {
               if (local.PLAYER.useheld==1)
               {
                wait 1
                if (local.PLAYER.useheld==1)
                {
                 local.EXPLOSIVE = spawn script_model
                 local.EXPLOSIVE model "models/items/explosive2.tik"
                 local.EXPLOSIVE physics_on
                 local.EXPLOSIVE scale 2
                 local.EXPLOSIVE.origin = local.PLAYER.origin - local.PLAYER.forwardvector * -40 + ( 0 0 2 )
                 local.EXPLOSIVE notsolid

                 local.EXPLOSIVE playsound plantbomb1
                 wait 0.1
                 local.EXPLOSIVE playsound radiobomb

                 thread MONITOR_EXPLOSIVE local.PLAYER local.EXPLOSIVE

                 local.PLAYER iprint "TNT PLANTED!" 1
                 local.PLAYER iprint "HOLD USE TO PLACE THE DETONATOR!" 1
                 local.PLAYER.ARMED = 0
               }
             }
               wait 0.1
             }
             end

MONITOR_EXPLOSIVE local.PLAYER local.EXPLOSIVE:

              while ((isalive local.PLAYER) && (local.PLAYER.DETONATORED==1))
              {
                 if (local.PLAYER.useheld==1)
                 {
                   wait 1
                   if (local.PLAYER.useheld==1)
                   {
                     local.DETONATOR = spawn script_model
                     local.DETONATOR model "models/miscobj/detonator.tik"
                     local.DETONATOR physics_on
                     local.DETONATOR.origin = local.PLAYER.origin - local.PLAYER.forwardvector * -40 + ( 0 0 8 )
                     local.DETONATOR.angles = ( 0 180 0 )
                     local.DETONATOR notsolid

                     local.DETONATOR.EXPLOSIVE = local.EXPLOSIVE

                     local.DETONATOR_TRIGGER = spawn trigger_use
                     local.DETONATOR_TRIGGER.origin = local.DETONATOR.origin
                     local.DETONATOR_TRIGGER.angles = local.DETONATOR.angles
                     local.DETONATOR_TRIGGER setsize "-16 -16 0" "16 16 40"

                     local.DETONATOR_TRIGGER bind local.DETONATOR

                     local.DETONATOR playsound plantbomb1                   

                     local.PLAYER iprint "DETONATOR READY!" 1
                     local.PLAYER iprint "PRESS USE ON DETONATOR TO DETONATE TNT!" 1

                     local.DETONATOR.DETONATOR_TRIGGER = local.DETONATOR_TRIGGER
                     thread DETONATOR_TRIGGER_CHECK local.PLAYER local.DETONATOR
                     local.PLAYER.DETONATORED = 0
                    } 
               }  
                 wait 0.1  
               }       
               end

DETONATOR_TRIGGER_CHECK local.PLAYER local.DETONATOR:

                   local.DETONATOR.DETONATOR_TRIGGER waittill trigger  

                   local.DETONATOR anim fire
                   local.DETONATOR playsound plunger
                   local.DETONATOR.EXPLOSIVE playsound activate
                   wait 0.5
                   local.DETONATOR.EXPLOSIVE hide

                   for (local.PNUM=1;local.PNUM <= $player.size;local.PNUM++)
                   {
                     if ((vector_within $player[local.PNUM].origin local.DETONATOR.EXPLOSIVE.origin 200) && ($player[local.PNUM].dmteam != local.PLAYER.dmteam))
                     {
                       $player[local.PNUM] damage local.PLAYER 100 local.DETONATOR.EXPLOSIVE (0 0 0) (0 0 0) (0 0 0) 0 1 rocket -1
                     }
                   }

                   exec global/model.scr local.DETONATOR.EXPLOSIVE.origin "models/emitters/explosion_bombdirt.tik" 

                   local.DETONATOR.EXPLOSIVE playsound boom
                   local.DETONATOR.EXPLOSIVE delete
                   wait 2
                   local.DETONATOR.DETONATOR_TRIGGER delete
                   local.DETONATOR delete
                   local.PLAYER.DEATH_SPEC = 1
                   local.PLAYER.NF = 0
                   end

                   thread DETONATOR_TRIGGER_CHECK local.PLAYER local.DETONATOR
                   end  
                  
DEAD_OR_ALIVE local.PLAYER:

                    while ((isalive local.PLAYER) && (local.PLAYER.dmteam!="spectator"))
                    waitframe

                    if (local.PLAYER.DEATH_SPEC!=1)
                   {
                      local.PLAYER.NF = 0
                      local.PLAYER.ARMED = 0
                      local.PLAYER.DETONATORED = 0
                      // local.PLAYER.DETONATOR delete                                     
                      // local.DETONATOR.EXPLOSIVE delete
                      // local.PLAYER.DETONATOR_TRIGGER delete			
                    }      
                    end
```

# zz_player_spotlight\global\player_spotlight.scr

```scr
// To use this script, make script_models with model miscobj/searchlightbase.tik and give them
// all the same targetname .You can also give the spotlights health and color .Then execute the script like this .
//
// local.s1 = spawn script_model model miscobj/searchlightbase.tik origin ( 4056.53 -4411.25 216.13 )
// local.s1 angles ( 0 205 0 )
// local.s1 targetname myspot
// local.s1.color = ( 1 1 0)
// local.s1.health = 100

// 
//     exec global/player_spotlight.scr mytargetname
// 
// When a player press the use key down it lights up, and it goes off when use is pressed again . 
// It will follow the players view while it is on.



main local.name:

local.master = spawn scriptmaster

local.master aliascache exp_searchlight sound/weapons/explo/Explo_Searchlight1.wav soundparms 0.9 0.2 0.8 0.4 1000 8000 auto loaded maps "DM obj"

for(local.num = 1;local.num <= $(local.name).size;local.num++)
{
thread makespot $(local.name)[local.num]
}
end

makespot local.spotlight:

	if(local.spotlight.color == NIL)
		local.color = ( 1 1 1 )
	else
		local.color = local.spotlight.color

	local.spot = spawn script_model model miscobj/searchlightoff.tik origin (local.spotlight.origin + ( 0 0 32 )) spawnflags 1
	local.spot.destroyed = 0
	local.angles = local.spotlight.angles
	local.angles[1] = (local.angles[1] * -1)
	local.spot.angles = local.angles

	local.spotdamage = spawn trigger_multiple origin local.spot.origin spawnflags 144
	local.spotdamage setsize ( -25 -25 -25 )( 25 25 25 )

	if(local.spotlight.health == NIL || local.spotlight.health <= 0)
		local.spotdamage.health = 300
	else
		local.spotdamage.health = local.spotlight.health

	local.spottrigger = spawn trigger_multiple origin local.spotlight.origin
	local.spottrigger setsize ( -50 -50 -100 )(50 50 50 )

	if($(local.spotlight.target))
	local.spottrigger origin $(local.spotlight.target).origin

	local.groundtarget = spawn script_origin
	local.groundspot_target = spawn script_origin

	local.light = spawn script_model
	local.light model "fx/searchlight.tik"
	local.light notsolid
	local.light.origin = local.spot.origin + local.spot.forwardvector * -16
	local.light hide

	local.flare = spawn script_model
	local.flare model "fx/searchlight.tik"
	local.flare notsolid
	local.flare scale 5
	local.flare.origin = local.groundtarget.origin
	local.flare hide
	local.flare light local.color
	local.flare lightradius 250

	local.beam = spawn func_beam origin local.spot.origin
	local.beam alpha .2
	local.beam maxoffset 0
	local.beam numsegments 20
	local.beam scale 50
	local.beam activate
	local.beam life .1
	local.beam color local.color
	local.beam hide

	thread aimspot local.groundspot_target local.beam local.spot local.light local.groundtarget local.flare local.spotdamage local.spottrigger



while(1)
{

	local.spottrigger waittill trigger

	local.spottrigger nottriggerable

	local.player = parm.other

	while(local.player istouching local.spottrigger )
	{

		local.fwd_vec = angles_toforward local.player.viewangles
		local.start = local.player gettagposition "Bip01 Head"

		local.range = 10240

		local.groundtarget.origin = trace (local.start + local.fwd_vec * 64) (local.start + local.fwd_vec * local.range ) 0

		local.s_vec = ( local.groundtarget.origin - local.spot.origin)
		local.s_ang = vector_toangles(local.s_vec)

		local.s_ang[1] = (local.s_ang[1] - 180)

		local.s_ang[0] = (local.s_ang[0] * -1)


		local.spot.angles = local.s_ang

		local.spotlight.angles = ( 0 local.s_ang[1] 0 )

		local.light.origin = local.spot.origin + local.spot.forwardvector * -8 

		if(local.player.useheld == 1)
		{

			wait .2

			if(local.showspot !=1)
			{
				local.showspot = 1
				local.light show
				local.flare show
				local.beam show

			}
			else
			{
				local.beam hide
				local.showspot = 0
				local.light hide
				local.flare hide

			}
		}


		waitframe

	if(local.spot.destroyed == 1)
		break

	}

	if(local.spot.destroyed == 1)
		break

	local.spottrigger triggerable
}

end

aimspot local.groundspot_target local.beam local.spot local.light local.groundtarget local.flare local.spotdamage local.spottrigger:


while(local.spot.destroyed != 1)
{
		local.groundspot_target.origin = local.spot.origin + local.spot.forwardvector * -10240

		local.p = trace local.spot.origin local.groundspot_target.origin 0

		local.beam endpoint local.p

		local.flare.origin = local.p


	if(local.spotdamage.health <= 0)
	{
		local.spot playsound exp_searchlight
		exec global/model.scr local.spot.origin models/fx/fx_spotlighthit

		local.light delete
		local.flare delete
		local.spottrigger delete
		local.spotdamage delete
		local.groundtarget delete
		local.spot.destroyed = 1
		local.beam deactivate
		break
	}

waitframe
}
end
```

# zz_Portable_30cal_V3\models\30cal.scr

```scr
main:

	local.player = parm.other
	
	if (local.player.needrevive == 1)
		end
		
	self remove
	local.player exec models/scan_player.scr 


end
```

# zz_Portable_30cal_V3\models\create_guns.scr

```scr
main local.origin: 

	local.cache = spawn scriptmaster 
	local.cache aliascache jeep_snd_fire sound/weapons/fire/50CalFire2.wav soundparms 0.8 0.2 0.95 0.1 800 2000 weapon loaded maps "m t e dm obj tow lib"

	local.trigger = spawn trigger_use origin local.origin
	local.trigger model models/vehicles/jeep_30cal.tik
	local.trigger show
	local.trigger setthread models/30cal.scr::main
	local.trigger droptofloor

end
```

# zz_Portable_30cal_V3\models\place_30cal.scr

```scr
main:


	local.team = self.dmteam

	local.ok = 1

	while(local.ok)
		{
		if(self == NULL)
			{
			local.ok = 0
			end
			}
		else
			{
			if(self.dmteam != local.team || !isalive self)
				{
				local.trigger = spawn trigger_use origin self.origin
				local.trigger model models/vehicles/jeep_30cal.tik
				local.trigger show
				local.trigger setthread models/30cal.scr::main
				local.trigger droptofloor
				local.trigger playsound mg_drop
				//spawn a new trigger
				end
				}
			else
				{
				if!(self.fireheld)
					local.ok = 0
				}
			}
		waitframe
		}

	local.specang = (angles_toforward self.viewangles)
	local.specorg = self.origin
	local.origin = ((local.specorg + ((local.specang[0]) (local.specang[1]) (0)) * 45) + ( 0 0 50 ))
	local.angle = self.angle

	local.gun = spawn models/vehicles/jeep_30cal.tik origin local.origin angle local.angle
	local.gun douse self
	local.gun pitchcaps ( -30 30 0 )

	local.ok = 1

	while(local.ok)
		{
		if(self == NULL)
			{
			local.ok = 0
			end
			}
		else
			{
			if(self.dmteam != local.team || !isalive self)
				{
				local.gun remove
				local.trigger = spawn trigger_use origin self.origin
				local.trigger model models/vehicles/jeep_30cal.tik
				local.trigger show
				local.trigger setthread models/30cal.scr::main
				local.trigger droptofloor
				local.trigger playsound mg_drop
				//spawn a new trigger
				end
				}
			else
				{
				local.specang = (angles_toforward self.viewangles)
				local.specorg = self.origin	
				local.gun.origin = ((local.specorg + ((local.specang[0]) (local.specang[1]) (0)) * 45) + ( 0 0 0 ))
				if(self.useheld)
					{
					local.check = 1
					while(local.check)
						{
						if(self == NULL)
							{
							local.check = 0
							local.gun setplayerusable 0 //douse self
							local.gun remove
							end
							}
						else
							{
							if(self.dmteam != local.team || !isalive self)
								{
								local.check = 0
								local.gun setplayerusable 0 //douse self
								local.gun remove
								end
								}
							else
								{
								if(!self.useheld)
									local.check = 0
								}
							}
						waitframe
						}
					local.gun setplayerusable 0 //douse self
					local.gun remove
					self exec models/scan_player.scr
					end
					}
				}
			}

		waitframe
		}



	if(self == NULL && (local.gun != NULL || local.gun != NIL))
		{
		local.trigger = spawn trigger_use origin local.gun.origin
		local.trigger model models/vehicles/jeep_30cal.tik
		local.trigger show
		local.trigger setthread models/30cal.scr::main
		local.trigger droptofloor
		local.trigger playsound mg_drop
		}


	if(local.gun != NULL)
		{
		local.gun remove
		}


				
end
```

# zz_Portable_30cal_V3\models\Portable30cal.tik

```tik
TIKI
setup
{
	scale 0.52				// Set default scale to 16/30.5 since world is in 16 units per foot and model is in cm's
	path models/fx/dummy
	skelmodel dummy3.skd
}

init
{
	server
	{
		classname		InventoryItem
		name			"Portable .30 Cal"
		rendereffects +dontdraw
		notsolid
		exec models/setup_tiki.scr portable
	}
}

animations
{
	idle    dummy3.skc

}


```

# zz_Portable_30cal_V3\models\scan_player.scr

```scr
main:

	local.num = randomint 999999999
	self attachmodel models/vehicles/jeep_30cal.tik "Bip01 Pelvis" 1 ("portable" + local.num) 1 -1 -1 -1 -1 ( 0 -30 -30 )
	self.packed_30cal = $("portable" + local.num)
	$("portable" + local.num).angles = ( 45 45 0 )
	self give models/Portable30cal.tik
	self use models/Portable30cal.tik
	self iprint "Press (fire) to Deploy" 1
	level.MG_ON = 1

	wait 2

	local.check = 1
	local.team = self.dmteam



	while(local.check)
		{
		if(self == NULL)
			local.check = 0
		else
			{
			if(self.dmteam != local.team || !isalive self)
				{
				//spawn a new trigger in original place
				local.trigger = spawn trigger_use origin self.origin
				local.trigger model models/vehicles/jeep_30cal.tik
				local.trigger show
				local.trigger setthread models/30cal.scr::main
				local.trigger droptofloor
				local.trigger playsound mg_drop
				self.packed_30cal remove
				level.MG_ON = 0
				end
				}
			else
				{

				if(self.fireheld)
					{
					self.packed_30cal remove
					self exec models/place_30cal.scr
					self take models/Portable30cal.tik
					self thread truck_cam //feho
					
					end
					}
					
				local.weapon = waitthread check_weapon self

				if(!local.weapon)
					{
					//spawn a new trigger
					local.trigger = spawn trigger_use origin self.origin
					local.trigger model models/vehicles/jeep_30cal.tik
					local.trigger show
					local.trigger setthread models/30cal.scr::main
					local.trigger droptofloor
					local.trigger playsound mg_drop
					self.packed_30cal remove
					level.MG_ON = 0
					end
					}
				}
			}
		waitframe
		}




end 

check_weapon local.weapon:
	
	local.ok = 1

	local.ran = randomint 999999

	local.model = models/portable30cal.tik

	local.weapon weaponcommand dual targetname ("Weaponcheck" + local.ran)

	if($("Weaponcheck" + local.ran) != NIL && $("Weaponcheck" + local.ran) != NULL)
		{
		if($("Weaponcheck" + local.ran).model != local.model)
			{
			local.weapon weaponcommand dual targetname ""
			local.ok = 0
			end local.ok
			}
		}

	local.weapon weaponcommand dual targetname ""

end local.ok

truck_cam:

if (level.MG_ON == 1) {
	wait 1
	cueplayer
	// thread truck_cam
}

end
```

# zz_Portable_30cal_V3\models\setup_tiki.scr

```scr
main local.command:

	thread local.command

end

portable:

	local.version = getcvar version

	if(local.version[15] == A)
		{
		self commanddelay 0 dmcrosshair 0
		}
	else
		{
		self commanddelay 0 dm crosshair 0
		}

end

static:

	local.version = getcvar version

	if(local.version[15] == A)
		{
		self commanddelay 0 dmbulletcount 1
		self commanddelay 0 dmfiredelay	0.065
		self commanddelay 0 dmbulletrange 4000
		self commanddelay 0 dmbulletdamage 45
		self commanddelay 0 dmbulletspread 50 50
		}
	else
		{
		self commanddelay 0 dm bulletcount 1
		self commanddelay 0 dm firedelay 0.065
		self commanddelay 0 dm bulletrange 4000
		self commanddelay 0 dm bulletdamage 45
		self commanddelay 0 dm bulletspread 50 50
		}

end
		
		
		
		
		
```

# zz_Portable_30cal_V3\models\vehicles\jeep_30cal_viewmodel.tik

```tik
TIKI
setup
{
	scale 1.33				// Set default scale to 16/30.5 since world is in 16 units per foot and model is in cm's
	path models/vehicles/jeep
	skelmodel 30cal_viewmodel.skd
	surface material1 shader 30cal
	surface material3 shader 30cal
	surface material2 shader 30calmount
}

init
{
	server
	{
		classname 		Animate
		kill                             //kill this entity as its fubar. (still works as viewthing when killed :D!!!)
		notsolid

		surface material2 +nodraw
		surface material3 +nodraw
	}
}

animations
{
	idle    30cal_viewmodel.skc
	fire	30cal_viewmodel_fire.skc
	{
		client
		{
			entry stopaliaschannel jeep_snd_fire
			entry sound jeep_snd_fire

			// muzzle flash
			entry tagdlight tag_barrel 0.25 0.2 0.05 110 0.11
			entry tagspawn tag_barrel
			(
				scale 0.6
				offsetalongaxis 3 0 0
				count 1
				model muzsprite.spr
				angles 0 0 crandom 25
				life 0.06
				hardlink
			)
			entry tagspawn tag_barrel
			(
				count 1
				scalemin 0.5
				scalemax 1.0
//				model models/fx/muzflash.tik
				model muzsprite.spr
				randomroll
				life 0.04
////				flicker
				hardlink
			)

		}
	}
}

```

# zz_Portable_30cal_V3\models\vehicles\jeep_30cal.tik

```tik
TIKI
setup
{
	scale 1.33				// Set default scale to 16/30.5 since world is in 16 units per foot and model is in cm's
	path models/vehicles/jeep
	skelmodel jeep_30cal.skd
	surface weapon shader 30cal
	surface mount shader 30calmount
}

init
{
	server
	{
		classname 		TurretGun
		weapontype		mg
		name			".30 Cal"

		// turret settings
		idleCheckOffset	"-56 0 0"


		// Primary fire type info
		firetype		bullet
		meansofdeath		bullet
		bulletcount		2

		usenoammo		1
		firedelay		0.06
		bulletrange		4000
		bulletdamage		45
		bulletspread		50 50
		tracerfrequency 	3

		viewOffset		"0 0 50"
		viewjitter		0.75

		exec models/setup_tiki.scr static




	}
}

animations
{
	idle    jeep_30cal.skc
	fire	jeep_30cal.skc
	{
		server
		{
			entry shoot
			entry playsound jeep_snd_fire
		}
		client
		{
			//entry stopaliaschannel jeep_snd_fire
			//entry sound jeep_snd_fire weapon 1.0 -1 0.95 0.1

			// muzzle flash
			entry tagdlight tag_barrel 0.25 0.2 0.05 110 0.11
			entry tagspawn tag_barrel
			(
				scale 0.6
				offsetalongaxis 3 0 0
				count 1
				model muzsprite.spr
				angles 0 0 crandom 25
				life 0.04
			)
			entry tagspawn tag_barrel
			(
				count 1
				scalemin 1.0
				scalemax 1.5
				model models/fx/muzflash.tik
				randomroll
				life 0.03
//				flicker
			)

		}
	}
}

/*QUAKED vehicle_allied_jeep_30cal (0.0 .0 0.0) (-60 -40 0) (60 40 128)
Jeep 30cal
*/
```

# zz_ranking_final_modif\global\health.scr

```scr
// trigger pour augmenter la vie (bug: ne fonctionne pas  chaque fois...)
local.trig = spawn trigger_multiple
local.trig.origin = ( -374.13 170.28 -144.23 )
local.trig setsize ( -10 -10 -10 ) ( 10 10 10 ) 
local.trig setthread health
local.trig message "Health bonus"

health:
	local.player = parm.other
	local.player volumedamage -100 
end
```

# zz_ranking_final_modif\global\limits.txt

```txt
// ************************************************************ //
// ************************************************************ //
//								//
// 		Weapon Limiter Options; by Sor			//
//								//
// ************************************************************	//
// ************************************************************	//


//==========================================================================================//
// BONUS
// ------
// Give people with a certain weapon a bonus!!
//
// Bonusses: 
//
// //Weaponmodel  //Option 	//amount to give?
// <"model">	"ammo"	 	<integer amount>
// <"model"> 	"nade"		<integer amount>
// <"model">   	"speed"		<float movementspeed>	//more than 1.00
// <"model"> 	"zoom"		<integer zoom>		//less than 20
//
//==========================================================================================//
bonuses: 

	level.AIR["bonus_weapons"] = makeArray

	// Weapon model					// Bonus	// Bonus Var 1	
	//"models/weapons/thompsonsmg.tik"		"ammo"		50

	endArray
end

//==========================================================================================//
// LIMITED
// --------
// Give people with a certain weapon a limit/restriction!!
//
// Limits: 
//
// //Weaponmodel  //Option 	//amount to give?
// <"model">	"ammo"	 	<"integer amount">	//use a negative (STRING)
// <"model"> 	"nade"		<"integer amount">	//use a negative (STRING)
// <"model">   	"speed"		<float movementspeed>	//less than 1.00 to decrease
// <"model"> 	"zoom"		<integer zoom>		//more than 20 to decrease
// <"model">	"take"		<"string model">	//take weapon (give modelstring)
//
//==========================================================================================//
limited:

	level.AIR["limited_weapons"] = makeArray

	// Weapon model					// Limitation	//Limitation variable
	//"models/weapons/panzerschreck.tik" 		"ammo" 		"-2"
	//"models/weapons/mp40.tik" 			"take" 		"models/weapons/p38.tik"

	endArray
end


//==========================================================================================//
// BANNED
// -------
// Takes banned weapon immediately away! 
// This is a special version I made for my ranking system. Bazookas, Panzerschrecks and
// shotguns don't get taken away if the player is .zooka_worth = 1 or .shotty_worth = 1
//
// Bans:
// //Weaponmodel
// <"model">
//
//==========================================================================================//
banned:

	level.AIR["banned_weapons"] = makeArray

	// Weapon Name		// Weapon model
	//"models/weapons/bazooka.tik"
	//"models/weapons/panzerschreck.tik"
	//"models/weapons/shotgun.tik"

	endArray

end

```

# zz_ranking_final_modif\global\rank\kicknade.scr

```scr
/*
======================================================
*** AIRborne; Ranking System NadeKick for MoH:AA
======================================================
by Sorridstroker, modified by Sor
Version: v4.23 BETA
-----------------------------------

======================================================
*/
main:

	if(self.kick)
		end

	self.kick = 1
	local.origin = self.origin
	local.id = spawn trigger_use origin local.origin
	local.id glue self
	local.id setsize ( -50 -50 -50 ) ( 50 50 50 )
	local.id.nade = self
	local.id setthread KickNade

	while(self != NULL)
		waitframe
	if(local.id != NULL)
		local.id remove

end

KickNade:

	local.player = parm.other
	if (local.player.rankbonus["nades"] != 1 && level.running_ranking == 1)
		end

	self nottriggerable
	local.angles = angles_toforward local.player.angles
	self.nade.velocity = local.angles * 600 + ( 0 0 450 )
	local.player iprint "Good Kick!"
	if(self != NULL)
		self remove

end
	


```

# zz_ranking_final_modif\global\rank\ranking.scr

```scr
/*

Update : remove medic bonus 23/06/11

======================================================
*** AIRborne; Ranking System Main Script for MoH:AA
======================================================
by Sor
Version: v4.23 BETA
-----------------------------------
--- NOTE:

 Customization Options are in the global/rank/ranks.txt file
 You can set this option to 1 if like to enable 
 your chosen bonuses.
 
 level.ranking["bonus"] = 1

-------------------

======================================================
*/
main:

	if (level.running_ranking == 1)
		end

	level.running_ranking = 1
	// level.run_radar = 0
	// level.running_killstreaks_allies = 0
	// level.running_killstreaks_axis = 0
	
	waitthread setup_array

	if (level.stop_ranking != 1)
	{
		waitthread cache

		level waittill spawn 

		if (level.ranking["bonus"] == NIL)
			level.ranking["bonus"] = 1

		thread player_handler
		// thread kill_streaks
	}

end


//-----------------------------------
setup_array:

	println "[Ranking Sys::Array]: Adding entries to Array..."

	level.rank = waitexec global/rank/ranks.txt

	if (level.rank != NIL)
	{
		println "[Ranking Sys::Array]: ...COMPLETED"
	}
	else
	{
		level.stop_ranking = 1
		println "[Ranking Sys::Array]: A fatal error has occurred! Terminating system!"
	}

end

//-----------------------------------
player_handler:

	println "[Ranking Sys::MAIN]: Main player handler Active and Running!"
	level.message = 0
	// exec global/Radar/setup_maps.radar

	while($player.size > 0)
	{	
		for (local.a = 1; local.a <= $player.size; local.a++)
		{
			if ($player[local.a].dmteam != "spectator" && $player[local.a].status == "alive" && $player[local.a].rank != NIL)
			{
				//TEAM SWAP FIX
				for (local.i = 1; local.i <= level.rank.size; local.i++)
				{
					if ($player[local.a].dmteam == "allies" && $player[local.a].rank == level.rank[local.i][2] && level.rank[local.i][1] != level.rank[local.i][2])
					{
						$player[local.a].rank = level.rank[local.i][1]
						$player[local.a] waitthread hud_setup
						waitframe
					}
					else if ($player[local.a].dmteam == "axis" && $player[local.a].rank == level.rank[local.i][1] && level.rank[local.i][1] != level.rank[local.i][2])
					{
						$player[local.a].rank = level.rank[local.i][2]
						$player[local.a] waitthread hud_setup
						waitframe
					}
				}
				//Activate MAIN Rank Handler
				waitframe
				// $player[local.a] thread kill_streaks
				$player[local.a] waitthread rank_handler
			}
		}

		wait 0.4
	}

	//if there are 0 players
	//boot backup handler
	println "[Ranking Sys::MAIN]: No players on server; turning Main Player Handler off, switching to backup"
	thread backup_player_handler

end

//-----------------------------------
backup_player_handler:

	println "[Ranking Sys::Backup]: Backup Handler initiated."

	while ( $player.size == 0 || $player == NULL )
	{
		wait 1 //easing up loop
	}

	//boot the MAIN player handler back up
	println "[Ranking Sys::Backup]: Main Player Handler has rebooted!"
	thread player_handler
	// thread kill_streaks

end 


//-----------------------------------
rank_handler:

	if (self == NULL)
		end

	waitframe

	//MAIN PROMOTION AND DEMOTION HANDLER
	for (local.i = 2; local.i <= level.rank.size && self != NULL; local.i++) 
	{
		local.nr = 0

		//Check for traitors seperatly, because if 
		//someone with -2 kills gains 1 kill(= -1), he gets 
		//promotion drums and print, that wouldn't make sense
		
		// *** Modif Feho ***
		local.player_kills = self getkills // rcupre le nombre de kills du joueur
		
		if (local.player_kills < 0 && local.player_kills != self.prevrank && self != NULL)
		{
			if (self.dmteam == "allies")
			{
				self.rank = level.rank[1][1]
			}
			else if (self.dmteam == "axis")
			{
				self.rank = level.rank[1][2]
			}
			self.prevrank = local.player_kills
			self playsound demote

			self iprint "YOU HAVE BEEN DEMOTED - DO YOU HAVE NO DISCIPLINE?" 1
			self waitthread hud_setup
		}
		// Check for a new entitled rank
		// Also prevents continuous "promoting" and checking for the same rank 
		// Because the rank handler gets activated in a loop
		
		// *** Modif Feho ***
		if (local.i < level.rank.size && local.player_kills >= level.rank[local.i][3] && local.player_kills < level.rank[(local.i + 1)][3] && self.prevrank != local.i)
		{
			local.nr = 1
		}
		else if (local.i == level.rank.size && local.player_kills >= level.rank[local.i][3] && self.prevrank != local.i)
		{
			local.nr = 1
		}

		if (local.nr == 1 && self != NULL && self.prevrank != local.i)
		{
			//Give new allies Rank
			if (self.dmteam == "allies" && level.rank[local.i][1] != self.rank && self != NULL)
			{
				self.rank = level.rank[local.i][1] 
				self waitthread hud_setup
				if(self.prevrank != NIL) 
				{
					if ( local.i > self.prevrank )
					{
						self playsound promote
						self thread motion_display 1

						if (level.ranking["bonus"] == 1)
						{
							self waitthread bonus_handler
						}
					}
					else if ( local.i < self.prevrank )
					{
						self playsound demote
						self thread motion_display 0

						if (level.ranking["bonus"] == 1)
						{
							self waitthread bonus_handler
						}
					}
				}
				waitframe
				self.prevrank = local.i
			}
			//Give new axis Rank
			else if (self.dmteam == "axis" && level.rank[local.i][2] != self.rank && self != NULL)
			{
				self.rank = level.rank[local.i][2]
				self waitthread hud_setup
				if(self.prevrank != NIL) 
				{
					if ( local.i > self.prevrank )
					{
						self playsound promote
						self thread motion_display 1

						if (level.ranking["bonus"] == 1)
						{
							self waitthread bonus_handler
						}
					}
					else if ( local.i < self.prevrank )
					{
						self playsound demote
						self thread motion_display 0

						if (level.ranking["bonus"] == 1)
						{
							self waitthread bonus_handler
						}
					}
				}
				waitframe
				self.prevrank = local.i
			}
		}
	}

end

//-----------------------------------
hud_setup:

	self stufftext "globalwidgetcommand dday2 shader townhallwindow"
	self stufftext "globalwidgetcommand dday2 fgcolor 1.00 0.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday2 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand dday2 fadein 0"
	self stufftext "globalwidgetcommand dday2 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday2 virtualres 1"
	self stufftext "globalwidgetcommand dday2 fullscreen 1"

	self stufftext "globalwidgetcommand charliesector shader townhallwindow"
	self stufftext "globalwidgetcommand charliesector textalign left"
	self stufftext "globalwidgetcommand charliesector rect 700 5 392 64" // feho 100 525 392 64
	self stufftext "globalwidgetcommand charliesector fgcolor 1.00 3.00 4.00 6.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector font facfont-20"
	self stufftext ("set rank_cvar RANK: " + self.rank)

	if (level.ranking["bonus"] == 1)
	{
		local.l = ""	
		if (self.rankbonus["silencer"] == 1)
			local.l += "[Si]"
		if (self.rankbonus["nades"] == 1)
			local.l += "[KG]"
		if (self.rankbonus["zoom"] == 1)
			local.l += "[DZ]"
		if (self.rankbonus["mines"] == 1) // bonus mines
			local.l += "[Mi]"
		if (self.rankbonus["regenerate"] == 1)
			local.l += "[Re]"			
		if (self.rankbonus["speed"] == 1)
			local.l += "[Sp]"
		if (self.rankbonus["explosion"] == 1) // bonus explosion
			local.l += "[Exp]"
		if (self.rankbonus["health"] == 1) // bonus vie
			local.l += "[Hp]"
		if (self.rankbonus["bazooka"] == 1) // bonus bazooka
			local.l += "[Ba]"
		if (self.rankbonus["damage"] == 1) // bonus dommages
			local.l += "[Dmg]"

		if (local.l != "")
			self stufftext ("set bonus_cvar BONUS: " + local.l)
		else
			self stufftext ("set bonus_cvar BONUS: none")

    		self stufftext "globalwidgetcommand credits2 name credits1"
		self stufftext "globalwidgetcommand credits1 shader townhallwindow"
		self stufftext "globalwidgetcommand credits1 fgcolor 1.00 0.00 1.00 1.00"
		self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
		self stufftext "globalwidgetcommand credits1 fadein 0"
		self stufftext "globalwidgetcommand credits1 menu dday1 640 480 NONE 0"
		self stufftext "globalwidgetcommand credits1 virtualres 1"
		self stufftext "globalwidgetcommand credits1 fullscreen 1"
   		self stufftext "globalwidgetcommand credits1 name credits2"    

		self stufftext "globalwidgetcommand credits1 shader townhallwindow"
		self stufftext "globalwidgetcommand credits1 textalign left"
		self stufftext "globalwidgetcommand credits1 rect 700 25 392 64" // feho 100 545 392 64
		self stufftext "globalwidgetcommand credits1 fgcolor 1.00 3.00 4.00 6.00"
		self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
		self stufftext "globalwidgetcommand credits1 font facfont-20"

   		self stufftext "globalwidgetcommand credits1 linkcvar bonus_cvar"

		self stufftext "showmenu credits1"
	}

	self stufftext "globalwidgetcommand charliesector linkcvar rank_cvar"
	self stufftext "showmenu dday2"
   	
end

//-----------------------------------
bonus_handler local.de_pro:

	//let's not make it too difficult - bunch of ifs
	//check if player hasn't left the server yet
	if ( self != NIL && self != NULL )
	{
		for (local.i = 1; local.i <= level.rank.size; local.i++)
		{
			if (self.rank == level.rank[local.i][1] || self.rank == level.rank[local.i][2])
			{
				local.bonus = waitthread global/strings.scr::split_line level.rank[local.i][4] 1 " "
				for (local.o = 1; local.o <= local.bonus[1].size; local.o++)
				{
					local.t = local.bonus[1][local.o] 
					if (local.t == "zoom" || local.t == "silencer" || local.t == "nades" || local.t == "regenerate" || local.t == "speed" || local.t == "health" || local.t == "mines" || local.t == "damage" || local.t == "bazooka" || local.t == "explosion") // bonus vie, mines, dommages, bazooka, explosion
					{
						local.b = int(local.bonus[1][(local.o + 1)])
						if (self.rankbonus[local.t] != 1 && local.b == 1)
						{
							self thread display_bonus local.t
						}
						self.rankbonus[local.t] = local.b
					}
				}

				end
			}
		}
	}
end



//-----------------------------------
cadet:

	//give the newbie his rank
	if (self == NULL)
		end
		

	self.killcount = 0
	self.deathcount = 0

	if (self.dmteam == "allies")
	{
		self.rank = level.rank[2][1]
		self.prevrank = 2
	}
	if (self.dmteam == "axis")
	{
		self.rank = level.rank[2][2]
		self.prevrank = 2
	}


	waitframe
	self waitthread hud_setup

	wait 0.5
	self iprint "Welcome Cadet to this Ranked Server!" 1
	self iprint "Kill your way to glory or Kill yourself to shame!!!" 1

end


//-----------------------------------
cache:
	println "[Ranking Sys::SoundCache]: Soundcaching started..."

	local.master = spawn ScriptMaster
	local.master aliascache promote sound/items/Shell_DrumApply_01.wav soundparms 5.0 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train"
	local.master aliascache demote sound/items/Shell_DrumBack_01.wav soundparms 8.0 0.0 1.0 0.0 160 1600 auto loaded maps "m dm moh obj train"

	println "[Ranking Sys::SoundCache]: Soundcaching COMPLETED..."

end

_bonus_regenerate:

	local.origin = self.origin

	while (self.status == "alive" && self.rankbonus["regenerate"] == 1)
	{
		if ( (vector_within local.origin self.origin 10) == 1 && self.health < 200) // original self.health < 100
		{
			self healthonly (self.health + 10) // original +1
		}
	
		local.origin = self.origin
		
		local.time = 1.0
		while(local.time > 0)
		{
			if (self.status != "alive" || self.rankbonus["regenerate"] != 1)
			{
				end
			}
			local.time -= 0.1
			wait 0.1
		}
		wait 0.1
	}

end

_bonus_health: // bonus vie

	self.health += 100
	// exec global/health.scr
	
end

_bonus_silencer:

	self give "models/weapons/silencedpistol.tik"
	self ammo pistol 16

end

_bonus_bazooka:

	self give "models/weapons/bazooka.tik"
	
end

_bonus_speed:

	self weaponcommand dual dmmovementspeed 1.20

end

_bonus_damage: // bonus dommages

	weaponcommand dual dmbulletdamage 120
	
end

display_bonus local.bonus:

	if (local.bonus == "nades")
	{
		local.l = "Bonus: Kick Grenades (press use)"
	}
	else if (local.bonus == "zoom")
	{
		local.l = "Bonus: Double Zoom (sniper only)"
	}
	else if (local.bonus == "silencer")
	{
		local.l = "Bonus: Silenced pistol (each spawn)"
		self thread _bonus_silencer
	}
	else if (local.bonus == "speed")
	{
		local.l = "Bonus: Increased Movement Speed"
		self thread _bonus_speed
	}
	else if (local.bonus == "regenerate")
	{
		local.l = "Bonus: Regeneration (when standing still)"
		waitframe
		self thread _bonus_regenerate
	}
	else if (local.bonus == "health") // bonus vie
	{
		local.l = "Bonus: Increased health (+100 HP)"
		self thread _bonus_health
	}
	else if (local.bonus == "mines") // bonus mines
	{
		local.l = "Bonus: 2 Proximity mines (Hold [USE] down for 3 seconds)"
	}
	else if (local.bonus == "damage") // bonus dommages
	{
		local.l = "Bonus: Increased Bullet Damage"
		self thread _bonus_damage
	}
	else if (local.bonus == "bazooka") // bonus bazooka
	{
		local.l = "Bonus: Bazooka (each spawn)"
		self thread _bonus_bazooka
	}
	else if (local.bonus == "explosion") // bonus explosion
	{
		local.l = "Bonus: More powerful grenades"
	}
	
    	self stufftext "globalwidgetcommand credits2 name credits1"
	self stufftext "globalwidgetcommand credits1 shader townhallwindow"
	self stufftext "globalwidgetcommand credits1 fgcolor 1.00 0.00 1.00 1.00"
	self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 fadein 0"
	self stufftext "globalwidgetcommand credits1 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand credits1 virtualres 1"
	self stufftext "globalwidgetcommand credits1 fullscreen 1"
   	self stufftext "globalwidgetcommand credits1 name credits2"    

	self stufftext "globalwidgetcommand credits1 shader townhallwindow"
	self stufftext "globalwidgetcommand credits1 rect 280 70 596 354" // feho 280 30 596...
	self stufftext "globalwidgetcommand credits1 fgcolor 1.00 3.00 4.00 6.00"
	self stufftext "globalwidgetcommand credits1 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand credits1 font handle-23"

	self stufftext ("set bonus_cvar " + local.l)
	self stufftext "globalwidgetcommand credits1 linkcvar rank_cvar

	self stufftext "showmenu credits1"

	wait 10

	self waitthread hud_setup

end

motion_display local.m:

	self stufftext "globalwidgetcommand dday2 shader townhallwindow"
	self stufftext "globalwidgetcommand dday2 fgcolor 1.00 0.00 1.00 1.00"
	self stufftext "globalwidgetcommand dday2 bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand dday2 fadein 0"
	self stufftext "globalwidgetcommand dday2 menu dday1 640 480 NONE 0"
	self stufftext "globalwidgetcommand dday2 virtualres 1"
	self stufftext "globalwidgetcommand dday2 fullscreen 1"

	self stufftext "globalwidgetcommand charliesector shader townhallwindow"
	self stufftext "globalwidgetcommand charliesector rect 280 30 596 354" // feho 280 0 596...
	self stufftext "globalwidgetcommand charliesector fgcolor 1.00 3.00 4.00 6.00"
	self stufftext "globalwidgetcommand charliesector bgcolor 0.00 0.00 0.00 0.00"
	self stufftext "globalwidgetcommand charliesector font handle-23"

	if (local.m == 1) {
		self stufftext ("set rank_cvar Promoted: " + self.rank)
		
		// Player announce his rank to other players
		if (self.rank == "Captain" || self.rank == "Hauptmann") {
			if (self.dmteam == "axis") {
				self stufftext "sayteam I'm now Hauptmann, I can plant proximity mines !"
			}
			else {
				self stufftext "sayteam I'm now Captain, I can plant proximity mines !"
			}
		}		
		
		if (self.rank == "Brigadier General" || self.rank == "Brigadegeneral") {		
				self stufftext "say I run faster, catch me if you can !"
		}
		
		if (self.rank == "Lieutenant General" || self.rank == "Generalleutnant") {
			if (self.dmteam == "axis") {
				self stufftext "say I'm now Generalleutnant, my health was increased !"
			}
			else {
				self stufftext "say I'm now Lieutenant General, my health was increased !"
			}
		}
		
		if (self.rank == "General-of-the-Army" || self.rank == "Generalfeldmarschall") {
			if (self.dmteam == "axis") {
				self stufftext "say I'm now Generalleutnant, kill me if you can !"
			}
			else {
				self stufftext "say I'm now General-of-the-Army, kill me if you can !"
			}
		}
	}		
		
	else {
		self stufftext ("set rank_cvar Demoted: " + self.rank)
	}

	self stufftext "showmenu dday2"
	
	wait 10

	self waitthread hud_setup

end

kill_streaks:
	println "kill-streaks Active and Running!"
	// iprintln "On est dans kill_streaks"
	while($player.size > 0)
	{
		for (local.a = 1; local.a <= $player.size; local.a++)
		{
			// $player[local.a] iprint "on va entrer dans test"
			$player[local.a] waitthread test
		}
		wait 0.4
	}
	
end
	

test:
	// iprintln "On est dans test"
	local.player_name = netname self
	local.player_kills = self getkills
	// local.player_deaths = self getdeaths
	// local.player_deaths_now = self getdeaths
	local.stop = 0
	local.stop2 = 0
	
	while (isAlive self)
	{
		// if (self == NULL || self == NIL) { end }
		
		// local.player_deaths_now = self getdeaths
		//if (local.player_deaths != local.player_deaths_now) {end}
		
		local.player_kills_now = self getkills
		local.player_killstreaks = local.player_kills_now - local.player_kills
		if (local.player_killstreaks == 3 && local.stop != 1)
		{
			iprintln ("3 killstreaks for " + local.player_name)
			local.stop = 1
		}
		if (local.player_killstreaks == 5 && local.stop2 != 1)
		{
			iprintln (local.player_name + " is on a Killing-Spree !")
			level.run_radar = 0
			// thread radar self.dmteam
			local.stop2 = 1
		}
		wait .04
	}
end
	
radar local.team:
	
	if (local.team == "allies") {
		// Turn Allies radar on for 30 sec
		for (local.i=1 ; local.i<=30 ; local.i++) {
		
			level.running_killstreaks_allies = 1
			
			if (level.run_radar == 1) {
				iprintln "entre dans if run radar"
				level.run_radar = 0
			}
			
			wait 1
		}
		level.running_killstreaks_allies = 0
	}
	else {
		// Turn Axis radar on for 30 sec
		for (local.i=1 ; local.i<=30 ; local.i++) {
			level.running_killstreaks_axis = 1
			
			if (level.run_radar == 1) {
				level.run_radar = 0
			}
			
			wait 1
		}
		level.running_killstreaks_axis = 0
	}
	
end
		
	
	
```

# zz_ranking_final_modif\global\rank\ranks.txt

```txt
/*
======================================================
*** AIRborne; Ranking System Customization for MoH:AA
======================================================
by Sor
Version: v4.23 BETA
-----------------------------------
--- NOTE:

 Customization Options for the Airborne ranking script.
 Here you can customize the following things:
  - the names for each rank (for both teams)
  - add new ranks
  - remove ranks
  - change the required kills for each rank
  - define the bonuses for each rank. Available bonuses:
    
	* "silencer"	- Get Silencer
	* "nades"	- Ability to kick nades
	* "zoom"	- Double Zoom for Snipers
        * "speed"	- Increased movement speed
	* "regenerate"	- You gain health slowly while standing still

  A few IMPORTANT REMARKS:
   1. Do not remove the Traitor rank! You may rename it.
   2. Do not enter a kill requirement for the Traitor rank!
   3. For every rank, if you are going to use bonuses, then all
      the bonuses must be defined (!) in the following layout:

      "bonus1 value ; bonus2 value ; bonus3 value ; bonus4 value"


-------------------

======================================================

Original :


	//Rankname - Allies		//Rankname - Axis		//kills needed		//Bonuses

	"Traitor"			"Verraeter"						"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0"    
	"Army Cadet"			"Cadet"				0			"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0"  
	"Private"			"Schuetze"			1			"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0"   
	"Private-First-Class"		"Oberschuetze"			2			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0"   
	"Corporal"			"Gefreiter"			4			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0"   
	"Sergeant"			"Unteroffizier"			6			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0"  
	"Staff Sergeant"		"Stabsunteroffizier"		8			"speed 0 ; zoom 0 ; nades 1 ; silencer 1 ; regenerate 0"
	"Sergeant-First-Class"		"Feldwebel"			10			"speed 0 ; zoom 0 ; nades 1 ; silencer 1 ; regenerate 0"
	"2nd Lieutenant"		"Leutnant"			14			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"1st Lieutenant"		"Oberleutnant"			18			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"Captain"			"Hauptmann"			21			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"Major"				"Major"				25			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"Lieutenant Colonel" 		"Oberstleutnant"		30			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0"
	"Colonel"			"Oberst"			35			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"Brigadier General" 		"Brigadegeneral"		40			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"Major General" 		"Generalmajor"			45			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"Lieutenant General" 		"Generalleutnant"		50			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"General"			"General"			60			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"
	"General-of-the-Army"		"Generalfeldmarschall"		70			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1"

*/

/*
main:

	local.ranks = makeArray

	//Rankname - Allies		//Rankname - Axis		//kills needed		//Bonuses

	"Traitor"			"Verraeter"						"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"    
	"Army Cadet"			"Cadet"				0			"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"  
	"Private"			"Schuetze"			1			"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"   
	"Private-First-Class"		"Oberschuetze"			2			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"   
	"Corporal"			"Gefreiter"			4			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"   
	"Sergeant"			"Unteroffizier"			5			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"  
	"Staff Sergeant"		"Stabsunteroffizier"		6			"speed 0 ; zoom 0 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"
	"Sergeant-First-Class"		"Feldwebel"			8			"speed 0 ; zoom 0 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"
	"2nd Lieutenant"		"Leutnant"			10			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"
	"1st Lieutenant"		"Oberleutnant"			12			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"
	"Captain"			"Hauptmann"			15			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Major"				"Major"				18			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Lieutenant Colonel" 		"Oberstleutnant"		20			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Colonel"			"Oberst"			25			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Brigadier General" 		"Brigadegeneral"		30			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Major General" 		"Generalmajor"			35			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 1"
	"Lieutenant General" 		"Generalleutnant"		40			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 1 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 1"
	"General"			"General"			50			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 1 ; damage 0 ; mines 1 ; bazooka 1 ; explosion 1"
	"General-of-the-Army"		"Generalfeldmarschall"		60			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 1 ; damage 1 ; mines 1 ; bazooka 1 ; explosion 1"

	endArray

end local.ranks
*/

main:

	local.ranks = makeArray

	//Rankname - Allies		//Rankname - Axis		//kills needed		//Bonuses

	"Traitor"			"Verraeter"						"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"    
	"Army Cadet"			"Cadet"				0			"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"  
	"Private"			"Schuetze"			1			"speed 0 ; zoom 0 ; nades 0 ; silencer 0 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"   
	"Private-First-Class"		"Oberschuetze"			2			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"   
	"Corporal"			"Gefreiter"			4			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"   
	"Sergeant"			"Unteroffizier"			6			"speed 0 ; zoom 0 ; nades 0 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"  
	"Staff Sergeant"		"Stabsunteroffizier"		8			"speed 0 ; zoom 0 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"
	"Sergeant-First-Class"		"Feldwebel"			10			"speed 0 ; zoom 0 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"
	"2nd Lieutenant"		"Leutnant"			12			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"
	"1st Lieutenant"		"Oberleutnant"			14			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 0 ; bazooka 0 ; explosion 0"
	"Captain"			"Hauptmann"			16			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Major"				"Major"				18			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Lieutenant Colonel" 		"Oberstleutnant"		20			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 0 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Colonel"			"Oberst"			22			"speed 0 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Brigadier General" 		"Brigadegeneral"		25			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 0"
	"Major General" 		"Generalmajor"			30			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 0 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 1"
	"Lieutenant General" 		"Generalleutnant"		35			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 1 ; damage 0 ; mines 1 ; bazooka 0 ; explosion 1"
	"General"			"General"			40			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 1 ; damage 0 ; mines 1 ; bazooka 1 ; explosion 1"
	"General-of-the-Army"		"Generalfeldmarschall"		50			"speed 1 ; zoom 1 ; nades 1 ; silencer 1 ; regenerate 1 ; health 1 ; damage 1 ; mines 1 ; bazooka 1 ; explosion 1"

	endArray

end local.ranks
```

# zz_ranking_final_modif\global\readme.txt

```txt
Ajouts bonus :

- health (+100 hp)
- damage (plus de dgats par balle)
- mines
- bazooka


// Bonus	// kills

silencer	2
nades		8
zoom		12	
mines		16	
regenerate	22
speed		25
explosion	30
health		35
bazooka		40
damage		50

```

# zz_ranking_final_modif\global\states\get_weapon.scr

```scr
/*
======================================================
*** AIRborne; Weapon Handler StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------
--- INFO:

1) WEAPONNAME: <player_alias>.current_weapon

 "StG44"			"UNARMED"			"BAR"	
 "MP40"			"Binoculars"		"Thompson SMG"
 "Panzerschreck"		"Shotgun"			"Bazooka"
 "Mauser KAR98 Rifle"					"M1 Garand"
 "KAR98 Sniper Rifle"					"Springfield '03 Sniper"
 "Walther P38"		"Silenced Pistol"		"Colt 45"
 "Stielhandgranate"					"Frag Grenade"

2) WEAPONCLASS: <player_alias>.current_weaponclass

 pistol			grenade
 mg				shotgun
 smg				none
 rifle			heavy

3) WEAPONMODEL: <player_alias>.current_weapon_model

 The string returned, contains the full weaponpath (with "models/")

-------------------

======================================================
*/

main local.name local.model local.class:

	if (self != NULL)
	{
		if (self.getweap != 1)
		{
			self.getweap = 1
			self.current_weapon = local.name
			self.current_weaponclass = local.class
			self.current_weapon_model = local.model

			if (self.rankbonus["speed"] == 1 && level.running_ranking == 1 && self.speed_bonus[local.model] != 1 )
			{
				self weaponcommand dual dmmovementspeed 1.20
				self.speed_bonus[local.model] = 1
			}

			if (self.rankbonus["damage"] == 1 && level.running_ranking == 1 && self.damage_bonus[local.model] != 1 ) // bonus dommages
			{
				if (local.name == "Thompson SMG") {
					self weaponcommand dual dmbulletdamage 111
				}
				else if (local.name == "BAR") {
					self weaponcommand dual dmbulletdamage 124
				}
				else if (local.name == "Colt 45") {
					self weaponcommand dual dmbulletdamage 98
				}
				else if (local.name == "Mauser KAR98 Rifle") {
					self weaponcommand dual dmbulletdamage 138
				}
				else if (local.name == "KAR98 Sniper Rifle") {
					self weaponcommand dual dmbulletdamage 138
				}
				else if (local.name == "M1 Garand") {
					self weaponcommand dual dmbulletdamage 135
				}
				else if (local.name == "MP40") {
					self weaponcommand dual dmbulletdamage 89
				}
				else if (local.name == "StG44") {
					self weaponcommand dual dmbulletdamage 98
				}
				else if (local.name == "Walther P38") {
					self weaponcommand dual dmbulletdamage 78
				}
				else if (local.name == "Shotgun") {
					self weaponcommand dual dmbulletdamage 20
				}
				else if (local.name == "Silenced Pistol") {
					self weaponcommand dual dmbulletdamage 78
				}
				else if (local.name == "Springfield '03 Sniper") {
					self weaponcommand dual dmbulletdamage 138
				}
				
				self.damage_bonus[local.model] = 1
			}
			
			waitframe
			local.weapon_limiter = level.AIR["weapon_limiter"]
			if (local.weapon_limiter == 1)
			{
				self waitexec global/states/weapon_limiter.scr::check local.model
			}
		
			wait 0.3
			self.getweap = 0
		}

	}
end
```

# zz_ranking_final_modif\global\states\joined_allies.scr

```scr
/*
======================================================
*** AIRborne; Joined-Allies StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
joined_allies:

	println "Client ID " self.entnum " has joined the allies!"

	// Reset state-info records
	self.usingScope = NIL
	self.usingTurret = NIL
	self.secondary_Fireheld = NIL

	// Weapon Limiter
	self.already_limited = NIL 
	self.already_bonus = NIL

	// Speed Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.speed_bonus = NIL
	}
	
	// Damage Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.damage_bonus = NIL
	}

	wait 1

	if (self.status != "alive")
	{
		println "bugged"
		self exec global/states/player_spawn.scr "spawned"
	}

end
```

# zz_ranking_final_modif\global\states\joined_axis.scr

```scr
/*
======================================================
*** AIRborne; Joined-Axis StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
joined_axis:

	println "Client ID " self.entnum " has joined the axis!"

	// Reset state-info records
	self.usingScope = NIL
	self.usingTurret = NIL
	self.secondary_Fireheld = NIL

	// Weapon Limiter
	self.already_limited = NIL 
	self.already_bonus = NIL

	// Speed Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.speed_bonus = NIL
	}
	
	// Damage Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.damage_bonus = NIL
	}

	wait 1

	if (self.status != "alive")
	{
		println "bugged"
		self exec global/states/player_spawn.scr "spawned"
	}


end
```

# zz_ranking_final_modif\global\states\joined_spec.scr

```scr
/*
======================================================
*** AIRborne; Joined-Spectator StateScript for MoH:AA
======================================================
by Sor
Version: v1.3
-----------------------------------

======================================================
*/
joined_spec:

	println "Client ID " self.entnum " has become a spectator"

	// To prevent 'trigger-collisions'
	if (self.detect)
		self.detect delete

	// Reset state-info records
	self.usingScope = NIL
	self.usingTurret = NIL
	self.secondary_Fireheld = NIL

	// Weapon Limiter
	self.already_limited = NIL 
	self.already_bonus = NIL

	// Speed Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.speed_bonus = NIL
	}
	
	// Damage Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.damage_bonus = NIL
	}
	
end
```

# zz_ranking_final_modif\global\states\just_left.scr

```scr
/*
======================================================
*** AIRborne; Left-Server StateScript for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/
left local.num:

	println "Client ID " local.num " has left the server!"

end
```

# zz_ranking_final_modif\global\states\just_spawned.scr

```scr
/*
======================================================
*** AIRborne; Spawned StateScript for MoH:AA
======================================================
by Sor
Version: v1.0
-----------------------------------

======================================================
*/
spawned:

	println "Client ID " self.entnum " has just spawned!"

	if (self.rank == NIL && level.running_ranking == 1)
	{
		self waitthread global/rank/ranking.scr::cadet
	}

	if (self.rankbonus["silencer"] == 1 && level.running_ranking == 1)
	{
		self thread global/rank/ranking.scr::_bonus_silencer
	}
	if (self.rankbonus["regenerate"] == 1 && level.running_ranking == 1)
	{
		self thread global/rank/ranking.scr::_bonus_regenerate
	}
	if (self.rankbonus["health"] == 1 && level.running_ranking == 1) // bonus vie
	{
		self thread global/rank/ranking.scr::_bonus_health
	}
	if (self.rankbonus["bazooka"] == 1 && level.running_ranking == 1)
	{
		self thread global/rank/ranking.scr::_bonus_bazooka
	}
	
	self item items/binoculars.tik

end
```

# zz_ranking_final_modif\global\states\new_player.scr

```scr
/*
======================================================
*** AIRborne; Entered-Server StateScript for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/

new_player:

	println "Client ID " self.entnum " has just entered the server."

end
```

# zz_ranking_final_modif\global\states\player_died.scr

```scr
/*
======================================================
*** AIRborne; Player-Died StateScript for MoH:AA
======================================================
by Sor
Version: v1.1
-----------------------------------

======================================================
*/
died:

	println "Client ID " self.entnum " died."

	// Reset state-info records
	self.usingScope = NIL
	self.usingTurret = NIL
	self.secondary_Fireheld = NIL

	// Weapon Limiter
	self.already_limited = NIL 
	self.already_bonus = NIL	

	// Speed Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.speed_bonus = NIL
	}
	
	// Damage Bonus
	if (level.running_ranking == 1 && level.ranking["bonus"] == 1)
	{
		self.damage_bonus = NIL
	}

end
```

# zz_ranking_final_modif\global\states\player_info.scr

```scr
/*
======================================================
*** AIRborne; Player Info StateScript for MoH:AA
======================================================
by Sor
Version: v0.9
-----------------------------------
--- INFO:

 <player_alias>.secondary_Fireheld
 <player_alias>.usingTurret 

-------------------

======================================================
*/
main local.setting local.extra_setting local.more_settings:

	if (self == NULL)
		end

	switch(local.setting)
	{
		// TURRET:
		// (1) Player is using an turret 
		// (0) Player stopped using a turret 
		// (NIL) Player hasn't used a turret yet
		// <player_alias>.usingTurret 

		case "turret_on":
			if (self.usingTurret != 1)
			{
				self.usingTurret = 1
			}
		break
		case "turret_off":
			if (self.usingTurret != 0 && self.usingTurret != NIL)
			{
				self.usingTurret = 0
			}
		break

		// SECONDARY FIREHELD
		// (0/NIL) Player isn't holding the Right Mouse Button (= Secondary Fireheld)
		// (1) Player is holding the Right Mouse Button (= Secondary Fireheld)
		// <player_alias>.secondary_Fireheld

		case "rmb_on":
			if (self.secondary_Fireheld != 1)
			{
				self.secondary_Fireheld = 1
			}
		break
		case "rmb_off":
			if (self.secondary_Fireheld != 0 && self.secondary_Fireheld != NIL)
			{
				self.secondary_Fireheld = 0
			}
		break
	}

end
```

# zz_ranking_final_modif\global\states\player_spawn.scr

```scr
/*
======================================================
*** AIRborne; Player Handler StateScript for MoH:AA
======================================================
by Sor
Version: v1.4
-----------------------------------
--- INFO:

 STATUS: <player_alias>.status 
  "alive"
  "killed"
  "spectator"
  "entered_server"

 JUST SPAWNED: <player_alias>.jspawned
  This variable gets set to 1 when the player has just spawned and
  back to 0 after max 5 seconds!

 KILLCOUNT: <player_alias>.killcount
 DEATHCOUNT: <player_alias>.deathcount

-------------------

======================================================
*/
main local.dead_or_alive:

	if (self != NULL)
	{
		if (isAlive self && self.status != "alive" && local.dead_or_alive == "spawned" && self.dmteam != "spectator")
		{
			//self exec global/fix/anti_fps.scr
			self.status = "alive"
			self.jspawned = 1

			self thread follow_player
			if (level.running_ranking == 1)
			{
				waitframe
				if (self.detect)
				{
					self.detect remove
				}

				self thread setup_kill
			}
		}
		else if (self.status != "killed" && local.dead_or_alive == "killed") //&& !(Isalive self))
		{
			self.status = "killed"
			//just in case
			self.jspawned = 0

			// wait till the states have reported if the player has cratered
			waitframe
			if (self.has_cratered == 1)
			{
				if (self.killcount == NIL)
					self.killcount = 0

				self.killcount--
				self.has_cratered = NIL
			}
				
		}
		else if (local.dead_or_alive == "cratered")
		{
			self.has_cratered = 1
		}
		else if (self.status == NIL && self.dmteam == "spectator" && local.dead_or_alive == NIL)
		{
			self.status = "entered_server"
			self exec global/states/new_player.scr
		}
		// Buggy Spawn...
		else if (self.status == NIL || self.status != "alive" && isAlive self)
		{
			wait 1
			self exec global/states/player_spawn.scr "spawned"
			end
		}
	}

end

//-----------------------------------
follow_player:

	if (self.followed == 1)
		end
	else
		self.followed = 1

	local.time = 0
	local.team = self.dmteam
	local.num = self.entnum


	// *****************************************************
	self exec global/states/just_spawned.scr

	while ( self && self.health >= 96 && local.time <= 5.00 && self.status != "killed" && self.dmteam == local.team )
	{
		waitframe
		local.time += 0.05
	}
	// *****************************************************

	// ...Left the server
	if (self == NULL || self == NIL)
	{
		exec global/states/just_left.scr local.num
		end
	}	
	else
	{
		self.followed = NIL
		self.jspawned = 0

		//...or Joined the spectators
		if (self.dmteam != local.team && self.dmteam == "spectator")
		{
			self.status = "joined_spectator"
			self exec global/states/joined_spec.scr
			end
		}
		//...or Joined the Axis
		else if (self.dmteam != local.team && self.dmteam == "axis")
		{
			self.status = "joined_axis"
			self exec global/states/joined_axis.scr
			end
		}
		//...or Joined the Allies
		else if (self.dmteam != local.team && self.dmteam == "allies")		
		{
			self.status = "joined_allies"
			self exec global/states/joined_allies.scr
			end
		}
		else if !(isAlive self)
		{
			self exec global/states/player_died.scr
			end
		}	
	}

	// *******************************************************************************************
	while ( self && self.status != "killed" && self.dmteam == local.team && isAlive self )
	{
		waitframe
	}
	// *******************************************************************************************

	//... left the server
	if (self == NULL || self == NIL)
	{
		exec global/states/just_left.scr local.num
		end
	}
	else if (self.dmteam != local.team)
	{
		self.followed = NIL

		if(self.dmteam == "spectator")
		{
			self.status = "joined_spectator"
			self exec global/states/joined_spec.scr
			end
		}
		else if (self.dmteam == "axis")
		{
			self.status = "joined_axis"
			self exec global/states/joined_axis.scr
			end
		}
		else if (self.dmteam == "allies")		
		{
			self.status = "joined_allies"
			self exec global/states/joined_allies.scr
			end
		}
	}
	else if !(isAlive self)
	{
		self.followed = NIL
		self exec global/states/player_died.scr
		end
	}

end

//-----------------------------------
setup_kill:

	if(self.detect != NIL && self.detect != NULL)
	{
		self.detect remove
	}

	self.detect = spawn trigger_multipleall "spawnflags" "128"
	self.detect.origin = self.origin
	self.detect.angle = self.angle
	self.detect glue self
	self.detect.player = self
	self.detect.team = self.dmteam
	self.detect.alive = 1
	self.detect.attacker = NIL
	self.detect setsize ( -17 -17 0 ) ( 17 17 72 )
	self.detect solid

	self.detect thread correct_detect

	while(1)
	{
		self.detect waittill trigger
		local.murderer = parm.other
		waitframe

		//check if player is still on the server or on the same team
		if (self == NIL || self == NULL || level.running_ranking != 1)
		{
			self.detect remove
			end
		}
		
		// if (self.detect != NULL || self.detect != NIL) {
			// self.detect waittill trigger
			// waitframe
		// }
		// local.murderer = parm.other

		// Bleeding *** Feho ***
		if (self.health <= 20)
		{			
			local.victim = self
			local.victim.bleeding = 1
			local.oldteam = local.victim.dmteam

			while(local.victim.health <= 20 && local.victim.health != 0 && local.victim.dmteam == local.oldteam)
            {
				if (self == NULL || self == NIL) {
					end
				}
				local.victim damage local.murderer 1 local.murderer (0 0 0) (0 0 0) (0 0 0) 0 1 0 -1
				local.victim iprint "***You are bleeding, find a healthpack or a medic***"
				wait 3	
            }
			local.victim.bleeding = 0
		}
			
		//MAIN KILL-HANDLER
		if ( isAlive self != 1 && self.detect.alive == 1 && self.dmteam != "spectator" )
		{	
			self.detect nottriggerable
			self.detect.alive = 0
			self.detect.attacker = local.murderer
			waitframe
		
			//benzin barrel
			if (local.murderer == NULL) 
			{
				if (self.deathcount == NIL)
					self.deathcount = 0
			
				self.deathcount++
				end
			}
			//committed suicide
			if ( local.murderer == self)
			{
				if ( local.murderer.killcount == NIL )
				{
					local.murderer.killcount = 0
					local.murderer.killcount--
				}
				else if ( local.murderer.killcount != NIL )
				{
					local.murderer.killcount--
				}
			}
			else if (local.murderer.dmteam == self.dmteam && (getcvar "g_gametype") != "1")
			{
				if ( local.murderer.killcount == NIL )
				{
					local.murderer.killcount = 0
					local.murderer.killcount--
				}
				else if ( local.murderer.killcount != NIL )
				{
					local.murderer.killcount--
				}
			}
			//no traitor
			else 
			{
				if ( local.murderer.killcount == NIL )
				{
					local.murderer.killcount = 0
					local.murderer.killcount++
					
					if (self.rank == "General-of-the-Army" || self.rank == "Generalfeldmarschall") {
						local.nbKillsMurderer = local.murderer getkills
						if (local.nbKillsMurderer >= 0 && local.nbKillsMurderer < 35) {
							local.murderer iprint "You killed a General of the Army (+2 kills)"
							local.murderer addkills 2
						}
						else if (local.nbKillsMurderer >= 35 && local.nbKillsMurderer < 50) {
							local.murderer iprint "You killed a General of the Army (+1 kill)"
							local.murderer addkills 1
						}
					}
				}
				else if ( local.murderer.killcount != NIL )
				{
					local.murderer.killcount++
					
					if (self.rank == "General-of-the-Army" || self.rank == "Generalfeldmarschall") {
						local.nbKillsMurderer = local.murderer getkills
						if (local.nbKillsMurderer >= 0 && local.nbKillsMurderer < 35) {
							local.murderer iprint "You killed a General of the Army (+2 kills)"
							local.murderer addkills 2
						}
						else if (local.nbKillsMurderer >= 35 && local.nbKillsMurderer < 50) {
							local.murderer iprint "You killed a General of the Army (+1 kill)"
							local.murderer addkills 1
						}
					}
				}
			}

			if (self.deathcount == NIL)
				self.deathcount = 0

			self.deathcount++
			self.detect immediateremove
			end
		}
	}
end

correct_detect:

	while(self && self.player)
	{
		if ( (self.player getposition)[0] == "c" && local.last_pos != 1)
		{
			local.last_pos = 1
			self setsize ( -17 -17 0 ) ( 17 17 42 )
		}
		else if ( (self.player getposition)[0] != "c" && local.last_pos == 1)
		{
			local.last_pos = 0
			self setsize ( -17 -17 0 ) ( 17 17 72 )
		}

		wait 0.2
	}
end
```

# zz_ranking_final_modif\global\states\scopes.scr

```scr
/*
======================================================
*** AIRborne; Scopes StateScript for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/
main:

	if (self != NULL)
	{
		if (self.usingScope != 1 && self.rankbonus["zoom"] != 1)
		{
			self.usingScope = 1
			end
		}
		else if (self.usingScope == 1 && self.rankbonus["zoom"] != 1)
		{
			self.usingScope = 0
			end
		}
		
		if (self.usingScope == NIL || self.usingScope == 0 && self.rankbonus["zoom"] == 1)
		{
			self.usingScope = 1

			self weaponcommand mainhand zoom 10 //15
		
		}
		else if (self.usingScope == 1 && self.rankbonus["zoom"] == 1)
		{
			self.usingScope = 2
		}
		else
		{
			self weaponcommand mainhand zoom 20
			self.usingScope = 0
		}
	}

end
```

# zz_ranking_final_modif\global\states\weapon_limiter.scr

```scr
/*
======================================================
*** AIRborne; Weapon Limiter Script for MoH:AA
======================================================
by Sor
Version: v1.2
-----------------------------------

======================================================
*/

//----------------------------------------------
check local.model:
//----------------------------------------------

	if (level.AIR["banned_weapons"] == NIL)
	{
		waitthread global/limits.txt::banned
		//waitframe
	}

	if (level.AIR["limited_weapons"] == NIL)
	{
		waitthread global/limits.txt::limited
		//waitframe
	}

	if (level.AIR["bonus_weapons"] == NIL)
	{
		waitthread global/limits.txt::bonuses
		//waitframe
	}

	// Is it banned?
	for (local.i = 1; local.i <= level.AIR["banned_weapons"].size; local.i++)
	{
		if (local.model == level.AIR["banned_weapons"][local.i][1])
		{
			self thread invalid local.model
			//self take local.model
			end
		}
	}

	// Limited?
	for (local.i = 1; local.i <= level.AIR["limited_weapons"].size; local.i++)
	{
		if (local.model == level.AIR["limited_weapons"][local.i][1])
		{
			local.var = int (level.AIR["limited_weapons"][local.i][3])
			local.limitation = (level.AIR["limited_weapons"][local.i][2]::local.var)
			self waitthread apply_limit local.limitation local.model
			end 
		}
	}

	// Or does it gain a bonus?
	for (local.i = 1; local.i <= level.AIR["bonus_weapons"].size; local.i++)
	{
		if (local.model == level.AIR["bonus_weapons"][local.i][1])
		{
			local.bonus = (level.AIR["bonus_weapons"][local.i][2]::level.AIR["bonus_weapons"][local.i][3])
			self waitthread apply_bonus local.bonus local.model
			end 
		}
	}

end


//----------------------------------------------
invalid local.model:
//----------------------------------------------

	self take local.model

end 

//----------------------------------------------
apply_limit local.limited_weapon local.model:
//----------------------------------------------

	if (local.limited_weapon != NIL && self.already_limited[local.model] != 1)
	{
		switch(local.limited_weapon[1])
		{
			case "ammo":
				local.ammo = local.limited_weapon[2]
				self ammo self.current_weaponclass local.ammo
			break
			case "nade":
				local.nades = local.limited_weapon[2] 
				self ammo grenade	local.nades
			break
			case "speed":
				local.newspeed = local.limited_weapon[2]
				self weaponcommand dual dmmovementspeed local.newspeed
			break
			case "zoom":
				local.newzoom = local.limited_weapon[2]
				self weaponcommand dual zoom local.newzoom
				//self weaponcommand dual dmzoom local.newzoom
			break
			case "take":
				local.take_weapon = local.limited_weapon[2]
				self take local.take_weapon 
			break
		}

		self.already_limited[local.model] = 1
	}

end

//----------------------------------------------
apply_bonus local.bonus local.model:
//----------------------------------------------

	if (local.bonus != NIL && self.already_bonus[local.model] != 1)
	{
		switch(local.bonus[1])
		{
			case "ammo":
				local.class = self.current_weaponclass
				local.ammo = local.bonus[2]
				self ammo local.class local.ammo
			break
			case "nade":
				local.nades = local.bonus[2]
				self ammo grenade	local.nades
			break
			case "speed":
				local.newspeed = local.bonus[2]
				self weaponcommand dual dmmovementspeed local.newspeed
			break
			case "zoom":
				local.newzoom = local.bonus[2]
				self weaponcommand dual zoom local.newzoom
				//self weaponcommand dual dmzoom local.newzoom
			break
		}
		
		self.already_bonus[local.model] = 1
	}

end
```

# zz_ranking_final_modif\global\strings.scr

```scr
// ------------------------------------------------------
// String Handler; by Elgan
// ------------------------------------------------------
//
// 11 September 2005 added 3 new functions
// array_to_int
// array_to_str
// array_to_float
//
/*
INDEX:
------
Array_to_lower
Array_to_upper
to_lower
to_upper
InStr
Right
left
Mid
Reverse
split_line
Replace
Remove
Format_replace
array_to_int
array_to_str
array_to_float
*/

// --------------------------------------------------------------------------
// Convert a array to lower  case.
// usage: exec global/strings.scr::Array_to_lower (const array of strings)
// returns: Array of lower case strings
// --------------------------------------------------------------------------
Array_to_lower local.strings:

	local.lower = waitthread chardata_lowercase
	local.upper = waitthread chardata_uppercase

	for(local.linni = 1; local.linni <= local.strings.size; local.linni++)
	{	
		for(local.anniken = 1; local.anniken <= local.strings[local.linni].size; local.anniken++)
		{
			local.string = local.strings[local.linni] [local.anniken]

			for(local.i = 0; local.i <= local.string.size - 1; local.i++)
			{
				local.letter = local.string[local.i]
				for(local.t = 1; local.t <= local.upper.size; local.t++)
				{
					if(local.letter == local.upper[local.t])
					{	
						local.letter = local.lower[local.t] 
						local.string[local.i] = local.letter 
					}
				}

			}
			local.strings[local.linni][local.anniken] = local.string
		}
	}

end  local.strings


// --------------------------------------------------------------------------
// Convert a array to upper case.
// usage: exec global/strings.scr::Array_to_upper (const array of strings)
// returns: Array of upper case strings
// --------------------------------------------------------------------------
Array_to_upper local.strings:

	local.lower = waitthread chardata_uppercase 
	local.upper = waitthread chardata_lowercase
 
	for(local.linni = 1; local.linni <= local.strings.size; local.linni++)
	{	
		for(local.anniken = 1; local.anniken <= local.strings[local.linni].size; local.anniken++)
		{
			local.string = local.strings[local.linni] [local.anniken]

			for(local.i = 0; local.i <= local.string.size - 1; local.i++)
			{
				local.letter = local.string[local.i]
				for(local.t = 1; local.t <= local.upper.size; local.t++)
				{
					if(local.letter == local.upper[local.t])
					{	
						local.letter = local.lower[local.t] 
						local.string[local.i] = local.letter 
					}
				}

			}
			local.strings[local.linni][local.anniken] = local.string
		}
	}

end  local.strings


// --------------------------------------------------------------------------	
//stolen arrays from jv's string handler:D
//of cause by jv

// returns all lowercase chars
// --------------------------------------------------------------------------
chardata_lowercase:
	local.hasharray = makeArray
	a
	b
	c
	d
	e
	f
	g
	h
	i
	j
	k
	l
	m
	n
	o
	p
	q
	r
	s
	t
	u
	v
	w
	x
	y
	z
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	

end local.array

// --------------------------------------------------------------------------
// returns all uppercase chars
// --------------------------------------------------------------------------

chardata_uppercase:
	local.hasharray = makeArray
	A
	B
	C
	D
	E
	F
	G
	H
	I
	J
	K
	L
	M
	N
	O
	P
	Q
	R
	S
	T
	U
	V
	W
	X
	Y
	Z
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	
end local.array


// --------------------------------------------------------------------------
// instr
// Instr will find the position in wich a string is found at.
// Usage: exec global/strings.scr::InStr (string to find \ string)
// returns the position of string_to_find
// eg
// exec global/strings.scr::InStr "\" "hell\o"
// gives 4 because it starts at 0

// If none found it will return NIL
// --------------------------------------------------------------------------

InStr local.char local.string:

	if(local.char.size == 1)
	{
		local.checktype = 0
	}
	else
	{
		local.checktype = 1
	}

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		if(local.checktype == 0)
		{
			local.check =  (local.char ==  local.string[local.i])
		}
		else
		{
			local.check =  (local.char[0] ==  local.string[local.i])
		}

		if(local.check)
		{
			if(local.checktype == 0)
			{
				local.i++
				end local.i
			}
			else
			{
				local.m = local.i
				for(local.t = 0;local.t <= local.char.size - 1 ;local.t++)
				{
					if(local.char[local.t] != local.string[local.m])
					{
						local.no = 1
					}
					local.m++
				}

				if(local.no != 1)
				{
					local.i++
					end local.i
				}
			}

		}
	}
end



// --------------------------------------------------------------------------
// Rightr
// Right will return a string of characters from the right.
// usage: waitexec global/strings.scr::Right ( Number of characters#, STRING STRING )
// Returns a string right from the number given as position
// eg
// local.string = waitexec global/strings.scr::Right 3 "hello"
// local.string will be 'llo'
// --------------------------------------------------------------------------

Right local.pos local.string:

	local.start = local.string.size - local.pos
	local.right = ""

	for(local.i = local.start; local.i <= local.string.size - 1 ; local.i++)
	{
		local.right += local.string[local.i]
	}

end local.right



// --------------------------------------------------------------------------
// Left
// Left will return Left of the string for the given number.
// usage: waitexec global/strings.scr::Right (NUMBER OF CHARACTERS LEFT, STRING STRING )
// Returns a string left from the number given as position
// eg
// local.string = waitexec global/strings.scr::Left 3 "hello" 
// local.string will be 'hell'
// --------------------------------------------------------------------------
Left local.pos local.string:

	local.pos--
	local.left = ""
	for(local.i = 0; local.i <=  local.pos; local.i++)
	{
		local.left += local.string[local.i]
	}

end local.left


// --------------------------------------------------------------------------
//Mid
//mid will return a string from a given position for a given number of characters.
// usage: local.string = waitexec global/strings.scr ( START POS, STRING, COUNT)
// returns: The string from start pos of string along the count.
//
//eg
// local.string = waitexec global/strings.scr 3 "hello" 2 
// local.string would become 'll'
// --------------------------------------------------------------------------
Mid local.start local.string local.count:

	local.start--
	local.mid = ""

	for(local.i = 1; local.i <= local.count;local.i++)
	{
		local.mid += local.string[local.start]
		local.start++
	}

end local.mid



// --------------------------------------------------------------------------
//Reverse
// Reverse will reverse a given string.
//useage:: local.string = waitexec global/strings.scr (STRING STRING)
// result: gives a string that is backwards to the string given.
//
//eg
// local.string = waitexec global/strings.scr::Reverse "hello" 
// local.string would become 'olleh'
// --------------------------------------------------------------------------
Reverse local.string:

	local.left = ""
	for(local.i = local.string.size - 1; local.i >=  0; local.i--)
	{
		local.left += local.string[local.i]
	}

end local.left


// --------------------------------------------------------------------------
// to_lower
// This will convert a given string to lower case
// usage local.string = waitexec global/strings.scr::to_lower (STRING STRING, INDEX TO CONVERT)
// Result: a lower case string
//
//eg
// local.string = waitexec global/strings.scr::to_lower "HELLO" 
// local.string will become 'hello'
//eg2
// local.string = waitexec global/strings.scr::to_lower "HELLO" 0
// local.string will become 'hELLO'
// --------------------------------------------------------------------------
to_lower local.string local.index:

	local.lower = waitthread chardata_lowercase
	local.upper = waitthread chardata_uppercase

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		local.letter = local.string[local.i]

		if(local.i == local.index || local.index == NIL)
		{
			for(local.t = 1; local.t <= local.upper.size; local.t++)
			{
				if(local.letter == local.upper[local.t])
				{	
					local.letter = local.lower[local.t] 
					local.string[local.i] = local.letter 
				}
			}
		}
		else
		{
			local.string[local.i] = local.letter 
		}

	}

end local.string


// --------------------------------------------------------------------------
// to_upper
// This will convert a given string to upper case
// usage local.string = waitexec global/strings.scr::to_upper (STRING STRING, INDEX TO CONVERT)
// Result: a upper case string
//
//eg
// local.string = waitexec global/strings.scr::to_upper "hello" 
// local.string will become 'HELLO'
//eg2
// local.string = waitexec global/strings.scr::to_upper "hello" 0
// local.string will become 'Hello'
// --------------------------------------------------------------------------
to_upper local.string local.index:

	local.upper = waitthread chardata_lowercase
	local.lower = waitthread chardata_uppercase

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		local.letter = local.string[local.i]

		if(local.i == local.index || local.index == NIL)
		{
			for(local.t = 1; local.t <= local.upper.size; local.t++)
			{
				if(local.letter == local.upper[local.t])
				{	
					local.letter = local.lower[local.t] 
					local.string[local.i] = local.letter 
				}
			}
		}
		else
		{
			local.string[local.i] = local.letter 
		}

	}

end local.string


// ----------------------------------------------------------------------------------------------------------------------
// Used to split a line of words into a array of words. return with word count
// localinfo == line to split
// local.say = say to admins input detected or not, set 1 usualy
// local.spacer = What to use to split the line. If none is set then " " will be used.
// usage local.wordarray = waitexec global/strings.scr::split_line ( STRING STRING , CONSOLE FEEDBACK, STRING SPACER)
//
//eg
//  local.wordarray = waitexec global/strings.scr::split_line "hello_mummy" 1 "_"
// local.wordarray is a const array
//
// local.wordarray[1] = array of words
// local.wordarray[2] word count
// local.wordarray[3] full string with " " spaces
//
// local.wordarray[1][1] is 'hello'
// local.wordarray[1][1] is 'mummy'
//
// local.wordarray[2] is 2 'two words'
//
// local.wordarray[3] is 'hello mummy'
// ----------------------------------------------------------------------------------------------------------------------

split_line local.info local.dont_say local.spacer:

	local.wordcount = 1

	if(local.spacer==NIL)
	{
		if(local.info[0] == "`")
		{
			local.spacer = "_"
			local.start = 1
		}
		else if(local.info[0] == " " || local.info[0] == "")
		{
			local.spacer = " "

			for(local.i = 0;local.i <= local.info.size;local.i++)
			{
				if(local.info[local.i] != " " && local.info[local.i] != "")
				{
					local.start = local.i
					break
				}
			}

		}
		else 
		{
			local.spacer = " "
			local.start = 0
		}
	}
	else
	{
		local.start = 0
		local.altcheck = 1
	}

	for(local.i=local.start;local.i<=local.info.size - 1;local.i++)
	{	
		if(local.info[local.i]!=local.spacer && local.info[local.i] != "`")
		{
			if(local.words[local.wordcount]==NIL)
			{
				local.words[local.wordcount]=""
			}

			local.words[local.wordcount] += local.info[local.i]
		}
		else
		{	
			if(local.altcheck != 1)
			{
				if(local.spacer == "_" && local.info[local.i + 1] == "`")	// if its like ui_hud 1. sud be ui_`hud so it knows:).
				{
					local.words[local.wordcount] += local.info[local.i]			
				}
				else if(local.spacer == "_" && local.info[local.i ] != "`")
				{
					local.wordcount++
				}
				else if(local.spacer == " " && local.info[local.i ] == " ")
				{
					if(local.i != local.info.size - 1)
					{
						if(local.info[local.i + 1] != " " && local.info[local.i + 1] != NIL)
						{
							local.wordcount++
						}
					}
				}
			}
			else
			{
				if(local.info[local.i ] == local.spacer)
				{
					local.wordcount++
				}
			}
		}
	}	

	if(local.spacer == "_")
	{
		local.actual = ""

		for(local.i=3;local.i<=local.words.size;local.i++)
		{
			if(local.i < local.words.size)
			{
				local.space = " "
			}
			else
			{
				local.space = ""
			}
			local.actual += ( local.words[local.i] + local.space )
		}

		if(local.dont_say != 1)
		{
			//exec global/ac/console_feedback.scr ( "> Input detected: " + local.actual )
		}
	}
	else
	{
		if(local.dont_say != 1)
		{
			//exec global/ac/console_feedback.scr ( "> Input detected: " + local.info)
			local.actual = local.info
		}
	}

end ( local.words::local.wordcount::local.actual) 



// --------------------------------------------------------------------------
// Replace is used just like replace in notepad or any text editor. 
// It will replace any string in a string with a string of any size. 
//
// exec global/strings::Replace ( String string , String String to replace, string string to replace with )
//
// eg
// local.string = waitexec global/strings.scr::Replace "once_upon_a_time_there_was__a_mod" "_" " "
// local.string would become
// "once upon a time there was  a mod" 
// --------------------------------------------------------------------------

Replace local.string local.replace local.replace_with:


	if(local.replace.size == 1)
	{
		local.checktype = 0
	}
	else
	{
		local.checktype = 1
	}
	
	local.new_str = ""

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		if(local.checktype == 0)
		{
			local.check =  (local.replace ==  local.string[local.i])
		}
		else
		{
			local.check =  (local.replace[0] ==  local.string[local.i])
		}

		if(local.check)
		{
			if(local.checktype == 0)
			{
				if(local.replace_with.size == 1)
				{
					local.new_str += local.replace_with
				}
				else
				{
					for(local.t = 0;local.t <= local.replace_with.size - 1 ;local.t++)
					{
						local.new_str += local.replace_with[local.t]
					}
				}

			}
			else
			{
				local.no = 0
				local.m = local.i
				for(local.t = 0;local.t <= local.replace.size - 1 ;local.t++)
				{
					if(local.replace[local.t] != local.string[local.m])
					{
						local.no = 1
					}
					local.m++
				}

				if(local.no != 1)
				{
					for(local.t = 0;local.t <= local.replace_with.size - 1 ;local.t++)
					{
						local.new_str += local.replace_with[local.t]
					}
					local.i += local.replace.size - 1
				}
				else
				{
					local.new_str += local.string[local.i]
				}
				
			}

		}
		else
		{
			local.new_str += local.string[local.i]
		}
	}

end local.new_str 



// --------------------------------------------------------------------------
// Remove is used to remove words or single characters from a line.
//
// exec global/strings::Remove ( String string , String String to replace )
//
// eg
// local.string = waitexec global/strings.scr::Remove "hello you idiot" "idiot"
// local.string would become
// "hello you idiot"
// --------------------------------------------------------------------------

Remove local.string local.string_remove:

	local.string = waitthread Replace local.string local.string_remove ""

end local.string



// --------------------------------------------------------------------------
// Format_replace is used like Replace except it will only replace a single instance in a group of the same character.
// It will only replace single characters.
//
// exec global/strings::Replace ( String string , String String to replace, string string to replace with )
//
// eg
// local.string = waitexec global/strings.scr::Format_replace "once_upon_a_time_there_was__a_mod" "_" " "
// local.string would become
// "once upon a time there was_a mod" 
// --------------------------------------------------------------------------

Format_replace local.string local.replace local.replace_with:

	local.new_str = ""

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{

		local.check =  (local.replace ==  local.string[local.i] && local.replace != local.string[local.i + 1])

		if(local.check)
		{
			if ( local.string[local.i - 1] !=  local.replace)
			{
				local.new_str += local.replace_with
			}
		}
		else
		{
			local.new_str += local.string[local.i]
		}
	}

end local.new_str 

// --------------------------------------------------------------------------
// Combine combines a array of stirngs into one single string of all.
// exec global/strings:;Combine (ARRAY , INT START IN ARRAY)
// --------------------------------------------------------------------------

Combine local.words local.start:

	local.actual = ""

	for(local.i=local.start;local.i<=local.words.size;local.i++)
	{
		if(local.i < local.words.size)
		{
			local.space = " "
		}
		else
		{
			local.space = ""
		}

		local.actual += ( local.words[local.i] + local.space )
	}

end local.actual

// --------------------------------------------------------------------------
// array_to_int
// converts a array into interger
// returns the array as int
// --------------------------------------------------------------------------
array_to_int local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = int local.array[local.i]
	}

end local.array

// --------------------------------------------------------------------------
// array_to_str
// converts a array into string
// returns the array as string
// --------------------------------------------------------------------------
array_to_str local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = string local.array[local.i]
	}

end local.array

// --------------------------------------------------------------------------
// array_to_float
// converts a array into float
// returns the array as float
// --------------------------------------------------------------------------
array_to_float local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = float local.array[local.i]
	}

end local.array

```

# zz_Reborn_pak8\global\check_team_swap.scr

```scr
main local.hva:

	if(local.hva=="end")
	{
		self.tss = 0
		end
	}
	
	local.team = self.dmteam
	self.tss = 1

	while(isalive self && self.tss == 1)
	{
		waitframe
		
		if(self.dmteam != "spectator" && self.dmteam != local.team)
		{
			self usestuff
			self unattachfromladder 
		}
	}
end
		
```

# zz_Reborn_pak8\global\strings.scr

```scr


// 11 September 2005 added 3 new functions
// array_to_int
// array_to_str
// array_to_float

/*
Array_to_lower
Array_to_upper
to_lower
to_upper
InStr
Right
left
Mid
Reverse
split_line
Replace
Remove
Format_replace
array_to_int
array_to_str
array_to_float
*/


// Convert a array to lower  case.
// usage: exec global/strings.scr::Array_to_lower (const array of strings)
// returns: Array of lower case strings

Array_to_lower local.strings:

	local.lower = waitthread chardata_lowercase
	local.upper = waitthread chardata_uppercase

	for(local.linni = 1; local.linni <= local.strings.size; local.linni++)
	{	
		for(local.anniken = 1; local.anniken <= local.strings[local.linni].size; local.anniken++)
		{
			local.string = local.strings[local.linni] [local.anniken]

			for(local.i = 0; local.i <= local.string.size - 1; local.i++)
			{
				local.letter = local.string[local.i]
				for(local.t = 1; local.t <= local.upper.size; local.t++)
				{
					if(local.letter == local.upper[local.t])
					{	
						local.letter = local.lower[local.t] 
						local.string[local.i] = local.letter 
					}
				}

			}
			local.strings[local.linni][local.anniken] = local.string
		}
	}

end  local.strings



// Convert a array to upper case.
// usage: exec global/strings.scr::Array_to_upper (const array of strings)
// returns: Array of upper case strings

Array_to_upper local.strings:

	local.lower = waitthread chardata_uppercase 
	local.upper = waitthread chardata_lowercase
 
	for(local.linni = 1; local.linni <= local.strings.size; local.linni++)
	{	
		for(local.anniken = 1; local.anniken <= local.strings[local.linni].size; local.anniken++)
		{
			local.string = local.strings[local.linni] [local.anniken]

			for(local.i = 0; local.i <= local.string.size - 1; local.i++)
			{
				local.letter = local.string[local.i]
				for(local.t = 1; local.t <= local.upper.size; local.t++)
				{
					if(local.letter == local.upper[local.t])
					{	
						local.letter = local.lower[local.t] 
						local.string[local.i] = local.letter 
					}
				}

			}
			local.strings[local.linni][local.anniken] = local.string
		}
	}

end  local.strings


	
//stolen arrays from jv's string handler:D
//of cause by jv

// returns all lowercase chars
chardata_lowercase:
	local.hasharray = makeArray
	a
	b
	c
	d
	e
	f
	g
	h
	i
	j
	k
	l
	m
	n
	o
	p
	q
	r
	s
	t
	u
	v
	w
	x
	y
	z
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	

end local.array

// returns all uppercase chars
chardata_uppercase:
	local.hasharray = makeArray
	A
	B
	C
	D
	E
	F
	G
	H
	I
	J
	K
	L
	M
	N
	O
	P
	Q
	R
	S
	T
	U
	V
	W
	X
	Y
	Z
	endArray
	
	for(local.i = 1; local.i <= local.hasharray.size; local.i++)
	{
		local.array[local.i] = local.hasharray[local.i][1]
	}	
end local.array


// instr
// Instr will find the position in wich a string is found at.
// Usage: exec global/strings.scr::InStr (string to find \ string)
// returns the position of string_to_find
// eg
// exec global/strings.scr::InStr "\" "hell\o"
// gives 4 because it starts at 0

// If none found it will return NIL
InStr local.char local.string:

	if(local.char.size == 1)
	{
		local.checktype = 0
	}
	else
	{
		local.checktype = 1
	}

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		if(local.checktype == 0)
		{
			local.check =  (local.char ==  local.string[local.i])
		}
		else
		{
			local.check =  (local.char[0] ==  local.string[local.i])
		}

		if(local.check)
		{
			if(local.checktype == 0)
			{
				local.i++
				end local.i
			}
			else
			{
				local.m = local.i
				for(local.t = 0;local.t <= local.char.size - 1 ;local.t++)
				{
					if(local.char[local.t] != local.string[local.m])
					{
						local.no = 1
					}
					local.m++
				}

				if(local.no != 1)
				{
					local.i++
					end local.i
				}
			}

		}
	}
end



// Rightr
// Right will return a string of characters from the right.
// usage: waitexec global/strings.scr::Right ( Number of characters#, STRING STRING )
// Returns a string right from the number given as position
// eg
// local.string = waitexec global/strings.scr::Right 3 "hello"
// local.string will be 'llo'
Right local.pos local.string:

	local.start = local.string.size - local.pos
	local.right = ""

	for(local.i = local.start; local.i <= local.string.size - 1 ; local.i++)
	{
		local.right += local.string[local.i]
	}

end local.right



// Left
// Left will return Left of the string for the given number.
// usage: waitexec global/strings.scr::Right (NUMBER OF CHARACTERS LEFT, STRING STRING )
// Returns a string left from the number given as position
// eg
// local.string = waitexec global/strings.scr::Left 3 "hello" 
// local.string will be 'hell'
// 
Left local.pos local.string:

	local.pos--
	local.left = ""
	for(local.i = 0; local.i <=  local.pos; local.i++)
	{
		local.left += local.string[local.i]
	}

end local.left



//Mid
//mid will return a string from a given position for a given number of characters.
// usage: local.string = waitexec global/strings.scr ( START POS, STRING, COUNT)
// returns: The string from start pos of string along the count.
//
//eg
// local.string = waitexec global/strings.scr 3 "hello" 2 
// local.string would become 'll'
Mid local.start local.string local.count:

	local.start--
	local.mid = ""

	for(local.i = 1; local.i <= local.count;local.i++)
	{
		local.mid += local.string[local.start]
		local.start++
	}

end local.mid




//Reverse
// Reverse will reverse a given string.
//useage:: local.string = waitexec global/strings.scr (STRING STRING)
// result: gives a string that is backwards to the string given.
//
//eg
// local.string = waitexec global/strings.scr::Reverse "hello" 
// local.string would become 'olleh'
Reverse local.string:

	local.left = ""
	for(local.i = local.string.size - 1; local.i >=  0; local.i--)
	{
		local.left += local.string[local.i]
	}

end local.left



// to_lower
// This will convert a given string to lower case
// usage local.string = waitexec global/strings.scr::to_lower (STRING STRING, INDEX TO CONVERT)
// Result: a lower case string
//
//eg
// local.string = waitexec global/strings.scr::to_lower "HELLO" 
// local.string will become 'hello'
//eg2
// local.string = waitexec global/strings.scr::to_lower "HELLO" 0
// local.string will become 'hELLO'
to_lower local.string local.index:

	local.lower = waitthread chardata_lowercase
	local.upper = waitthread chardata_uppercase

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		local.letter = local.string[local.i]

		if(local.i == local.index || local.index == NIL)
		{
			for(local.t = 1; local.t <= local.upper.size; local.t++)
			{
				if(local.letter == local.upper[local.t])
				{	
					local.letter = local.lower[local.t] 
					local.string[local.i] = local.letter 
				}
			}
		}
		else
		{
			local.string[local.i] = local.letter 
		}

	}

end local.string



// to_upper
// This will convert a given string to upper case
// usage local.string = waitexec global/strings.scr::to_upper (STRING STRING, INDEX TO CONVERT)
// Result: a upper case string
//
//eg
// local.string = waitexec global/strings.scr::to_upper "hello" 
// local.string will become 'HELLO'
//eg2
// local.string = waitexec global/strings.scr::to_upper "hello" 0
// local.string will become 'Hello'

to_upper local.string local.index:

	local.upper = waitthread chardata_lowercase
	local.lower = waitthread chardata_uppercase

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		local.letter = local.string[local.i]

		if(local.i == local.index || local.index == NIL)
		{
			for(local.t = 1; local.t <= local.upper.size; local.t++)
			{
				if(local.letter == local.upper[local.t])
				{	
					local.letter = local.lower[local.t] 
					local.string[local.i] = local.letter 
				}
			}
		}
		else
		{
			local.string[local.i] = local.letter 
		}

	}

end local.string



// Used to split a line of words into a array of words. return with word count
// localinfo == line to split
// local.say = say to admins input detected or not, set 1 usualy
// local.spacer = What to use to split the line. If none is set then " " will be used.
// usage local.wordarray = waitexec global/strings.scr::split_line ( STRING STRING , CONSOLE FEEDBACK, STRING SPACER)
//
//eg
//  local.wordarray = waitexec global/strings.scr::split_line "hello_mummy" 1 "_"
// local.wordarray is a const array
//
// local.wordarray[1] = array of words
// local.wordarray[2] word count
// local.wordarray[3] full string with " " spaces
//
// local.wordarray[1][1] is 'hello'
// local.wordarray[1][1] is 'mummy'
//
// local.wordarray[2] is 2 'two words'
//
// local.wordarray[3] is 'hello mummy'
//

split_line local.info local.dont_say local.spacer:

	local.wordcount = 1

	if(local.spacer==NIL)
	{
		if(local.info[0] == "`")
		{
			local.spacer = "_"
			local.start = 1
		}
		else if(local.info[0] == " " || local.info[0] == "")
		{
			local.spacer = " "

			for(local.i = 0;local.i <= local.info.size;local.i++)
			{
				if(local.info[local.i] != " " && local.info[local.i] != "")
				{
					local.start = local.i
					break
				}
			}

		}
		else 
		{
			local.spacer = " "
			local.start = 0
		}
	}
	else
	{
		local.start = 0
		local.altcheck = 1
	}

	for(local.i=local.start;local.i<=local.info.size - 1;local.i++)
	{	
		if(local.info[local.i]!=local.spacer && local.info[local.i] != "`")
		{
			if(local.words[local.wordcount]==NIL)
			{
				local.words[local.wordcount]=""
			}

			local.words[local.wordcount] += local.info[local.i]
		}
		else
		{	
			if(local.altcheck != 1)
			{
				if(local.spacer == "_" && local.info[local.i + 1] == "`")	// if its like ui_hud 1. sud be ui_`hud so it knows:).
				{
					local.words[local.wordcount] += local.info[local.i]			
				}
				else if(local.spacer == "_" && local.info[local.i ] != "`")
				{
					local.wordcount++
				}
				else if(local.spacer == " " && local.info[local.i ] == " ")
				{
					if(local.i != local.info.size - 1)
					{
						if(local.info[local.i + 1] != " " && local.info[local.i + 1] != NIL)
						{
							local.wordcount++
						}
					}
				}
			}
			else
			{
				if(local.info[local.i ] == local.spacer)
				{
					local.wordcount++
				}
			}
		}
	}	

	if(local.spacer == "_")
	{
		local.actual = ""

		for(local.i=3;local.i<=local.words.size;local.i++)
		{
			if(local.i < local.words.size)
			{
				local.space = " "
			}
			else
			{
				local.space = ""
			}
			local.actual += ( local.words[local.i] + local.space )
		}

		if(local.dont_say != 1)
		{
			exec global/ac/console_feedback.scr ( "> Input detected: " + local.actual )
		}
	}
	else
	{
		if(local.dont_say != 1)
		{
			exec global/ac/console_feedback.scr ( "> Input detected: " + local.info)
			local.actual = local.info
		}
	}

end ( local.words::local.wordcount::local.actual) 




// Replace is used just like replace in notepad or any text editor. 
// It will replace any string in a string with a string of any size. 
//
// exec global/strings::Replace ( String string , String String to replace, string string to replace with )
//
// eg
// local.string = waitexec global/strings.scr::Replace "once_upon_a_time_there_was__a_mod" "_" " "
// local.string would become
// "once upon a time there was  a mod" 

Replace local.string local.replace local.replace_with:


	if(local.replace.size == 1)
	{
		local.checktype = 0
	}
	else
	{
		local.checktype = 1
	}
	
	local.new_str = ""

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{
		if(local.checktype == 0)
		{
			local.check =  (local.replace ==  local.string[local.i])
		}
		else
		{
			local.check =  (local.replace[0] ==  local.string[local.i])
		}

		if(local.check)
		{
			if(local.checktype == 0)
			{
				if(local.replace_with.size == 1)
				{
					local.new_str += local.replace_with
				}
				else
				{
					for(local.t = 0;local.t <= local.replace_with.size - 1 ;local.t++)
					{
						local.new_str += local.replace_with[local.t]
					}
				}

			}
			else
			{
				local.no = 0
				local.m = local.i
				for(local.t = 0;local.t <= local.replace.size - 1 ;local.t++)
				{
					if(local.replace[local.t] != local.string[local.m])
					{
						local.no = 1
					}
					local.m++
				}

				if(local.no != 1)
				{
					for(local.t = 0;local.t <= local.replace_with.size - 1 ;local.t++)
					{
						local.new_str += local.replace_with[local.t]
					}
					local.i += local.replace.size - 1
				}
				else
				{
					local.new_str += local.string[local.i]
				}
				
			}

		}
		else
		{
			local.new_str += local.string[local.i]
		}
	}

end local.new_str 




// Remove is used to remove words or single characters from a line.
//
// exec global/strings::Remove ( String string , String String to replace )
//
// eg
// local.string = waitexec global/strings.scr::Remove "hello you idiot" "idiot"
// local.string would become
// "hello you idiot"

Remove local.string local.string_remove:

	local.string = waitthread Replace local.string local.string_remove ""

end local.string




// Format_replace is used like Replace except it will only replace a single instance in a group of the same character.
// It will only replace single characters.
//
// exec global/strings::Replace ( String string , String String to replace, string string to replace with )
//
// eg
// local.string = waitexec global/strings.scr::Format_replace "once_upon_a_time_there_was__a_mod" "_" " "
// local.string would become
// "once upon a time there was_a mod" 

Format_replace local.string local.replace local.replace_with:

	local.new_str = ""

	for(local.i = 0; local.i <= local.string.size - 1; local.i++)
	{

		local.check =  (local.replace ==  local.string[local.i] && local.replace != local.string[local.i + 1])

		if(local.check)
		{
			if ( local.string[local.i - 1] !=  local.replace)
			{
				local.new_str += local.replace_with
			}
		}
		else
		{
			local.new_str += local.string[local.i]
		}
	}

end local.new_str 


// Combine combines a array of stirngs into one single string of all.
// exec global/strings:;Combine (ARRAY , INT START IN ARRAY)
// 

Combine local.words local.start:

	local.actual = ""

	for(local.i=local.start;local.i<=local.words.size;local.i++)
	{
		if(local.i < local.words.size)
		{
			local.space = " "
		}
		else
		{
			local.space = ""
		}

		local.actual += ( local.words[local.i] + local.space )
	}

end local.actual

// array_to_int
// converts a array into interger
// returns the array as int

array_to_int local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = int local.array[local.i]
	}

end local.array

// array_to_str
// converts a array into string
// returns the array as string
array_to_str local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = string local.array[local.i]
	}

end local.array

// array_to_float
// converts a array into float
// returns the array as float
array_to_float local.array:

	if(local.array[0] != NIL)
	{
		local.start = 0
	}
	else
	{
		local.start = 1
	}

	for(local.i = local.start;local.i <= local.array.size; local.i++)
	{
		 local.array[local.i] = float local.array[local.i]
	}

end local.array

```

# zz_smoke_grenades_feho\global\smoke2.scr

```scr
smoke:

	// self = grenade
	local.smoke = spawn models/emitters/linger_smoke.tik
	local.smoke glue self
	local.smoke loopsound steamloop
	wait 3
	local.smoke remove
	
	local.smoke2 = spawn models/emitters/higgins_mushroom.tik
	local.smoke2.origin = self.origin + ( 0 0 35 )
	self.angles = ( 90 0 0)
	local.smoke2 glue self
	local.smoke2.angles = ( 90 0 0 )
	local.smoke2.alpha = 0.2
	local.smoke2 loopsound steamloop
	for (local.i=0.1 ; local.i<=1.8 ; local.i=local.i+0.1)
	{
		local.smoke2.scale = local.i
		wait .47
	}
	// wait 7
	local.smoke2 remove
end
```

# zz_soundfix\global\AA\weaponsoundfix.scr

```scr
main local.state:

	local.fegyver = self

	// A mapok nevei, ahol engedlyezve vannak a hangok, az ubersound.scr fjlbl vannak meghatrozva.

	switch (local.state)
	{
		// PISTOL Sounds
		case "ATTACK_PISTOL_PRIMARY":
			if (local.fegyver.model == "models/weapons/colt45.tik")
			{
				local.map_allj = m1l1::m1l2a::m1l2b::m1l3c::m3l1a::m3l1b::m3l2::m3l3::m4l1::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l3a::m6l3b::m6l3c::m6l3d::dm::moh::obj::train
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound colt45_snd_fire
			}
			else if (local.fegyver.model == "models/weapons/silencedpistol.tik")
			{
				local.map_allj = m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m2l1::m2l2a::m2l2b::m2l2c::m2l3::m4l2::m4l3::m6l1a::m6l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3c::m6l3d::m6l3e::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound silencer_snd_fire
			}
		break
		case "RELOAD_PISTOL":
			if (local.fegyver.model == "models/weapons/colt45.tik")
			{
				local.map_allj = m1l1::m1l2a::m1l2b::m1l3c::m3l1a::m3l1b::m3l2::m3l3::m4l1::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l3a::m6l3b::m6l3c::m6l3d::dm::moh::obj::train
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound colt45_snd_reload
			}
			else if (local.fegyver.model == "models/weapons/silencedpistol.tik")
			{
				local.map_allj = m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m2l1::m2l2a::m2l2b::m2l2c::m2l3::m4l2::m4l3::m6l1a::m6l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3c::m6l3d::m6l3e::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound silencer_snd_reload
			}
		break

		// RIFLE Sounds
		case "ATTACK_RIFLE_PRIMARY":
			if (local.fegyver.model == "models/weapons/m1_garand.tik")
			{
				local.map_allj = m1l1::m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m3l1a::m3l2::m3l3::m4l0::m4l1::m5l1a::m5l1b::m6l3a::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound m1_snd_fire
			}
			else if (local.fegyver.model == "models/weapons/springfield.tik")
			{
				local.random = randomint 5
				if (local.random <= 2)
					local.random = 1
				else
					local.random = 2

				if (local.random == 1)
					local.map_allj = m2l1::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::dm::moh::obj::train
				else
					local.map_allj = m2l2a::m2l2b::m2l2c::m6l3b::m6l3c::m6l3d::m6l3e

				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.hang = "springfield_snd_fire" + local.random
				local.fegyver playsound local.hang
			}
		break
		case "ATTACK_RIFLE_PRIMARY_EMPTY":
			if (local.fegyver.model == "models/weapons/m1_garand.tik")
			{
				local.map_allj = m1l1::m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m3l1a::m3l2::m3l3::m4l0::m4l1::m5l1a::m5l1b::m6l3a::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound m1_snd_fire
				wait 0.3
				local.fegyver playsound snd_ping
			}
		break
		case "RELOAD_RIFLE":
			if (local.fegyver.model == "models/weapons/m1_garand.tik")
			{
				local.map_allj = m1l1::m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m3l2::m3l3::m4l0::m4l1::m5l1a::m5l1b::m6l3a::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound m1_snd_reload
			}
		break
		case "ATTACK_SPRINGFIELD_RECHAMBER":
			if (local.fegyver.model == "models/weapons/springfield.tik")
			{
				local.map_allj = m2l1::m2l2a::m2l2b::m2l2c::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj::train
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound springfield_snd_bolt
			}
		break
		case "RELOAD_SPRINGFIELD":
			if (local.fegyver.model == "models/weapons/springfield.tik")
			{
				local.map_allj = m2l1::m2l2a::m2l2b::m2l2c::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj::train
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound springfield_snd_reload_start
			}
		break
		case "RELOAD_SPRINGFIELD_SINGLE":
			if (local.fegyver.model == "models/weapons/springfield.tik")
			{
				local.map_allj = m2l1::m2l2a::m2l2b::m2l2c::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj::train
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound springfield_snd_reload_single
			}
		break
		case "RELOAD_SPRINGFIELD_END":
			if (local.fegyver.model == "models/weapons/springfield.tik")
			{
				local.map_allj = m2l1::m2l2a::m2l2b::m2l2c::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj::train
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound springfield_snd_reload_end
			}
		break

		// MG Sounds
		case "ATTACK_MG_PRIMARY":
			if (local.fegyver.model == "models/weapons/bar.tik")
			{
				local.map_allj = m2l3::m3l1a::m3l2::m3l3::m4l0::m5l1b::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound bar_snd_fire
			}
			else if (local.fegyver.model == "models/weapons/mp44.tik")
			{
				local.map_allj = m5l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3b::m6l3c::m6l3::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound mp44_snd_fire
			}
		break
		case "RELOAD_MG":
			if (local.fegyver.model == "models/weapons/bar.tik")
			{
				local.map_allj = m3l1a::m3l2::m3l3::m4l0::m5l1b::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound bar_snd_reload
			}
			else if (local.fegyver.model == "models/weapons/mp44.tik")
			{
				local.map_allj = m5l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3b::m6l3::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound mp44_snd_reload
			}
		break
		case "PUTAWAY_MG_BAR":
			local.map_allj = m3l1a::m3l2::m3l3::m4l0::m5l1b::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound bar_snd_putaway
		break
		case "RAISE_MG_BAR":
			local.map_allj = m3l1a::m3l2::m3l3::m4l0::m5l1b::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound bar_snd_pullout
		break
		case "RAISE_MG_MP44":
			local.map_allj = m5l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3b::m6l3::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound mp44_snd_pullout
		break

		// PNCLTR Sounds
		case "ATTACK_BAZOOKA_PRIMARY":
			if (local.fegyver.model == "models/weapons/bazooka.tik")
			{
				local.map_allj = m5::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound bazooka_snd_fire
			}
			else if (local.fegyver.model == "models/weapons/panzerschreck.tik")
			{
				local.map_allj = m1l1::m1l3::m3l3::m5l2::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound panzerschreck_snd_fire
			}
		break
		case "RELOAD_HEAVY":
			if (local.fegyver.model == "models/weapons/bazooka.tik")
			{
				local.map_allj = m5::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound bazooka_snd_reload
			}
			else if (local.fegyver.model == "models/weapons/panzerschreck.tik")
			{
				local.map_allj = m1l1::m1l3::m3l3::m5l2::dm::moh::obj
				local.ertek = waitthread palyaellenorzes local.map_allj

				if (local.ertek == 0)
					end

				local.fegyver playsound panzerschreck_snd_reload
			}
		break
		case "PUTAWAY_HEAVY":
			local.map_allj = m1l1::m5::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound snd_bazooka_putaway
		break
		case "RAISE_HEAVY":
			local.map_allj = m1l1::m3l3::m5::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound snd_bazooka_pullout
		break

		// SHOTGUN Sounds
		case "ATTACK_SHOTGUN_PRIMARY":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound shotgun_snd_fire
			local.fegyver playsound shotgun_snd_rechamber
		break
		case "RELOAD_SHOTGUN":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound shotgun_snd_reload_start
		break
		case "RELOAD_SHOTGUN_SINGLE":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound shotgun_snd_reload_single
		break
		case "RELOAD_SHOTGUN_END":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound shotgun_snd_reload_end
		break
		case "PUTAWAY_SHOTGUN":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound snd_shotgun_putaway
		break
		case "RAISE_SHOTGUN":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			if (local.ertek == 0)
				end

			local.fegyver playsound snd_shotgun_pullout
		break
	}

end

palyaellenorzes local.map_allj:

	local.map = getcvar (mapname)

	for (local.i = 1;local.i <= local.map_allj.size;local.i++)
	{
		for (local.j = 0;local.j < local.map_allj[local.i].size;local.j++)
		{
			if (local.map[local.j] != local.map_allj[local.i][local.j])
			{
				break
			}

			if !(local.egyezes[local.i])
				local.egyezes[local.i] = 0

			local.egyezes[local.i]++

			if (local.map.size >= local.map_allj[local.i].size)
			{
				local.kulonbseg = local.map.size - local.map_allj[local.i].size
				local.darabszam = local.map.size - local.kulonbseg
			}
			else
			{
				local.kulonbseg = local.map_allj[local.i].size - local.map.size
				local.darabszam = local.map_allj[local.i].size - local.kulonbseg
			}

			if (local.egyezes[local.i] == local.darabszam)
			{
				end 0 // Nem kell a plussz hozzadott hang
			}
		}
	}

end 1

```

# zz_soundfix\soundfix\barsound.scr

```scr
main local.command:

	if(level.bar != 1)
	{
	end
	}


	thread local.command



end

reload:

self playsound bar_snd_reload

end


shoot:

self playsound bar_snd_fire

end

raise:

self playsound bar_snd_pullout

end

putaway:

self playsound bar_snd_putaway

end
```

# zz_soundfix\soundfix\bazookasound.scr

```scr
main local.command:

	if(level.bazooka != 1)
	{
	end
	}


	thread local.command



end

reload:

self playsound bazooka_snd_reload

end


shoot:

self playsound bazooka_snd_fire

end

raise:

if(level.panzer != 1)
{
end
}

self playsound snd_bazooka_pullout

end

putaway:

if(level.panzer != 1)
{
end
}

self playsound snd_bazooka_putaway

end
```

# zz_soundfix\soundfix\coltsound.scr

```scr
main local.command:

	if(level.colt != 1)
	{
	end
	}


	thread local.command



end

reload:

self playsound colt45_snd_reload

end


shoot:

self playsound colt45_snd_fire

end

wip:

self playsound pistol_whip1

end

raise:

self playsound snd_pistol_pullout

end

putaway:

self playsound snd_pistol_putaway1

end
```

# zz_soundfix\soundfix\kar98snipersound.scr

```scr
main local.command:

	if(level.kar98sniper != 1)
	{
	end
	}

	thread local.command



end

start:

self playsound kar98sniper_snd_reload_start

end

single:

self playsound kar98sniper_snd_reload_single

end

end:

self playsound kar98sniper_snd_reload_end

end

rechamber:

self playsound kar98sniper_snd_bolt item

end

shoot:

self playsound kar98sniper_snd_fire

end
```

# zz_soundfix\soundfix\kar98sound.scr

```scr
main local.command:

	if(level.kar98 != 1)
	{
	end
	}

	thread local.command



end

rechamber:

self playsound kar98_snd_bolt

end

reload:

self playsound kar98_snd_reload

end

shoot:

self playsound kar98_snd_fire1

end
```

# zz_soundfix\soundfix\m1sound.scr

```scr
main local.command:

	if(level.rifle != 1)
	{
	end
	}

	thread local.command



end



reload:

self playsound m1_snd_reload
waitframe
self playsound snd_ping

end

shoot:

self playsound m1_snd_fire

end

ping:

self playsound snd_ping

end
```

# zz_soundfix\soundfix\mapswitch_bak.scr

```scr
main:	

//string conversions made by mefy

level.mapname = getcvar (mapname)

level.sfx_stringconv["tolower"] = waitthread string_makeconv "ABCDEFGHIJKLMNOPQRSTUVWXYZ"   "abcdefghijklmnopqrstuvwxyz"

local.map = waitthread string_convert level.mapname level.sfx_stringconv["tolower"]




//weapon variables only apply if needed


//		level.springfield = 1	
//		level.rifle = 1							
//		level.bar = 1								
//		level.bazooka = 1
//		level.panzer = 1	
//		level.mp44 = 1		
//		level.colt = 1
//		level.p38 = 1
//		level.silencer = 1
	

	switch ( local.map )
	{
	  case "m1l1":
		{
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
 		}
	  	break
	  case "m1l2a":
		{
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m1l2b":
		{
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m1l3a":
		{
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m1l3b":
		{
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m1l3c":
		{
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m2l1":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m2l2a":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m2l2b":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m2l2c":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty		
		}
	  	break
	  case "m2l3":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m3l1a":
		{
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m3l1b":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m3l2":
		{
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m3l3":
		{
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m4l0":
		{
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m4l1":
		{
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m4l2":
		{
		level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m4l3":
		{
		level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m5l1a":
		{
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m5l1b":
		{
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m5l2a":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty	
		}
	  	break
	  case "m5l2b":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m5l3":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty	
		}
	  	break
	  case "m6l1a":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l1b":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty	
		}
	  	break
	  case "m6l1c":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l2a":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l2b":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l3a":
		{
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l3b":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty	
		}
	  	break
	  case "m6l3c":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l3d":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty	
		}
	  	break
	  case "m6l3e":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty
		}
	  	break
	  case "training":
		{
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.kar98 = 1
		level.kar98sniper = 1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.mp40 = 1
		//level.colt = 1         //pistol
		level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}		
		break

	  default:
	  	// error?  ignore?
	  	end
	}


end
	
string_makeconv local.fromchars local.tochars:
	for (local.i = 0; local.i < local.fromchars.size; local.i++)
	{
		local.map[(string local.fromchars[local.i])] = local.tochars[local.i]
	}
end local.map

string_convert local.str local.map:
	local.result = ""
	for (local.i = 0; local.i < local.str.size; local.i++)
	{
		local.char = (string local.str[local.i])
		
		if (local.map[local.char] != NIL)
		{
			local.result += local.map[local.char]
		} else
		{
			local.result += local.str[local.i]
		}
	}
end local.result




```

# zz_soundfix\soundfix\mapswitch.scr

```scr
// Feho : ajout du fraglimit pour chaque map

main:	

//string conversions made by mefy

level.mapname = getcvar (mapname)

level.sfx_stringconv["tolower"] = waitthread string_makeconv "ABCDEFGHIJKLMNOPQRSTUVWXYZ"   "abcdefghijklmnopqrstuvwxyz"

local.map = waitthread string_convert level.mapname level.sfx_stringconv["tolower"]




//weapon variables only apply if needed


//		level.springfield = 1	
//		level.rifle = 1							
//		level.bar = 1								
//		level.bazooka = 1
//		level.panzer = 1	
//		level.mp44 = 1		
//		level.colt = 1
//		level.p38 = 1
//		level.silencer = 1
	

	switch ( local.map )
	{
	  case "m1l1":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
 		}
	  	break
	  case "m1l2a":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m1l2b":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m1l3a":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m1l3b":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m1l3c":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m2l1":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m2l2a":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m2l2b":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m2l2c":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty		
		}
	  	break
	  case "m2l3":
		{
		setcvar "fraglimit" "3"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m3l1a":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m3l1b":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m3l2":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m3l3":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m4l0":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m4l1":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m4l2":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m4l3":
		{
		setcvar "fraglimit" "0"
		level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m5l1a":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m5l1b":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		//level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m5l2a":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty	
		}
	  	break
	  case "m5l2b":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		//level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m5l3":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		//level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty	
		}
	  	break
	  case "m6l1a":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l1b":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty	
		}
	  	break
	  case "m6l1c":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l2a":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l2b":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l3a":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		//level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l3b":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty	
		}
	  	break
	  case "m6l3c":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty
		}
	  	break
	  case "m6l3d":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty	
		}
	  	break
	  case "m6l3e":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		//level.mp44 = 1      //mg 
		//level.colt = 1         //pistol
		//level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		//level.shotgun = 1  //shotty
		}
	  	break
	  case "training":
		{
		setcvar "fraglimit" "0"
		//level.springfield = 1//sniper 
		level.rifle = 1           //m1
		level.kar98 = 1
		level.kar98sniper = 1
		level.bar = 1          //mg 
		level.bazooka = 1  //rocket
		level.panzer = 1    //rocket
		level.mp44 = 1      //mg 
		level.mp40 = 1
		//level.colt = 1         //pistol
		level.p38 = 1        //pistol
		level.silencer = 1  //pistol
		level.shotgun = 1  //shotty
		}		
		break
	  case "dm/mohdm1":
		{
		setcvar "fraglimit" "0"
		}
		break
	  case "dm/mohdm2":
		{
		setcvar "fraglimit" "0"
		}
		break
	  case "dm/mohdm6":
		{
		setcvar "fraglimit" "0"
		}
		break

	  default:
	  	// error?  ignore?
	  	end
	}


end
	
string_makeconv local.fromchars local.tochars:
	for (local.i = 0; local.i < local.fromchars.size; local.i++)
	{
		local.map[(string local.fromchars[local.i])] = local.tochars[local.i]
	}
end local.map

string_convert local.str local.map:
	local.result = ""
	for (local.i = 0; local.i < local.str.size; local.i++)
	{
		local.char = (string local.str[local.i])
		
		if (local.map[local.char] != NIL)
		{
			local.result += local.map[local.char]
		} else
		{
			local.result += local.str[local.i]
		}
	}
end local.result




```

# zz_soundfix\soundfix\mp40sound.scr

```scr
main local.command:

	if(level.mp40 != 1)
	{
	end
	}

	thread local.command



end

reload:

self playsound mp40_snd_reload

end

shoot:

self playsound mp40_snd_fire

end
```

# zz_soundfix\soundfix\mp44sound.scr

```scr
main local.command:

	if(level.mp44 != 1)
	{
	end
	}

	thread local.command



end

reload:

self playsound mp44_snd_reload

end


shoot:

self playsound mp44_snd_fire

end

raise:

self playsound mp44_snd_pullout

end

putaway:

self playsound mp44_snd_putaway

end
```

# zz_soundfix\soundfix\nade1.scr

```scr

```

# zz_soundfix\soundfix\p38sound.scr

```scr
main local.command:

	if(level.p38 != 1)
	{
	end
	}


	thread local.command



end

reload:

self playsound p38_snd_reload

end


shoot:

self playsound p38_snd_fire1

end

wip:

self playsound pistol_whip2

end

raise:

self playsound snd_pistol_pullout

end

putaway:

self playsound snd_pistol_putaway1

end
```

# zz_soundfix\soundfix\panzersound.scr

```scr
main local.command:

	if(level.panzer != 1)
	{
	end
	}


	thread local.command



end

reload:

self playsound panzerschreck_snd_reload

end


shoot:

self playsound panzerschreck_snd_fire

end

raise:

if(level.bazooka != 1)
{
end
}

self playsound snd_bazooka_pullout

end

putaway:

if(level.bazooka != 1)
{
end
}

self playsound snd_bazooka_putaway

end
```

# zz_soundfix\soundfix\shotgunsound.scr

```scr
main local.command:

	if(level.shotgun != 1)
	{
	end
	}

	thread local.command



end

reload:

self playsound shotgun_snd_reload_start

end

single:

self playsound shotgun_snd_reload_single

end

end:

self playsound shotgun_snd_reload_end

end


shoot:

self playsound shotgun_snd_fire
waitframe
self playsound shotgun_snd_rechamber

end

raise:

self playsound snd_shotgun_pullout

end

putaway:

self playsound snd_shotgun_putaway

end
```

# zz_soundfix\soundfix\silencersound.scr

```scr
main local.command:

	if(level.silencer != 1)
	{
	end
	}


	thread local.command



end

reload:

self playsound silencer_snd_reload

end


shoot:

self playsound silencer_snd_fire1

end

wip:

self playsound pistol_whip2

end

raise:

self playsound snd_pistol_pullout

end

putaway:

self playsound snd_pistol_putaway1

end
```

# zz_soundfix\soundfix\springsound.scr

```scr
main local.command:

	if(level.springfield != 1)
	{
	end
	}

	thread local.command



end

start:

self playsound springfield_snd_reload_start

end

single:

self playsound springfield_snd_reload_single

end

end:

self playsound springfield_snd_reload_end

end

rechamber:

self playsound springfield_snd_bolt item

end

shoot:

self playsound springfield_snd_fire

end
```

# zz_squadmaker_maps\maps\dm\mohdm1.scr

```scr
// SOUTHERN FRANCE
// ARCHITECTURE: SENN
// SCRIPTING: POWZER

main:

// set scoreboard messages
setcvar "g_obj_alliedtext1" "Southern France"
setcvar "g_obj_alliedtext2" ""
setcvar "g_obj_alliedtext3" ""
setcvar "g_obj_axistext1" ""
setcvar "g_obj_axistext2" ""
setcvar "g_obj_axistext3" ""

setcvar "g_scoreboardpic" "mohdm1"

	// load support gun sounds
	waitthread global/support/support.scr::soundcache

	// call additional stuff for playing this map round based is needed
	if(level.roundbased)
		thread roundbasedthread
		
	level waitTill prespawn

	//*** Precache Dm Stuff
	exec global/DMprecache.scr

	level.script = maps/dm/mohdm1.scr
	exec global/ambient.scr mohdm1

	//exec global/ambient.scr mohdm2

	//$world farplane 5000
	//$world farplane_color (.333 .333 .329)

	level waittill spawn

	level.squadmaker_areaname = "in southern France"

	// start support gunner scripts
	exec global/support/support.scr

	// start squadmaker
	exec global/squadmaker/squadmaker.scr

end

//-----------------------------------------------------------------------------

roundbasedthread:

	// Can specify different scoreboard messages for round based games here.
	
	level waitTill prespawn

	level waittill spawn

	// set the parameters for this round based match
	level.dmrespawning = 0 // 1 or 0
	level.dmroundlimit = 5 // round time limit in minutes
	level.clockside = kills // set to axis, allies, kills, or draw

	level waittill roundstart

end

```

# zz_squadmaker_maps\maps\dm\mohdm2.scr

```scr
// DESTROYED VILLAGE
// ARCHITECTURE: NED
// SCRIPTING: NED

main:

// set scoreboard messages
setcvar "g_obj_alliedtext1" "Destroyed Village"
setcvar "g_obj_alliedtext2" ""
setcvar "g_obj_alliedtext3" ""
setcvar "g_obj_axistext1" ""
setcvar "g_obj_axistext2" ""
setcvar "g_obj_axistext3" ""

setcvar "g_scoreboardpic" "mohdm2"

	// load support gun sounds
	waitthread global/support/support.scr::soundcache

	// call additional stuff for playing this map round based is needed
	if(level.roundbased)
		thread roundbasedthread

	level waittill prespawn

	//*** Precache Dm Stuff
	exec global/DMprecache.scr

	exec global/door_locked.scr::lock
	level.script = maps/dm/mohdm2.scr
	exec global/ambient.scr mohdm2
	
	level waittill spawn

	level.squadmaker_areaname = "in the village"

	// start support gunner scripts
	exec global/support/support.scr

	// start squadmaker
	exec global/squadmaker/squadmaker.scr

end

//-----------------------------------------------------------------------------

roundbasedthread:

	// Can specify different scoreboard messages for round based games here.

	level waitTill prespawn

	level waittill spawn

	// set the parameters for this round based match
	level.dmrespawning = 0 // 1 or 0
	level.dmroundlimit = 5 // round time limit in minutes
	level.clockside = kills // set to axis, allies, kills, or draw

	level waittill roundstart

end

```

# zz_squadmaker_maps\maps\dm\mohdm3.scr

```scr
// REMAGEN
// ARCHITECTURE: STAGGER
// SCRIPTING: POWZER

main:

// set scoreboard messages
setcvar "g_obj_alliedtext1" "Remagen"
setcvar "g_obj_alliedtext2" ""
setcvar "g_obj_alliedtext3" ""
setcvar "g_obj_axistext1" ""
setcvar "g_obj_axistext2" ""
setcvar "g_obj_axistext3" ""

setcvar "g_scoreboardpic" "mohdm3"

	// load support gun sounds
	waitthread global/support/support.scr::soundcache

	// call additional stuff for playing this map round based is needed
	if(level.roundbased)
		thread roundbasedthread

	level waittill prespawn
	
	//*** Precache Dm Stuff
	exec global/DMprecache.scr
	
	level.script = maps/dm/mohdm3.scr
	exec global/ambient.scr mohdm3
	
thread global/door_locked.scr::lock

	level waittill spawn

	level.squadmaker_areaname = "in Remagen"

	// start support gunner scripts
	exec global/support/support.scr

	// start squadmaker
	exec global/squadmaker/squadmaker.scr

end

//-----------------------------------------------------------------------------

roundbasedthread:

	// Can specify different scoreboard messages for round based games here.

	level waitTill prespawn

	level waittill spawn

	// set the parameters for this round based match
	level.dmrespawning = 0 // 1 or 0
	level.dmroundlimit = 5 // round time limit in minutes
	level.clockside = kills // set to axis, allies, kills, or draw

	level waittill roundstart

end

```

# zz_squadmaker_maps\maps\dm\mohdm4.scr

```scr
// THE BRIDGE
// ARCHITECTURE: POWZER
// SCRIPTING: POWZER

main:

// set scoreboard messages
setcvar "g_obj_alliedtext1" "The Crossroads"
setcvar "g_obj_alliedtext2" ""
setcvar "g_obj_alliedtext3" ""
setcvar "g_obj_axistext1" ""
setcvar "g_obj_axistext2" ""
setcvar "g_obj_axistext3" ""

setcvar "g_scoreboardpic" "mohdm4"

	// load support gun sounds
	waitthread global/support/support.scr::soundcache

	// call additional stuff for playing this map round based is needed
	if(level.roundbased)
		thread roundbasedthread

	level waittill prespawn

	//*** Precache Dm Stuff
	exec global/DMprecache.scr

	exec global/door_locked.scr::lock
	level.script = maps/dm/mohdm4.scr
	exec global/ambient.scr mohdm4
	
	thread global/minefield.scr::minefield_setup

	level waittill spawn

	level.squadmaker_areaname = "at the crossroads"

	// start support gunner scripts
	exec global/support/support.scr

	// start squadmaker
	exec global/squadmaker/squadmaker.scr

end

//-----------------------------------------------------------------------------

roundbasedthread:

	// Can specify different scoreboard messages for round based games here.

	level waitTill prespawn

	level waittill spawn

	// set the parameters for this round based match
	level.dmrespawning = 0 // 1 or 0
	level.dmroundlimit = 5 // round time limit in minutes
	level.clockside = kills // set to axis, allies, kills, or draw

	level waittill roundstart

end

```

# zz_squadmaker_maps\maps\dm\mohdm5.scr

```scr
// SNOWY PARK
// ARCHITECTURE: NED
// SCRIPTING: NED

main:

// set scoreboard messages
setcvar "g_obj_alliedtext1" "Snowy Park"
setcvar "g_obj_alliedtext2" ""
setcvar "g_obj_alliedtext3" ""
setcvar "g_obj_axistext1" ""
setcvar "g_obj_axistext2" ""
setcvar "g_obj_axistext3" ""

setcvar "g_scoreboardpic" "mohdm5"

	// load support gun sounds
	waitthread global/support/support.scr::soundcache

	// call additional stuff for playing this map round based is needed
	if(level.roundbased)
		thread roundbasedthread

	level waitTill prespawn

	//*** Precache Dm Stuff
	exec global/DMprecache.scr

	level.script = maps/dm/mohdm5.scr
	exec global/ambient.scr mohdm5

	level waittill spawn
	
	level.squadmaker_areaname 	= "in the park"
	level.squadmaker_config		= "winterwar"

	// start support gunner scripts
	exec global/support/support.scr

	// start squadmaker
	exec global/squadmaker/squadmaker.scr

snow:
	wait 1

	level.rain_speed = "32"
	level.rain_speed_vary = "16"
	level.rain_length = "2"
	level.rain_width = "1"
	level.rain_density = ".2"
	level.rain_slant = "250"
	level.rain_min_dist = "1800"
	//level.rain_min_dist = "512"
	level.rain_numshaders = 12
	level.rain_shader = "textures/snow0"


end

//-----------------------------------------------------------------------------

roundbasedthread:

	// Can specify different scoreboard messages for round based games here.

	level waitTill prespawn

	level waittill spawn

	// set the parameters for this round based match
	level.dmrespawning = 0 // 1 or 0
	level.dmroundlimit = 5 // round time limit in minutes
	level.clockside = kills // set to axis, allies, kills, or draw

	level waittill roundstart
end


```

# zz_squadmaker_maps\maps\dm\mohdm6.scr

```scr
// STALINGRAD
// ARCHITECTURE: ZIED, POWZER
// SCRIPTING: POWZER

main:

// set scoreboard messages
setcvar "g_obj_alliedtext1" "Stalingrad"
setcvar "g_obj_alliedtext2" ""
setcvar "g_obj_alliedtext3" ""
setcvar "g_obj_axistext1" ""
setcvar "g_obj_axistext2" ""
setcvar "g_obj_axistext3" ""

setcvar "g_scoreboardpic" "mohdm6"

	// load support gun sounds
	waitthread global/support/support.scr::soundcache

	// call additional stuff for playing this map round based is needed
	if(level.roundbased)
		thread roundbasedthread

	level waittill prespawn
	
	//*** Precache Dm Stuff
	exec global/DMprecache.scr

	exec global/door_locked.scr::lock
	level.script = maps/dm/mohdm6.scr
	exec global/ambient.scr mohdm6
	
	level waittill spawn

	level.squadmaker_areaname = "in Stalingrad"
	
	// start squadmaker
	exec global/squadmaker/squadmaker.scr

end

//-----------------------------------------------------------------------------

roundbasedthread:

	// Can specify different scoreboard messages for round based games here.

	level waitTill prespawn

	level waittill spawn

	// set the parameters for this round based match
	level.dmrespawning = 0 // 1 or 0
	level.dmroundlimit = 5 // round time limit in minutes
	level.clockside = kills // set to axis, allies, kills, or draw

	level waittill roundstart

end

```

# zz_squadmaker_maps\maps\dm\mohdm7.scr

```scr
// NORTH AFRIKA
// ARCHITECTURE: NED, POWZER
// SCRIPTING: POWZER

main:

// set scoreboard messages
setcvar "g_obj_alliedtext1" "Algiers"
setcvar "g_obj_alliedtext2" ""
setcvar "g_obj_alliedtext3" ""
setcvar "g_obj_axistext1" ""
setcvar "g_obj_axistext2" ""
setcvar "g_obj_axistext3" ""

setcvar "g_scoreboardpic" "mohdm7"

	// load support gun sounds
	waitthread global/support/support.scr::soundcache

	// call additional stuff for playing this map round based is needed
	if(level.roundbased)
		thread roundbasedthread

	level waittill prespawn
	
		//*** Precache Dm Stuff
		exec global/DMprecache.scr
		
		exec global/door_locked.scr::lock
		level.script = maps/dm/mohdm7.scr
		exec global/ambient.scr mohdm7
	
	level waittill spawn

	level.squadmaker_areaname 	= "in Algiers"
	level.squadmaker_config		= "afrika"

	// start support gunner scripts
	exec global/support/support.scr

	// start squadmaker
	exec global/squadmaker/squadmaker.scr

end

//-----------------------------------------------------------------------------

roundbasedthread:

	// Can specify different scoreboard messages for round based games here.

	level waitTill prespawn

	level waittill spawn

		// set the parameters for this round based match
		level.dmrespawning = 0 // 1 or 0
		level.dmroundlimit = 5 // round time limit in minutes
		level.clockside = kills // set to axis, allies, kills, or draw

	level waittill roundstart

end

```

# zz_squadmaker\global\sqdmksupport_shared.scr

```scr
// by jv_map

enforcestatefile local.file:

	if(level.enforcing_statefile)
	{
		if(level.enforcing_statefile != local.file)
		{
			println "[SQDMKSUPPORTSHARED]: Can't enforce 2 different statefile sets '" level.enforcing_statefile "' and '" local.file "' (using '" level.enforcing_statefile "')"
		}
		end
	}

	level.enforcing_statefile = local.file
	level.desired_statefile = local.file
	
	// this is quite heavily enforced so user can't 
	// break mod via console command in mid-game
	while(1)
	{
		// make sure right statefile is running
		if(getcvar g_statefile == level.desired_statefile)
		{
			waitframe
		}
		else
		{
			setcvar g_statefile level.desired_statefile
			
			// resetstate for all players
			for(local.i = 1; local.i <= $player.size; local.i++)
			{
				$player[local.i] resetstate
			}
		}
	}
end
```

# zz_squadmaker\global\squadmaker\shell.scr

```scr
// do some shelling
// by jv_map

shell local.tname local.arg1:

	thread local.tname local.arg1

end

raise_weapon_general:

	if(!self.sqdmk_suppress_raise)
	{
		self viewmodelanim pullout
	}

end

weapon_raise local.type:
	
	self.sqdmk_last_raised_prim_weapon_type = local.type

end
```

# zz_squadmaker\global\squadmaker\squadmaker.scr

```scr
// squadmaker
// by jv_map

main:

	// don't allow calling this twice
	if(level.sqdmk_running)
	{
		end
	}

	level.sqdmk_running = 1
	level.sqdmk_version = "1.0"

	if(!(waitthread init))
	{
		waitthread userprint ("[SQUADMAKER]: Failed initialization. Please check files. Exiting.")
		end
	}

	// check if user wants me
	if(getcvar level.sqdmk_cvar_enabled != level.sqdmk_cvar_str_on)
	{
		// don't run squadmaker
		waitthread userprint ("[SQUADMAKER]: Squadmaker has been disabled by server admin. To enable via rcon, type: ")
		thread userprint ("rcon set " + level.sqdmk_cvar_enabled + " " + level.sqdmk_cvar_str_on) 0.25
		thread userprint ("rcon map " + (getcvar mapname)) 0.50
		end
	}

	// verify gametype
	if(int (getcvar g_gametype) <= 1)
	{
		// don't enforce weapon in sp or ffa, obviously
		waitthread userprint ("[SQUADMAKER]: Gametype " + (getcvar g_gametype) + " (" + (getcvar g_gametypestring) + ") not supported!")
		end
	}

	// load content
	local.ok = waitthread load_content

	if(!local.ok)
	{
		waitthread userprint ("[SQUADMAKER]: A fatal error occured while loading custom files. Squadmaker cannot run.") 0.25
		end
	}

	thread playermonitor
	thread showinfo
end

init:
	level.sqdmk_cvarprefix = "sqdmk"

	level.sqdmk_cvar_enabled 			= level.sqdmk_cvarprefix
	level.sqdmk_cvar_verbose			= level.sqdmk_cvarprefix + "_verbose"
	level.sqdmk_cvar_msgecho 			= level.sqdmk_cvarprefix + "_msgecho"
	level.sqdmk_cvar_force_skins		= level.sqdmk_cvarprefix + "_force_skins"
	level.sqdmk_cvar_show_command_level = level.sqdmk_cvarprefix + "_show_command_level"
	level.sqdmk_cvar_show_unit 			= level.sqdmk_cvarprefix + "_show_unit"
	level.sqdmk_cvar_enable_preference	= level.sqdmk_cvarprefix + "_enable_preference"
	level.sqdmk_cvar_grenade_start_ammo	= level.sqdmk_cvarprefix + "_grenade_startammo"
	level.sqdmk_cvar_subconfiguration	= level.sqdmk_cvarprefix + "_subconfig"
	level.sqdmk_cvar_superconfiguration	= level.sqdmk_cvarprefix + "_superconfig"
	level.sqdmk_cvar_showinfo			= level.sqdmk_cvarprefix + "_showinfo"
	level.sqdmk_cvar_huddraw_element	= level.sqdmk_cvarprefix + "_huddraw_element"
	level.sqdmk_cvar_huddraw_nudge_x	= level.sqdmk_cvarprefix + "_huddraw_nudge_x"
	level.sqdmk_cvar_huddraw_nudge_y	= level.sqdmk_cvarprefix + "_huddraw_nudge_y"

	level.sqdmk_cvar_str_on 	= "1"
	level.sqdmk_cvar_str_off 	= "0"
	level.sqdmk_huddraw_default = "83"

	// set default config
	waitthread setdfcvar level.sqdmk_cvar_enabled 				level.sqdmk_cvar_str_on
	waitthread setdfcvar level.sqdmk_cvar_verbose				level.sqdmk_cvar_str_off
	waitthread setdfcvar level.sqdmk_cvar_msgecho 				level.sqdmk_cvar_str_off
	waitthread setdfcvar level.sqdmk_cvar_force_skins			level.sqdmk_cvar_str_on
	waitthread setdfcvar level.sqdmk_cvar_show_command_level	level.sqdmk_cvar_str_off
	waitthread setdfcvar level.sqdmk_cvar_show_unit				level.sqdmk_cvar_str_on
	waitthread setdfcvar level.sqdmk_cvar_enable_preference		level.sqdmk_cvar_str_on
	waitthread setdfcvar level.sqdmk_cvar_grenade_start_ammo	6 	// this should match realism setting dmstartammo in grenade_base tiks
	waitthread setdfcvar level.sqdmk_cvar_subconfiguration		""
	waitthread setdfcvar level.sqdmk_cvar_superconfiguration	""
	waitthread setdfcvar level.sqdmk_cvar_showinfo				level.sqdmk_cvar_str_on
	waitthread setdfcvar level.sqdmk_cvar_huddraw_element		level.sqdmk_huddraw_default
	waitthread setdfcvar level.sqdmk_cvar_huddraw_nudge_x		"0"
	waitthread setdfcvar level.sqdmk_cvar_huddraw_nudge_y		"0"
																	
	// don't allow this to be changed without a restart
	level.sqdmk_grenade_start_ammo = int(getcvar level.sqdmk_cvar_grenade_start_ammo)
	
	level.sqdmk_script_path 			= "global/squadmaker/"
	level.sqdmk_settings_path 			= "squadmaker_config/"

	waitthread configure
	
	// check if we're using a valid huddraw_element
	level.sqdmk_huddraw_element = int (getcvar level.sqdmk_cvar_huddraw_element)
	if (level.sqdmk_huddraw_element <= 0 || level.sqdmk_huddraw_element > 255)
	{
		// aww
		waitthread userprint ("[SQUADMAKER]: Invalid " + level.sqdmk_cvar_huddraw_element + ": '" + (getcvar level.sqdmk_cvar_huddraw_element) + "', must be in range 1-255")
		setcvar level.sqdmk_cvar_huddraw_element level.sqdmk_huddraw_default
		level.sqdmk_huddraw_element = level.sqdmk_huddraw_default
	}
	
	if !(level.squadmaker_areaname)
	{
		level.squadmaker_areaname = "in the area"
	}
	
	level.sqdmk_config_error = 0
	
	println "[SQUADMAKER]: Checking for custom files. If you find error messages right below here, there's usually nothing to worry about."
	
	level.sqdmk_main 					= level.sqdmk_script_path + "squadmaker.scr"
	
	level.sqdmk_loadout 				= waitthread pathcustomfile "loadout.scr"
	level.sqdmk_squaddef_txt[allies] 	= waitthread pathcustomfile "squad_allied.txt"
	level.sqdmk_squaddef_txt[axis] 		= waitthread pathcustomfile "squad_axis.txt"
	level.sqdmk_division_txt[allies] 	= waitthread pathcustomfile "divisions_allied.txt"
	level.sqdmk_division_txt[axis] 		= waitthread pathcustomfile "divisions_axis.txt"
	level.sqdmk_squadnames_txt[allies]	= waitthread pathcustomfile "squadnames_allied.txt"
	level.sqdmk_squadnames_txt[axis]	= waitthread pathcustomfile "squadnames_axis.txt"
	level.sqdmk_hudmessages_txt			= waitthread pathcustomfile "hudmessages.txt"
	
	println "[SQUADMAKER]: Done checking for custom files."
	
	if(level.sqdmk_config_error)
	{
		waitthread userprint ("[SQUADMAKER]: Failed to load " + level.sqdmk_config_error + " configurable files. Squadmaker cannot run.")
		end 0
	}
	
	// squad seeding: this is the highest number that can be assigned to the first squad.
	level.sqdmk_squadnamemaxseed = 30
	
	// preferred weapons names
	level.sqdmk_prefstr[allies][rifle] 		= "M1 Garand"
	level.sqdmk_prefstr[allies][sniper] 	= "Springfield '03 Sniper"
	level.sqdmk_prefstr[allies][smg] 		= "Thompson"
	level.sqdmk_prefstr[allies][mg] 		= "BAR"
	level.sqdmk_prefstr[allies][heavy] 		= "M1919"
	level.sqdmk_prefstr[allies][shotgun] 	= "Shotgun"
	
	level.sqdmk_prefstr[axis][rifle] 		= "Mauser KAR 98K"
	level.sqdmk_prefstr[axis][sniper] 		= "KAR98 - Sniper"
	level.sqdmk_prefstr[axis][smg] 			= "MP40"
	level.sqdmk_prefstr[axis][mg] 			= "StG 44"
	level.sqdmk_prefstr[axis][heavy] 		= "MG42"
	level.sqdmk_prefstr[axis][shotgun] 		= "Shotgun"
	
	// counts number of weapons are available per squad
	// with the current squad config
	level.sqdmk_prefavailable[allies][rifle] 	= 0
	level.sqdmk_prefavailable[allies][sniper] 	= 0
	level.sqdmk_prefavailable[allies][smg] 		= 0
	level.sqdmk_prefavailable[allies][mg] 		= 0
	level.sqdmk_prefavailable[allies][heavy] 	= 0
	level.sqdmk_prefavailable[allies][shotgun] 	= 0
	
	level.sqdmk_prefavailable[axis][rifle] 		= 0
	level.sqdmk_prefavailable[axis][sniper] 	= 0
	level.sqdmk_prefavailable[axis][smg] 		= 0
	level.sqdmk_prefavailable[axis][mg] 		= 0
	level.sqdmk_prefavailable[axis][heavy] 		= 0
	level.sqdmk_prefavailable[axis][shotgun] 	= 0
	
	level.sqdmk_availablestr[0] = "permanently unavailable"
	level.sqdmk_availablestr[1] = "out of stock"
	
	thread global/sqdmksupport_shared.scr::enforcestatefile "global/nagle_aa" //sqdmksupport"
end 1

// configures the mod
configure:

	local.char_seperator = ","

	if(!level.squadmaker_config)
	{
		level.squadmaker_config = ""
	}

	local.config_str = "default" + local.char_seperator + (getcvar level.sqdmk_cvar_subconfiguration) + local.char_seperator + level.squadmaker_config + local.char_seperator + (getcvar level.sqdmk_cvar_superconfiguration)
	
	local.configs = waitthread string_to_array local.config_str local.char_seperator
	
	// sanitized array index
	local.j = 0
	
	// grab config infos
	for(local.i = local.configs.size; local.i >= 1; local.i--)
	{
		local.config = local.configs[local.i]
		if(local.config)
		{
			// have to check for duplicates
			// only add this if not already present in an overriding config
			local.skip = 0
			for(local.k = local.i + 1; local.k <= local.configs.size; local.k++)
			{
				local.other_config = local.configs[local.k]
				if(local.other_config == local.config)
				{
					// do nothing
					local.skip = 1
					break
				}
			}
			
			if(!local.skip)
			{
				local.config_path = level.sqdmk_settings_path + local.config + "/"
				local.config_info_txt = local.config_path + "config_info.txt"
				local.rtn = waitexec local.config_info_txt
				if(local.rtn)
				{
					local.j++
					level.sqdmk_config[local.j] = local.config
					level.sqdmk_config_info[local.j] = local.rtn
				}
				else
				{
					waitthread userprint ("[SQUADMAKER]: " + local.config_info_txt + " doesn't exist or didn't return anything, can't use config '" + local.config + "'")
				}
			}
		}
	}
	
	waitthread userprint ("[SQUADMAKER]: Using configuration: " + waitthread configprint)
end

// crappily formatted
configprint:

	local.str = ""

	for(local.i = level.sqdmk_config.size; local.i >= 1; local.i--)
	{
		local.str += level.sqdmk_config[local.i]
		
		if(local.i > 1)
		{
			local.str += ">>"
		}
	}

end local.str

// nicely formatted
configinfo:

	if(level.sqdmk_config.size == 1)
	{
		local.str = level.sqdmk_config_info[1]
	}
	else
	{
		local.str = ""
		for(local.i = 1; local.i < level.sqdmk_config.size; local.i++)
		{
			local.str += level.sqdmk_config_info[local.i]
			
			if(local.i < level.sqdmk_config.size - 1)
			{
				local.str += " on "
			}
		}
	}

end local.str

// Checks if file in custom config path returns anything
// if it returns something that casts to true, this method 
// returns the filename to the custom file. Otherwise, the 
// path the the default file is returned.
// 
// Hence, it is only necessary to have the modified files 
// in config folders, and have squadmaker fallback to the 
// default files (or next subconfig) when customization is not necessary.
pathcustomfile local.file:
	
	// have to check entire config stack
	// I check highest priority first and then make my way up
	for(local.i = 1; local.i <= level.sqdmk_config.size; local.i++)
	{
		local.pathfile = level.sqdmk_settings_path + level.sqdmk_config[local.i] + "/" + local.file
		
		// check return
		local.rtn = waitexec local.pathfile
		
		if(local.rtn)
		{
			// ok!
			break
		}
		else
		{
			// nok
			if(local.i == level.sqdmk_config.size)
			{
				// eek, can't fallback
				waitthread userprint ("[SQUADMAKER]: (FATAL) Could not locate a working copy of configurable file " + local.file + " in any config!")
				level.sqdmk_config_error++
			}
			else if(getcvar level.sqdmk_cvar_verbose == level.sqdmk_cvar_str_on)
			{
				waitthread userprint ("[SQUADMAKER]: " + local.file + " not present in config '" + level.sqdmk_config[local.i] + "', falling back to '" + level.sqdmk_config[local.i+1] + "'.")
			}
		}
	}
end local.pathfile

// load squad defs, skin defs, etc
// and check if they're ok
load_content:

	local.ok = waitthread loadsquad allies
	local.ok = local.ok && waitthread loadsquad axis
	local.ok = local.ok && waitthread loadsquadnames allies
	local.ok = local.ok && waitthread loadsquadnames axis
	local.ok = local.ok && waitthread loaddivisions allies
	local.ok = local.ok && waitthread loaddivisions axis
	local.ok = local.ok && waitthread loadhudmessages
	
end local.ok

loadsquad local.team:
	level.sqdmk_squad[local.team] = waitexec level.sqdmk_squaddef_txt[local.team]
	
	local.ok = level.sqdmk_squad[local.team].size >= 1
	
	if(!local.ok)
	{
		waitthread userprint ("[SQUADMAKER]: Critical error in file " + level.sqdmk_squaddef_txt[local.team])
	}
	else
	{
		// set weapon preference available flags
		for(local.i = 1; local.i <= level.sqdmk_squad[local.team].size; local.i++)
		{
			if(level.sqdmk_squad[local.team][local.i].size >= 3)
			{
				level.sqdmk_prefavailable[local.team][level.sqdmk_squad[local.team][local.i][3]]++
			}
			else
			{
				waitthread userprint ("[SQUADMAKER]: Warning, squad entry " + local.i + " in " + level.sqdmk_squaddef_txt[local.team] + " does not have a weapon preference entry (column 3).")
			}
		}
	}
end local.ok

loadsquadnames local.team:

	level.sqdmk_squadnames[local.team] = waitexec level.sqdmk_squadnames_txt[local.team]
	
	local.ok = level.sqdmk_squadnames[local.team].size >= 1

	if(!local.ok)
	{
		waitthread userprint ("[SQUADMAKER]: Critical error in file " + level.sqdmk_squadnames_txt[local.team])
	}

end local.ok

loaddivisions local.team:
	level.sqdmk_division[local.team] = waitexec level.sqdmk_division_txt[local.team]
	
	local.ok = level.sqdmk_division[local.team].size >= 1
	
	if(!local.ok)
	{
		waitthread userprint ("[SQUADMAKER]: Critical error in file " + level.sqdmk_division_txt[local.team])
	}

end local.ok

loadhudmessages:

	level.sqdmk_hudmessages = waitexec level.sqdmk_hudmessages_txt
	
	if(level.sqdmk_hudmessages.size < 1)
	{
		waitthread userprint ("[SQUADMAKER]: No hud messages defined in " + level.sqdmk_hudmessages_txt)
	}
end 1 // never fatal

// continuously checks for new players
playermonitor:

	while(1)
	{
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			local.p = $player[local.i]
			if(!local.p.sqdmk_handled)
			{
				local.p thread playerhandler
			}
		}
		waitframe
	}

end

// checks for player respawns, etc.
playerhandler:

	self.sqdmk_handled = 1

	thread ingamehandler
	thread respawnhandler

end

// checks when players respawn
respawnhandler:

	self.sqdmk_respawn = 0 // clear respawnflag

	local.fake_max_health = 100.01

	if(isAlive self && self.dmteam != "spectator")
	{
		// immediate spawn at start of round
		local.immediate_spawn = 1
	}

	while(self)
	{
		if(!local.immediate_spawn)
		{
			self.max_health = local.fake_max_health
			self heal 1.0
			
			while(self && self.max_health == local.fake_max_health)
			{
				waitframe
			}
		}
		
		// can respawn as spectator for inactivity
		if(isAlive self && self.dmteam != "spectator")
		{
			self.sqdmk_respawn = 1 // set respawnflag
			
			// must leave current squad first
			while(self.sqdmk_cumulative_position)
			{
				wait 0.01
			}
			
			// assign weapon and skin
			waitthread assign
			
			if(local.immediate_spawn)
			{
				local.immediate_spawn = 0
			}
		}
	}

end

// checks when players switch teams etc
ingamehandler:

	if(!level.dmrespawning)
	{
		local.last_join_time = level.time + float(getcvar g_allowjointime) + 2.0 	// small safety:
																					// rather to give weaps 
																					// to a spectator than 
																					// to allow a player 
																					// to enter game with
																					// forbidden weapons
	}

	while(self)
	{
		// clear ingame flag
		self.sqdmk_ingame = 0
		
		// clear cumulative position if I hold one
		self.sprt_is_support_gunner = 0
		waitthread leave_squad
		
		// wait till player spawns
		while(self && !self.sqdmk_respawn)
		{
			waitframe
		}
		
		if(!self)
		{
			break
		}
		
		if(level.dmrespawning || level.time <= local.last_join_time)
		{
			// yup, in game now
			self.sqdmk_ingame = 1
			
			// clear respawn flag
			self.sqdmk_respawn = 0
			
			local.team = self.dmteam
			
			while(isAlive self && !self.sqdmk_respawn && self.dmteam == local.team)
			{
				waitframe
			}
		}
		else
		{
			// can't join anymore this game
			break
		}
	}

end

assign:
	
	self.sqdmk_suppress_raise = 1
	
	// whether to take player preference into account
	local.pref = getcvar level.sqdmk_cvar_enable_preference == level.sqdmk_cvar_str_on
	
	local.t = self.dmteam
	
	if(local.pref)
	{
		// this'll be a bit ugly on spawn but it'll have to
		// don't change! the wait must be EXACTLY 0.301 otherwise
		// the weapon can be dropped before a new one is assigned
		wait 0.301
		
		local.preference = self.sqdmk_last_raised_prim_weapon_type
	}
	
	if(self)
	{
		self.sqdmk_suppress_raise = 0
	}
	
	// couldn't determine weapon type for whatever reason
	if(!local.preference)
	{
		local.pref = 0
	}
	
	if( !isAlive self || self.dmteam != local.t || !self.sqdmk_ingame)
	{
		end
	}
	
	// need to take immediately or player might drop weapon while we're in the cueue
	self takeall
	
	// randomize spawn time a bit
	// so the same person doesn't always get his 
	// prefed weap in roundbased games
	wait (randomfloat 0.3)
	
	// make sure I'm the only one selecting a position atvm
	while(level.sqdmk_assigning)
	{
		wait 0.001
	}
	
	if( !isAlive self || self.dmteam != local.t || !self.sqdmk_ingame)
	{
		end
	}
	
	self forcetorsostate STAND
	
	level.sqdmk_assigning = 1

	// check how current squads are doing
	// i.e. if they need any help :P
	
	local.cumulative_position = 1
	
	while(1)
	{
		// check if this position is covered
		if(!level.sqdmk_man_on_position[self.dmteam][local.cumulative_position] || level.sqdmk_man_on_position[self.dmteam][local.cumulative_position] == self)
		{
			if(!local.pref)
			{
				local.selected_pos = local.cumulative_position
				break
			}
			else
			{
				if(!local.min_cum_pos)
				{
					// store valid position
					local.min_cum_pos = local.cumulative_position
					
					// look for other positions within this squad only
					local.max_cum_pos = (waitthread getsquadnum local.cumulative_position self.dmteam) * level.sqdmk_squad[self.dmteam].size
				}
				
				if(local.cumulative_position <= local.max_cum_pos)
				{
					local.posnum = waitthread getposnum local.cumulative_position self.dmteam
					local.pospref = level.sqdmk_squad[self.dmteam][local.posnum][3]
					
					if(local.preference == local.pospref)
					{
						// yay! I liked this pos in the first place. grab this pos quickly!
						local.selected_pos = local.cumulative_position
						local.metpref = 1
						break
					}
					else if(local.cumulative_position == local.max_cum_pos)
					{
						// all through.. couldn't match my preference .. take the 1st free spot
						local.selected_pos = local.min_cum_pos
						local.metpref = 0
						break
					}
				}
				else
				{
					// all through.. couldn't match my preference .. take the 1st free spot
					local.selected_pos = local.min_cum_pos
					local.metpref = 0
					break
				}
			}
		}
		local.cumulative_position++
	}
	
	// done, just assign this pos
	level.sqdmk_man_on_position[self.dmteam][local.selected_pos] = self
	thread take_position local.selected_pos
	
	if(local.pref && !local.metpref)
	{
		if(level.sqdmk_prefavailable[self.dmteam][local.preference])
		{
			self iprint ("Your preferred weapon (" + level.sqdmk_prefstr[self.dmteam][local.preference] + ") is " + level.sqdmk_availablestr[1] + " (" + level.sqdmk_prefavailable[self.dmteam][local.preference] + " available per squad of " + level.sqdmk_squad[self.dmteam].size + " players)")
		}
		else
		{
			self iprint ("Your preferred weapon (" + level.sqdmk_prefstr[self.dmteam][local.preference] + ") is " + level.sqdmk_availablestr[0])
		}
		
	}
	
	level.sqdmk_assigning = 0
end

// returns squadnumber from cumulative position
getsquadnum local.cumpos local.team:
end  (int ((local.cumpos-1)/level.sqdmk_squad[local.team].size) + 1)

// returns squad position index from cumulative position
getposnum local.cumpos local.team:
end ((local.cumpos-1)%level.sqdmk_squad[local.team].size + 1)

take_position local.cumpos:

	local.sqdnum = waitthread getsquadnum local.cumpos self.dmteam
	local.posnum = waitthread getposnum local.cumpos self.dmteam
	
	self.sqdmk_last_team = self.dmteam
	self.sqdmk_cumulative_position = local.cumpos
	
	// actual assignment
	waitthread final_assign local.sqdnum local.posnum
end

final_assign local.sqdnum local.posnum:

	local.type = level.sqdmk_squad[self.dmteam][local.posnum][1]

	// take again in case player picked up something while in the assignment cueue
	self takeall
	
	waitthread level.sqdmk_loadout::("loadout_" + self.dmteam) local.type

	if(getcvar level.sqdmk_cvar_show_command_level == level.sqdmk_cvar_str_on)
	{
		if(local.posnum == 1)
		{
			local.cmdstr = " [cmding]"
		}
		else
		{
			local.cmdstr = " [" + local.posnum + "i/c]"
		}
	}
	else
	{
		local.cmdstr = "" 
	}
	
	local.sqdstr = waitthread squadname self.dmteam local.sqdnum
	
	if(!level.sqdmk_squnitnumber[self.dmteam][local.sqdnum])
	{
		level.sqdmk_squnitnumber[self.dmteam][local.sqdnum] = randomint level.sqdmk_division[self.dmteam].size + 1
	}
	
	local.unit = level.sqdmk_division[self.dmteam][level.sqdmk_squnitnumber[self.dmteam][local.sqdnum]]
	
	if(getcvar level.sqdmk_cvar_show_unit == level.sqdmk_cvar_str_on)
	{
		local.unitstr = "[" + local.unit[1] + "] "
	}
	else
	{
		local.unitstr = ""
	}
	
	// force skin
	if(getcvar level.sqdmk_cvar_force_skins == level.sqdmk_cvar_str_on)
	{
		if(local.posnum == 1 && local.unit.size >= 3)
		{
			self model ("models/player/" + local.unit[3] + ".tik")
		}
		else
		{
			self model ("models/player/" + local.unit[2] + ".tik")
		}
	}
	
	if(self.dmteam != self.sqdmk_stashed_team || local.sqdnum != self.sqdmk_stashed_squad || local.posnum != self.sqdmk_stashed_position)
	{
		self iprint ("You've been attached to " + local.sqdstr + " " + local.unitstr + "as " + level.sqdmk_squad[self.dmteam][local.posnum][2] + local.cmdstr) 1
		self.sqdmk_stashed_team = self.dmteam
		self.sqdmk_stashed_squad = local.sqdnum
		self.sqdmk_stashed_position = local.posnum
	}
end

squadname local.team local.num:
	
	// randomize a bit
	if (!level.sqdmk_squadnameseed[local.team])
	{
		level.sqdmk_squadnameseed[local.team] = randomint level.sqdmk_squadnamemaxseed + 1
	}
	
	local.seedednum = local.num + level.sqdmk_squadnameseed[local.team]
	
	local.str = level.sqdmk_squadnames[local.team][(local.seedednum-1)%level.sqdmk_squadnames[local.team].size+1][1]
	
	local.str = waitthread char_replace local.str "#" local.seedednum
end local.str

char_replace local.string local.find local.replace:

	local.out = ""

	for(local.i = 0; local.i < local.string.size; local.i++)
	{
		local.char = local.string[local.i]
		
		if(local.char == local.find)
		{
			local.out += local.replace
		}
		else
		{
			local.out += local.char
		}
	}

end local.out

leave_squad:

	if(self.sqdmk_cumulative_position)
	{
		level.sqdmk_man_on_position[self.sqdmk_last_team][self.sqdmk_cumulative_position] = NIL
		self.sqdmk_cumulative_position = NIL
	}
	
end

// set default value for cvar
setdfcvar local.cvar local.df:

	if(getcvar local.cvar == "")
	{
		setcvar local.cvar local.df
	}
end

// print text to server console and optionally echo to players
userprint local.txt local.delay:
	
	// print to server console even if developer is 0
	local.prevdev = getcvar developer
	setcvar developer "1"
	println local.txt
	setcvar developer local.prevdev
	
	if(getcvar level.sqdmk_cvar_msgecho == level.sqdmk_cvar_str_on)
	{
		if(local.delay)
		{
			wait local.delay
		}
		
		for(local.i = 1; local.i <= $player.size; local.i++)
		{
			$player[local.i] stufftext ("echo " + local.txt)
		}
	}

end

showinfo:

	local.message_delay = 0.5
	local.chunk_delay = 30.0

	wait 10.0

	while(1)
	{
		for(local.i = 1; local.i <= level.sqdmk_hudmessages.size && getcvar level.sqdmk_cvar_showinfo == level.sqdmk_cvar_str_on; local.i++)
		{
			// concatenate the message
			local.str = ""
			for(local.j = 1; local.j <= level.sqdmk_hudmessages[local.i].size; local.j++)
			{
				local.out = waitthread specialize_message level.sqdmk_hudmessages[local.i] local.j local.i
				local.str 	+= local.out[1]
				local.j		+= local.out[2] // num_arguments
			}
			
			waitthread hudmsg local.str
			wait local.message_delay
		}
		wait local.chunk_delay
	}

end

// some special messages
specialize_message local.msg_list local.index local.lineno:

	local.msg = local.msg_list[local.index]

	local.errlocmsg = "(message #" + local.lineno + " in " + level.sqdmk_hudmessages_txt + ")"
	local.errstr = "ERROR"

	local.num_arguments = 0

	switch(local.msg)
	{
		SPLASH:
			// I know it's tempting but 
			// please don't steal my work
			// by putting your name there
			local.str = "Squadmaker " + level.sqdmk_version + " " + (waitthread configinfo) + "\nby jv_map"
			break
		
		TIP1:
			local.str = "Join a team to become a squad member."
			break
		
		TIP2:
			local.str = "Your weapon depends on your role in the squad."
			break
		
		TIP3:
			local.num_arguments = 1
			if(local.index >= local.msg_list.size)
			{
				waitthread userprint ("[SQUADMAKER]: Missing weapon parameter for specialized string TIP3 " + local.errlocmsg)
				local.weap = "UNSPECIFIED"
			}
			else
			{
				local.weap = local.msg_list[local.index+1]
			}
			local.str = "The support weapon is the heaviest weapon in your squad.\nSelect the " + local.weap + " to use it."
			break
		
		TIP4:
			local.str = "Use left/right click to quickly (un)holster the support weapon."
			break
		
		AREANAME:
			local.str = level.squadmaker_areaname
			break
		
		ORDER_OF_BATTLE:
			local.num_arguments = 1
		
			if(local.index >= local.msg_list.size)
			{
				waitthread userprint ("[SQUADMAKER]: Missing team parameter for specialized string ORDER_OF_BATTLE " + local.errlocmsg)
				local.str = local.errstr
				break
			}
			local.team = local.msg_list[local.index+1]
		
			if(local.team == allies || local.team == axis)
			{
				local.str = waitthread order_of_battle local.team
			}
			else
			{
				waitthread userprint ("[SQUADMAKER]: Invalid team parameter '" + local.team + "' for specialized string ORDER_OF_BATTLE " + local.errlocmsg + ", must be 'allies' or 'axis'")
				local.str = local.errstr
			}
			break
		
		CVAR:
			local.num_arguments = 1
		
			if(local.index >= local.msg_list.size)
			{
				waitthread userprint ("[SQUADMAKER]: Missing cvar name for specialized string CVAR " + local.errlocmsg)
				local.str = local.errstr
				break
			}
			local.cvar = local.msg_list[local.index+1]
			local.str = getcvar local.cvar
			break
		
		VERSION:
			local.str = level.sqdmk_version
			break
			
		AUTHOR:
			local.str = "jv_map" // don't you *dare* change this :P
			break
			
		CONFIG:
			local.str = waitthread configinfo
			break
		
		default:
			local.str = local.msg
	}

	local.out = local.str::local.num_arguments

end local.out

order_of_battle local.team:

	local.str = ""
	local.sqdnum = 1
	while(1)
	{
		if(local.sqdnum != 1)
		{
			local.str += "\n"
		}
		
		local.unitnum = level.sqdmk_squnitnumber[local.team][local.sqdnum]
		if(local.unitnum)
		{
			local.str += (waitthread squadname local.team local.sqdnum) + " / " + level.sqdmk_division[local.team][local.unitnum][1]
		}
		else
		{
			if(local.sqdnum == 1)
			{
				local.str += "Unknown"
			}
			break
		}
		local.sqdnum++
	}
end local.str

stringcountsubstr local.string local.substr:
	local.num = 0

	for(local.i = 0; local.i <= local.string.size - local.substr.size; local.i++)
	{
		local.cursubstr = waitthread substr local.string local.i local.substr.size
		
		if(local.cursubstr == local.substr)
		{
			local.num++
			local.i += local.substr.size - 1
		}
	}

end local.num

substr local.string local.start local.length:

	local.out = ""
	for(local.i = local.start; local.i < local.start + local.length; local.i++)
	{
		local.out += local.string[local.i]
	}
	
end local.out

hudmsg local.msg:

	if(getcvar level.sqdmk_cvar_verbose == level.sqdmk_cvar_str_on)
	{
		// don't echo this to clients
		println ("[SQUADMAKER]: Showing hud message: " + local.msg)
	}

	local.showtime = 0.1 * local.msg.size
	local.fadetime = 0.5
	local.fontwidth = 6.0 // px
	local.dt = 0.05
	
	local.width = local.fontwidth * local.msg.size / (1 + (waitthread stringcountsubstr local.msg "\n"))
	local.height = 80
	
	local.dx = int (getcvar level.sqdmk_cvar_huddraw_nudge_x)
	local.dy = -int (getcvar level.sqdmk_cvar_huddraw_nudge_y)
	
	huddraw_alpha  level.sqdmk_huddraw_element 1.0
	huddraw_align  level.sqdmk_huddraw_element center bottom
	huddraw_color  level.sqdmk_huddraw_element 1.0 1.0 1.0
	huddraw_font   level.sqdmk_huddraw_element "facfont-20"
	huddraw_rect   level.sqdmk_huddraw_element local.dx (local.dy-local.height) local.width local.height
	huddraw_string level.sqdmk_huddraw_element local.msg

	wait local.showtime

	// fade out
	for(local.time = 0.0; local.time <= local.fadetime; local.time += local.dt)
	{
		huddraw_alpha level.sqdmk_huddraw_element (1.0 - local.time/local.fadetime)
		wait local.dt
	}

	// just to be sure
	huddraw_alpha level.sqdmk_huddraw_element 0.0

end

string_to_array local.string local.char_seperator:

	local.j = 1
	local.array[local.j] = ""
	for(local.i = 0; local.i < local.string.size; local.i++)
	{
		local.char = local.string[local.i]
		if(local.char == local.char_seperator)
		{
			local.j++
			local.array[local.j] = ""
		}
		else
		{
			local.array[local.j] += local.char
		}
	}

end local.array
```

# zz_squadmaker\global\support\shell.scr

```scr
// support sheller
// fire in the hole :o
// by jv_map

shell local.thread:
	thread local.thread
end

// called when player raises an mg (bar or mp44)
// called from mike_torso.st
raise_weapon:

	// hardcode the reference here
	// in case this gets called when not in a _sprt map
	// we can still clean up the hud
	if (!level.sprt_main)
	{
		level.sprt_main = "global/support/support.scr"
	}

	waitframe

	if(isAlive self)
	{
		local.weap = waitthread level.sprt_main::grabweap
		
		self.sprt_last_raised_weapon = local.weap
		
		if(local.weap)
		{
			if(local.weap._sprt)
			{
				// go fuck up the hud
				self stufftext ("globalwidgetcommand weaponname itemstat -1")
				self stufftext ("globalwidgetcommand weaponname title " + local.weap.sprt_property_set.name)
				self stufftext ("globalwidgetcommand clipcount playerstat -1")
				self stufftext ("globalwidgetcommand clipcount title T")
				self stufftext ("globalwidgetcommand ammocount playerstat -1")
				self stufftext ("globalwidgetcommand ammocount linkcvar support_guntemp")
				self stufftext ("globalwidgetcommand clipbulletso playerstat -1")
				self stufftext ("globalwidgetcommand clipbulletse playerstat -1")
			}
			else
			{
				// go clean up your mess
				self stufftext ("globalwidgetcommand weaponname itemstat 1")
				self stufftext ("globalwidgetcommand clipcount playerstat 6")
				self stufftext ("globalwidgetcommand ammocount playerstat 4")
				self stufftext ("globalwidgetcommand ammocount fgcolor .7 .6 .05 1")
				self stufftext ("globalwidgetcommand clipbulletso playerstat 6")
				self stufftext ("globalwidgetcommand clipbulletse playerstat 6")
			}
		}
	}
	
end

fire_support_weapon:

	if( !self.sprt_last_raised_weapon || !self.sprt_last_raised_weapon._sprt)
	{
		println "[SUPPORT] Debug: Unexpected situation in shell::fire_support_weapon"
	}

	local.w = self.sprt_last_raised_weapon

	if(local.w.sprt_overheat_flag)
	{
		waitframe
	}
	else
	{
		// fire. fire. fire.
		
		// Feho
		// Tracer bullets ------------>
		if (self.tracerMG == NIL || self.tracerMG > 1) {
			self.tracerMG = 0
		}
		if (self.tracerMG == 1) {
			exec global/feho/tracerbullet.scr
		}
		self.tracerMG++
		//<----------------------------
		
		self viewmodelanim fire 1
		local.w shoot
		local.w.sprt_last_trigger_time = level.time
		
		// heat up
		local.w.sprt_temperature_cueue++
	
		// handle viewkick
		if( !self.sprt_viewkick_handler_active)
		{
			self.sprt_viewkick_handler_active = 1
			self.sprt_accum_viewkick = (0 0 0)
			thread viewkickhandler
		}
	
		waitthread applyviewkick local.w
	
		self forcetorsostate ATTACK_SUPPORT_FIRE
	
		wait local.w.sprt_property_set.firedelay
	}
	
	if(isAlive self)
	{
		self forcetorsostate STAND
	}

end

// prints the time to console
print_time:
	println level.time
end

// applies the viewkick
applyviewkick local.w:

	// viewkick
	local.kick = (0 0 0)
	
	for(local.i = 0; local.i <= 2; local.i++)
	{
		local.rnd = randomfloat 1.0
		local.kick[local.i] = local.rnd * local.w.sprt_property_set.viewkick_min[local.i] + (1.0 - local.rnd) * local.w.sprt_property_set.viewkick_max[local.i]
	}
	
	// multiply
	local.kick = local.kick * level.sprt_viewkick_movemult[(self getmovement)]
	
	// stand bonus
	if(self getposition != "crouching")
	{
		local.kick += (randomfloat 1.0) * level.sprt_viewkick_stand
	}
	
	// lean bonus
	local.kick += (randomfloat 1.0) * (self getcontrollerangles 0)[2]/16.0 * level.sprt_viewkick_lean * local.w.sprt_property_set.viewkick_lean_mult
	
	self.viewangles += local.kick
	self.sprt_accum_viewkick += local.kick
	
end


// viewkickhandler continues even after respawn
// (should not be a problem)
// caller should set:
// self.sprt_viewkick_handler_active = 1
// self.sprt_accum_viewkick = (0 0 0)
viewkickhandler:

	local.THRESHOLD = 0.001

	local.min_life = 1.0
	local.dietime = level.time + local.min_life
	
	while(self)
	{
		local.reduction = level.sprt_viewkick_falloff * self.sprt_accum_viewkick
		
		if(level.time > local.dietime && local.reduction * local.reduction < local.THRESHOLD)
		{
			self.viewangles -= self.sprt_accum_viewkick
			break
		}
		else
		{
			self.sprt_accum_viewkick -= local.reduction
			self.viewangles -= local.reduction
			waitframe
		}
	}
	
	if(self)
	{
		self.sprt_viewkick_handler_active = 0
	}

end
```

# zz_squadmaker\global\support\support.scr

```scr
// support gun support
// mg42 and .30cal
// by jv_map

// call this AFTER level waittill SPAWN
main:
	
	if(level.sprt_running)
	{
		end
	}
	
	level.sprt_running = 1
	
	level.sprt_path = "global/support/"
	level.sprt_config_basepath = "supportgun_config/"
	
	level.sprt_main = level.sprt_path + "support.scr"
	
	level.sprt_viewkick_falloff 	= 0.2 // per frame
	
	level.sprt_temperature_falloff 				= 0.01 // per frame not fired
	level.sprt_max_initiate_fire_temperature 	= 0.6
	level.sprt_max_temperature					= 1.0
	
	level.sprt_viewkick_lean  = (0.0 1.0 -1.0)
	level.sprt_viewkick_stand = ( -0.5 0.0 0.0)
	
	level.sprt_viewkick_movemult[standing] = 1.0
	level.sprt_viewkick_movemult[walking]  = 1.3 // only for crouchwalk :/
	level.sprt_viewkick_movemult[running]  = 1.7
	level.sprt_viewkick_movemult[falling]  = 2.3
	
	level.sprt_baseweap = "models/weapons/bar.tik"
	level.sprt_baseweaptype = "mg" // MUST be weapontype of level.sprt_baseweap
	level.sprt_baseweapname = "BAR" // MUST be the name of the level.sprt_baseweap
	
	level.sprt_cvar_prefix = "support_"
	level.sprt_cvar_droppable_respawning 	= level.sprt_cvar_prefix + "droppable_dm"
	level.sprt_cvar_droppable_nonrespawning	= level.sprt_cvar_prefix + "droppable_obj"
	level.sprt_cvar_showammobelt			= level.sprt_cvar_prefix + "showammobelt"
	level.sprt_cvar_config					= level.sprt_cvar_prefix + "config"
	
	level.sprt_cvar_str_on 	= "1"
	level.sprt_cvar_str_off = "0"
	level.sprt_cvar_config_default = "default"
	
	level.sprt_droppable_respawning 	= int(waitthread cvarconfig level.sprt_cvar_droppable_respawning level.sprt_cvar_str_off)
	level.sprt_droppable_nonrespawning 	= int(waitthread cvarconfig level.sprt_cvar_droppable_nonrespawning level.sprt_cvar_str_on)
	level.sprt_showammobelt 			= bool(waitthread cvarconfig level.sprt_cvar_showammobelt level.sprt_cvar_str_on)
	local.config 						= waitthread cvarconfig level.sprt_cvar_config level.sprt_cvar_config_default
	
	waitthread consoleprint ("[SUPPORT]: Using configuration: " + local.config)
	
	level.sprt_config_path = level.sprt_config_basepath + local.config + "/"
	level.sprt_config_path_default = level.sprt_config_basepath + level.sprt_cvar_config_default + "/"
	
	level.sprt_properties[allies] 	= spawn listener
	level.sprt_properties[axis] 	= spawn listener
	local.ok = 				level.sprt_properties[allies] 	waitexec (level.sprt_config_path + "gun_allied.scr")
	local.ok = local.ok && 	level.sprt_properties[axis] 	waitexec (level.sprt_config_path + "gun_axis.scr")
	
	if(!local.ok && local.config != level.sprt_cvar_config_default)
	{
		waitthread consoleprint ("[SUPPORT]: Failed to load config '" + local.config + "', falling back to " + level.sprt_cvar_config_default)
		
		// set config back to default
		setcvar level.sprt_cvar_config level.sprt_cvar_config_default
		
		level.sprt_properties[allies]	remove
		level.sprt_properties[axis]		remove
		level.sprt_properties[allies] 	= spawn listener
		level.sprt_properties[axis] 	= spawn listener
		
		local.ok = 				level.sprt_properties[allies] 	waitexec (level.sprt_config_path_default + "gun_allied.scr")
		local.ok = local.ok && 	level.sprt_properties[axis] 	waitexec (level.sprt_config_path_default + "gun_axis.scr")
	}
	
	if(!local.ok)
	{
		level.sprt_init_failure = 1
		waitthread consoleprint ("[SUPPORT]: Failed to load default config files in " + level.sprt_config_path_default + ". Can't spawn support gunners.")
		end
	}
	
	thread global/sqdmksupport_shared.scr::enforcestatefile "global/nagle_aa" //sqdmksupport"
end

// set default value for cvar
cvarconfig local.cvar local.df:
	if(getcvar local.cvar == "")
	{
		setcvar local.cvar local.df
	}
end (getcvar local.cvar)

// call this BEFORE level waittill PRESPAWN
soundcache:

	if(!level.master)
	{
		level.master = spawn ScriptMaster
	}

	level.master aliascache m1919_snd_fire sound/weapons/fire/50CalFire1.wav soundparms 1.05 0.2 0.95 0.1 800 4000 weapon loaded maps (getcvar mapname)

end

// self is player that should be turned 
// into a support gunner
// only gives the support gun, doesn't take anything
make_supporter local.team local.start_temperature:

	if(!level.sprt_running)
	{
		waitthread main
	}
	
	if(level.sprt_init_failure)
	{
		self iprint ("Ops! There's an error somewhere, can't give you a support gun.")
		
		if(getcvar g_gametype != "0")
		{
			self iprint ("I hope you're happy with an mg instead.")
			if(self.dmteam == allies)
			{
				self give weapons/bar.tik
			}
			else
			{
				self give weapons/mp44.tik
			}
			self useweaponclass mg
		}
		
		waitthread consoleprint ("[SUPPORT]: Support scripts didn't load properly. Can't make a support gunner.")
		end
	}
	
	if(!local.start_temperature)
	{
		local.start_temperature = 0.0
	}

	local.maxtime = 1.0

	// give him the gun
	self give level.sprt_baseweap
	self useweaponclass level.sprt_baseweaptype

	local.time_to_die = level.time + local.maxtime

	while(level.time < local.time_to_die && (!local.gun || local.gun.model != level.sprt_baseweap))
	{	
		self useweaponclass level.sprt_baseweaptype
		waitframe
		if(!isAlive self || (getcvar g_gametype != "0" && self.dmteam != local.team))
		{
			// might drop the baseweap.. but shouldn't be too problematic though
			end
		}
		
		local.gun = waitthread grabweap
	}
	
	if(!local.gun)
	{
		// probs dead or something
		end
	}
	
	local.gun.baseteam = local.team
	local.gun waitthread set_properties
	
	// make the showgun
	// this one we'll actually see :)
	// doesn't have to be a weapon as it's 
	// only for keeping up appearances
	local.showgun = spawn Animate
	local.showgun.parentgun = local.gun
	local.showgun waitthread showgun
	
	// child reference
	local.gun.showgun = local.showgun
	
	local.gun.legitimate_owner 	= self
	local.gun.sprt_weaponowner 	= self
	
	local.gun.sprt_overheat_flag = 0
	
	local.gun thread dropper
	local.gun thread fuse
	local.gun thread temperature local.start_temperature
	
	if(level.sqdmk_running && getcvar g_gametype != "0" && level.sprt_showammobelt)
	{
		thread ammobelt
	}
end

// show an ammobelt over the player's shoulders
// this requires squadmaker
ammobelt:

	if(self.sprt_has_ammo_belt)
	{
		// nvm
		end
	}

	self.sprt_has_ammo_belt = 1

	local.belt = spawn Animate model gear/heer/grenadierload.tik
	local.belt attach self "Bip01 Spine2" 1 ( -70 1 0)
	local.belt surface ammobox "+nodraw"
	local.belt angles (0 90 90)
	
	while(isAlive self && !self.sqdmk_respawn)
	{
		waitframe
	}
	
	if(local.belt)
	{
		local.belt remove
	}
	
	if(self)
	{
		self.sprt_has_ammo_belt = 0
	}

end

// handles firing of the weapon
fuse:
	
	self.sprt_last_trigger_time = 0.0
	
	while(self)
	{
		if(level.time - self.sprt_last_trigger_time <= self.sprt_property_set.firedelay)
		{
			self.showgun anim fire
			
			if(self.sprt_property_set.firing_sound)
			{
				self.showgun playsound self.sprt_property_set.firing_sound
			}
			
			waitframe
			if(self)
			{
				self.showgun anim idle	
			}
		}
		waitframe
	}
	
end

// handles dropping of the weapon
dropper:

	if(getcvar g_gametype == "0")
	{
		// can't drop weapons in sp, anyway
		end
	}

	local.can_be_dropped = (level.sprt_droppable_respawning && level.dmrespawning)^(level.sprt_droppable_nonrespawning && !level.dmrespawning)

	if(!local.can_be_dropped)
	{
		// other players cannot receive it (pick it up)
		self nottriggerable
	}

	while(self)
	{
		local.wasdropped = local.isdropped
		local.isdropped = self.angles[2] == 90.0 || self.velocity != (0 0 0)
		
		if(local.isdropped && !local.wasdropped)
		{
			self.sprt_weaponowner = NULL
			if(!local.can_be_dropped)
			{
				// can't be dropped
				local.o = self.legitimate_owner
				local.bt = self.baseteam
				if(isAlive local.o)
				{
					local.dt = local.o.dmteam
					wait 1.0
					if(isAlive local.o && local.o.dmteam == local.dt)
					{
						// could sneakily have picked up another primary weapon
						local.o waitthread takeallprimaryweapons
						local.o useweaponclass mg
						
						local.o thread make_supporter local.bt self.sprt_temperature
						local.o iprint "You'll still need that gun, soldier!"
						local.o iprint ("Reassigned " + self.sprt_property_set.name)
					}
				}
				self remove
			}
			else
			{
				// may be dropped
				self name self.sprt_property_set.name
			}
		}
		else if(!local.isdropped && local.wasdropped)
		{
			// picked up
			// use immediately so we'll see the weapon on back when holstered
			parm.other useweaponclass level.sprt_baseweaptype
			self.sprt_weaponowner = parm.other
			self name level.sprt_baseweapname
		}
		waitframe
	}
end

temperature local.start_temperature:

	self.sprt_temperature 		= local.start_temperature
	self.sprt_temperature_cueue = 0
	
	// set temp to zero
	self.sprt_weaponowner waitthread set_hud_temp self.sprt_temperature 1
	
	while(self)
	{
		if(self.sprt_weaponowner)
		{
			self.sprt_weaponowner waitthread set_hud_temp self.sprt_temperature
		}
		
		local.cur_overheat_flag = self.sprt_overheat_flag

		self.sprt_overheat_flag = self.sprt_overheat_flag || self.sprt_temperature >= level.sprt_max_temperature
		self.sprt_overheat_flag = self.sprt_overheat_flag && self.sprt_temperature >= level.sprt_max_initiate_fire_temperature
	
		if(self.sprt_overheat_flag != local.cur_overheat_flag)
		{
			self playsound m1_snd_noammo
		}
		
		if(self.sprt_temperature_cueue)
		{
			self.sprt_temperature += self.sprt_temperature_cueue * self.sprt_property_set.temperature_per_shot * level.sprt_max_temperature
			self.sprt_temperature_cueue = 0
			
			if(self.sprt_temperature > level.sprt_max_temperature)
			{
				self.sprt_temperature = level.sprt_max_temperature
			}
			wait self.sprt_property_set.firedelay
		}
		else
		{
			self.sprt_temperature -= level.sprt_temperature_falloff
			
			if(self.sprt_temperature < 0.0)
			{
				self.sprt_temperature = 0.0
			}
			waitframe
		}
	}

end

set_hud_temp local.temp local.force:

	local.color_green  	= 1
	local.color_yellow 	= 2
	local.color_red		= 3

	local.max_breakers = 9
	local.breakers = int (local.max_breakers * local.temp/level.sprt_max_temperature)

	local.str = "|"
	for(local.i = 1; local.i <= local.breakers; local.i++)
	{
		local.str += "|"
	}

	if(local.force || local.breakers != self.sprt_last_num_breakers)
	{
		self stufftext ("set support_guntemp " + local.str)
		self.sprt_last_num_breakers = local.breakers
		
		// set color
		if(local.breakers <= 5)
		{
			local.color = local.color_green
		}
		else if(local.breakers <= 7)
		{
			local.color = local.color_yellow
		}
		else
		{
			local.color = local.color_red
		}
		
		if(local.force || local.color != self.sprt_last_color)
		{
			self.sprt_last_color = local.color
			
			if(local.color == local.color_green)
			{
				self stufftext ("globalwidgetcommand ammocount fgcolor 0.0 1.0 0.0 1.0")
			}
			else if(local.color == local.color_yellow)
			{
				self stufftext ("globalwidgetcommand ammocount fgcolor 1.0 1.0 0.0 1.0")
			}
			else // red
			{
				self stufftext ("globalwidgetcommand ammocount fgcolor 1.0 0.0 0.0 1.0")
			}
		}
	}
end

set_properties:
	local.wp = level.sprt_properties[self.baseteam]
	
	self.sprt_property_set = local.wp

	self ammotype 			local.wp.ammotype
	self holstertag			local.wp.holstertag
	self holsteroffset 		local.wp.holsteroffset
	self holsterangles		local.wp.holsterangles
	
	// crap for sp
	self movementspeed 	local.wp.movementspeed
	self bulletspread -local.wp.bulletspread -local.wp.bulletspread local.wp.bulletspread local.wp.bulletspread
	self bulletdamage 	local.wp.bulletdamage
	self firedelay 		local.wp.firedelay
	//self ammorequired 0
	
	// crap for dm
	self dmmovementspeed 	local.wp.movementspeed
	self dmbulletspread -local.wp.bulletspread -local.wp.bulletspread local.wp.bulletspread local.wp.bulletspread
	self dmbulletdamage 	local.wp.bulletdamage
	self dmfiredelay 		local.wp.firedelay
	//self dmammorequired 0

	// no firespreadmult as it's just stupid
	self firespreadmult 0.0 0.0 0.0 0.0
	self dmfirespreadmult 0.0 0.0 0.0 0.0

	// hide the thing
	self surface all "+nodraw"
	
	// make the gun semiauto so it can be detected 
	// as a support gun by the state files.
	// unfort. this forces all support weapons to use the 
	// same anim set.
	self semiauto
	
	// can't fire the thing (only shoot)
	self ammo_in_clip 0
	self noammosound snd_step_paper // null.wav (no sound)

	// flag as a support weapon
	self._sprt = 1
end

showgun:

	local.wp = self.parentgun.sprt_property_set

	self model	local.wp.model
	self attach	self.parentgun "origin" 1 (local.wp.showgunoffset * local.wp.showgunscale)
	self angles	local.wp.showgunangles
	self scale	local.wp.showgunscale
	
	if(local.wp.hidesurface)
	{
		self surface local.wp.hidesurface "+nodraw"
	}
	
	// add a bipod for thrills
	local.bipod = spawn Animate model local.wp.podmodel
	local.bipod attach self local.wp.podtag 1 local.wp.podoffset
	local.bipod.angles = local.wp.podangles

end

// grabs the weap ent
grabweap:
	// good old targetname trick
	local.id = randomint 1000000
	local.tg = "_sprt" + local.id
	self weaponcommand dual targetname local.tg
	local.gun = $(local.tg)
	self weaponcommand dual targetname ""
end local.gun

takeallprimaryweapons:

	self take weapons/m1_garand.tik
	self take weapons/kar98.tik
	self take weapons/springfield.tik
	self take weapons/kar98sniper.tik
	self take weapons/thompsonsmg.tik
	self take weapons/mp40.tik
	self take weapons/bar.tik
	self take weapons/mp44.tik
	self take weapons/bazooka.tik
	self take weapons/panzerschreck.tik
	self take weapons/shotgun.tik

end

consoleprint local.txt:
	// print to server console even if developer is 0
	local.prevdev = getcvar developer
	setcvar developer "1"
	println local.txt
	setcvar developer local.prevdev
end
```

# zz_squadmaker\squadmaker_config\afrika\config_info.txt

```txt
// Config information.

// This MUST return a non-empty string with some descriptive
// text of the squad configuration (max 255 chars).
// Squadmaker uses this information to determine if a 
// user-specified configuration exists.

end "Desert War"

// End of config information. Keep this line.
```

# zz_squadmaker\squadmaker_config\afrika\divisions_allied.txt

```txt
// Allied divisions in Africa

local.a = makeArray

"Special Air Service" allied_SAS
"1st Rangers" american_ranger
"2nd Rangers" american_ranger
"6th Infantry" american_army // part of 1st Armored Division
"36th Infantry" american_army // part of 1st Armored Division
"9th Infantry" american_army

endArray

end local.a

```

# zz_squadmaker\squadmaker_config\afrika\divisions_axis.txt

```txt
// German divisions in Africa

local.a = makeArray

"5. Leichte Afrika Div" 	german_afrika_private 		german_afrika_officer
"90. Leichte Afrika Div" 	german_afrika_private 		german_afrika_officer
"164. Leichte Afrika Div" 	german_afrika_private 		german_afrika_officer
"15. Panzer Div"			german_panzer_shutze 		german_panzer_obershutze
"22. Leichte Div" 			german_wehrmacht_soldier 	german_wehrmacht_officer

endArray

end local.a

```

# zz_squadmaker\squadmaker_config\art_of_war\config_info.txt

```txt
// Config information.

// This MUST return a non-empty string with some descriptive
// text of the squad configuration (max 255 chars).
// Squadmaker uses this information to determine if a 
// user-specified configuration exists.

end "Art-Of-War"

// End of config information. Keep this line.
```

# zz_squadmaker\squadmaker_config\art_of_war\squad_allied.txt

```txt
// Allied squad definition
// This is a script file, don't make syntax errors

local.a = makeArray // don't change this line

//----------------------------
// squad definition below here
//----------------------------

// loadouts:
//----------
// rifleman
// sniper
// smg
// mg
// support
// shotgun
// bazooka

// primary weapons:
//----------
// rifle
// sniper
// smg
// mg
// bazooka
// shotgun

//----------------------------------------------------------------------------
// 	loadout			name						associated with primary weapon
//----------------------------------------------------------------------------
	smg				"Sergeant"				smg
	rifleman		"Corporal"				rifle
	support			"Private First Class"	heavy
	rifleman		"Private"				rifle
	rifleman		"Private"				rifle
	rifleman		"Private"				rifle
	rifleman		"Private"				rifle
	rifleman		"Private"				rifle

//----------------------------
// end squad definition
//----------------------------

endArray // don't change this line

end local.a // don't change this line

// don't change this line
```

# zz_squadmaker\squadmaker_config\art_of_war\squad_axis.txt

```txt
// Axis squad definition
// This is a script file, don't make syntax errors

local.a = makeArray // don't change this line

//----------------------------
// squad definition below here
//----------------------------

// loadouts:
//----------
// rifleman
// sniper
// smg
// mg
// support
// shotgun
// bazooka

// primary weapons:
//----------
// rifle
// sniper
// smg
// mg
// bazooka
// shotgun

//------------------------------------------------------------------------
// 	loadout			name					associated with primary weapon
//------------------------------------------------------------------------
	smg				"Hauptfeldwebel"		smg
	mg				"Unteroffizier"			mg
	mg				"Obergefreiter"			mg
	support			"Oberschutze"			heavy
	rifleman		"Schutze"				rifle
	rifleman		"Schutze"				rifle
	rifleman		"Schutze"				rifle
	rifleman		"Schutze"				rifle

//----------------------------
// end squad definition
//----------------------------

endArray // don't change this line

end local.a // don't change this line

// don't change this line
```

# zz_squadmaker\squadmaker_config\default\config_info.txt

```txt
// Config information.

// Name of the configuration (required).

end "Standard"

// End of config information. Keep this line.
```

# zz_squadmaker\squadmaker_config\default\divisions_allied.txt

```txt
// Allied divisions

// best viewed with 4 spaces per tab

// Skin names are without path and without .tik extensions.
// All skins must be present in the models/player folder.

// The officer skin is used for each first member of a squad. 
// If no officer skin is specified, the enlisted skin is used 
// for all squad members.

local.a = makeArray // do not modify

//-----------------------------------------------------------------
//	Division name		Enlisted skin		Officer skin (optional)
//-----------------------------------------------------------------
	"82nd Airborne" 	allied_airborne
	"101st Airborne" 	allied_airborne
	"1st Rangers" 		american_ranger
	"2nd Rangers" 		american_ranger
	"1st Infantry"		american_army
	"9th Infantry" 		american_army
//-----------------------------------------------------------------

endArray // do not modify

end local.a // do not modify

// do not modify
```

# zz_squadmaker\squadmaker_config\default\divisions_axis.txt

```txt
// German divisions

// best viewed with 4 spaces per tab

// Skin names are without path and without .tik extensions.
// All skins must be present in the models/player folder.

// The officer skin is used for each first member of a squad. 
// If no officer skin is specified, the enlisted skin is used 
// for all squad members.

local.a = makeArray // do not modify

//-------------------------------------------------------------------------------------
//	Division name					Enlisted skin				Officer skin (optional)
//-------------------------------------------------------------------------------------
	"16. Panzer Div" 				german_panzer_grenadier
	"5. SS Panzergrenadier Div"		german_panzer_shutze 		german_panzer_obershutze
	"1. SS Div" 					german_waffenss_shutze 		german_waffenss_officer
	"22. Leichte Div" 				german_wehrmacht_soldier 	german_wehrmacht_officer
//-------------------------------------------------------------------------------------

endArray // do not modify

end local.a // do not modify

// do not modify
```

# zz_squadmaker\squadmaker_config\default\hudmessages.txt

```txt
// Messages for the hud
// by jv_map

// Best viewed with 4 spaces per tab

/* 
Hud commands:
-----------------
SPLASH  				: Standard squadmaker title screen (= "Squadmaker " VERSION " " CONFIG "\nby " AUTHOR)
TIP1					: Join a team to become part of a squad.
TIP2					: Your weapon depends on your role in the squad.
TIP3 weapon				: The support gun is the heaviest weapon in your squad, select the <weapon> to use it.
TIP4					: Use left/right click to swiftly (un)holster the support gun.
ORDER_OF_BATTLE	team	: Lists squads of specified team (e.g. 'ORDER_OF_BATTLE allies' or 'ORDER_OF_BATTLE axis')
AREANAME				: Prints level.squadmaker_areaname or "in the area" if not specified.
CVAR name				: Prints data of any cvar on server (e.g. 'CVAR sv_hostname' prints server hostname)
VERSION					: Squadmaker version number
AUTHOR					: Prints 'jv_map'
CONFIG					: Prints config in the form 'Config1 on Config2 on Config3 ...'

Spaces are pruned unless quotes (") are used.
Use '\n' for a line break.
All commands and their arguments are case-sensitive.
All arguments are required (never optional).
*/

local.a = makeArray

	// hud messages here
	SPLASH
	"You're playing " CVAR g_gametypestring " on\n" CVAR sv_hostname
	TIP1
	TIP2
	TIP3 "Rocket Launcher"
	TIP4
	"Allied forces " AREANAME ":\n" ORDER_OF_BATTLE allies
	"German resistance " AREANAME ":\n" ORDER_OF_BATTLE axis
	// end hud messages

endArray

end local.a
// keep this line
```

# zz_squadmaker\squadmaker_config\default\loadout.scr

```scr
// Infantry type loadouts
// by jv_map

// this is used to tell squadmaker
// we're using a custom loadout.scr
// in this config instead of falling 
// back to the default
let_them_know_im_here:
end 1

// Allied loadouts
loadout_allies local.type:

	self.sprt_is_support_gunner = local.type == "support"

	switch(local.type)
	{
		mg:
			self give models/weapons/bar.tik
			self useweaponclass mg
			
			local.pistol 	= 1
			local.grenades	= 1
			local.binocs 	= 1
			
			break		
		smg:
			self give models/weapons/thompsonsmg.tik
			self useweaponclass smg
			
			local.pistol 	= 1
			local.grenades 	= 2
			local.binocs 	= 1
			
			break
		sniper:
			self give models/weapons/springfield.tik
			self useweaponclass rifle
			
			local.pistol 	= 1
			local.grenades 	= 2
			local.binocs 	= 1
			
			break
			
			// Support type requires support gunner mod
			// to be present (mod by jv_map)
		support:
			thread global/support/support.scr::make_supporter allies
			
			local.pistol 	= 0
			local.grenades 	= 0
			local.binocs 	= 1
			
			break
			
			// *blegh*, but in case someone wants them :/
		shotgun:
			self give models/weapons/shotgun.tik
			self useweaponclass heavy
		
			local.pistol 	= 0
			local.grenades 	= 2
			local.binocs	= 1
		
			break
			
			// *blegh*, but in case someone wants them :/
		bazooka:
			self give models/weapons/bazooka.tik
			self useweaponclass heavy
			
			local.pistol	= 1
			local.grenades	= 0
			local.binocs	= 1 // should be able to see em panzers from a long way
			break
		
		// the common soldier :)
		rifleman:
		default:
			self give models/weapons/m1_garand.tik
			self useweaponclass rifle
			
			local.pistol 	= 1
			local.grenades 	= 4
			local.binocs 	= 1
			
			break
	}
	
	if(local.pistol)
	{
		// give pistol
		self give models/weapons/colt45.tik
	}
	
	if(local.binocs)
	{
		// give binocs
		self give models/items/binoculars.tik
	}
	
	if(local.grenades)
	{
		// give right ammount of nades
		self item models/weapons/m2frag_grenade.tik
		self ammo grenade (local.grenades - level.sqdmk_grenade_start_ammo)
	}
	
end

// Axis loadouts
loadout_axis local.type:

	self.sprt_is_support_gunner = local.type == "support"

	switch(local.type)
	{
		mg:
			self give models/weapons/mp44.tik
			self useweaponclass mg
			
			local.pistol 	= 1
			local.grenades	= 1
			local.binocs 	= 1
			
			break
		smg:
			self give models/weapons/mp40.tik
			self useweaponclass smg
			
			local.pistol 	= 1
			local.grenades	= 2
			local.binocs 	= 1
			
			break
		sniper:
			self give models/weapons/kar98sniper.tik
			self useweaponclass rifle
			
			local.pistol 	= 1
			local.grenades	= 2
			local.binocs 	= 1

			break
			
		// Support type requires support gunner mod
		// to be present (mod by jv_map)
		support:
			thread global/support/support.scr::make_supporter axis
			
			local.pistol 	= 0
			local.grenades	= 0
			local.binocs 	= 1
			
			break
			
		// *blegh*, but in case someone wants them :/
		shotgun:
			self give models/weapons/shotgun.tik
			self useweaponclass heavy
		
			local.pistol 	= 0
			local.grenades 	= 2
			local.binocs	= 1
		
			break
			
			// *blegh*, but in case someone wants them :/
		bazooka:
			self give models/weapons/panzerschreck.tik
			self useweaponclass heavy
			
			local.pistol	= 1
			local.grenades	= 0
			local.binocs	= 1 // should be able to see em shermans from a long way
			break
			
		rifleman:
		default:
			self give models/weapons/kar98.tik
			self useweaponclass rifle
			
			local.pistol 	= 1
			local.grenades	= 4
			local.binocs 	= 1
			
			break
	}
	
	if(local.pistol)
	{
		self give models/weapons/p38.tik
	}
	
	if(local.binocs)
	{
		// give binocs
		self give models/items/binoculars.tik
	}
	
	if(local.grenades)
	{
		// get 6 grenades unless some are taken away
		self give models/weapons/steilhandgranate.tik
		self ammo grenade (local.grenades - level.sqdmk_grenade_start_ammo)
	}
end
```

# zz_squadmaker\squadmaker_config\default\squad_allied.txt

```txt
// Allied squad definition
// This is a script file, don't make syntax errors

// best viewed with 4 spaces per tab

local.a = makeArray // don't change this line

//----------------------------
// squad definition below here
//----------------------------

// loadouts:
//----------
// rifleman
// sniper
// smg
// mg
// support
// shotgun
// bazooka

// primary weapons:
//----------
// rifle
// sniper
// smg
// mg
// heavy
// shotgun

// You may change the size of the squad by adding/removing lines.

//----------------------------------------------------------------------------
// 	loadout			name						associated with primary weapon
//----------------------------------------------------------------------------
	rifleman		"Rifleman"					rifle
	rifleman		"Rifleman"					rifle
	rifleman		"Rifleman"					rifle
	rifleman		"Rifleman"					rifle
	sniper			"Sniper"					sniper
	sniper			"Sniper"					sniper
	sniper			"Sniper"					sniper
	sniper			"Sniper"					sniper
	smg				"Scout"						smg
	smg				"Scout"						smg
	smg				"Scout"						smg
	smg				"Scout"						smg
	mg				"Light machine gunner"		mg
	mg				"Light machine gunner"		mg
	mg				"Light machine gunner"		mg
	mg				"Light machine gunner"		mg
	shotgun			"Hunter"					shotgun
	support			"Support gunner"			heavy


//----------------------------
// end squad definition
//----------------------------

endArray // don't change this line

end local.a // don't change this line

// don't change this line
```

# zz_squadmaker\squadmaker_config\default\squad_axis.txt

```txt
// Axis squad definition
// This is a script file, don't make syntax errors

// best viewed with 4 spaces per tab

local.a = makeArray // don't change this line

//----------------------------
// squad definition below here
//----------------------------

// loadouts:
//----------
// rifleman
// sniper
// smg
// mg
// support
// shotgun
// bazooka

// primary weapons:
//----------
// rifle
// sniper
// smg
// mg
// heavy
// shotgun

// You may change the size of the squad by adding/removing lines.

//------------------------------------------------------------------------
// 	loadout			name					associated with primary weapon
//------------------------------------------------------------------------
	rifleman		"Schutze"				rifle
	rifleman		"Schutze"				rifle
	rifleman		"Schutze"				rifle
	rifleman		"Schutze"				rifle
	sniper			"Heckenschutze"			sniper
	sniper			"Heckenschutze"			sniper
	sniper			"Heckenschutze"			sniper
	sniper			"Heckenschutze"			sniper
	smg				"Hauptmann"				smg
	smg				"Hauptmann"				smg
	smg				"Hauptmann"				smg
	smg				"Hauptmann"				smg
	mg				"Sturmmann"				mg
	mg				"Sturmmann"				mg
	mg				"Sturmmann"				mg
	mg				"Sturmmann"				mg
	shotgun			"Hunter"				shotgun
	support			"Grenadier"				heavy




//----------------------------
// end squad definition
//----------------------------

endArray // don't change this line

end local.a // don't change this line

// don't change this line
```

# zz_squadmaker\squadmaker_config\default\squadnames_allied.txt

```txt
// Allied squad names
// use '#' for the squad number
// US Joint Army/Navy (JAN) Phonetic Alphabet (1941)

local.a = makeArray // do not modify

	// start squad names
	// add/remove any lines as needed
	"Able Squad"
	"Baker Squad"
	"Charlie Squad"
	"Dog Squad"
	"Easy Squad"
	"Fox Squad"
	"George Squad"
	"How Squad"
	"Item Squad"
	"Jig Squad"
	"King Squad"
	"Love Squad"
	"Mike Squad"
	"Nan Squad"
	"Oboe Squad"
	"Peter Squad"
	"Queen Squad"
	"Roger Squad"
	"Sail Squad"
	"Tare Squad"
	"Uncle Squad"
	"Victor Squad"
	"William Squad"
	"X-ray Squad"
	"Yoke Squad"
	"Zebra Squad"
	// end squad names

endArray // do not modify

end local.a // do not modify

end // keep this line
```

# zz_squadmaker\squadmaker_config\default\squadnames_axis.txt

```txt
// Axis squad names
// use '#' for the squad number

local.a = makeArray // do not modifty

	// start squad names
	// add any lines as needed
	"#. Gruppe"
	// end squad names
	
endArray // do not modify

end local.a // do not modify

end // keep this line
```

# zz_squadmaker\squadmaker_config\winterwar\config_info.txt

```txt
// Config information.

// This MUST return a non-empty string with some descriptive
// text of the squad configuration (max 255 chars).
// Squadmaker uses this information to determine if a 
// user-specified configuration exists.

end "Winter War"

// End of config information. Keep this line.
```

# zz_squadmaker\squadmaker_config\winterwar\divisions_allied.txt

```txt
// Allied divisions in Ardennes

local.a = makeArray

"101st Airborne" allied_airborne
"6th Infantry" american_ranger
"36th Infantry" american_army
"9th Infantry" american_army

endArray

end local.a

```

# zz_squadmaker\squadmaker_config\winterwar\divisions_axis.txt

```txt
// German divisions in Ardennes

local.a = makeArray

"6. Leichte Div" 			german_wehrmacht_soldier 	german_wehrmacht_officer
"1. SS Div" 				german_winter_1
"36. Volksgrenadier Div" 	german_winter_2
"5. SS Panzergrenadier Div"	german_panzer_shutze 		german_panzer_obershutze

endArray

end local.a

```

# zz_squadmaker\supportgun_config\default\gun_allied.scr

```scr
// .30cal (taktaktak) properties
// by jv_map

main:
	self.name 			= "M1919"
	self.normalteam		= allies
	self.model 			= "models/vehicles/jeep_30cal.tik"
	
	self.firedelay		= 0.10 // 600 rpm
	self.bulletdamage	= 30.0
	
	self.ammotype		= "Support"
	self.movementspeed	= 0.4
	
	self.holstertag		= "Bip01 Spine2"
	self.holsteroffset 	= ( -30 -2 0)
	self.holsterangles 	= ( -10 -10 89)

	self.showgunoffset 	= (18 0 62) //(0 -19 62)
	self.showgunangles  = (180 180 0) //(180 90 0)
	self.showgunscale	= 0.8
	
	self.podmodel 		= "models/statweapons/mg42_bipod_nonstatic.tik"
	self.podtag 		= "pitch"
	self.podoffset 		= (1 0 0)
	self.podangles		= (0 90 0)
	
	self.bulletspread	= 45.0
	
	self.viewkick_min	= ( -1.2 -0.25 -1.0)
	self.viewkick_max	= ( -0.8 0.25  1.0)
	
	self.viewkick_lean_mult = 1.0
	
	self.temperature_per_shot = 0.009 // in fraction of max temperature
	
	// lil hack
	self.hidesurface	= "mount"
	self.firing_sound 	= "m1919_snd_fire"
end 1 // MUST return 1

```

# zz_squadmaker\supportgun_config\default\gun_axis.scr

```scr
// mg42 (prrrrrrrt) properties
// by jv_map

main:
	self.name 			= "MG42"
	self.normalteam		= axis
	self.model 			= "models/statweapons/mg42_gun.tik"
	
	self.firedelay		= 0.05 // 1200 rpm
	self.bulletdamage	= 15.0
	
	self.ammotype		= "Support"
	self.movementspeed	= 0.4
	
	self.holstertag		= "Bip01 Spine2"
	self.holsteroffset 	= ( -15.0 -7.0 0.0)
	self.holsterangles 	= (15 0 170)
	
	self.showgunoffset 	= (36 0 0) //(37 0 0)
	self.showgunangles  = (0 0 180)
	self.showgunscale	= 1.0
	
	self.podmodel 		= "models/statweapons/mg42_bipod_nonstatic.tik"
	self.podtag 		= "tag_barrel"
	self.podoffset 		= ( -12 -1 0)
	self.podangles		= (0 0 0)
	
	self.bulletspread	= 45.0
	
	self.viewkick_min	= ( -1.0 -0.25 -1.0)
	self.viewkick_max	= ( 0.0  0.25  1.0)
	
	self.viewkick_lean_mult = 0.35 // a bit too heavy
	
	self.temperature_per_shot = 0.0045 // in fraction of max temperatures
end 1 // MUST return 1

```

# zz_squadmaker\supportgun_config\equal\gun_allied.scr

```scr
// .30cal (taktaktak) properties
// by jv_map

main:
	self.name 			= "M1919"
	self.normalteam		= allies
	self.model 			= "models/vehicles/jeep_30cal.tik"
	
	self.firedelay		= 0.10 // 600 rpm
	self.bulletdamage	= 30.0
	
	self.ammotype		= "Support"
	self.movementspeed	= 0.4
	
	self.holstertag		= "Bip01 Spine2"
	self.holsteroffset 	= ( -30 -2 0)
	self.holsterangles 	= ( -10 -10 89)

	self.showgunoffset 	= (18 0 62)
	self.showgunangles  = (180 180 0)
	self.showgunscale	= 0.8
	
	self.podmodel 		= "models/statweapons/mg42_bipod_nonstatic.tik"
	self.podtag 		= "pitch"
	self.podoffset 		= (1 0 0)
	self.podangles		= (0 90 0)
	
	self.bulletspread	= 45.0
	
	self.viewkick_min	= ( -1.2 -0.25 -1.0)
	self.viewkick_max	= ( -0.8 0.25  1.0)
	
	self.viewkick_lean_mult = 1.0
	
	self.temperature_per_shot = 0.009 // in fraction of max temperature
	
	// lil hack
	self.hidesurface	= "mount"
	self.firing_sound 	= "m1919_snd_fire"
end 1 // MUST return 1

```

# zz_squadmaker\supportgun_config\equal\gun_axis.scr

```scr
// mg42 (prrrrrrrt) properties
// by jv_map

main:
	self.name 			= "MG42"
	self.normalteam		= axis
	self.model 			= "models/statweapons/mg42_gun.tik"
	
	self.firedelay		= 0.10 // 1200 rpm
	self.bulletdamage	= 30.0
	
	self.ammotype		= "Support"
	self.movementspeed	= 0.4
	
	self.holstertag		= "Bip01 Spine2"
	self.holsteroffset 	= ( -15.0 -7.0 0.0)
	self.holsterangles 	= (15 0 170)
	
	self.showgunoffset 	= (36 0 0)
	self.showgunangles  = (0 0 180)
	self.showgunscale	= 1.0
	
	self.podmodel 		= "models/statweapons/mg42_bipod_nonstatic.tik"
	self.podtag 		= "tag_barrel"
	self.podoffset 		= ( -12 -1 0)
	self.podangles		= (0 0 0)
	
	self.bulletspread	= 45.0
	
	self.viewkick_min	= ( -1.2 -0.25 -1.0)
	self.viewkick_max	= ( -0.8 0.25  1.0)
	
	self.viewkick_lean_mult = 1.0
	
	self.temperature_per_shot = 0.0045 // in fraction of max temperature
end 1 // MUST return 1

```

# zz_squadmaker\supportgun_config\realism\gun_allied.scr

```scr
// .30cal (taktaktak) properties
// by jv_map

main:
	self.name 			= "M1919"
	self.normalteam		= allies
	self.model 			= "models/vehicles/jeep_30cal.tik"
	
	self.firedelay		= 0.10 // 600 rpm
	self.bulletdamage	= 90 //45.0
	
	self.ammotype		= "Support"
	self.movementspeed	= 0.4
	
	self.holstertag		= "Bip01 Spine2"
	self.holsteroffset 	= ( -30 -2 0)
	self.holsterangles 	= ( -10 -10 89)

	self.showgunoffset 	= (18 0 62) //(0 -19 62)
	self.showgunangles  = (180 180 0) //(180 90 0)
	self.showgunscale	= 0.8
	
	self.podmodel 		= "models/statweapons/mg42_bipod_nonstatic.tik"
	self.podtag 		= "pitch"
	self.podoffset 		= (1 0 0)
	self.podangles		= (0 90 0)
	
	self.bulletspread	= 45.0
	
	self.viewkick_min	= ( -1.2 -0.25 -1.0)
	self.viewkick_max	= ( -0.8 0.25  1.0)
	
	self.viewkick_lean_mult = 1.0
	
	self.temperature_per_shot = 0.02 // 0.011 // in fraction of max temperature
	
	// lil hack
	self.hidesurface	= "mount"
	self.firing_sound 	= "m1919_snd_fire"
end 1 // MUST return 1

```

# zz_squadmaker\supportgun_config\realism\gun_axis.scr

```scr
// mg42 (prrrrrrrt) properties
// by jv_map

main:
	self.name 			= "MG42"
	self.normalteam		= axis
	self.model 			= "models/statweapons/mg42_gun.tik"
	
	self.firedelay		= 0.05 // 1200 rpm
	self.bulletdamage	= 45 //22.5
	
	self.ammotype		= "Support"
	self.movementspeed	= 0.4
	
	self.holstertag		= "Bip01 Spine2"
	self.holsteroffset 	= ( -15.0 -7.0 0.0)
	self.holsterangles 	= (15 0 170)
	
	self.showgunoffset 	= (36 0 0) //(37 0 0)
	self.showgunangles  = (0 0 180)
	self.showgunscale	= 1.0
	
	self.podmodel 		= "models/statweapons/mg42_bipod_nonstatic.tik"
	self.podtag 		= "tag_barrel"
	self.podoffset 		= ( -12 -1 0)
	self.podangles		= (0 0 0)
	
	self.bulletspread	= 45.0
	
	self.viewkick_min	= ( -1.0 -0.25 -1.0)
	self.viewkick_max	= ( 0.0  0.25  1.0)
	
	self.viewkick_lean_mult = 0.35 // a bit too heavy
	
	self.temperature_per_shot = 0.01 // 0.0055 // in fraction of max temperatures
end 1 // MUST return 1

```

# zz_veersmods\global\AA\accounts.scr

```scr
main:

	level.account = getcvar "sv_account"
	if (level.account == "")
		setcvar "sv_account" "0"

	level.account = int ( getcvar "sv_account" )
	if (level.account == 0)
		end

	level.rewards = waitexec rewards.txt
	if (level.rewards == NIL)
	{
		level.account = 0
		end
	}

	if ( getcvar "reset_login" != "1" )
		waitthread reset_login

	// Rewards
	// [1] - reward's name
	// [2] - reward's price
	// [3] - reward's type for the script
	// [4] - if reward needs to reset after restart

	level.cash_id = 51

	level.rewards_background_id = 166
	level.rewards_hud_id = level.rewards_background_id + 1
	level.rewards_x = 50
	level.rewards_y = 155
	level.rewards_x2 = level.rewards_x + 137
	level.rewards_white = ( 1.0 1.0 1.0 )
	level.rewards_green = ( 0.0 1.0 0.0 )
	level.rewards_yellow = ( 1.0 1.0 0.0 )
	level.rewards_blue = ( 0.04 0.85 0.96 )

	level.rewards_size = level.rewards.size
	if (level.rewards_size > 26)
		level.rewards_size = 26

end

init_account local.command local.datas:

	if (level.account != 1)
		end

	switch (local.command)
	{
		case "rew_reg":
			if (self.logged_in == 1)
			{
				self iprint "You are logged in. Please log out to create another account." 1
				end
			}

			local.strings = waitthread separate_strings local.datas
			if ( local.strings == NIL || local.strings.size != 2 )
			{
				self iprint "Something is wrong with your registration datas." 1
				end
			}

			local.existing_account = waitthread existing_account local.strings[1]
			if (local.existing_account == 1)
			{
				self iprint "This account is already existing." 1
				end
			}

			local.check_chars = waitthread check_characters local.strings[1]
			if (local.check_chars != 1)
			{
				self iprint "Your username contains not allowed ( / : * ? < > | ) character(s)." 1
				end
			}

			local.username = local.strings[1]
			local.password = local.strings[2]

			thread global/AA/reward_store.scr::update_rewards local.username local.password

			self iprint "You successfully generated an account."
			conprintf ( "<--ACCOUNT SYSTEM--> '" + (netname self) + "' generated an account.\n" )

			self thread admin_message "generated"
			self thread login_message
		break
		case "rew_login":
			if (self.logged_in == 1)
			{
				self iprint "You already logged in." 1
				end
			}

			local.strings = waitthread separate_strings local.datas
			if ( local.strings == NIL || local.strings.size != 2 )
			{
				self iprint "Something is wrong with your login datas." 1
				end
			}

			local.existing_account = waitthread existing_account local.strings[1]
			if (local.existing_account != 1)
			{
				self iprint "This account doesn't exist." 1
				end
			}

			local.username = local.strings[1]
			local.password = local.strings[2]

			local.check_password = waitthread check_password local.username local.password
			if (local.check_password != 1)
			{
				self iprint "Wrong password." 1
				end
			}

			local.other_user = waitthread check_other_user local.username
			if (local.other_user == 1)
			{
				self iprint "Somebody else is using your account now." 1
				end
			}

			self.logged_in = 1
			self.rew_username = local.username
			self.rew_password = local.password

			thread global/AA/reward_market.scr::check_rewards self.rew_username self.rew_password

			self iprint ( "You logged in into your '" + local.username + "' account." )
			conprintf ( "<--ACCOUNT SYSTEM--> '" + (netname self) + "' logged in into his account.\n" )

			self thread admin_message "login"

			self stufftext ( "bind F7 keyp 1001" )
			self stufftext ( "bind F8 keyp 1002" )

			ihuddraw_alpha self 49 0
			ihuddraw_alpha self 50 0

			wait 1

			if (self == NULL)
				end

			self iprint "To open the reward market press F7 or type in console: keyp 1001"
			self iprint "To open your reward store press F8 or type in console: keyp 1002"
		break
		case "rew_logout":
			if (int local.datas != 1)
				end

			if (self.logged_in == 1)
			{
				local.username = self.rew_username

				self.logged_in = 0
				self.rew_username = NIL
				self.rew_password = NIL

				self thread global/AA/reward_store.scr::reset_rewards
				self thread delete_login local.username

				self iprint ( "You logged out from your '" + local.username + "' account." )
				conprintf ( "<--ACCOUNT SYSTEM--> '" + (netname self) + "' logged out from his account.\n" )

				self thread admin_message "logout"
			}
			else
				self iprint "You are not logged in." 1
		break
	}

end

admin_message local.type:

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.isplayer == 1 )
		{
			if ( local.player isadmin == 1 && self != local.player )
			{
				switch (local.type)
				{
					case "generated":
						local.player iprint ( "<--ACCOUNT SYSTEM--> '" + (netname self) + "' generated an account." )
					break
					case "login":
						local.player iprint ( "<--ACCOUNT SYSTEM--> '" + (netname self) + "' logged in." )
					break
					case "logout":
						local.player iprint ( "<--ACCOUNT SYSTEM--> '" + (netname self) + "' logged out." )
					break
				}
			}
		}
	}

end

print_logged_players:

	self iprint "LOGGED PLAYERS:" 1

	wait .5

	if (self == NULL)
		end

	local.amount = 0
	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.isplayer == 1 && local.player.logged_in == 1 )
		{
			if (local.player != self)
				self iprint ( (local.amount + 1) + ". " + (netname local.player) )
			else
				self iprint ( (local.amount + 1) + ". " + (netname local.player) + " (YOU)" )

			local.amount++
		}
	}

	if (local.amount == 0)
		self iprint "Nobody logged in."

end

save_login:

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.logged_in == 1 )
		{
			local.id = local.player waitthread global/AA/files.scr::player_identification (netname local.player)

			if (local.content == NIL)
				local.content[1] = ( "name=" + local.id + "username=" + local.player.rew_username + "\n" )
			else
				local.content[local.content.size + 1] = ( "name=" + local.id + "username=" + local.player.rew_username + "\n" )

			for (local.j = 1;local.j <= level.rewards_size;local.j++)
			{
				local.rew = level.rewards[local.j][3]
				local.rew_value = local.player.reward_activated[local.j]
				local.rew_reset = int (level.rewards[local.j][4])

				if ( local.rew_value == 1 && local.rew_reset != 1 )
				{
					if (local.content == NIL)
						local.content[1] = local.rew + "=" + local.rew_value + "\n"
					else
						local.content[local.content.size + 1] = local.rew + "=" + local.rew_value + "\n"
				}
			}
		}
	}

	if (local.content == NIL)
	{
		local.file = fopen "main/global/accounts/logged_players.txt" "w"
		local.close = fclose local.file

		end
	}

	thread global/AA/files.scr::save_new_file "main/global/accounts/logged_players.txt" local.content

end

delete_login local.username:

	local.content = waitthread global/AA/files.scr::string_lines "main/global/accounts/logged_players.txt"
	if (local.content == NIL)
		end

	if (self == NULL)
		end

	local.id = self waitthread global/AA/files.scr::player_identification (netname self)
	local.string = ( "name=" + local.id + "username=" + local.username + "\n" )

	local.line = waitthread global/AA/files.scr::string_to_find local.content local.string
	if (local.line != NIL)
	{
		if (local.content.size > local.line)
		{
			for (local.i = local.line + 1;local.i <= local.content.size;local.i++)
			{
				if (local.content[local.i].size > 5)
				{
					if ( local.content[local.i][0] == "n" && local.content[local.i][1] == "a" && local.content[local.i][2] == "m" && local.content[local.i][3] == "e" && local.content[local.i][4] == "=" )
					{
						local.next_line = local.i
						break
					}
				}
			}
		}

		for (local.i = 1;local.i <= local.content.size;local.i++)
		{
			if (local.i != local.line)
			{
				if ( local.i < local.line || ( local.i > local.line && local.next_line != NIL && local.i >= local.next_line ) )
				{
					if (local.new_content == NIL)
						local.new_content[1] = local.content[local.i]
					else
						local.new_content[local.new_content.size + 1] = local.content[local.i]
				}
			}
			else
			{
				if (local.next_line == NIL)
					break
			}
		}

		if (local.new_content == NIL)
		{
			local.file = fopen "main/global/accounts/logged_players.txt" "w"
			local.close = fclose local.file

			end
		}

		thread global/AA/files.scr::save_new_file "main/global/accounts/logged_players.txt" local.new_content
	}

end

existing_account local.username:

	local.filepath = "main/global/accounts/" + local.username + ".txt"
	if ( fexists local.filepath )
		end 1

end 0

check_login:

	local.content = waitthread global/AA/files.scr::string_lines "main/global/accounts/logged_players.txt"
	if (local.content == NIL)
	{
		self thread register_message
		end
	}

	local.id = self waitthread global/AA/files.scr::player_identification (netname self)
	local.string = ( "name=" + local.id + "\n" )

	local.line = waitthread global/AA/files.scr::string_to_find local.content local.string
	if (local.line != NIL)
	{
		local.username = waitthread global/AA/files.scr::right local.content[local.line] "username="

		local.text = waitthread global/AA/files.scr::string_lines ( "main/global/accounts/" + local.username + ".txt" )
		local.pw = waitthread global/AA/files.scr::right local.text[1] "password="

		self.logged_in = 1
		self.rew_username = local.username
		self.rew_password = local.pw

		waitthread global/AA/reward_market.scr::check_rewards self.rew_username self.rew_password
		waitthread global/AA/reward_store.scr::check_activated_rewards local.content (local.line + 1)

		self iprint ( "You logged in into your '" + local.username + "' account." )

		self thread admin_message "login"
	}
	else
		self thread register_message

end

check_password local.username local.password:

	local.text = waitthread global/AA/files.scr::string_lines ( "main/global/accounts/" + local.username + ".txt" )
	if (local.text == NIL)
		end 0

	local.pw = waitthread global/AA/files.scr::right local.text[1] "password="
	if (local.password != local.pw)
		end 0

end 1

check_other_user local.username:

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.isplayer == 1 )
		{
			if ( local.player.logged_in == 1 && local.player.rew_username == local.username )
				end 1
		}
	}

end 0

check_characters local.name:

	local.no_chars[1] = "\"
	local.no_chars[2] = "/"
	local.no_chars[3] = ":"
	local.no_chars[4] = "*"
	local.no_chars[5] = "?"
	local.no_chars[6] = "<"
	local.no_chars[7] = ">"
	local.no_chars[8] = "|"

	for (local.i = 0;local.i < local.name.size;local.i++)
	{
		local.char = local.name[local.i]
		if ( local.char == string local.no_chars[1] || local.char == string local.no_chars[2] || local.char == string local.no_chars[3] || local.char == string local.no_chars[4] || local.char == string local.no_chars[5] || local.char == string local.no_chars[6] || local.char == string local.no_chars[7] || local.char == string local.no_chars[8] )
			end 0
	}

end 1

register_message:

	local.msg = (
		"Welcome to the server!" + "\n" +
		"Register new account or login." + "\n" +
		"Enable the console in Options/Advanced." + "\n" +
		"To register type in console: scmd rew_reg yourusername yourpassword" + "\n" +
		"You can register any username and password." + "\n" +
		"Don't use space characters in username and password neither." + "\n"
		)

	wait 2

	if ( self != NULL && self.logged_in != 1 )
	{
		self exec global/AA/message.scr 270 50 361 78 0.75 local.msg "fromright" 1 0.5 60
	}

end

login_message:

	local.msg = (
		"Your account succesfully generated." + "\n" +
		"You can login now." + "\n" +
		"Type in console: scmd rew_login yourusername yourpassword" + "\n" +
		"After login you can earn cash and buy rewards." + "\n" +
		"To log out: scmd rew_logout 1" + "\n"
		)

	self exec global/AA/message.scr 316 50 314 66 0.75 local.msg "fromright" 1 0.5 60

end

separate_strings local.datas:

	local.chars = ""

	for (local.i = 0;local.i < local.datas.size;local.i++)
	{
		local.space = chartoint local.datas[local.i]
		if (local.space != 32)
			local.chars += local.datas[local.i]

		if ( local.space == 32 || local.i + 1 == local.datas.size )
		{
			if (local.strings == NIL)
				local.strings[1] = local.chars
			else
				local.strings[local.strings.size + 1] = local.chars

			local.chars = ""
		}
	}

end local.strings

reset_login:

	setcvar "reset_login" "1"

	local.filepath = "main/global/accounts/logged_players.txt"
	local.file = fopen local.filepath "w"
	local.close = fclose local.file

end

```

# zz_veersmods\global\AA\airstrike.scr

```scr
main:

	if ( level.airstrike_startpoints == NIL || level.airstrike_startpoints == NULL )
	{
		if ($airstrike_startpoint.size > 0)
		{
			for (local.i = 1;local.i <= $airstrike_startpoint.size;local.i++)
			{
				local.startpoint = $airstrike_startpoint[local.i].origin

				if ( level.airstrike_startpoints == NIL || level.airstrike_startpoints == NULL )
					level.airstrike_startpoints[1] = local.startpoint
				else
					level.airstrike_startpoints[level.airstrike_startpoints.size + 1] = local.startpoint
			}
		}
		else
		{
			self iprint "Airstrike is not available on this map." 1
			end
		}
	}

	self.binoculars_fire = 0

	if (self.airstrike_recharged == NIL)
		self.airstrike_recharged = 1

	if (self.airstrike_help != 1)
	{
		self.airstrike_help = 1
		self iprint "Use your binoculars and press the attack button to call for Airstrike!" 1
	}

	if (self.airstrike_message == 1)
	{
		self.airstrike_message = 0

		self iprint "Airstrike is ready!" 1

		self playsound airstrike_ready
	}

	if (self.max_airstrike == NIL)
		self.max_airstrike = 4

	if (self.current_airstrike == NIL)
		self.current_airstrike = self.max_airstrike

	self give models/items/binoculars.tik

	while ( self != NULL && self.player_spawned == 1 )
	{
		if (self.binoculars_fire == 1)
		{
			self.binoculars_fire = 0

			if (self.current_airstrike == 0)
				self iprint "You are out of Airstrike." 1
			else
			{
				if (self.airstrike_recharged == 1)
				{
					if (level.airspace_occupied != 1)
					{
						self.airstrike_recharged = 0
						level.airspace_occupied = 1

						self.current_airstrike--

						self thread reloading_airstrike

						local.pos = self gettagposition "eyes bone"
						local.angles = angles_toforward self.viewangles
						local.trace = waitexec global/AA/trace.scr local.pos ( local.pos + local.angles * 20000 ) self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569441

						self thread start_planes local.trace["endPos"] self.dmteam
					}
					else
						self iprint "Airspace is occupied!" 1
				}
				else
					self iprint "You can't call for Air Support now!" 1
			}
		}

		waitframe
	}

end

reloading_airstrike:

	if (self.current_airstrike == 0)
		end

	local.time = 60

	wait local.time

	if (self == NULL)
		end

	if ( self.player_spawned == 1 && self.airstrike == 1 )
	{
		self iprint "Airstrike is ready!" 1

		self playsound airstrike_ready
	}
	else
		self.airstrike_message = 1

	self.airstrike_recharged = 1

end

start_planes local.pos local.team:

	if (self.current_airstrike > 0)
		self iprint ( "You can call for Airstrike " + self.current_airstrike + " times." ) 1
	else
		self iprint "You are out of Airstrike." 1

	self playsound airstrike_target

	local.fx = self waitthread strike_marker local.pos

	self dmmessage -1 ( "FRIENDLY AIRSTRIKE ON THE WAY!!!" )

	local.origin = ( local.pos[0] local.pos[1] 0 )
	for (local.i = 1;local.i < level.airstrike_startpoints.size;local.i++)
	{
		if (local.point == NIL)
			local.point = ( level.airstrike_startpoints[local.i][0] level.airstrike_startpoints[local.i][1] 0 )

		local.startpoint1 = ( local.point[0] local.point[1] 0 )
		local.startpoint2 = ( level.airstrike_startpoints[local.i + 1][0] level.airstrike_startpoints[local.i + 1][1] 0 )
		local.closer = vector_closer local.startpoint1 local.startpoint2 local.origin

		if (local.closer == 1)
			local.point = local.startpoint2
		else
			local.point = local.startpoint1
	}

	for (local.i = 1;local.i <= level.airstrike_startpoints.size;local.i++)
	{
		if ( local.point[0] == level.airstrike_startpoints[local.i][0] && local.point[1] == level.airstrike_startpoints[local.i][1] )
		{
			local.point = ( local.point[0] local.point[1] level.airstrike_startpoints[local.i][2] )
			break
		}
	}

	local.startpoint = local.point

	local.pos1 = ( local.pos[0] local.pos[1] 0 )
	local.pos2 = ( local.startpoint[0] local.startpoint[1] 0 )
	local.angles = vector_toangles ( local.pos1 - local.pos2 )

	if (local.team == "allies")
		local.model = "models/vehicles/p47fly.tik"
	else if (local.team == "axis")
		local.model = "models/vehicles/stuka_fly.tik"

	self thread spawn_plane local.startpoint local.angles local.team local.model local.pos1 local.pos2 local.fx 0
	wait 1
	self thread spawn_plane ( local.startpoint + angles_toleft local.angles * -400 ) local.angles local.team local.model local.pos1 local.pos2 local.fx 0
	wait 1
	self thread spawn_plane ( local.startpoint + angles_toleft local.angles * 400 ) local.angles local.team local.model local.pos1 local.pos2 local.fx 1

end

spawn_plane local.startpoint local.angles local.team local.model local.pos1 local.pos2 local.fx local.last_plane:

	local.plane = spawn script_model model local.model
	local.plane.origin = local.startpoint
	local.plane.angles = ( 0 local.angles[1] 0 )
	local.plane.attacker = self
	local.plane.bombs = 6
	local.plane nodamage
	local.plane notsolid

	local.plane.weapon = spawn "models/weapons/weapon.tik"
	local.plane.weapon notsolid
	local.plane.weapon hide
	local.plane.weapon glue local.plane

	local.plane.weapon firetype heavy
	local.plane.weapon projectile "models/projectiles/planebomb.tik"
	local.plane.weapon dmprojectile "models/projectiles/planebomb.tik"

	local.plane.speed = 2000.0
	local.plane.velocity = local.plane.forwardvector * local.plane.speed

	local.plane loopsound airstrike

	local.plane waitthread bombs local.team local.fx.origin

	wait .5

	local.roll = randomfloat 60
	local.rand = randomint 3

	if (local.roll < 20.0)
		local.roll = 20.0

	if (local.rand > 1)
		local.roll = local.roll * -1.0

	local.plane thread turn (local.roll * -1.0)

	wait .5

	if (local.last_plane == 1)
	{
		local.fx anim stop
		local.fx remove

		wait 2

		level.airspace_occupied = 0
	}
	else
		wait 2

	local.plane.weapon unglue
	local.plane.weapon remove

	local.plane stoploopsound airstrike
	local.plane remove

end

bombs local.team local.pos:

	while ( vector_length ( self.origin - ( local.pos[0] local.pos[1] self.origin[2] ) ) > self.speed * 1.6 )
		waitframe

	local.time = 40
	local.num = self.bombs

	while ( local.time > 0 && local.num > 0 )
	{
		local.startpos = self.origin
		local.endpos = local.startpos + ( 0 0 -20000 )
		local.trace = waitexec global/AA/trace.scr local.startpos local.endpos self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569441

		if (local.trace["surfacetype"] != "none")
		{
			if ( self.attacker != NULL && self.attacker.dmteam == local.team )
			{
				self.attacker bindweap self.weapon
				self.weapon shoot
				self.attacker bindweap self.weapon

				self thread checking_bomb self.attacker
			}

			self.bombs--
			local.num = self.bombs
		}

		wait .1

		local.time--
	}

end

checking_bomb local.attacker:

	local.planebomb = NULL
	while (local.planebomb == NULL)
	{
		waitframe

		if ($planebomb.size > 0)
		{
			for (local.i = 1;local.i <= $planebomb.size;local.i++)
			{
				local.proj = $planebomb[local.i]

				if ( local.proj != NULL && local.proj.attacker != NIL && local.proj.attacker != NULL && local.proj.attacker == local.attacker && local.proj.checked != 1 )
				{
					local.proj.checked = 1
					local.planebomb = local.proj

					break
				}
			}
		}
	}

	if (local.planebomb != NULL)
	{
		local.rand = randomint 2
		local.yaw = randomfloat 2

		if (local.rand > 0)
			local.yaw = local.yaw * -1.0

		local.planebomb.origin = self.origin + ( 0 0 -50 )
		local.planebomb.angles = self.angles + ( 0 local.yaw 0 )

		local.planebomb setsize ( -10 -10 -10 ) ( 10 10 10 )
		local.planebomb solid
		local.planebomb show
		local.planebomb surface all "+nodraw"
		local.planebomb gravity 2.0
		local.planebomb explodeontouch

		local.planebomb.velocity = self.forwardvector * self.speed
		local.planebomb loopsound arty_leadinmp5

		local.planebomb hitdamage 700

		local.bomb = spawn script_model model "models/ammo/us_bomb.tik" origin local.planebomb.origin
		local.bomb notsolid
		local.bomb attach local.planebomb "Box01" 0 ( 0 0 0 )
		local.bomb.angles = ( 0 (self.angles[1] + 90) 0 )
	}

end

strike_marker local.pos:

	local.trace = waitexec global/AA/trace.scr local.pos ( local.pos - ( 0 0 20000 ) ) NIL ( -1 -1 -1 ) ( 1 1 1 ) 1107569441

	wait .2

	local.fx = spawn "models/emitters/linger_smoke.tik" origin local.trace["endPos"]
	local.fx anim start

end local.fx

turn local.roll:

	self rotatez (local.roll * 1.5)

	self.rolling = 1

	while (self)
	{
		local.roll = self.angles[2]
		if (local.roll > 180)
			local.roll -= 360

		if (self.rolling == 1)
		{
			if (local.roll > 70)
			{
				self rotatez 0
				self.rolling = 0
			}
			else if (local.roll < -70)
			{
				self rotatez 0
				self.rolling = 0
			}
		}

		local.pitch = randomfloat 1.0
		local.pitch = local.pitch * -1.0

		self waitthread global/AA/math.scr::axisrotate (self.leftvector * local.pitch)
		self.velocity = self.forwardvector * self.speed

		waitframe
	}

end

```

# zz_veersmods\global\AA\ammodrop.scr

```scr
main local.team:

	if (self.isengineer != 1)
		end

	if (self.can_dropammo == NIL)
		self.can_dropammo = 1

	if (self.ammodrop_help != 1)
	{
		self.ammodrop_help = 1
		self iprint "You can drop ammo by holstering your weapon and pressing the sec. attack button!" 1
	}

	if ( self.can_dropammo == 1 && self.fireheld == 1 && self.secfireheld == 1 && self.useheld != 1 && self.engineerpoint >= 50 )
	{
		if ( self.has_weapon != 1 && self.inveh != 1 && self.inturret != 1 )
		{
			self.can_dropammo = 0

			self.engineerpoint -= 50
			if (self.engineerpoint < 0)
				self.engineerpoint = 0

			ihuddraw_string self 45 ( "Engineer Point: " + self.engineerpoint )

			self thread spawn_ammunitionbox local.team
		}
	}

end

spawn_ammunitionbox local.team:

	local.angles = ( self.viewangles[0] self.viewangles[1] 0 )
	local.origin = self gettagposition "Bip01 Head" + angles_toforward local.angles * 5

	local.ammunitionbox = spawn script_model model "models/items/item_mg_ammobox.tik" origin local.origin angles ( 0 (local.angles[1] + 180) 0 )
	local.ammunitionbox.dmteam = local.team
	local.ammunitionbox touchtriggers

	local.ammunitionbox.trigger = spawn trigger_multiple
	local.ammunitionbox.trigger glue local.ammunitionbox
	local.ammunitionbox.trigger setsize ( -10 -10 -10 ) ( 10 10 10 )

	local.ammunitionbox.vehtrigger = spawn trigger_vehicle
	local.ammunitionbox.vehtrigger glue local.ammunitionbox
	local.ammunitionbox.vehtrigger setsize ( -10 -10 -10 ) ( 10 10 10 )

	local.ammunitionbox.player = self
	local.ammunitionbox.trigger.box = local.ammunitionbox
	local.ammunitionbox.vehtrigger.box = local.ammunitionbox

	local.ammunitionbox physics_on
	local.ammunitionbox gravity 1.0
	local.ammunitionbox.velocity = angles_toforward local.angles * 1000

	local.ammunitionbox thread ammunitionbox_time local.ammunitionbox.trigger local.ammunitionbox.vehtrigger
	local.ammunitionbox thread ammunitionbox_stop

	local.ammunitionbox.trigger setthread player_ammunition
	local.ammunitionbox.vehtrigger setthread vehicle_ammunition

	self thread can_drop_ammo

end

can_drop_ammo:

	wait 1

	if (self != NULL)
		self.can_dropammo = 1

end

ammunitionbox_time local.t local.vt:

	local.time = 30 // 15s

	while ( self != NULL && local.time > 0 )
	{
		wait .5
		local.time--
	}

	if (local.t)
		local.t remove

	if (local.vt)
		local.vt remove

	if (self)
		self remove

end

ammunitionbox_stop:

	while (self != NULL)
	{
		self waittill touch

		local.item = parm.other
		if (local.item != self)
			break
	}

	if (self)
	{
		self.velocity = ( 0 0 0 )
		self notsolid

		if ( local.item != NIL && local.item.isvehicle == 1 && local.item.isturret != 1 )
			self.vehtrigger thread add_vehicle_ammo local.item
	}

end

player_ammunition:

	self nottriggerable

	local.player = parm.other

	if (local.player.player_spawned == 1)
	{
		local.player ammo pistol 20
		local.player ammo rifle 20
		local.player ammo smg 30
		local.player ammo mg 40
		local.player ammo grenade 2
		local.player ammo heavy 2
		local.player ammo shotgun 20

		if ( local.player.has_portablemg == 1 && local.player.portable_mg != NIL && local.player.portable_mg != NULL )
		{
			local.player.portable_mg.tolteny += 50
			if (local.player.portable_mg.tolteny > local.player.portable_mg.maxtolteny)
				local.player.portable_mg.tolteny = local.player.portable_mg.maxtolteny

			local.player stufftext ("set portablemg " + local.player.portable_mg.tolteny)
		}

		if (local.player.ismortarman == 1)
		{
			local.player.mortar_ap_proj_amount += 5
			local.player.mortar_he_proj_amount += 5

			if (local.player.mortar_ap_proj_amount > local.player.mortar_max_ap_proj_amount)
				local.player.mortar_ap_proj_amount = local.player.mortar_max_ap_proj_amount

			if (local.player.mortar_he_proj_amount > local.player.mortar_max_he_proj_amount)
				local.player.mortar_he_proj_amount = local.player.mortar_max_he_proj_amount

			if (local.player.has_mortar == 1)
				local.player thread global/AA/mortar.scr::check_ammo_hud
		}

		local.player playsound bar_snd_pickup_ammo

		local.player iprint "You picked up an ammobox."
	}
	else
	{
		self triggerable
		end
	}

	if (self)
	{
		if (self.box)
		{
			if (self.box.vehtrigger)
				self.box.vehtrigger remove

			self.box remove
		}

		self remove
	}

end

vehicle_ammunition:

	self nottriggerable

	local.vehicle = parm.other

	if (local.vehicle.classname == "VehicleCollisionEntity")
	{
		if (local.vehicle.vehicle)
			local.vehicle = local.vehicle.vehicle
		else
		{
			self triggerable
			end
		}
	}

	if (local.vehicle.fakehealth <= 0)
	{
		self triggerable
		end
	}

	self thread add_vehicle_ammo local.vehicle

end

add_vehicle_ammo local.vehicle:

	local.box_remove = 0

	if ( local.vehicle.mpteam && ( local.vehicle.mpteam == "neutral" || local.vehicle.mpteam == self.box.dmteam ) )
	{
		if (local.vehicle.torony_geppuska)
		{
			if (local.vehicle.torony_geppuska.tolteny < local.vehicle.torony_geppuska.max_tolteny)
			{
				local.box_remove = 1

				local.vehicle.torony_geppuska.tolteny += 50
				if (local.vehicle.torony_geppuska.tolteny > local.vehicle.torony_geppuska.max_tolteny)
					local.vehicle.torony_geppuska.tolteny = local.vehicle.torony_geppuska.max_tolteny
			}
		}

		if ( local.vehicle.max_lovedek_szama != NIL && local.vehicle.max_lovedek_szama != NULL )
		{
			if (local.vehicle.lovedek_szama < local.vehicle.max_lovedek_szama)
			{
				local.box_remove = 1

				local.vehicle.lovedek_szama += 5
				if (local.vehicle.lovedek_szama > local.vehicle.max_lovedek_szama)
					local.vehicle.lovedek_szama = local.vehicle.max_lovedek_szama

				if ( local.vehicle.driver != NIL && local.vehicle.driver != NULL )
					ihuddraw_string local.vehicle.driver 42 ( "Shell: " + local.vehicle.lovedek_szama + " || MG: " + local.vehicle.torony_geppuska.tolteny_tarban + " | " + local.vehicle.torony_geppuska.tolteny )
			}
		}

		if (local.vehicle.test_geppuska)
		{
			if (local.vehicle.test_geppuska.tolteny < local.vehicle.test_geppuska.max_tolteny)
			{
				local.box_remove = 1

				local.vehicle.test_geppuska.tolteny += 50
				if (local.vehicle.test_geppuska.tolteny > local.vehicle.test_geppuska.max_tolteny)
					local.vehicle.test_geppuska.tolteny = local.vehicle.test_geppuska.max_tolteny

				if ( local.vehicle.gunner != NIL && local.vehicle.gunner != NULL )
					ihuddraw_string local.vehicle.gunner 42 ( "MG: " + local.vehicle.test_geppuska.tolteny_tarban + " | " + local.vehicle.test_geppuska.tolteny )
			}
		}

		if (local.vehicle.max_tolteny)
		{
			if (local.vehicle.tolteny < local.vehicle.max_tolteny)
			{
				local.box_remove = 1

				local.vehicle.tolteny += 50
				if (local.vehicle.tolteny > local.vehicle.max_tolteny)
					local.vehicle.tolteny = local.vehicle.max_tolteny

				if ( local.vehicle.gunner != NIL && local.vehicle.gunner != NULL )
					ihuddraw_string local.vehicle.gunner 42 ( "MG: " + local.vehicle.tolteny_tarban + " | " + local.vehicle.tolteny )
			}
		}
	}

	if (local.box_remove == 1)
		local.vehicle playsound bar_snd_pickup_ammo

	if (self)
	{
		if (self.box)
		{
			if (self.box.trigger)
				self.box.trigger remove

			self.box remove
		}

		self remove
	}

end

ammo_help:

	if (self.ammo_call == 1)
		end

	if ( self.player_spawned == 1 && self.ammo_call != 1 )
	{
		self.ammo_call = 1

		if (self.inveh == 1)
		{
			for (local.i = 1;local.i <= $vezetheto_jarmu.size;local.i++)
			{
				local.jarmu = $vezetheto_jarmu[local.i]
				if (local.jarmu.istank == 1)
				{
					if ( ( local.jarmu.driver && local.jarmu.driver == self ) || ( local.jarmu.gunner && local.jarmu.gunner == self ) )
					{
						switch (local.jarmu.type)
						{
							case "kingtiger":
								local.type = "King Tiger"
							break
							case "tiger":
								local.type = "Tiger"
							break
							case "panzer_brown":
							case "panzer_euro":
								local.type = "Panzer"
							break
						}
					}
				}
				else if (local.jarmu.isturret != 1)
				{
					if ( ( local.jarmu.driver && local.jarmu.driver == self ) || ( local.jarmu.gunner && local.jarmu.gunner == self ) )
						local.type = "Jeep"
				}

				if (local.type != NIL)
				{
					self dmmessage -1 ( "I need Ammo in " + local.type + "!!!" )
					break
				}
			}
		}
		else
			self dmmessage -1 ( "I need Ammo!!!" )
	}

	wait 1

	if (self != NULL)
		self.ammo_call = 0

end

```

# zz_veersmods\global\AA\artillery.scr

```scr
main:

	if (self.artillery_recharged == NIL)
		self.artillery_recharged = 1

	if (self.artillery_binoc_activated == NIL)
		self.artillery_binoc_activated = 0

	if (self.artillery_help != 1)
	{
		self.artillery_help = 1
		self iprint "Use your binoculars and press the use button to call for Artillery!" 1
	}

	if (self.artillery_message == 1)
	{
		self.artillery_message = 0

		self iprint "Artillery ready to go!" 1

		self playsound artillery_ready
	}

	if (self.max_artillery == NIL)
		self.max_artillery = 4

	if (self.current_artillery == NIL)
		self.current_artillery = self.max_artillery

	self give models/items/binoculars.tik

	while ( self != NULL && self.player_spawned == 1 )
	{
		if ( self.useheld == 1 && self.inveh != 1 && self.inturret != 1 && self.current_weapon != NULL && self.current_weapon.model == "models/items/binoculars.tik" && self.artillery_binoc_activated != 1 )
		{
			self.artillery_binoc_activated = 1

			self thread binoc_active

			if (self.current_artillery == 0)
				self iprint "You are out of Artillery." 1
			else
			{
				if (self.artillery_recharged == 1)
				{
					if (level.artillery_occupied != 1)
					{
						self.artillery_recharged = 0
						level.artillery_occupied = 1

						self.current_artillery--

						self thread reloading_artillery

						local.pos = self gettagposition "eyes bone"
						local.angles = angles_toforward self.viewangles
						local.trace = waitexec global/AA/trace.scr local.pos ( local.pos + local.angles * 20000 ) self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569441

						self thread start_artillery local.trace["endPos"] self.dmteam
					}
					else
						self iprint "The battery is still busy!" 1
				}
				else
					self iprint "You can't call for Artillery now!" 1
			}
		}

		waitframe
	}

end

binoc_active:

	wait .5

	if (self != NULL)
		self.artillery_binoc_activated = 0

end

reloading_artillery:

	if (self.current_artillery == 0)
		end

	if (self.first_artillery == NIL)
		self.first_artillery = 1

	if (self.first_artillery == 1)
	{
		self.first_artillery = 0
		local.time = 60
	}
	else
		local.time = 90

	wait local.time

	if (self == NULL)
		end

	if ( self.player_spawned == 1 && self.artillery == 1 )
	{
		self iprint "Artillery ready to go!" 1

		self playsound artillery_ready
	}
	else
		self.artillery_message = 1

	self.artillery_recharged = 1

end

start_artillery local.pos local.team:

	if (self.current_artillery > 0)
		self iprint ( "You can call for Artillery " + self.current_artillery + " times." ) 1
	else
		self iprint "You are out of Artillery." 1

	self playsound artillery_target

	local.marker_pos = self waitthread strike_marker local.pos

	self dmmessage -1 ( "OUR ARTILLERY WILL SHAKE THEM UP!!!" )

	local.weapon = spawn "models/weapons/weapon.tik" origin ( 0 0 -20000 )
	local.weapon notsolid
	local.weapon hide

	local.weapon firetype heavy
	local.weapon projectile "models/projectiles/artilleryshell.tik"
	local.weapon dmprojectile "models/projectiles/artilleryshell.tik"

	wait 2

	self thread artillery_area local.weapon local.marker_pos local.team

end

artillery_area local.weapon local.marker_pos local.team:

	local.radius = 650.0
	local.num = 12

	local.sound_org = spawn script_origin
	local.sound_org.origin = local.marker_pos

	for (local.i = 1;local.i <= local.num;local.i++)
	{
		local.x_neg = randomint 10
		local.x_neg++

		local.y_neg = randomint 10
		local.y_neg++

		local.x = randomfloat local.radius
		local.y = randomfloat local.radius

		if (local.x_neg > 5)
			local.x = local.x * -1.0

		if (local.y_neg > 5)
			local.y = local.y * -1.0

		local.pos = ( (local.marker_pos[0] + local.x) (local.marker_pos[1] + local.y) 20000 )
		local.hit_pos = waitthread find_hit_pos local.pos

		if ( self == NULL || self.dmteam != local.team )
			end

		self thread artillery_impact local.weapon local.hit_pos local.team local.sound_org

		local.wait = randomfloat 1.5
		if (local.wait < 0.35)
			local.wait = 0.35

		wait local.wait
	}

	wait 5

	local.sound_org remove

end

artillery_impact local.weapon local.hit_pos local.team local.sound_org:

	local.sound_org playsound tank_fire_dist

	wait 2

	local.fx = spawn script_model model "models/animate/fx_mortar_dirt.tik"
	local.fx.origin = local.hit_pos
	local.fx notsolid

	local.fx playsound arty_leadinmp5

	wait 1.7

	if ( self != NULL && self.dmteam == local.team )
	{
		local.fx anim start

		self bindweap local.weapon
		local.weapon shoot
		self bindweap local.weapon

		self thread artillery_proj local.hit_pos
	}

	wait 3

	local.fx remove

	level.artillery_occupied = 0

end

artillery_proj local.pos:

	local.artilleryshell = NULL
	while (local.artilleryshell == NULL)
	{
		waitframe

		if ($artilleryshell.size > 0)
		{
			for (local.i = 1;local.i <= $artilleryshell.size;local.i++)
			{
				local.proj = $artilleryshell[local.i]

				if ( local.proj != NULL && local.proj.attacker != NIL && local.proj.attacker != NULL && local.proj.attacker == self && local.proj.checked != 1 )
				{
					local.proj.checked = 1
					local.artilleryshell = local.proj

					break
				}
			}
		}
	}

	if (local.artilleryshell != NULL)
	{
		local.artilleryshell.origin = local.pos + ( 0 0 200 )
		local.artilleryshell hitdamage 600
		local.artilleryshell explodeontouch

		local.artilleryshell.velocity = $world.upvector * -4000
	}

end

find_hit_pos local.pos:

	local.trace = waitexec global/AA/trace.scr local.pos ( local.pos - ( 0 0 20000 ) ) NIL ( -1 -1 -1 ) ( 1 1 1 ) 1107569441
	local.traced_pos = local.trace["endPos"]

	local.z = 30

	for (local.i = 1;local.i <= 20;local.i++)
	{
		local.trace = waitexec global/AA/trace.scr ( local.traced_pos - ( 0 0 local.z ) ) local.traced_pos NIL ( -1 -1 -1 ) ( 1 1 1 ) 1107569441
		local.new_traced_pos = local.trace["endPos"]

		local.z += 30

		if (local.new_traced_pos[2] != local.traced_pos[2])
			break
	}

	local.trace = waitexec global/AA/trace.scr local.new_traced_pos ( local.new_traced_pos - ( 0 0 20000 ) ) NIL ( -1 -1 -1 ) ( 1 1 1 ) 1107569441
	local.traced_pos = local.trace["endPos"]

end local.traced_pos

strike_marker local.pos:

	local.trace = waitexec global/AA/trace.scr local.pos ( local.pos - ( 0 0 20000 ) ) NIL ( -1 -1 -1 ) ( 1 1 1 ) 1107569441

end local.trace["endPos"]

```

# zz_veersmods\global\AA\binoculars.scr

```scr
main:

	self.binoculars_fire = 1

end


```

# zz_veersmods\global\AA\block_triggers.scr

```scr
main local.origin local.size1 local.size2 local.angles local.speed local.pos:

	local.t = spawn trigger_multipleall origin local.origin
	local.t setsize local.size1 local.size2
	local.t.angl = local.angles
	local.t.speed = local.speed
	local.t.pos = local.pos
	local.t setthread block_trigger

end

block_trigger:

	local.player = parm.other

	if ( local.player.isplayer != 1 && local.player.inveh == 1 )
		end

	local.player.velocity = angles_toforward self.angl * self.speed + self.pos

	local.player iprint "You can't pass through here."

end

```

# zz_veersmods\global\AA\callbacksetup.scr

```scr
connected local.player:

	if ( !local.player || local.player.classname != "Player" || level.intermission_started == 1 )
		end

	local.player.isplayer = 1
	local.player.disable_spawn = 0

	local.player stufftext ( "set rate 30000" )
	local.player stufftext ( "set developer 0" )
	local.player stufftext ( "set ui_console 1" )
	local.player stufftext ( "set cg_forcemodel 0" )
	local.player stufftext "ui_checkrestart"

	local.player exec global/AA/clear_huds.scr
	local.player exec global/AA/check_weapons.scr

	if (local.player.dmteam != "spectator")
		thread spawn local.player

	if (level.account == 1)
		local.player thread global/AA/accounts.scr::check_login

	if (level.bas_huds == 1)
		thread global/BAS/huds.scr::refresh_huds 4

	if ( netname local.player == "" || netname local.player == "UnnamedSoldier" )
		local.player stufftext ( "name Ihavetochangemyname" + randomint 9999 )

	local.rand1 = randomint 1
	local.rand1++

	local.sound = "allied_medic_kialltas" + local.rand1
	local.player.allies_medic_callsound = local.sound

	local.rand2 = randomint 4
	local.rand2++

	local.sound = "axis_medic_kialltas" + local.rand2
	local.player.axis_medic_callsound = local.sound

end

disconnected local.player:

	if (local.player == NULL)
		end

	if (local.player.logged_in == 1)
		local.player thread global/AA/accounts.scr::delete_login local.player.rew_username

	if ( local.player.vehicle_trigger != NIL && local.player.vehicle_trigger != NULL )
		local.player.vehicle_trigger remove

end

spawn local.player:

	if ( local.player.dmteam == "spectator" || local.player.isplayer != 1 )
		end

	if ( level.intermission_started == 1 || level.bas_roundend == 1 )
		end

	local.team = local.player.dmteam

	local.player.player_spawned = 0

	if (local.player.disable_spawn > 0)
	{
		local.player.disable_spawn--
		end
	}

	wait 0.051

	if (local.player == NULL)
		end

	local.player.player_spawned = 1
	local.player.poziciot_valt = 0

	local.player waitthread remove_things

	local.player exec global/AA/spawn_protection.scr local.team

	local.player waitthread check_class local.team

	if (local.player == NULL)
		end

	local.player thread global/AA/reward_store.scr::spawned_player_rewards

	if (local.player.binded_call_key != 1)
	{
		local.player.binded_call_key = 1

		local.player stufftext ( "bind i scmd needammo" )
		local.player stufftext ( "bind k scmd needengineer" )
		local.player stufftext ( "bind l scmd needmedic" )

		local.player iprint "Press the 'i' button to call for ammo."
		local.player iprint "Press the 'k' button to call for engineers in vehicle."
		local.player iprint "Press the 'l' button to call for medics."
	}

	//local.player thread global/AA/telefrag.scr::telefrag

	local.player thread maps/m4l0.scr::parachute

	if (local.player.mortar_area_help != 1)
	{
		local.player.mortar_area_help = 1
		local.player iprint "Use your binoculars to mark a target area for mortars by pressing the sec. attack button." 1
	}

	while ( local.player != NULL && isAlive local.player && local.player.dmteam == local.team && local.player.isplayer == 1 && local.player.player_spawned == 1 && level.bas_roundend != 1 )
	{
		local.player thread global/AA/vehicle_fixes.scr::veh_coll

		if (local.player.ammodrop == 1)
			local.player exec global/AA/ammodrop.scr local.player.dmteam

		if ( local.player.current_weapon != NULL && local.player.current_weapon.model == "models/items/binoculars.tik" && local.player.fireheld == 1 && local.player.secfireheld == 1 )
			local.player thread global/AA/mortar.scr::mortar_target

		waitframe
	}

	if (local.player == NULL)
		end // Player disconnected

	local.player stufftext "ui_removehud dday1"
	local.player stufftext "ui_removehud dday2"
	local.player stufftext "ui_removehud credits1"

	local.player.player_spawned = 0
	local.player.poziciot_valt = 0
	local.player.ismortarman = 0

	if ( level.intermission_started == 1 || level.bas_roundend == 1 )
		end

	if !(isAlive local.player)
		local.player thread global/AA/medic.scr::dead_player local.team

end

check_class local.team:

	self surface all "-nodraw"

	if (self.revived == 1)
	{
		self.revived = 0

		if (self.isengineer == 1)
			self exec global/AA/engineer.scr local.team
		else if (self.ismedic == 1)
			self exec global/AA/medic.scr local.team
		else
		{
			self takeall

			if (local.team == "allies")
				self give models/weapons/colt45.tik
			else if (local.team == "axis")
				self give models/weapons/p38.tik

			self useweaponclass pistol
		}

		end
	}

	self.isengineer = 0
	self.ismedic = 0

	if (self.current_weapon == NULL)
	{
		while ( self != NULL && self.player_spawned == 1 && self.current_weapon == NULL )
			waitframe
	}

	if ( self != NULL && self.player_spawned == 1 && self.current_weapon != NULL )
	{
		switch (self.current_weapon.model)
		{
			case "models/weapons/kar98sniper.tik":
			case "models/weapons/springfield.tik":
				self exec global/AA/sniper.scr
			break
			case "models/weapons/bazooka.tik":
			case "models/weapons/panzerschreck.tik":
				self exec global/AA/engineer.scr local.team
			break
			case "models/weapons/shotgun.tik":
				self exec global/AA/medic.scr local.team
			break
		}
	}

end

remove_things:

	if (self.medic_helmet)
	{
		self.medic_helmet detach
		self.medic_helmet remove
	}

	if (self.medic_healthbox)
	{
		self.medic_healthbox detach
		self.medic_healthbox remove
	}

	if (self.engineer_helmet)
	{
		self.engineer_helmet detach
		self.engineer_helmet remove
	}

	if (self.wrench)
	{
		self.wrench detach
		self.wrench remove
	}

	if (self.welding_torch)
	{
		self.welding_torch anim idleoff
		self.welding_torch detach
		self.welding_torch remove
	}

end

damage local.target local.inflictor local.damage local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location local.entity:

	if (local.entity.isplayer == 1)
		local.entity thread player_damage local.target local.inflictor local.damage local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location
	else if (local.entity.isvehicle == 1)
		local.entity exec global/AA/vehicle_damage.scr local.target local.inflictor local.damage local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location
	else if (local.entity.isbase == 1)
	{
		local.base = local.entity
		if (local.base.classname == "VehicleTurretGun")
			local.base = local.base.base

		local.base thread global/BAS/baseassault.scr::damage_monitor local.target local.inflictor local.damage local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location
	}

end

kill local.attacker local.damage local.inflictor local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location local.player:

	if ( local.attacker == NULL || local.attacker.isplayer != 1 )
		end

	//local.player thread check_last_weapons

	if (local.player == local.attacker)
		end

	local.gt = int ( getcvar "g_gametype" )
	local.td = int ( getcvar "g_teamdamage" )

	if ( local.gt == 1 || ( local.gt != 1 && local.player.dmteam != local.attacker.dmteam ) )
	{
		if (local.attacker.playerextras == 1)
			local.attacker playsound hitsound

		local.attacker thread global/AA/reward_store.scr::give_cash 5

		if (level.first_blood != 1)
		{
			level.first_blood = 1

			if (local.attacker.dmteam == "allies")
				local.team = "ALLIES"
			else if (local.attacker.dmteam == "axis")
				local.team = "AXIS"

			local.attacker thread global/AA/reward_store.scr::give_cash 8

			iprintlnbold ( "'" + (netname local.attacker) + "' got the first blood in " + local.team + " team." )
		}
	}

end

check_last_weapons:

	local.weap = self getactiveweap 0
	if (local.weap == NULL)
	{
		self weapnext
		self activatenewweapon righthand
	}

	for (local.i = 1;local.i <= 20;local.i++)
	{
		local.weap = self getactiveweap 0
		if (local.weap == NULL)
			end
		else
		{
			self iprint local.weap.model 1

			self weapnext
			self activatenewweapon righthand
		}
	}

end

player_damage local.target local.inflictor local.damage local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location:

	local.attacker = local.inflictor

	if ( local.attacker == NULL || local.attacker.isplayer != 1 )
		end

	if (self == local.attacker)
		end

	local.gt = int ( getcvar "g_gametype" )
	local.td = int ( getcvar "g_teamdamage" )

	if ( local.gt == 1 || ( local.gt != 1 && self.dmteam != local.attacker.dmteam ) )
	{
		local.bonus_damage = 0
		local.weap = local.attacker getactiveweap 0

		if ( local.weap != NIL && local.weap != NULL && ( local.meansofdeath == 18 || local.meansofdeath == 19 )  )
		{
			if (local.attacker.rifledamage == 1)
			{
				if ( local.weap.model == "models/weapons/kar98.tik" || local.weap.model == "models/weapons/kar98sniper.tik" || local.weap.model == "models/weapons/m1_garand.tik" || local.weap.model == "models/weapons/springfield.tik" )
					local.bonus_damage = 1
			}

			if ( local.bonus_damage != 1 && local.attacker.smgdamage == 1 )
			{
				if ( local.weap.model == "models/weapons/mp40.tik" || local.weap.model == "models/weapons/thompsonsmg.tik" )
					local.bonus_damage = 1
			}

			if ( local.bonus_damage != 1 && local.attacker.mgdamage == 1 )
			{
				if ( local.weap.model == "models/weapons/bar.tik" || local.weap.model == "models/weapons/mp44.tik" )
					local.bonus_damage = 1
			}
		}

		if (local.bonus_damage == 1)
		{
			local.dmg = local.damage * 0.5
			self damage local.attacker local.dmg local.attacker local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location
		}

		if (local.attacker.playerextras == 1)
			local.attacker playsound hitsound
	}

end

keypress local.player local.keynum:

	if (local.player == NULL)
		end

	if (level.account == 1)
	{
		if (local.keynum == 1001)
		{
			if ( local.player.logged_in == 1 && local.player.market_isopen != 1 && local.player.store_isopen != 1 && local.player.player_spawned == 1 )
				local.player exec global/AA/reward_market.scr
		}
		else if (local.keynum == 1002)
		{
			if ( local.player.logged_in == 1 && local.player.market_isopen != 1 && local.player.store_isopen != 1 && local.player.player_spawned == 1 )
				local.player exec global/AA/reward_store.scr
		}
		else if (local.keynum == 111)
		{
			if (local.player isadmin == 1)
				local.player thread global/AA/accounts.scr::print_logged_players
		}
	}

end

intermission local.type:

	// 0 = Player intermission screen
	// 1 = Map change (happens after using commands: map, gamemap , but also right after player intermission screen)
	// 2 = Map restart (happens after restart command)

	if (level.intermission_started != 1)
	{
		level.intermission_started = 1

		if (level.account == 1)
			thread global/AA/accounts.scr::save_login

		if (level.original_timelimit != NIL)
			setcvar "timelimit" level.original_timelimit
	}

end

servercommand local.player local.command local.args:

	if (local.player == NULL)
		end

	if ( level.intermission_started == 1 || level.bas_roundend == 1 )
		end

	local.player thread global/AA/accounts.scr::init_account local.command local.args

	if (local.command == "r_pl")
		local.player thread global/AA/check_cvars.scr::force_respawn_player local.args

	if (local.command == "needammo")
		local.player thread global/AA/ammodrop.scr::ammo_help

	if (local.command == "needengineer")
		local.player thread global/AA/engineer.scr::engineer_help

	if (local.command == "needmedic")
		local.player thread global/AA/medic.scr::medic_help

end

/*
// Locations
-1 General
0 Pelvis
1 Lower Torso
2 Mid Torso
3 Upper Torso
4 Neck
5 Head
6 RUpperArm
7 RForearm
8 RHand
9 LUpperArm
10 LForearm
11 LHand
12 RThigh
13 RCalf
14 RFoot
15 LThigh
16 LCalf
17 LFoot

// Means of Death
0 - none
1 - suicide
2 - crush
3 - crush_every_frame
4 - telefrag
5 - lava
6 - slime
7 - falling
8 - last_self_inflicted
9 - explosion
10 - explodewall
11 - electric
12 - electricwater
13 - thrownobject
14 - grenade
15 - beam
16 - rocket
17 - impact
18 - bullet
19 - fast_bullet
20 - vehicle
21 - fire
22 - flashbang
23 - on_fire
24 - gib
25 - impale
26 - bash
27 - shotgun

// Location damage
-1 - 1.00
0 - 2.00
1 - 2.00
2 - 2.00
3 - 1.00
4 - 0.95
5 - 0.90
6 - 0.85
7 - 0.80
8 - 0.80
9 - 0.80
10 - 0.80
11 - 0.60
12 - 0.60
13 - 0.60
14 - 0.60
15 - 0.50
16 - 0.50
17 - 0.50
18 - 0.50

// Tanks
Always immune: grenade (14), bullet (18), fast_bullet (19), vehicle (20), shotgun (27)
*/

```

# zz_veersmods\global\AA\check_cvars.scr

```scr
main:

	level waittill spawn

	while ( level.intermission_started != 1 && level.bas_roundend != 1 )
	{
		thread player_things
		wait 7
	}

end

player_things:

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.isplayer == 1 )
		{
			if (local.player getconnstate != 4)
				local.player.isplayer = 0

			if ( local.player isadmin == 1 && level.account == 1 && local.player.binded_logged_key != 1 )
			{
				local.player.binded_logged_key = 1
				local.player stufftext ( "bind F4 keyp 111" )

				local.player iprint "Press F4 to check the logged players." 1
			}

			local.player stufftext ( "set cg_forcemodel 0" )
		}
	}

end

force_respawn_player local.clnum:

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.isplayer == 1 && local.player.player_spawned == 1 )
		{
			local.num = getclientnum local.player
			if (local.num == int local.clnum)
			{
				if ( local.player.inveh == 1 || local.player.inturret == 1 )
				{
					if (local.player.inturret == 1)
						local.player usestuff

					local.player.player_spawned = 0

					wait .1
				}

				if (local.player != NULL)
				{
					local.player.inveh = 0
					local.player.inturret = 0

					local.player respawn

					stuffsrv ( "say " + netname local.player + " was forced to respawn by the Admin." )
					local.player iprint "You were forced to respawn by the admin."
				}

				end
			}
		}
	}

	self iprint "The player not found." 1

end

```

# zz_veersmods\global\AA\check_weapons.scr

```scr
main:

	self.has_weapon = 0
	self.current_weapon = NULL

	while ( self != NULL && level.intermission_started != 1 )
	{
		local.weap = self getactiveweap 0
		if (local.weap != NULL)
		{
			if (self.has_weapon != 1)
				self.has_weapon = 1
		}
		else
		{
			if (self.has_weapon == 1)
				self.has_weapon = 0
		}

		if ( local.weap != NULL && self.current_weapon != NIL && self.current_weapon != local.weap )
			self.has_weapon = 1

		self.current_weapon = local.weap

		waitframe
	}

end

```

# zz_veersmods\global\AA\clear_huds.scr

```scr
main:

	self stufftext "ui_removehud dday1"
	self stufftext "ui_removehud dday2"
	self stufftext "ui_removehud credits1"

	for (local.i = 0;local.i <= 255;local.i++)
	{
		ihuddraw_alpha self local.i 0
	}

end

```

# zz_veersmods\global\AA\engineer.scr

```scr
main local.team:

	local.engineer_caste = getcvar "engineer_caste"
	if (local.engineer_caste != "1")
		end

	self.isengineer = 1

	self takeall

	if (local.team == "allies")
	{
		self model "models/player/american_ranger.tik"

		self give models/weapons/colt45.tik
		self give models/weapons/m1_garand.tik
		self give models/weapons/m2frag_grenade.tik

		self surface us_helmet "+nodraw"
	}
	else if (local.team == "axis")
	{
		self model "models/player/german_worker.tik"

		self give models/weapons/p38.tik
		self give models/weapons/kar98.tik
		self give models/weapons/steilhandgranate.tik
	}

	self forcelegsstate STAND

	self ammo grenade 2
	self useweaponclass rifle

	self thread engineer_felszereles local.team

	if ( self.max_engineerpoint == NIL || self.max_engineerpoint == NULL )
	{
		self.max_engineerpoint = 500
		if (self.doublepoints == 1)
			self.max_engineerpoint += self.max_engineerpoint
	}

	if ( self.engineerpoint == NIL || self.engineerpoint == NULL )
		self.engineerpoint = self.max_engineerpoint

	ihuddraw_align self 45 left bottom
	ihuddraw_font self 45 facfont-20
	ihuddraw_rect self 45 40 -81 128 16
	ihuddraw_string self 45 ( "Engineer Point: " + self.engineerpoint )
	ihuddraw_color self 45 0 1 0
	ihuddraw_alpha self 45 1.0

	self.vehicle_repairing = 0

	self thread vehiclerepair
	self thread point_recharging

end

engineer_felszereles local.team:

	if (local.team == "allies")
		local.model = "models/equipment/ushelmet_engineer01.tik"
	else if (local.team == "axis")
		local.model = "models/equipment/ushelmet_engineer02.tik"

	local.helmetname = "engineer_helmet" + randomint 999999 + self.entnum
	self attachmodel local.model "Bip01 Head" 1.0 local.helmetname 1 -1 -1 -1 -1 ( -84 -1.5 0 )
	$(local.helmetname).angles = ( -180 -90 -90 )
	$(local.helmetname) scale 1.0

	local.pos = ( -3 6 -10 )

	local.wrenchname = "engineer_wrench" + randomint 999999 + self.entnum
	self attachmodel "models/miscobj/wrench.tik" "Bip01 Pelvis" 0.7 local.wrenchname 1 -1 -1 -1 -1 local.pos
	$(local.wrenchname).angles = ( 105 30 30 )
	$(local.wrenchname) scale 0.7

	self.engineer_helmet = $(local.helmetname)
	self.wrench = $(local.wrenchname)

end

vehiclerepair:

	local.damaged_vehicle = NULL

	while ( self != NULL && self.player_spawned == 1 )
	{
		if ( self.fireheld == 1 && self.secfireheld != 1 && self.useheld != 1 && self.engineerpoint > 0 )
		{
			if ( self.has_weapon != 1 && self.inveh != 1 && self.inturret != 1 )
			{
				if ($vezetheto_jarmu.size > 0)
				{
					local.damaged_vehicle = NULL

					for (local.i = 1;local.i <= $vezetheto_jarmu.size;local.i++)
					{
						local.vehicle = $vezetheto_jarmu[local.i]
						if ( isAlive local.vehicle && local.vehicle.fakehealth != NIL && local.vehicle.fakehealth < local.vehicle.maxhealth && local.vehicle.fakehealth > 0 )
						{
							local.surface = local.vehicle
							if (local.vehicle.collisionent)
								local.surface = local.vehicle.collisionent

							if ( self istouching local.surface || ( local.vehicle.torony && self istouching local.vehicle.torony ) )
							{
								if ( !local.vehicle.mpteam || ( local.vehicle.mpteam && ( local.vehicle.mpteam == "neutral" || local.vehicle.mpteam == self.dmteam ) ) )
									local.damaged_vehicle = local.vehicle
							}
						}

						if (local.damaged_vehicle != NULL)
							break
					}
				}

				if (local.damaged_vehicle != NULL)
				{
					self.vehicle_repairing = 1

					if !(self.engineer_welding_torch)
					{
						local.welding_torch_name = "engineer_welding_torch" + randomint 999999 + self.entnum
						self attachmodel "models/miscobj/welding_torch.tik" "tag_weapon_right" 1.0 local.welding_torch_name 1 -1 -1 -1 -1 ( 4 -2 -4 )
						self.engineer_welding_torch = $(local.welding_torch_name)
						self.engineer_welding_torch.angles = ( 0 0 0 )
						self.engineer_welding_torch scale 1.0
						self.engineer_welding_torch hide

						self.engineer_welding_torch show
						self.engineer_welding_torch anim idleon

						self.engineer_welding_torch loopsound welding_torch
					}

					self.engineerpoint--
					if (self.engineerpoint < 0)
						self.engineerpoint = 0

					ihuddraw_string self 45 ( "Engineer Point: " + self.engineerpoint )

					local.plus_health = 4
					if (self.fastengineer == 1)
						local.plus_health += 3

					local.damaged_vehicle.fakehealth += local.plus_health

					if (local.damaged_vehicle.fakehealth > local.damaged_vehicle.maxhealth)
						local.damaged_vehicle.fakehealth = local.damaged_vehicle.maxhealth

					if (self.classworks == 1)
					{
						if (self.repair_points == NIL)
							self.repair_points = 0.0

						if ( local.damaged_vehicle.mpteam != NIL && local.damaged_vehicle.mpteam == self.dmteam )
						{
							self.repair_points += local.plus_health / 4.0
							if (self.repair_points > 40.0)
							{
								self.repair_points = 0.0
								self thread global/AA/reward_store.scr::give_cash 4
							}
						}
					}

					local.perc = int ( (local.damaged_vehicle.fakehealth / local.damaged_vehicle.maxhealth) * 100 )

					if (local.vehicle_health_hud != 1)
					{
						local.vehicle_health_hud = 1
						local.damaged_vehicle thread global/AA/vehicle_damage.scr::vehicle_health_hud self
					}

					if ( self != NULL && local.vehicle_health_hud == 1 )
						local.damaged_vehicle thread global/AA/vehicle_damage.scr::update_vehicle_health_hud self

					if ( local.damaged_vehicle.driver != NIL && local.damaged_vehicle.driver != NULL )
						local.damaged_vehicle thread global/AA/vehicle_damage.scr::update_vehicle_health_hud local.damaged_vehicle.driver

					if ( local.damaged_vehicle.gunner != NIL && local.damaged_vehicle.gunner != NULL )
						local.damaged_vehicle thread global/AA/vehicle_damage.scr::update_vehicle_health_hud local.damaged_vehicle.gunner

					if (local.damaged_vehicle.fakehealth >= local.damaged_vehicle.maxhealth)
					{
						local.damaged_vehicle.fakehealth = local.damaged_vehicle.maxhealth
						local.damaged_vehicle = NULL
					}
				}
			}
			else
				local.damaged_vehicle = NULL
		}
		else
			local.damaged_vehicle = NULL

		if ( local.damaged_vehicle == NULL && self.vehicle_repairing == 1 )
		{
			self.vehicle_repairing = 0

			if (self.engineer_welding_torch)
			{
				self.engineer_welding_torch anim idleoff

				self.engineer_welding_torch detach
				self.engineer_welding_torch hide
				self.engineer_welding_torch notsolid

				self.engineer_welding_torch thread remove_welding_torch
			}

			if (local.vehicle_health_hud == 1)
			{
				if (self.inveh != 1)
					self thread global/AA/vehicle_damage.scr::remove_vehicle_health_hud

				local.vehicle_health_hud = 0
			}
		}

		wait .1
	}

	if (self != NULL)
	{
		self.vehicle_repairing = 0

		ihuddraw_alpha self 45 0.0

		if (local.vehicle_health_hud == 1)
			self thread global/AA/vehicle_damage.scr::remove_vehicle_health_hud

		if (self.engineer_welding_torch)
		{
			self.engineer_welding_torch anim idleoff

			self.engineer_welding_torch detach
			self.engineer_welding_torch hide
			self.engineer_welding_torch notsolid

			self.engineer_welding_torch thread remove_welding_torch
		}
	}

end

remove_welding_torch:

	self.origin = ( 0 0 -20000 )

	wait .5

	if (self)
		self remove

end

engineer_help:

	if ( self.player_spawned == 1 && self.inveh == 1 && self.engineer_call != 1 )
	{
		for (local.i = 1;local.i <= $vezetheto_jarmu.size;local.i++)
		{
			local.jarmu = $vezetheto_jarmu[local.i]
			if (local.jarmu.istank == 1)
			{
				if ( ( local.jarmu.driver && local.jarmu.driver == self ) || ( local.jarmu.gunner && local.jarmu.gunner == self ) )
				{
					switch (local.jarmu.type)
					{
						case "kingtiger":
							local.type = "King Tiger"
						break
						case "tiger":
							local.type = "Tiger"
						break
						case "panzer_brown":
						case "panzer_euro":
							local.type = "Panzer"
						break
					}
				}
			}
			else if (local.jarmu.isturret == 1)
			{
				if ( local.jarmu.gunner && local.jarmu.gunner == self )
					local.type = "Turret"
			}
			else
			{
				if ( ( local.jarmu.driver && local.jarmu.driver == self ) || ( local.jarmu.gunner && local.jarmu.gunner == self ) )
					local.type = "Jeep"
			}

			if (local.type != NIL)
			{
				self.engineer_call = 1

				self dmmessage -1 ( "I need an Engineer in " + local.type + "!!!" )
				self thread engineer_sound

				end
			}
		}
	}

end

engineer_sound:

	local.sound_org = spawn script_origin origin self.origin
	local.sound_org show
	local.sound_org loopsound needengineer

	wait 1.4

	local.sound_org stoploopsound needengineer
	local.sound_org remove

	if (self != NULL)
		self.engineer_call = 0

end

point_recharging:

	while ( self != NULL && self.player_spawned == 1 && self.engineerpoint == self.max_engineerpoint )
		wait .1

	if ( self == NULL || self.player_spawned != 1 )
		end

	local.time = 10
	local.count = local.time

	while ( self != NULL && self.player_spawned == 1 && self.engineerpoint < self.max_engineerpoint )
	{
		if (self.vehicle_repairing != 1)
			local.count--
		else
			local.count = local.time

		if (local.count == 0)
		{
			local.count = local.time

			self.engineerpoint += 10
			if (self.engineerpoint > self.max_engineerpoint)
				self.engineerpoint = self.max_engineerpoint

			ihuddraw_string self 45 ( "Engineer Point: " + self.engineerpoint )
		}

		wait .1
	}

	if (self != NULL)
	{
		if (self.engineerpoint >= self.max_engineerpoint)
		{
			self.engineerpoint = self.max_engineerpoint

			ihuddraw_string self 45 ( "Engineer Point: " + self.engineerpoint )
		}
	}

	if ( self == NULL || self.player_spawned != 1 )
		end
	else
		goto point_recharging

end

```

# zz_veersmods\global\AA\files.scr

```scr
read_file local.filepath:

	if (local.filepath == NIL)
		end

	if ( fexists local.filepath != 1 )
		end

	local.file = fopen local.filepath "rb"
	local.content = freadall local.file
	local.close = fclose local.file

	if (local.content.size == 0)
		end

end local.content

save_new_file local.filepath local.content:

	if ( local.filepath == NIL || local.content == NIL )
		end

	local.file = fopen local.filepath "w+"

	for (local.i = 1;local.i <= local.content.size;local.i++)
	{
		local.save = fputs local.file local.content[local.i]
	}

	local.close = fclose local.file

end

string_lines local.filepath:

	if (local.filepath == NIL)
		end

	if ( fexists local.filepath != 1 )
		end

	local.file = fopen local.filepath "r"

	local.text = ""
	local.new_text = NIL
	local.lines = 0

	if (local.file != 0)
	{
		local.position = fseek local.file 1 2
		local.length = ftell local.file
		local.length--

		local.close = fclose local.file
		local.file = fopen local.filepath "r"

		if (local.length > 0)
		{
			while ( !feof local.file )
			{
				if (feof local.file)
					break

				local.position = ftell local.file

				local.line = fgets local.file 2000
				if (local.line != "\n")
				{
					local.text += local.line
					local.lines++

					local.new_text[local.lines] = local.text
					local.text = ""
				}

				local.position = ftell local.file

				if (local.position >= local.length)
					break
			}
		}

		local.close = fclose local.file
	}

end local.new_text

string_to_find local.text local.string:

	if ( local.text == NIL || local.string == NIL )
		end

	local.s = 0
	for (local.i = 1;local.i <= local.text.size;local.i++)
	{
		for (local.j = 0;local.j < local.text[local.i].size;local.j++)
		{
			if (local.text[local.i][local.j] == local.string[local.s])
				local.s++
			else
			{
				if (local.s > 0)
					local.s = 0
			}

			if (local.s + 1 == local.string.size)
				end local.i
		}
	}

end

left local.text local.string:

	if ( local.text == NIL || local.string == NIL )
		end

	local.chars = ""
	local.first_char = local.string[0]

	for (local.i = 0;local.i < local.text.size;local.i++)
	{
		if (local.text[local.i] != local.first_char)
		{
			if (local.text[local.i] != "\n")
				local.chars += local.text[local.i]
		}
		else
		{
			local.s = local.i
			for (local.j = 0;local.j < local.string.size;local.j++)
			{
				if (local.text[local.s] == local.string[local.j])
					local.s++

				if ( local.s - local.i == local.string.size )
					end (string local.chars)
			}

			if (local.text[local.i] != "\n")
				local.chars += local.text[local.i]
		}
	}

end

right local.text local.string:

	if ( local.text == NIL || local.string == NIL )
		end

	local.chars = ""
	local.last_char = local.string[local.string.size - 1]

	for (local.i = local.text.size - 1;local.i >= 0;local.i--)
	{
		if (local.text[local.i] != local.last_char)
		{
			if (local.text[local.i] != "\n")
				local.chars += local.text[local.i]
		}
		else
		{
			local.s = local.i
			for (local.j = local.string.size - 1;local.j >= 0;local.j--)
			{
				if (local.text[local.s] == local.string[local.j])
					local.s--

				if ( local.i - local.s == local.string.size )
				{
					local.new_chars = ""
					for (local.k = local.chars.size - 1;local.k >= 0;local.k--)
					{
						local.new_chars += local.chars[local.k]
					}

					end (string local.new_chars)
				}
			}

			if (local.text[local.i] != "\n")
				local.chars += local.text[local.i]
		}
	}

end

player_identification local.name:

	if (local.name == NIL)
		local.name = netname self

	local.ip = getip self
	local.ip = waitthread remove_string local.ip ":"
	local.id = local.name + "+(IP " + local.ip + ")"

end local.id

remove_string local.string local.char:

	local.chars = ""

	for (local.i = 0;local.i < local.string.size;local.i++)
	{
		if (local.string[local.i] != local.char)
			local.chars += local.string[local.i]
		else
			break
	}

end local.chars

```

# zz_veersmods\global\AA\hasznalhato_flak.scr

```scr
spawn_flak local.origin local.angles local.alap local.coll:

	if ( local.origin == NIL || local.origin == NULL )
		end

	if ( local.angles == NIL || local.angles == NULL )
		local.angles = ( 0 0 0 )

	local.origin = trace ( local.origin + ( 0 0 10 ) ) ( ( local.origin[0] local.origin[1] -17123 ) )

	if (local.alap == 1)
	{
		local.flak_alap = spawn script_model model "models/statweapons/flak88base.tik"
		local.flak_alap.origin = local.origin
		local.flak_alap.angles = local.angles
	}

	local.pos = local.origin + angles_toup local.angles * 56
	local.flak_torony = spawn "models/statweapons/flak88turret.tik" origin local.pos angles local.angles

	waitframe

	local.flak_torony thread init_flak local.coll local.origin

end

init_flak local.coll local.origin:

	if ( local.origin == NIL || local.origin == NULL )
		local.origin = self.origin

	if ( local.coll && local.coll.brushmodel )
	{
		self.collisionent = local.coll

		self.collisionent.vehicle = self
		self.collisionent.isvehicle = 1
	}

	self.targetname = "vezetheto_jarmu"
	self.mpteam = "neutral"
	self.last_angles = self.viewangles

	self removeondeath 0
	self takedamage

	self waitexec global/AA/immunities.scr

	local.immunities = crush::telefrag::explosion::bullet::fast_bullet::vehicle::bash::shotgun
	for (local.i = 1;local.i <= local.immunities.size;local.i++)
	{
		self.immunities[local.i] = local.immunities[local.i]
	}

	if (self.collisionent)
	{
		self lock
		self notsolid
	}
	else
	{
		self unlock
		self solid
	}

	self.hasgunner = 0
	self.gunner = NULL

	self.isvehicle = 1
	self.isturret = 1
	self.destroyed = 0

	self.death_exp = self thread spawn_fx "models/fx/fx_tank_explosion.tik"

	self.health = 400

	self.respawn_time = 40

	if !(self.collisionent)
	{
		self setsize ( -48 -34 0 ) ( 48 34 56 )
		self solid
	}

	local.respawn_size1 = ( -60 -40 0 )
	local.respawn_size2 = ( 60 40 70 )

	self.firetime = 4.0
	self.max_lovedek_szama = 50
	self.lovedek_szama = self.max_lovedek_szama
	self.tuzelhet = 1

	self weapontype			cannon
	self name 			"88mm AT Gun"

	self projectile 		"models/projectiles/tigercannonshell.tik"
	self dmprojectile 		"models/projectiles/tigercannonshell.tik"
	self ammotype			"Fakeammo"
	self usenoammo 			0
	self ammorequired		1
	self startammo			0
	self clipsize			1
	self ammo_in_clip		0
	self turnspeed 			30
	self pitchcaps 			"-20 15 0"
	self yawcenter 			self.angle

	self dmammorequired		1
	self dmstartammo		0

	self.maxhealth = self.health
	self.fakehealth = self.maxhealth

	self thread flak_funkciok local.coll local.origin self.angles local.respawn_size1 local.respawn_size2

end

flak_funkciok local.coll local.origin local.angles local.size1 local.size2:

	while ( self != NULL && self.fakehealth > 0 )
	{
		if (self.hasgunner != 1)
			self thread wait_for_activate

		if ( self.gunner != NULL && self.gunner_kamera )
		{
			if (self.gunner.forced_cueplayer == 1)
			{
				self.gunner.forced_cueplayer = 0
				self.gunner_kamera.kam_trigger douse self.gunner
			}

			self.gunner_kamera.angles = ( self.gunner.viewangles[0] self.gunner.viewangles[1] self.angles[2] )
		}

		waitframe
	}

	self thread flak_respawn local.coll local.origin local.angles local.size1 local.size2
	self thread flak_destroyed

end

wait_for_activate:

	local.surface = self
	if (self.collisionent)
		local.surface = self.collisionent

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.player_spawned == 1 )
		{
			if ( local.surface && local.player istouching local.surface )
			{
				if ( local.player.useheld && local.player.inveh != 1 && local.player.inturret != 1 )
				{
					self thread flak_gunner local.player
				}
			}
		}
	}

end

flak_gunner local.gunner:

	self.hasgunner = 1
	self.gunner = local.gunner
	self.gunner.inveh = 1

	local.team = self.gunner.dmteam
	self.mpteam = local.team

	local.angles = vector_toangles ( self.origin - self.gunner.origin )
	self.gunner.viewangles = ( 0 (local.angles[1] + 180) 0 )

	if (self.gunner.has_weapon == 1)
		self.gunner deactivateweapon righthand

	if (self.collisionent)
	{
		self unlock
		self douse self.gunner
	}

	self lock

	self.viewangles = self.last_angles

	local.org = spawn script_origin
	self.gunner glue local.org

	self thread flak_gunner_hud self.gunner
	self thread global/AA/vehicle_damage.scr::vehicle_health_hud self.gunner

	local.kamera = self thread kamera

	waitframe

	self unlock

	while ( self.gunner != NULL && local.gunner.player_spawned == 1 && local.gunner.inturret == 1 )
	{
		if ( self.gunner.fireheld == 1 && self.gunner.secfireheld != 1 && self.tuzelhet == 1 )
			self thread tuzeles

		local.org.origin = self.origin + angles_toforward self.angles * -130 + ( 0 0 -40 ) + angles_toleft self.angles * -30
		local.org.angles = self.angles

		waitframe
	}

	if (local.org)
		local.org remove

	if (local.gunner != NULL)
		local.gunner unglue

	if (local.kamera != NIL)
	{
		if (local.kamera.kam_trigger)
			local.kamera.kam_trigger remove

		local.kamera remove
	}

	self lock

	self thread gunner_getout local.gunner local.team

end

kamera:

	local.name = "flak_kamera" + randomint 999999 + self.gunner.entnum
	local.kamera = spawn func_camera targetname local.name
	local.kamera attach self "origin" 1 ( 0 100 0 )

	cueplayer

	self.gunner waitthread global/AA/vehicle_fixes.scr::vehicle_camera

	local.kam_trigger = spawn trigger_camerause target local.name
	local.kam_trigger douse self.gunner
	local.kam_trigger nottriggerable

	self.gunner_kamera = local.kamera
	self.gunner_kamera.kam_trigger = local.kam_trigger

end local.kamera

gunner_getout local.gunner local.team:

	self.gunner = NULL

	if (local.gunner != NULL)
	{
		local.gunner.origin = self.origin + angles_toleft self.angles * -100 + ( 0 0 24 )
		local.gunner.viewangles = ( 0 self.angles[1] 0 )

		local.gunner surface all "-nodraw"

		ihuddraw_alpha local.gunner 42 0

		local.gunner thread global/AA/vehicle_damage.scr::remove_vehicle_health_hud

		if (local.gunner.dmteam != local.team)
		{
			local.gunner usestuff

			if (local.gunner.dmteam != "spectator")
				local.gunner.disable_spawn = 1

			local.gunner respawn
		}

		local.gunner.inturret = 0
	}

	self.mpteam = "neutral"
	self.last_angles = self.viewangles

	waitframe

	if (self.fakehealth > 0)
	{
		local.target = spawn script_origin origin ( self gettagposition "tag_barrel" + angles_toforward (self gettagangles "tag_barrel") * 10000 )
		self setaimtarget local.target
	}

	wait .5

	if (local.target)
		local.target remove

	wait .5

	if (self)
	{
		self.hasgunner = 0

		if ( self.collisionent == NIL || self.collisionent == NULL )
			self unlock
	}

	if (local.gunner != NULL)
	{
		local.gunner.inveh = 0
		local.gunner.forced_cueplayer = 0
	}

end

tuzeles:

	if (self.lovedek_szama > 0)
	{
		self.tuzelhet = 0

		self ammo_in_clip 1
		self.lovedek_szama--

		local.map = getcvar "mapname"
		if ( local.map != "m3l2" && local.map != "m5l2" && local.map != "m5l3" )
			self playsound flak_snd_fire

		if (self.gunner != NULL)
			ihuddraw_string self.gunner 42 ( "Shell: " + self.lovedek_szama )

		if (self.lovedek_szama > 0)
			self thread flak_ujratoltes self.firetime
		else
			self thread flak_add_ammo
	}

end

flak_add_ammo:

	wait 60

	if (self == NULL)
		end

	self.lovedek_szama = self.max_lovedek_szama

	if (self.gunner != NULL)
		ihuddraw_string self.gunner 42 ( "Shell: " + self.lovedek_szama )

	if (self)
		self.tuzelhet = 1

end

flak_ujratoltes local.firetime:

	wait local.firetime

	if (self)
		self.tuzelhet = 1

end

flak_respawn local.coll local.origin local.angles local.size1 local.size2:

	local.respawn_time = self.respawn_time

	while (self.destroyed_model == NIL)
		wait .1

	if (self == NULL)
		end

	local.destroyed_model = self.destroyed_model

	if (local.destroyed_model.collision)
		local.collision = local.destroyed_model.collision

	wait 10

	local.exp = local.destroyed_model waitthread spawn_fx "models/fx/fx_tank_explosion.tik"
	local.exp.origin = local.destroyed_model.origin + ( 0 0 10 )
	local.exp anim start
	local.exp playsound explode_flak
	local.exp thread remove_fx

	wait .5

	local.destroyed_model remove

	if (local.collision)
		local.collision remove

	wait local.respawn_time

	waitexec global/AA/vehicle_respawn.scr local.origin local.angles local.size1 local.size2

	thread spawn_flak local.origin local.angles 0 local.coll

end

flak_destroyed:

	self playsound explode_flak88
	self setaimtarget NULL
	self show

	if (self.gunner)
	{
		local.gunner = self.gunner
		self.gunner = NULL
	}

	if ( self.last_attacker == NIL || self.last_attacker == NULL )
		self.last_attacker = $world

	local.origin = self.origin
	local.angles = self.angles

	if (self.collisionent)
	{
		local.brushmodel = self.collisionent.brushmodel
		self.collisionent remove
	}

	self.death_exp.origin = self.origin
	waitframe

	if (local.gunner)
	{
		local.gunner takedamage
		local.gunner damage self.last_attacker 1000 self.last_attacker ( 0 0 0 ) ( 0 0 0 ) ( 0 0 0 ) 0 0 9 0
	}

	self.death_exp anim start
	self.death_exp thread remove_fx

	radiusdamage ( self.origin + ( 0 0 200 ) ) 400 400

	self hide
	self notsolid

	if (local.brushmodel)
	{
		local.collision = thread damaged_collision local.brushmodel local.origin local.angles
	}

	local.damaged = thread spawn_damaged "models/statweapons/flak88_d.tik" local.origin local.angles

	if (local.collision != NIL)
	{
		local.damaged notsolid
		local.collision disconnect_paths
		local.damaged.collision = local.collision
	}

	self.destroyed_model = local.damaged

	wait 2

	self remove

end

flak_gunner_hud local.gunner:

	ihuddraw_align local.gunner 42 left bottom
	ihuddraw_rect local.gunner 42 540 -50 0 0
	ihuddraw_color local.gunner 42 0.0 1.0 1.0
	ihuddraw_font local.gunner 42 "facfont-20"
	ihuddraw_string local.gunner 42 ( "Shell: " + self.lovedek_szama )
	ihuddraw_virtualsize local.gunner 42 1
	ihuddraw_alpha local.gunner 42 1

end

remove_fx:

	wait 5
	self remove

end

spawn_damaged local.model local.origin local.angles:
	local.damaged = spawn script_model model local.model
	local.damaged.origin = local.origin
	local.damaged.angles = local.angles
	local.damaged solid
	local.damaged nodamage
end local.damaged

spawn_fx local.fx:
	local.temp = spawn script_model model local.fx
	local.temp.origin = self.origin
	local.temp notsolid
end local.temp

damaged_collision local.brushmodel local.origin local.angles:
	local.collision = spawn script_object model local.brushmodel
	local.collision.origin = local.origin
	local.collision.angles = local.angles
	local.collision solid
end local.collision

```

# zz_veersmods\global\AA\hasznalhato_nebelwerfer.scr

```scr
spawn_nebelwerfer local.origin local.angles local.coll:

	if ( local.origin == NIL || local.origin == NULL )
		end

	if ( local.angles == NIL || local.angles == NULL )
		local.angles = ( 0 0 0 )

	local.pos = trace ( local.origin + ( 0 0 10 ) ) ( (local.origin[0] local.origin[1] -17123) )
	local.neb = spawn VehicleTurretGun model "models/statweapons/nebelwerfer.tik" origin local.pos angles local.angles

	waitframe

	local.neb thread init_nebelwerfer local.coll local.origin

end

init_nebelwerfer local.coll local.origin:

	if ( local.origin == NIL || local.origin == NULL )
		local.origin = self.origin

	if ( local.coll && local.coll.brushmodel )
	{
		self.collisionent = local.coll

		self.collisionent.vehicle = self
		self.collisionent.isvehicle = 1
	}

	self.targetname = "vezetheto_jarmu"
	self.mpteam = "neutral"
	self.last_angles = self.viewangles

	self removeondeath 0
	self takedamage

	self waitexec global/AA/immunities.scr

	local.immunities = crush::telefrag::explosion::bullet::fast_bullet::vehicle::bash::shotgun
	for (local.i = 1;local.i <= local.immunities.size;local.i++)
	{
		self.immunities[local.i] = local.immunities[local.i]
	}

	if (self.collisionent)
	{
		self lock
		self notsolid
	}
	else
	{
		self unlock
		self solid
	}

	self.hasgunner = 0
	self.gunner = NULL

	self.isvehicle = 1
	self.isturret = 1
	self.destroyed = 0

	self.death_exp = self thread spawn_fx "models/fx/fx_tank_explosion.tik"

	self.health = 400

	self.respawn_time = 40

	if !(self.collisionent)
	{
		self setsize ( -20 -40 0 ) ( 40 40 80 )
		self solid
	}

	local.respawn_size1 = ( -40 -60 0 )
	local.respawn_size2 = ( 40 60 80 )

	self.lovedek_betoltve = 6
	self.tuzelocso = 0
	self.csoszam = 6
	self.firetime = 0.3
	self.max_lovedek_szama = 96
	self.lovedek_szama = self.max_lovedek_szama
	self.tuzelhet = 1

	self weapontype		cannon
	self name		"Nebelwerfer"

	self idleCheckOffset	self.angles

	// Primary fire type info
	self projectile		models/projectiles/nebelwerfershell.tik
	self dmprojectile	models/projectiles/nebelwerfershell.tik
	self firetype		heavy
	self ammotype		"Fakeammo"
	self usenoammo 		0
	self ammorequired	1
	self startammo		0
	self clipsize		1
	self ammo_in_clip	0
	self firedelay		7
	self turnspeed		25
	self pitchcaps		"-20 7 0"
	self yawcenter		self.angle

	self dmammorequired	1
	self dmstartammo	0

	self SoundSet		"flak_"

	self.maxhealth = self.health
	self.fakehealth = self.maxhealth

	self thread nebelwerfer_funkciok local.coll local.origin self.angles local.respawn_size1 local.respawn_size2

end

nebelwerfer_funkciok local.coll local.origin local.angles local.size1 local.size2:

	local.tag_barrel[1] = spawn script_origin
	local.tag_barrel[2] = spawn script_origin
	local.tag_barrel[3] = spawn script_origin
	local.tag_barrel[4] = spawn script_origin
	local.tag_barrel[5] = spawn script_origin
	local.tag_barrel[6] = spawn script_origin

	for (local.i = 1;local.i <= local.tag_barrel.size;local.i++)
	{
		self.tag_barrel[local.i] = local.tag_barrel[local.i]
	}

	while ( self != NULL && self.fakehealth > 0 )
	{
		if (self.hasgunner != 1)
			self thread wait_for_activate

		local.tag_barrel[1].origin = self.origin + angles_toforward self.angles * 71 + angles_toleft self.angles * -6 + angles_toup self.angles * 73
		local.tag_barrel[1].angles = self.angles

		local.tag_barrel[2].origin = self.origin + angles_toforward self.angles * 71 + angles_toleft self.angles * 6 + angles_toup self.angles * 73
		local.tag_barrel[2].angles = self.angles

		local.tag_barrel[3].origin = self.origin + angles_toforward self.angles * 71 + angles_toleft self.angles * 10 + angles_toup self.angles * 63
		local.tag_barrel[3].angles = self.angles

		local.tag_barrel[4].origin = self.origin + angles_toforward self.angles * 71 + angles_toleft self.angles * 6 + angles_toup self.angles * 54
		local.tag_barrel[4].angles = self.angles

		local.tag_barrel[5].origin = self.origin + angles_toforward self.angles * 71 + angles_toleft self.angles * -6 + angles_toup self.angles * 54
		local.tag_barrel[5].angles = self.angles

		local.tag_barrel[6].origin = self.origin + angles_toforward self.angles * 71 + angles_toleft self.angles * -10 + angles_toup self.angles * 63
		local.tag_barrel[6].angles = self.angles

		if ( self.gunner != NULL && self.gunner_kamera )
		{
			if (self.gunner.forced_cueplayer == 1)
			{
				self.gunner.forced_cueplayer = 0
				self.gunner_kamera.kam_trigger douse self.gunner
			}

			self.gunner_kamera.origin =  self gettagposition "Box02" + angles_toforward self.angles * -30 + angles_toup self.angles * 90
			self.gunner_kamera.angles = ( self.gunner.viewangles[0] self.gunner.viewangles[1] self.angles[2] )
		}

		waitframe
	}

	self thread nebelwerfer_respawn local.coll local.origin local.angles local.size1 local.size2
	self thread nebelwerfer_destroyed

	wait 1

	for (local.i = 1;local.i <= local.tag_barrel.size;local.i++)
	{
		if (local.tag_barrel[local.i])
			local.tag_barrel[local.i] remove
	}

end

wait_for_activate:

	local.surface = self
	if (self.collisionent)
		local.surface = self.collisionent

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.player_spawned == 1 )
		{
			if ( local.surface && local.player istouching local.surface )
			{
				if ( local.player.useheld && local.player.inveh != 1 && local.player.inturret != 1 )
				{
					self thread nebelwerfer_gunner local.player
				}
			}
		}
	}

end

nebelwerfer_gunner local.gunner:

	self.hasgunner = 1
	self.gunner = local.gunner
	self.gunner.inveh = 1

	local.team = self.gunner.dmteam
	self.mpteam = local.team

	local.angles = vector_toangles ( self.origin - self.gunner.origin )
	self.gunner.viewangles = ( 0 (local.angles[1] + 180) 0 )

	if (self.gunner.has_weapon == 1)
		self.gunner deactivateweapon righthand

	if (self.collisionent)
	{
		self unlock
		self douse self.gunner
	}

	self lock

	self.viewangles = self.last_angles

	local.org = spawn script_origin
	self.gunner glue local.org

	self thread nebelwerfer_gunner_hud self.gunner
	self thread global/AA/vehicle_damage.scr::vehicle_health_hud self.gunner

	local.kamera = self thread kamera

	waitframe

	self unlock

	while ( self.gunner != NULL && local.gunner.player_spawned == 1 && local.gunner.inturret == 1 )
	{
		if ( self.gunner.fireheld == 1 && self.gunner.secfireheld != 1 && self.tuzelhet == 1 )
			self thread tuzeles

		local.org.origin = self.origin + angles_toforward self.angles * -70
		local.org.angles = self.angles

		waitframe
	}

	if (local.org)
		local.org remove

	if (local.gunner != NULL)
		local.gunner unglue

	if (local.kamera != NIL)
	{
		if (local.kamera.kam_trigger)
			local.kamera.kam_trigger remove

		local.kamera remove
	}

	self lock

	self thread gunner_getout local.gunner local.team

end

kamera:

	local.name = "nebelwerfer_kamera" + randomint 999999 + self.gunner.entnum
	local.kamera = spawn func_camera targetname local.name
	local.kamera.origin =  self gettagposition "Box02" + angles_toforward self.angles * -30 + angles_toup self.angles * 90

	cueplayer

	self.gunner waitthread global/AA/vehicle_fixes.scr::vehicle_camera

	local.kam_trigger = spawn trigger_camerause target local.name
	local.kam_trigger douse self.gunner
	local.kam_trigger nottriggerable

	self.gunner_kamera = local.kamera
	self.gunner_kamera.kam_trigger = local.kam_trigger

end local.kamera

gunner_getout local.gunner local.team:

	self.gunner = NULL

	if (local.gunner != NULL)
	{
		local.gunner.origin = self.origin + angles_toforward ( 0 self.angles[1] 0 ) * -90 + ( 0 0 16 )
		local.gunner.viewangles = ( 0 self.angles[1] 0 )

		local.gunner surface all "-nodraw"

		ihuddraw_alpha local.gunner 42 0

		local.gunner thread global/AA/vehicle_damage.scr::remove_vehicle_health_hud

		if (local.gunner.dmteam != local.team)
		{
			local.gunner usestuff

			if (local.gunner.dmteam != "spectator")
				local.gunner.disable_spawn = 1

			local.gunner respawn
		}

		local.gunner.inturret = 0
	}

	self.mpteam = "neutral"
	self.last_angles = self.viewangles

	waitframe

	if (self.fakehealth > 0)
	{
		local.target = spawn script_origin origin ( self.tag_barrel[1].origin + angles_toforward self.angles * 10000 )
		self setaimtarget local.target
	}

	wait .5

	if (local.target)
		local.target remove

	wait .5

	if (self)
	{
		self.hasgunner = 0

		if ( self.collisionent == NIL || self.collisionent == NULL )
			self unlock
	}

	if (local.gunner != NULL)
	{
		local.gunner.inveh = 0
		local.gunner.forced_cueplayer = 0
	}

end

tuzeles:

	if (self.lovedek_betoltve > 0)
	{
		self.tuzelhet = 0

		if (self.tuzelocso >= 6)
			self.tuzelocso = 0

		self.tuzelocso++
		self shoot

		local.pos = self.tag_barrel[self.tuzelocso].origin

		local.smoke = spawn script_model model "models/fx/cannonsmoke.tik" origin local.pos angles self.angles
		local.smoke notsolid
		local.smoke anim idle
		local.smoke thread remove_smoke

		self.lovedek_betoltve--

		if (self.gunner != NULL)
			ihuddraw_string self.gunner 42 ( "Shell: " + self.lovedek_betoltve + " | " + self.lovedek_szama )

		self thread nebelwerfer_projectile self.gunner

		if (self.lovedek_betoltve == 0)
			self thread nebelwerfer_teljes_ujratoltes
		else
			self thread nebelwerfer_tolt self.firetime
	}

end

remove_smoke:

	wait 2

	self remove

end

nebelwerfer_tolt local.firetime:

	wait local.firetime

	if (self)
		self.tuzelhet = 1

end

flak_add_ammo:

	wait 60

	if (self == NULL)
		end

	self.lovedek_szama = self.max_lovedek_szama

	if (self)
		self.tuzelhet = 1

end

nebelwerfer_teljes_ujratoltes:

	if (self.lovedek_szama <= 0)
		self thread flak_add_ammo

	while ( self.fakehealth > 0 && self.lovedek_szama <= 0 )
		waitframe

	if (self.fakehealth <= 0)
		end

	wait 3

	if (self != NULL)
	{
		if (self.lovedek_szama >= self.csoszam)
		{
			local.a = self.lovedek_szama - self.csoszam
			local.a = self.lovedek_szama - local.a
		}
		else
			local.a = self.lovedek_szama

		self.lovedek_betoltve = local.a
		self.lovedek_szama -= self.lovedek_betoltve

		if (self.lovedek_szama < 0)
			self.lovedek_szama = 0

		if (self.lovedek_betoltve > 0)
			self.tuzelhet = 1

		if (self.gunner != NULL)
			ihuddraw_string self.gunner 42 ( "Shell: " + self.lovedek_betoltve + " | " + self.lovedek_szama )
	}

end

nebelwerfer_projectile local.attacker:

	local.nebelproj = NULL
	while (local.nebelproj == NULL)
	{
		waitframe

		if ($nebelwerfer_proj.size > 0)
		{
			for (local.i = 1;local.i <= $nebelwerfer_proj.size;local.i++)
			{
				local.proj = $nebelwerfer_proj[local.i]

				if ( local.proj != NULL && local.proj.attacker != NIL && local.proj.attacker != NULL && local.proj.attacker == local.attacker && local.proj.checked != 1 )
				{
					local.proj.checked = 1
					local.nebelproj = local.proj

					break
				}
			}
		}
	}

	if (self != NULL && local.nebelproj != NULL )
	{
		local.origin = self.tag_barrel[self.tuzelocso].origin + angles_toforward self.angles * 200
		local.angles = self.angles

		local.nebelproj.origin = local.origin
		local.nebelproj.angles = local.angles

		local.nebelproj.velocity = angles_toforward local.nebelproj.angles * 4000
		local.nebelproj gravity 1.0

		local.rocket = spawn script_model model "models/fx/fx_nebelwerfer.tik"
		local.rocket.origin = local.origin
		local.rocket.angles = local.angles
		local.rocket notsolid
		local.rocket glue local.nebelproj

		local.nebelproj hitdamage 300
		local.nebelproj explosionmodel "models/fx/explosionnebelwerfershell.tik"
		local.nebelproj explodeontouch

		local.nebelproj playsound nebelwerfer_launch

		while (local.nebelproj != NULL)
			waitframe

		local.exp = spawn script_model model "models/emitters/mortar_dirt_nebelwerfer.tik"
		local.exp.origin = local.rocket.origin
		local.exp notsolid
		local.exp anim start
		local.exp playsound arty_exp_sand

		local.rocket remove

		wait 3

		local.exp remove
	}

end

nebelwerfer_respawn local.coll local.origin local.angles local.size1 local.size2:

	local.respawn_time = self.respawn_time

	while (self.destroyed_model == NIL)
		wait .1

	if (self == NULL)
		end

	local.destroyed_model = self.destroyed_model

	if (local.destroyed_model.collision)
		local.collision = local.destroyed_model.collision

	wait 10

	local.exp = local.destroyed_model waitthread spawn_fx "models/fx/fx_tank_explosion.tik"
	local.exp.origin = local.destroyed_model.origin + ( 0 0 10 )
	local.exp anim start
	local.exp playsound explode_flak
	local.exp thread remove_fx

	wait .5

	local.destroyed_model remove

	if (local.collision)
		local.collision remove

	wait local.respawn_time

	waitexec global/AA/vehicle_respawn.scr local.origin local.angles local.size1 local.size2

	thread spawn_nebelwerfer local.origin local.angles local.coll

end

nebelwerfer_destroyed:

	self playsound explode_flak88
	self setaimtarget NULL
	self show

	if (self.gunner)
	{
		local.gunner = self.gunner
		self.gunner = NULL
	}

	if ( self.last_attacker == NIL || self.last_attacker == NULL )
		self.last_attacker = $world

	local.origin = self.origin
	local.angles = self.angles

	if (self.collisionent)
	{
		local.brushmodel = self.collisionent.brushmodel
		self.collisionent remove
	}

	self.death_exp.origin = self.origin
	waitframe

	if (local.gunner)
	{
		local.gunner takedamage
		local.gunner damage self.last_attacker 1000 self.last_attacker ( 0 0 0 ) ( 0 0 0 ) ( 0 0 0 ) 0 0 9 0
	}

	self.death_exp anim start
	self.death_exp thread remove_fx

	radiusdamage ( self.origin + ( 0 0 200 ) ) 400 400

	self hide
	self notsolid

	if (local.brushmodel)
	{
		local.collision = thread damaged_collision local.brushmodel local.origin local.angles
	}

	local.damaged = thread spawn_damaged "models/statweapons/nebelwerfer_d.tik" local.origin local.angles
	local.damaged setsize ( 0 -40 0 ) ( 67 40 80 )

	local.damaged loopsound fire_med

	if (local.collision != NIL)
	{
		local.damaged notsolid
		local.collision disconnect_paths
		local.damaged.collision = local.collision
	}

	self.destroyed_model = local.damaged

	wait 2

	self remove

end

nebelwerfer_gunner_hud local.gunner:

	ihuddraw_align local.gunner 42 left bottom
	ihuddraw_rect local.gunner 42 540 -50 0 0
	ihuddraw_color local.gunner 42 0.0 1.0 1.0
	ihuddraw_font local.gunner 42 "facfont-20"
	ihuddraw_string local.gunner 42 ( "Shell: " + self.lovedek_betoltve + " | " + self.lovedek_szama )
	ihuddraw_virtualsize local.gunner 42 1
	ihuddraw_alpha local.gunner 42 1

end

remove_fx:

	wait 5
	self remove

end

spawn_damaged local.model local.origin local.angles:
	local.damaged = spawn script_model model local.model
	local.damaged.origin = local.origin
	local.damaged.angles = local.angles
	local.damaged solid
	local.damaged nodamage
end local.damaged

spawn_fx local.fx:
	local.temp = spawn script_model model local.fx
	local.temp.origin = self.origin
	local.temp notsolid
end local.temp

damaged_collision local.brushmodel local.origin local.angles:
	local.collision = spawn script_object model local.brushmodel
	local.collision.origin = local.origin
	local.collision.angles = local.angles
	local.collision solid
end local.collision

```

# zz_veersmods\global\AA\heatseeker.scr

```scr
main:

	local.hs = getcvar "heatseeker"
	if (local.hs == "")
		setcvar "heatseeker" "0"

	local.hs = int ( getcvar "heatseeker" )
	if (local.hs != 1)
		end

	local.mapname = getcvar "mapname"

	switch (local.mapname)
	{
		case "m1l3a":
			local.datas = makeArray
			( -1622 -5899 368 ) ( 0 180 0 )
			( -3584 -3360 302 ) ( 0 90 0 )
			( -3076 -1317 343 ) ( -13 0 0 )
			( -2095 -3182 101 ) ( 0 180 0 )
			endArray
		break
		case "m1l3b":
			local.datas = makeArray
			( 180 397 121 ) ( 0 270 0 )
			( -2573 -1108 70 ) ( 0 -204 0 )
			( -3417 696 78 ) ( 0 270 0 )
			( -5500 1616 111 ) ( 0 90 0 )
			endArray
		break
		case "m4l0":
			local.datas = makeArray
			( 2374 -1294 209 ) ( 10 -116 0 )
			( 2099 -3849 -9 ) ( 0 -107 0 )
			endArray
		break
		case "m4l1":
			local.datas = makeArray
			( 2838 -3732 284 ) ( 0 270 0 )
			( 2214 -3734 96 ) ( 0 90 0 )
			( 5119 -638 93 ) ( 15 -100 0 )
			( 4337 -3628 209 ) ( 0 -220 0 )
			endArray
		break
		case "m4l3":
			local.datas = makeArray
			( -5944 350 74 ) ( 0 90 0 )
			( -4531 1005 84 ) ( 0 0 0 )
			( -4705 2789 107 ) ( 0 0 0 )
			( -5823 2639 107 ) ( 0 270 0 )
			endArray
		break
		case "m5l2a":
			local.datas = makeArray
			( 1838 4932 374 ) ( 0 0 0 )
			( 947 2054 381 ) ( 0 0 0 )
			( 4186 5153 395 ) ( 0 180 0 )
			( -733 2071 367 ) ( 0 90 0 )
			endArray
		break
		case "m5l3":
			local.datas = makeArray
			( 295 2697 514 ) ( 0 -194 0 )
			( -658 4199 506 ) ( 0 0 0 )
			( 266 1666 984 ) ( 0 180 0 )
			( 992 4202 589 ) ( 0 90 0 )
			endArray
		break
	}

	if (local.datas == NIL)
		end

	level waittill spawn

	local.hs_amount = getcvar "heatseeker_amount"
	if (local.hs_amount == "")
		setcvar "heatseeker_amount" "5"

	local.hs_amount = int ( getcvar "heatseeker_amount" )

	level.allies_heatseeker = 0
	level.axis_heatseeker = 0
	level.max_heatseeker_count = local.hs_amount

	local.new_origin = waitthread check_datas local.datas 1
	local.new_angles = waitthread check_datas local.datas 2

	thread spawn_heatseeker local.new_origin local.new_angles 999

end

spawn_heatseeker local.origin local.angles local.last_num:

	local.num = waitthread random_position local.origin.size local.last_num

	local.weapon = spawn script_model
	local.weapon.origin = local.origin[local.num]
	local.weapon.angles = local.angles[local.num] + ( 0 0 90 )
	local.weapon model "models/weapons/bazooka.tik"
	local.weapon notsolid

	local.weapon.scope = spawn script_model
	local.weapon.scope attach local.weapon "origin" 1 ( 8 2.6 -2.1 )
	local.weapon.scope model "models/weapons/kar98sniper.tik"
	local.weapon.scope notsolid

	local.weapon.scope surface KAR981 "+nodraw"
	local.weapon.scope surface KAR982 "+nodraw"

	local.t = spawn trigger_use
	local.t.origin = local.weapon.origin
	local.t setsize ( -10 -10 0 ) ( 10 10 20 )

	local.weapon light 1.0 0.0 0.0 80

	local.weapon thread pickup_heatseeker local.t local.origin local.angles local.num

end

pickup_heatseeker local.t local.origin local.angles local.last_num:

	local.t waittill trigger

	local.player = parm.other

	if (local.player.has_heatseeker == 1)
	{
		local.player iprint "You already have a Heat-seeking Launcher." 1

		goto pickup_heatseeker local.t local.origin local.angles local.last_num
		end
	}

	if ( local.player.dmteam == "allies" && level.allies_heatseeker == 2 )
	{
		local.player iprint "Your team already has 2 Heat-seeking Launchers." 1

		goto pickup_heatseeker local.t local.origin local.angles local.last_num
		end
	}
	else if ( local.player.dmteam == "axis" && level.axis_heatseeker == 2 )
	{
		local.player iprint "Your team already has 2 Heat-seeking Launchers." 1

		goto pickup_heatseeker local.t local.origin local.angles local.last_num
		end
	}

	if ( local.player.heatseeker_count != NIL && local.player.heatseeker_count <= 0 )
	{
		local.player iprint "You can't get more Heat-seeking Launchers." 1

		goto pickup_heatseeker local.t local.origin local.angles local.last_num
		end
	}

	self light 0 0 0 0

	local.scope = self.scope
	local.scope detach

	self remove
	local.t remove

	if (local.player.dmteam == "allies")
		level.allies_heatseeker++
	else if (local.player.dmteam == "axis")
		level.axis_heatseeker++

	local.player.has_heatseeker = 1

	local.player iprint "You picked up a Heat-seeking Launcher."

	iprintlnbold "The Heat-seeking Missile Launcher is in new position now!"

	thread spawn_heatseeker local.origin local.angles local.last_num

	local.player take models/weapons/bazooka.tik
	local.player take models/weapons/panzerschreck.tik

	local.player deactivateweapon righthand

	waitframe

	local.player give models/weapons/bazooka.tik
	local.player use models/weapons/bazooka.tik

	while ( local.player != NULL && local.player.player_spawned == 1 && local.player.current_weapon == NULL )
		waitframe

	if ( local.player == NULL || local.player.player_spawned != 1 )
		end

	if (local.player.current_weapon.model != "models/weapons/bazooka.tik")
		end

	local.player thread init_heatseeker local.player.current_weapon local.scope

end

init_heatseeker local.weapon local.scope:

	if (self.heatseeker_help != 1)
	{
		self.heatseeker_help = 1
		self thread help
	}

	local.scope attach local.weapon "origin" 1 ( 8 2.6 -2.1 )

	if (self.heatseeker_count == NIL)
		self.heatseeker_count = level.max_heatseeker_count

	local.weapon noammosound		snd_step_paper
	local.weapon ammotype			"fakeammo"
	local.weapon dmmovementspeed		0.55
	local.weapon ammo_in_clip		0 semiauto

	local.weapon.canfire = 0
	local.weapon.reloadtime = 5
	local.weapon.reloading = 0
	local.weapon.laseron = 0
	local.weapon.can_switch_laser = 1
	local.weapon.lockon_phase = 1
	local.weapon.targeted_pos = NULL
	local.weapon.targeted_vehicle = NULL

	local.locking_delay = 1
	local.lasttime = level.time

	local.weapon.laser_org = spawn script_model
	local.weapon.laser_org notsolid

	local.team = self.dmteam

	while ( self != NULL && self.player_spawned == 1 && self.heatseeker_count > 0 )
	{
		waitframe

		if ( self == NULL || self.player_spawned != 1 )
			break

		if ( self.current_weapon != NULL && self.current_weapon == local.weapon )
		{
			if ( self.fireheld == 1 && self.secfireheld != 1 )
			{
				if (local.weapon.canfire == 1)
				{
					self viewmodelanim fire 1

					self thread fire_missile local.weapon local.team

					self.heatseeker_count--
					if (self.heatseeker_count > 0)
						self iprint ( "You have " + self.heatseeker_count + " Heat-seeking Missile(s)." ) 1

					local.weapon thread reload_weapon local.weapon.reloadtime

					self stoploopsound

					local.weapon.canfire = 0
					local.weapon.isreloading = 1
					local.weapon.laseron = 0
					local.weapon.can_switch_laser = 0
					local.weapon.lockon_phase = 1
					local.weapon.targeted_pos = NULL
					local.weapon.targeted_vehicle = NULL
				}
			}
			else if ( self.fireheld == 1 && self.secfireheld == 1 )
			{
				if (local.weapon.can_switch_laser == 1)
				{
					if (local.weapon.laseron != 1)
					{
						local.weapon.laseron = 1
						local.weapon.can_switch_laser = 0

						local.weapon thread switch_laser

						local.weapon.targeted_pos = NULL
						local.weapon.targeted_vehicle = NULL
						local.weapon.lockon_phase = 1
					}
					else
					{
						local.weapon.laseron = 0
						local.weapon.can_switch_laser = 0

						local.weapon thread switch_laser

						if (local.weapon.canfire == 1)
							self stoploopsound

						local.weapon.canfire = 0
						local.weapon.laseron = 0
						local.weapon.lockon_phase = 1
						local.weapon.targeted_pos = NULL
						local.weapon.targeted_vehicle = NULL
					}
				}
			}
		}
		else
		{
			if (local.weapon != NULL)
			{
				if (local.weapon.canfire == 1)
					self stoploopsound

				local.weapon.canfire = 0
				local.weapon.laseron = 0
				local.weapon.lockon_phase = 1
				local.weapon.targeted_pos = NULL
				local.weapon.targeted_vehicle = NULL

				if (local.weapon.angles[2] == 90.0)
					break
			}
		}

		if (local.weapon.isreloading == 1)
			continue

		if (local.weapon.laseron != 1)
		{
			if (local.weapon.canfire == 1)
				self stoploopsound

			local.weapon.canfire = 0
			local.weapon.laseron = 0
			local.weapon.lockon_phase = 1
			local.weapon.targeted_pos = NULL
			local.weapon.targeted_vehicle = NULL

			continue
		}

		if (local.weapon.lockon_phase == 1)
		{
			self waitthread vehicletarget local.weapon

			if (local.weapon.targeted_vehicle == NULL)
				local.weapon.targeted_pos = local.weapon.laser_org.origin
			else
				self iprint "Locking Vehicle..."

			self playsound heatseeker_lockon

			local.weapon.lockon_phase = 2
			local.lasttime = level.time
		}
		else if (local.weapon.lockon_phase == 2)
		{
			if ( level.time - local.lasttime < local.locking_delay )
				continue

			if (local.weapon.targeted_vehicle != NULL)
			{
				local.targeted_vehicle = local.weapon.targeted_vehicle
				self waitthread vehicletarget local.weapon

				if ( local.weapon.targeted_vehicle == NULL || local.weapon.targeted_vehicle != local.targeted_vehicle )
				{
					local.weapon.laseron = 0
					local.weapon.lockon_phase = 1
					local.weapon.targeted_pos = NULL
					local.weapon.targeted_vehicle = NULL

					continue
				}
				else
					self iprint "Locking Vehicle..."
			}

			self playsound heatseeker_lockon

			local.weapon.lockon_phase = 3
			local.lasttime = level.time
		}
		else if (local.weapon.lockon_phase == 3)
		{
			if ( level.time - local.lasttime < local.locking_delay )
				continue

			if (local.weapon.targeted_vehicle != NULL)
			{
				local.targeted_vehicle = local.weapon.targeted_vehicle
				self waitthread vehicletarget local.weapon

				if ( local.weapon.targeted_vehicle == NULL || local.weapon.targeted_vehicle != local.targeted_vehicle )
				{
					if (local.weapon.canfire == 1)
						self stoploopsound

					local.weapon.canfire = 0
					local.weapon.laseron = 0
					local.weapon.lockon_phase = 1
					local.weapon.targeted_pos = NULL
					local.weapon.targeted_vehicle = NULL

					continue
				}
			}

			if (local.weapon.canfire != 1)
			{
				local.weapon.canfire = 1

				self loopsound heatseeker_locked

				if (local.weapon.targeted_vehicle != NULL)
					self iprint "Vehicle Locked!!!"
			}

			local.lasttime = level.time + local.locking_delay
		}
	}

	if (self != NULL)
	{
		self.has_heatseeker = 0

		self stoploopsound
	}

	if (local.team == "allies")
		level.allies_heatseeker--
	else if (local.team == "axis")
		level.axis_heatseeker--

	if (local.scope)
		local.scope remove

	if (local.weapon)
	{
		if (local.weapon.laser_org)
			local.weapon.laser_org remove

		local.weapon remove
	}

end

switch_laser:

	wait .5

	if (self)
		self.can_switch_laser = 1

end

vehicletarget local.weapon:

	local.pos = self gettagposition "eyes bone"
	local.trace = waitexec global/AA/trace.scr local.pos ( local.pos + angles_toforward self.viewangles * 20000 ) self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569441
	local.weapon.laser_org.origin = local.trace["endPos"]

	local.gt = int ( getcvar "g_gametype" )
	local.td = int ( getcvar "g_teamdamage" )

	local.weapon.targeted_vehicle = NULL

	for (local.i = 1;local.i <= $vezetheto_jarmu.size;local.i++)
	{
		local.veh = $vezetheto_jarmu[local.i]

		if !(isAlive local.veh)
			continue

		local.surface = local.veh
		if (local.surface.collisionent)
			local.surface = local.surface.collisionent

		if ( local.gt == 1 || ( local.gt > 1 && local.td == 1 ) || ( local.gt > 1 && local.td != 1 && local.veh.mpteam && local.veh.mpteam != self.dmteam ) )
		{
			if (local.weapon.laser_org istouching local.surface)
			{
				local.weapon.targeted_vehicle = local.veh
				break
			}
		}
	}

end

fire_missile local.weapon local.team:

	local.weapon playsound bazooka_snd_fire

	if ( self getposition == "standing" )
		local.z = 90
	else
		local.z = 60

	local.missile = spawn script_model
	local.missile.origin = self.origin + angles_toforward self.angles * 40 + ( 0 0 local.z )
	local.missile.angles = ( 90 self.viewangles[1] 0 )
	local.missile model "models/static/v2.tik"
	local.missile.scale = 0.04
	local.missile setsize ( 0 -3 -3 ) ( 10 0 0 )
	local.missile notsolid

	local.smoke = spawn script_model
	local.smoke model "models/projectiles/bazookashell_dm.tik"
	local.smoke glue local.missile
	local.smoke notsolid
	local.smoke surface all "+nodraw"

	local.missile.attacker = self

	local.missile physics_on
	local.missile gravity 1.3

	local.missile.destroyed = 0
	local.missile.following_target = 0
	local.missile.speed = 100

	local.target = NULL
	if (local.weapon.targeted_vehicle != NULL)
	{
		local.target = local.weapon.targeted_vehicle
		local.endpos = local.target.origin
	}
	else
		local.endpos = local.weapon.targeted_pos

	local.missile thread missile_flying local.missile.attacker local.smoke local.team local.target local.endpos

	wait .3

	if (local.missile == NULL)
		end

	local.missile thread up_angles

	local.missile.speed = 700
	local.missile physics_off

	local.missile loopsound heatseeker_proj_loop

	wait 3

	if (local.missile == NULL)
		end

	if (local.target != NULL)
		local.nextpos = ( local.target.origin[0] local.target.origin[1] (local.missile.origin[2] + 500) )
	else
		local.nextpos = ( local.endpos[0] local.endpos[1] (local.missile.origin[2] + 500) )

	local.angles = vector_toangles ( local.missile.origin - local.nextpos )
	local.missile.angles = local.angles - ( 90 0 0 )
	local.dist = vector_length ( local.missile.origin - local.nextpos )
	local.dist = local.dist * 0.75
	local.missile.speed = local.dist / 2.0

	wait 2

	if (local.missile == NULL)
		end

	local.life = 300
	local.missile.speed = 1500
	local.missile.following_target = 1

end

missile_flying local.player local.smoke local.team local.target local.endpos:

	local.life = 400

	while ( self != NULL && local.player != NULL && local.player.dmteam == local.team && self.destroyed != 1 && local.life > 0 )
	{
		if (self.following_target == 1)
		{
			if (local.target != NULL)
				local.nextpos = local.target.origin
			else
				local.nextpos = local.endpos

			if (self.origin[2] > local.nextpos[2])
			{
				local.angles = vector_toangles ( self.origin - local.nextpos )
				self.angles = local.angles - ( 90 0 0 )
			}
		}

		self.velocity = angles_toforward ( (self.angles[0] - 90) self.angles[1] self.angles[2] ) * self.speed

		local.sky = self waitthread check_sky_bottom self.origin
		self waitthread check_missile_impact local.sky

		self.current_pos = self.origin

		waitframe

		self.last_pos = self.origin

		local.life--
	}

	self stoploopsound

	self.velocity = ( 0 0 0 )

	local.smoke remove
	self remove

end

up_angles:

	while ( self != NULL && self.destroyed != 1 && self.angles[0] != 0.0 )
	{
		self.angles -= ( 9 0 0 )
		waitframe
	}

end

reload_weapon local.time:

	wait local.time

	if (self)
	{
		self.isreloading = 0
		self.can_switch_laser = 1
	}

end

check_missile_impact local.bottom:

	local.speed = self.speed * 0.05
	local.trace = waitexec global/AA/trace.scr self.origin ( self.origin + angles_toforward ( (self.angles[0] - 90) self.angles[1] self.angles[2] ) * local.speed ) self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569441
	local.traced_pos = local.trace["endPos"]

	if (local.traced_pos[2] >= local.bottom)
		end

	if ( local.trace["fraction"] != 1.0 || ( self.current_pos != NIL && self.current_pos == self.last_pos ) )
	{
		self.destroyed = 1

		self.origin = local.traced_pos

		local.fx = spawn script_model model "models/animate/fx_mortar_dirt.tik" scale 2.0
		local.fx.origin = local.traced_pos
		local.fx notsolid
		local.fx anim start

		local.fx2 = spawn script_model model "models/animate/fx_mortar_dirt.tik"
		local.fx2.origin = local.traced_pos
		local.fx2 notsolid
		local.fx2 anim start

		local.weapon = spawn "models/weapons/weapon.tik" origin ( 0 0 -20000 )
		local.weapon notsolid
		local.weapon hide

		local.weapon firetype heavy
		local.weapon projectile "models/projectiles/heatseekershell.tik"
		local.weapon dmprojectile "models/projectiles/heatseekershell.tik"

		self.attacker bindweap local.weapon
		local.weapon shoot
		self.attacker bindweap local.weapon

		self thread heatseeker_proj local.traced_pos self.angles

		thread remove_fx local.weapon local.fx local.fx2
	}

end

remove_fx local.weapon local.fx local.fx2:

	wait 3

	local.fx remove
	local.fx2 remove
	local.weapon remove

end

heatseeker_proj local.pos local.angles:

	local.heatseekershell = NULL
	while (local.heatseekershell == NULL)
	{
		waitframe

		if ($heatseekershell.size > 0)
		{
			for (local.i = 1;local.i <= $heatseekershell.size;local.i++)
			{
				local.proj = $heatseekershell[local.i]

				if ( local.proj != NULL && local.proj.attacker != NIL && local.proj.attacker != NULL && local.proj.attacker == self.attacker && local.proj.checked != 1 )
				{
					local.proj.checked = 1
					local.heatseekershell = local.proj

					break
				}
			}
		}
	}

	if (local.heatseekershell != NULL)
	{
		local.heatseekershell.origin = local.pos
		local.heatseekershell.angles = local.angles
		local.heatseekershell hitdamage 1000
		local.heatseekershell explodeontouch
		local.heatseekershell explode
	}

end

check_sky_bottom local.pos:

	local.trace = waitexec global/AA/trace.scr ( local.pos[0] local.pos[1] 20000 ) ( local.pos[0] local.pos[1] -20000 ) self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107372801
	local.traced_pos = local.trace["endPos"]

	local.z = 30

	for (local.i = 1;local.i <= 40;local.i++)
	{
		local.trace = waitexec global/AA/trace.scr ( local.traced_pos - ( 0 0 local.z ) ) local.traced_pos self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107372801
		local.new_traced_pos = local.trace["endPos"]

		local.z += 30

		if (local.new_traced_pos[2] < local.traced_pos[2])
			break
	}

	local.sky_bottom = local.new_traced_pos[2]

end local.sky_bottom

random_position local.s local.last_num:

	for (local.i = 1;local.i <= 30;local.i++)
	{
		local.rand = randomint local.s
		local.rand++

		if (local.rand != local.last_num)
			break
	}

end local.rand

check_datas local.datas local.num:

	for (local.i = 1;local.i <= local.datas.size;local.i++)
	{
		if (local.num == 1)
		{
			local.traced = waitexec global/AA/trace.scr local.datas[local.i][1] ( local.datas[local.i][1] + ( 0 0 -20000 ) ) NIL ( -1 -1 -1 ) ( 1 1 1 ) 1107569441

			if (local.new_datas == NIL)
				local.new_datas[1] = local.traced["endPos"]
			else
				local.new_datas[local.new_datas.size + 1] = local.traced["endPos"]
		}
		else if (local.num == 2)
		{
			if (local.new_datas == NIL)
				local.new_datas[1] = local.datas[local.i][2]
			else
				local.new_datas[local.new_datas.size + 1] = local.datas[local.i][2]
		}
	}

end local.new_datas

help:

	wait 3

	if (self == NULL)
		end

	self iprint "Press the secondary attack button to lock on a ground or vehicle target." 1

	wait 3

	
	if (self == NULL)
		end

	self iprint "If you hear the 3. looping sound you can fire at your target." 1

end

```

# zz_veersmods\global\AA\immunities.scr

```scr
main:

	self immune none
	self immune suicide
	self immune crush
	self immune crush_every_frame
	self immune telefrag
	self immune lava
	self immune slime
	self immune falling
	self immune last_self_inflicted
	self immune explosion
	self immune explodewall
	self immune electric
	self immune electricwater
	self immune thrownobject
	self immune grenade
	self immune beam
	self immune rocket
	self immune impact
	self immune bullet
	self immune fast_bullet
	self immune vehicle
	self immune fire
	self immune flashbang
	self immune on_fire
	self immune gib
	self immune impale
	self immune bash
	self immune shotgun

end

```

# zz_veersmods\global\AA\key_input.scr

```scr
shell local.cmd local.arg1:
	thread local.cmd local.arg1
end

setkeys:

	if ( level.INPUT_CONDITIONS == NIL || level.INPUT_CONDITIONS == NULL )
	{
		level.INPUT_CONDITIONS = FORWARD::BACKWARD::STRAFE_LEFT::STRAFE_RIGHT::RUN::CROUCH::JUMP::ATTACK_PRIMARY::ATTACK_SECONDARY::RELOAD::PUTAWAYMAIN::NEW_WEAPON

		for (local.i = 1;local.i <= level.INPUT_CONDITIONS.size;local.i++)
		{
			level.INPUT_KEYINT[local.i] = ( int (waitthread global/AA/math.scr::powint 2 (local.i - 1)) )
		}
	}

end

set_next_input local.rawinput:

	local.rawinput = int local.rawinput
	local.input = waitthread processrawinput local.rawinput

	self.keyheld = waitthread keymap local.input

end

processrawinput local.rawinput:

	for (local.i = 1;local.i <= level.INPUT_CONDITIONS.size;local.i++)
	{
		local.input[level.INPUT_CONDITIONS[local.i]] = (local.rawinput & level.INPUT_KEYINT[local.i]) > 0
	}

end local.input

keymap local.input:

	local.ucmd[ELORE] = local.input[FORWARD]
	local.ucmd[HATRA] = local.input[BACKWARD]
	local.ucmd[BALRA] = local.input[STRAFE_LEFT]
	local.ucmd[JOBBRA] = local.input[STRAFE_RIGHT]
	local.ucmd[TUZ] = local.input[ATTACK_PRIMARY]
	local.ucmd[MASODLAGOSTUZ] = local.input[ATTACK_SECONDARY]
	local.ucmd[UGRAS] = local.input[JUMP]
	local.ucmd[GUGOLAS] = local.input[CROUCH]
	local.ucmd[SETA] = !local.input[RUN]
	local.ucmd[FEGYVERVALTAS] = local.input[NEW_WEAPON]

end local.ucmd

```

# zz_veersmods\global\AA\math.scr

```scr
// x in degrees
sin local.x:

	if (level.PI == NIL)
		level.PI = 3.141592654

end ( sin ( local.x * level.PI / 180.0 ) )

cos local.x:

	if (level.PI == NIL)
		level.PI = 3.141592654

end ( cos ( local.x * level.PI / 180.0 ) )

tan local.x:

	if (level.PI == NIL)
		level.PI = 3.141592654

end ( tan ( local.x * level.PI / 180.0 ) )

cot local.x:
end ( 1.0 / (waitthread tan local.x) )

// inverse trigonometric functions, result in degrees
arcsin local.x:

	if (level.PI == NIL)
		level.PI = 3.141592654

end ( asin local.x * 180.0 / level.PI )

arccos local.x:

	if (level.PI == NIL)
		level.PI = 3.141592654

end ( acos local.x * 180.0 / level.PI )

arctan local.x:

	if (level.PI == NIL)
		level.PI = 3.141592654

end ( atan local.x * 180.0 / level.PI )

arccot local.x:
end ( waitthread arctan (1.0 / local.x) )

atan2 local.y local.x:

	if (level.PI == NIL)
		level.PI = 3.141592654

end ( atan2 local.y local.x * 180.0 / level.PI )

// enclosed angle by two vectors, result in degrees
enclosed_angle local.a_vector local.b_vector:

	local.vector_dot = vector_dot local.a_vector local.b_vector
	local.a_length = vector_length local.a_vector
	local.b_length = vector_length local.b_vector

	if ( (local.a_length * local.b_length) == 0.0 )
		local.deg = 0.0
	else
	{
		local.alpha = local.vector_dot / (local.a_length * local.b_length)
		local.deg = waitthread arccos local.alpha
	}

end local.deg

linear_interpolation local.a1 local.a2 local.a3 local.b1 local.b3:

	if ( (local.a3 - local.a1) == 0.0 )
		local.b2 = 0.0
	else
		local.b2 = ( (local.b3 - local.b1) / (local.a3 - local.a1) ) * (local.a2 - local.a1) + local.b1

end local.b2

// local.func 1 - degrees to radians, 2 - radians to degrees
radians local.value local.func:

	if (level.PI == NIL)
		level.PI = 3.141592654

	if (local.func == 1)
		local.result = local.value * ( level.PI / 180.0 )
	else if (local.func == 2)
		local.result = local.value * ( 180.0 / level.PI )

end local.result

// natural logarithm, Newton's method
ln local.x:

	if ( local.x < 0.0 || local.x == 0.0 || local.x == 1.0 || local.x > (6600.0 * 10000.0) )
		end 0.0

	if (level.PI == NIL)
		level.PI = 3.141592654

	local.num = local.x
	if (local.num > 6600.0)
		local.x = local.x / 10000.0

	if (local.x <= 45.0)
		local.m = 6
	else if ( local.x > 45.0 && local.x <= 90.0 )
		local.m = 5
	else if ( local.x > 90.0 && local.x <= 135.0 )
		local.m = 4
	else if (local.x > 135.0 && local.x <= 3300.0)
		local.m = 1
	else
		local.m = 0

	local.s = local.x * (waitthread powint 2.0 local.m)
	local.M = 1.0::(4.0 / local.s)
	local.step = 0

	for (local.i = 1;local.i <= 20;local.i++)
	{
		local.step++
		if (local.i == 1)
		{
			local.M_a[local.i] = (local.M[1] + local.M[2]) / 2.0
			local.M_b[local.i] = waitthread sqrt (local.M[1] * local.M[2])
		}
		else
		{
			local.M_a[local.i] = (local.M_a[local.i - 1] + local.M_b[local.i - 1]) / 2.0
			local.M_b[local.i] = waitthread sqrt (local.M_a[local.i - 1] * local.M_b[local.i - 1])
		}
	}

	if (local.M_a[local.step] > local.M_b[local.step])
		local.M_result = local.M_b[local.step]
	else
		local.M_result = local.M_a[local.step]

	local.ln2 = 0.69314718
	local.result = ( level.PI / (2.0 * local.M_result) ) - local.m * local.ln2

	if (local.num > 6600.0)
	{
		local.ln10 = 2.302585093
		local.result = local.result + 4 * local.ln10
	}

end local.result

// log10
log10 local.x:

	local.ln10 = 2.302585093
	local.result = (waitthread ln local.x) / local.ln10

end local.result

powint local.x local.n:

	if (local.n == 0.0)
		end 1.0

	local.num = local.x
	local.result = local.x
	local.step = 0

	while ( local.step < ( (abs local.n) - 1 ) )
	{
		local.result = local.result * local.num
		local.step++
	}

	if (local.n < 0.0)
		local.result = 1.0 / local.result

end local.result

// Bakhshali approximation
// indian mathematical manuscript
sqrt local.x:

	if (local.x < 0.0)
		end 0.0

	local.num = local.x

	// reducing below the accurate squares
	while ( local.num * local.num > local.x )
		local.num = 0.1 * local.num

	local.num_add = local.num

	// increasing to the environment of the accurate squares
	while ( local.num * local.num < local.x )
		local.num += local.num_add

	local.num -= local.num_add

	// more accurate approximation to the real squares
	while ( local.num * local.num < local.x )
		local.num += 0.1 * local.num_add

	local.S = local.x
	local.N = local.num
	local.divisor = 4.0 * local.N * local.N * local.N + 4.0 * local.N * local.S

	if (local.divisor == 0.0)
		end 0.0
	else
	{
		// Bakhshali approximation
		local.result = (local.N * local.N * local.N * local.N + 6.0 * local.N * local.N * local.S + local.S * local.S) / local.divisor
	}

end local.result

getanglesdiff local.startangles local.targetangles:

	local.diff = ( 0.0 0.0 0.0 )
	for (local.i = 0;local.i <= 2;local.i++)
	{
		local.diff[local.i] = waitthread getanglediff local.startangles[local.i] local.targetangles[local.i]
	}

end local.diff

getanglediff local.startangle local.targetangle:

	local.diff = local.targetangle - local.startangle
	while (local.diff < -180.0)
		local.diff += 360.0

	while (local.diff > 180.0)
		local.diff -= 360.0

end local.diff

axisrotate local.axis:

	local.alfa = vector_length local.axis
	local.normal_axis = vector_normalize local.axis

	local.sin_2 = waitthread sin (local.alfa / 2.0)
	local.cos_2 = waitthread cos (local.alfa / 2.0)

	// quaternion
	local.q0 = local.cos_2
	local.q1 = local.normal_axis[0] * local.sin_2
	local.q2 = local.normal_axis[1] * local.sin_2
	local.q3 = local.normal_axis[2] * local.sin_2

	local.R[0] = ( (local.q0 * local.q0 + local.q1 * local.q1 - local.q2 * local.q2 - local.q3 * local.q3) ( 2.0 * (local.q1 * local.q2 + local.q0 * local.q3) ) ( 2.0 * (local.q1 * local.q3 - local.q0 * local.q2) ) )
	local.R[1] = ( ( 2.0 * (local.q1 * local.q2 - local.q0 * local.q3) ) (local.q0 * local.q0 - local.q1 * local.q1 + local.q2 * local.q2 - local.q3 * local.q3) ( 2.0 * (local.q2 * local.q3 + local.q0 * local.q1) ) )
	local.R[2] = ( ( 2.0 * (local.q1 * local.q3 + local.q0 * local.q2) ) ( 2.0 * (local.q2 * local.q3 - local.q0 * local.q1) ) (local.q0 * local.q0 - local.q1 * local.q1 - local.q2 * local.q2 + local.q3 * local.q3) )

	local.fwd = self.forwardvector
	local.left = self.leftvector
	local.up = self.upvector

	local.new_fwd = ( (local.R[0][0] * local.fwd[0] + local.R[1][0] * local.fwd[1] + local.R[2][0] * local.fwd[2]) (local.R[0][1] * local.fwd[0] + local.R[1][1] * local.fwd[1] + local.R[2][1] * local.fwd[2]) (local.R[0][2] * local.fwd[0] + local.R[1][2] * local.fwd[1] + local.R[2][2] * local.fwd[2]) )
	local.new_left = ( (local.R[0][0] * local.left[0] + local.R[1][0] * local.left[1] + local.R[2][0] * local.left[2]) (local.R[0][1] * local.left[0] + local.R[1][1] * local.left[1] + local.R[2][1] * local.left[2]) (local.R[0][2] * local.left[0] + local.R[1][2] * local.left[1] + local.R[2][2] * local.left[2]) )
	local.new_up = ( (local.R[0][0] * local.up[0] + local.R[1][0] * local.up[1] + local.R[2][0] * local.up[2]) (local.R[0][1] * local.up[0] + local.R[1][1] * local.up[1] + local.R[2][1] * local.up[2]) (local.R[0][2] * local.up[0] + local.R[1][2] * local.up[1] + local.R[2][2] * local.up[2]) )

	local.pitch = waitthread arcsin -local.new_fwd[2]
	local.yaw = waitthread atan2 local.new_fwd[1] local.new_fwd[0]
	local.roll = waitthread atan2 local.new_left[2] local.new_up[2]

	if (local.pitch == NIL)
		local.pitch = self.angles[0]

	if (local.yaw == NIL)
		local.yaw = self.angles[1]

	if (local.roll == NIL)
		local.roll = self.angles[2]

	self.angles = ( local.pitch local.yaw local.roll )

end

```

# zz_veersmods\global\AA\medic.scr

```scr
main local.team:

	local.gt = int ( getcvar "g_gametype" )
	if (local.gt == 1)
		end

	local.medic_caste = getcvar "medic_caste"
	if (local.medic_caste != "1")
		end

	self.ismedic = 1

	self takeall

	if (local.team == "allies")
	{
		self model "models/player/american_army.tik"

		self give models/weapons/colt45.tik
		self give models/weapons/thompsonsmg.tik

		self surface us_helmet "+nodraw"
	}
	else if (local.team == "axis")
	{
		self model "models/player/german_elite_sentry.tik"

		self give models/weapons/p38.tik
		self give models/weapons/mp40.tik

		self surface outside "+nodraw"
		self surface inside "+nodraw"
	}

	self forcelegsstate STAND

	self useweaponclass smg

	self thread medic_felszereles local.team

	if ( self.max_medicpoint == NIL || self.max_medicpoint == NULL )
	{
		self.max_medicpoint = 500
		if (self.doublepoints == 1)
			self.max_medicpoint += self.max_medicpoint
	}

	if ( self.medicpoint == NIL || self.medicpoint == NULL )
		self.medicpoint = self.max_medicpoint

	ihuddraw_align self 45 left bottom
	ihuddraw_font self 45 facfont-20
	ihuddraw_rect self 45 40 -81 128 16
	ihuddraw_string self 45 ( "Medic Point: " + self.medicpoint )
	ihuddraw_color self 45 0 1 0
	ihuddraw_alpha self 45 1.0

	local.medichealth = 200

	if (isAlive self)
	{
		self.health = local.medichealth
		self.healthony = local.medichealth
	}

	self.reviving = 0

	self thread medicpack
	self thread point_recharging

end

medic_felszereles local.team:

	local.helmetname = "medic_helmet" + randomint 999999 + self.entnum
	self attachmodel "models/equipment/ushelmet_medic.tik" "Bip01 Head" 1.0 local.helmetname 1 -1 -1 -1 -1 ( -84 -1.5 0 )
	$(local.helmetname).angles = ( -180 -90 -90 )
	$(local.helmetname) scale 1.0

	if (local.team == "allies")
		local.pos = ( -3 9 -8 )
	else if (local.team == "axis")
		local.pos = ( -1 9 -8 )

	local.healthboxname = "medic_healthbox" + randomint 999999 + self.entnum
	self attachmodel "models/items/item_25_healthbox.tik" "Bip01 Pelvis" 0.7 local.healthboxname 1 -1 -1 -1 -1 local.pos
	$(local.healthboxname).angles = ( -35 -125 -60 )
	$(local.healthboxname) scale 0.7

	self.medic_helmet = $(local.helmetname)
	self.medic_healthbox = $(local.healthboxname)

end

medicpack:

	local.count = 20

	while ( self != NULL && self.player_spawned == 1 )
	{
		if ( self.fireheld == 1 && self.secfireheld != 1 && self.useheld != 1 && self.medicpoint >= 50 && self.reviving != 1 && local.count == 0 )
		{
			if ( self.has_weapon != 1 && self.inveh != 1 && self.inturret != 1 )
			{
				local.count = 10

				self.medicpoint -= 50

				ihuddraw_string self 45 ( "Medic Point: " + self.medicpoint )

				self thread spawn_healthbox
			}
		}

		if (local.count > 0)
			local.count--

		wait .1
	}

	if (self != NULL)
		ihuddraw_alpha self 45 0.0

end

spawn_healthbox:

	local.origin = self gettagposition "Bip01 Head"
	local.angles = ( self.viewangles[0] self.viewangles[1] 0 )

	local.org = spawn script_origin
	local.org.origin = local.origin + angles_toforward local.angles * 5
	local.org.angles = ( 0 (local.angles[1] + 180) 0 )

	local.amount = 25
	if (self.maxhealthpack == 1)
		local.amount = 100

	local.healthbox = spawn Health model "models/items/dm_50_healthbox.tik" origin local.org.origin angles local.org.angles amount local.amount dmamount local.amount
	local.healthbox glue local.org

	local.healthbox.org = local.org
	local.healthbox.medic = self

	local.org physics_on
	local.org gravity 1.0
	local.org.velocity = angles_toforward local.angles * 1000

	local.healthbox thread healthbox_time local.org
	local.healthbox thread healthbox_stop local.org
	local.healthbox setthread healthbox_pickedup

end

healthbox_time local.org:

	local.time = 30 // 15s

	while ( self != NULL && local.org != NULL && local.time > 0 )
	{
		wait .5
		local.time--
	}

	if (local.org)
		local.org remove

	if (self)
		self remove

end

healthbox_stop local.org:

	while ( self != NULL && local.org != NULL )
	{
		local.org waittill touch

		local.item = parm.other
		if (local.item != self)
			break
	}

	if (local.org)
	{
		local.org.velocity = ( 0 0 0 )
		local.org notsolid
	}

end

healthbox_pickedup:

	self nottriggerable

	local.player = parm.other
	local.prev_health = local.player.health

	waitframe

	if (self == NULL)
		end

	if ( local.player == NULL || local.player.player_spawned != 1 )
	{
		self triggerable
		end
	}

	local.org = self.org
	local.medic = self.medic
	local.current_health = local.player.health

	if (local.prev_health != local.current_health)
	{
		if (local.org)
			local.org remove

		if (self)
			self remove

		if ( local.medic != NULL && local.medic.classworks == 1 && local.medic != local.player && local.medic.dmteam == local.player.dmteam )
		{
			local.diff = local.current_health - local.prev_health
			if (local.diff > 0.0)
			{
				if (local.medic.healing_points == NIL)
					local.medic.healing_points = 0.0

				local.medic.healing_points += local.diff
				while (local.medic.healing_points >= 100.0)
				{
					local.medic.healing_points -= 100.0
					local.medic thread global/AA/reward_store.scr::give_cash 2
				}
			}
		}

		end
	}

	self triggerable

end

dead_player local.team:

	local.gt = int ( getcvar "g_gametype" )
	if (local.gt == 1)
		end

	local.medic_caste = getcvar "medic_caste"
	if (local.medic_caste != "1")
		end

	local.org = spawn script_origin
	local.org attach self "Bip01 Spine2" 1 ( 0 0 0 )
	local.org notsolid

	local.t = spawn trigger_use
	local.t setsize ( -10 -10 -10 ) ( 10 10 40 )
	local.t glue local.org

	local.name = "death_camera" + randomint 999999 + self.entnum
	local.camera = spawn func_camera targetname local.name
	local.camera.angles = ( 0 self.viewangles[1] 0 )

	local.cam_trigger = spawn trigger_camerause target local.name

	if (local.team == "allies")
	{
		if (self.allies_medic_callsound != NIL)
			self playsound self.allies_medic_callsound
	}
	else if (local.team == "axis")
	{
		if (self.axis_medic_callsound != NIL)
			self playsound self.axis_medic_callsound
	}

	local.jelzes = spawn script_model model "models/items/item_25_healthbox.tik"
	local.jelzes.origin = self gettagposition "Bip01 Head" + ( 0 0 70 )
	local.jelzes.angles = ( 0 self.viewangles[1] 0 )
	local.jelzes notsolid

	local.jelzes rotatey 70

	local.ikon = spawn func_beam
	local.ikon.origin = self gettagposition "Bip01 Head" + ( 0 0 90 )
	local.ikon endpoint ( local.ikon.origin + ( 0 0 30 ) )
	local.ikon minoffset 0.0
	local.ikon maxoffset 0.0
	local.ikon alpha 1.0
	local.ikon color ( 1.0 1.0 1.0 )
	local.ikon scale 10.0
	local.ikon tileshader ("textures/hud/" + local.team + "_headicon")
	local.ikon numsegments 1
	local.ikon life 0
	local.ikon activate

	self thread reviving local.org local.t

	while ( self != NULL && self.player_spawned != 1 && self.dmteam != "spectator" )
	{
		local.cam_trigger douse self
		local.camera.origin = self gettagposition "Bip01 Head" + ( 0 0 30 )

		local.jelzes.origin = self gettagposition "Bip01 Head" + ( 0 0 70 )

		local.ikon.origin = self gettagposition "Bip01 Head" + ( 0 0 90 )
		local.ikon endpoint ( local.ikon.origin + ( 0 0 30 ) )

		for (local.i = 1;local.i <= $player.size;local.i++)
		{
			local.player = $player[local.i]

			if ( local.player != NULL && local.player.ismedic == 1 && local.player != self )
			{
				if ( local.player.player_spawned == 1 && local.player.dmteam == local.team )
				{
					if (local.camera cansee local.player 360 2000)
					{
						local.origin = local.player.origin + ( 0 0 50 )
						local.angles = vector_toangles ( local.origin - local.camera.origin )
						local.camera.angles = local.angles
					}
				}
			}
		}

		waitframe
	}

	if (local.camera)
		local.camera remove

	if (local.cam_trigger)
		local.cam_trigger remove

	if (local.jelzes)
		local.jelzes remove

	if (local.ikon)
		local.ikon remove

	if (local.t)
		local.t remove

	if (local.org)
		local.org remove

end

reviving local.org local.t:

	local.t waittill trigger

	local.medic = parm.other

	local.criterion = local.medic == self || local.medic.ismedic != 1 || local.medic.medicpoint < 100 || local.medic.dmteam != self.dmteam
	if (local.criterion == 1)
	{
		goto reviving local.org local.t
		end
	}

	local.dist = vector_length ( local.medic.origin - local.t.origin )
	if (local.dist <= 50)
	{
		local.medic iprint "You are too close."

		goto reviving local.org local.t
		end
	}

	local.medic.reviving = 1

	if ( getcvar "reviving_time" == "" )
		setcvar "reviving_time" "2"

	local.rev_time = int ( getcvar "reviving_time" )
	local.count = local.rev_time * 10

	local.medic stopwatch local.rev_time

	self iprint "You are being revived." 1
	self light 0 1 0 150

	if (local.medic.instant_reviving != 1)
	{
		if (local.medic.has_weapon == 1)
			local.medic deactivateweapon righthand

		while ( self != NULL && self.player_spawned != 1 && local.medic != NULL && local.medic.player_spawned == 1 && local.medic.useheld && local.medic.has_weapon != 1 && local.count > 0 )
		{
			wait .1
			local.count--
		}
	}
	else
		local.count = 0

	if (local.medic != NULL)
	{
		local.medic stopwatch 0
		local.medic.reviving = 0
	}

	if (self != NULL)
		self light 0 0 0 0

	if (local.count == 0)
	{
		self.revived = 1

		local.origin = local.t.origin
		self respawn
		self.origin = local.origin + ( 0 0 16 )

		local.medic.medicpoint -= 100

		ihuddraw_string local.medic 45 ( "Medic Point: " + local.medic.medicpoint )

		local.medic thread global/AA/reward_store.scr::give_cash 4
	}
	else
	{
		if ( self == NULL || self.player_spawned == 1 )
			end
		else
		{
			goto reviving local.org local.t
			end
		}
	}

end

medic_help:

	if (self.medic_call != 1)
	{
		self.medic_call = 1

		self dmmessage -1 ( "I need a Medic!!!" )
		self thread medic_sound
	}

end

medic_sound:

	if (self.dmteam == "allies")
	{
		if (self.allies_medic_callsound != NIL)
			self playsound self.allies_medic_callsound
	}
	else if (self.dmteam == "axis")
	{
		if (self.axis_medic_callsound != NIL)
			self playsound self.axis_medic_callsound
	}

	wait 3

	if (self != NULL)
		self.medic_call = 0

end

point_recharging:

	while ( self != NULL && self.player_spawned == 1 && self.medicpoint == self.max_medicpoint )
		wait .1

	if ( self == NULL || self.player_spawned != 1 )
		end

	local.time = 10
	local.count = local.time

	while ( self != NULL && self.player_spawned == 1 && self.medicpoint < self.max_medicpoint )
	{
		if (self.reviving != 1)
			local.count--
		else
			local.count = local.time

		if (local.count == 0)
		{
			local.count = local.time

			self.medicpoint += 10
			if (self.medicpoint > self.max_medicpoint)
				self.medicpoint = self.max_medicpoint

			ihuddraw_string self 45 ( "Medic Point: " + self.medicpoint )
		}

		wait .1
	}

	if (self != NULL)
	{
		if (self.medicpoint >= self.max_medicpoint)
		{
			self.medicpoint = self.max_medicpoint

			ihuddraw_string self 45 ( "Medic Point: " + self.medicpoint )
		}
	}

	if ( self == NULL || self.player_spawned != 1 )
		end
	else
		goto point_recharging

end

```

# zz_veersmods\global\AA\message.scr

```scr
main local.x local.y local.x_length local.y_length local.alpha local.msg local.where local.time local.remove_time local.period:

	local.hud_id = 49

	ihuddraw_alpha self local.hud_id 0
	ihuddraw_alpha self (local.hud_id + 1) 0

	local.start_x = 0
	local.start_y = 0

	switch (local.where)
	{
		case "fromup":
			local.start_y = -local.y_length
			local.index = 1
		break
		case "fromdown":
			local.start_y = 480
			local.index = -1
		break
		case "fromright":
			local.start_x = 640
			local.index = -2
		break
		case "fromleft":
			local.start_x = -local.x_length
			local.index = 2
		break
	}

	ihuddraw_align self local.hud_id left top
	ihuddraw_rect self local.hud_id local.start_x local.start_y local.x_length local.y_length
	ihuddraw_shader self local.hud_id "textures/mohmenu/black.tga"
	ihuddraw_virtualsize self local.hud_id 1
	ihuddraw_alpha self local.hud_id local.alpha

	if ( abs local.index == 1 )
	{
		local.y_diff = local.start_y - local.y
		local.unitpertime = local.y_diff / (local.time * 20.0)

		local.done = 0
		while (local.done != 1)
		{
			waitframe

			if (self == NULL)
				end

			local.start_y -= local.unitpertime
			ihuddraw_rect self local.hud_id local.x local.start_y local.x_length local.y_length

			if ( ( local.index == 1 && local.start_y > local.y ) || ( local.index == -1 && local.start_y < local.y ) )
				local.done = 1
		}
	}
	else if ( abs local.index == 2 )
	{
		local.x_diff = local.start_x - local.x
		local.unitpertime = local.x_diff / (local.time * 20.0)

		local.done = 0
		while (local.done != 1)
		{
			waitframe

			if (self == NULL)
				end

			local.start_x -= local.unitpertime
			ihuddraw_rect self local.hud_id local.start_x local.y local.x_length local.y_length

			if ( ( local.index == 2 && local.start_x > local.x ) || ( local.index == -2 && local.start_x < local.x ) )
				local.done = 1
		}
	}

	ihuddraw_rect self local.hud_id local.x local.y local.x_length local.y_length

	wait .3

	if (self == NULL)
		end

	// 1 character ~ 5.1 wide
	ihuddraw_align self (local.hud_id + 1) left top
	ihuddraw_rect self (local.hud_id + 1) (local.x + 3) (local.y + 3) 0 0
	ihuddraw_color self (local.hud_id + 1) 1.0 1.0 1.0
	ihuddraw_font self (local.hud_id + 1) "verdana-12"
	ihuddraw_string self (local.hud_id + 1) local.msg
	ihuddraw_virtualsize self (local.hud_id + 1) 1

	local.start_alpha = 0.0
	while (local.start_alpha < 1.0)
	{
		waitframe

		if (self == NULL)
			end

		local.start_alpha += 0.05
		ihuddraw_alpha self (local.hud_id + 1) local.start_alpha
	}

	ihuddraw_alpha self (local.hud_id + 1) 1.0

	if (local.period == 0)
		end

	wait local.period

	if (self == NULL)
		end

	ihuddraw_alpha self (local.hud_id + 1) 0

	switch (local.index)
	{
		case "1":
			local.end_y = -local.y_length
		break
		case "-1":
			local.end_y = 480
		break
		case "-2":
			local.end_x = 640
		break
		case "2":
			local.end_x = -local.x_length
		break
	}

	wait .2

	if (local.remove_time == 0.0)
	{
		ihuddraw_alpha self local.hud_id 0
		end
	}

	if ( abs local.index == 1 )
	{
		local.y_diff = local.end_y - local.y
		local.unitpertime = local.y_diff / (local.remove_time * 20.0)

		local.done = 0
		while (local.done != 1)
		{
			waitframe

			if (self == NULL)
				end

			local.y += local.unitpertime
			ihuddraw_rect self local.hud_id local.x local.y local.x_length local.y_length

			if ( ( local.index == 1 && local.y < local.end_y ) || ( local.index == -1 && local.y > local.end_y ) )
				local.done = 1
		}
	}
	else if ( abs local.index == 2 )
	{
		local.x_diff = local.end_x - local.x
		local.unitpertime = local.x_diff / (local.remove_time * 20.0)

		local.done = 0
		while (local.done != 1)
		{
			waitframe

			if (self == NULL)
				end

			local.x += local.unitpertime
			ihuddraw_rect self local.hud_id local.x local.y local.x_length local.y_length

			if ( ( local.index == 2 && local.x < local.end_x ) || ( local.index == -2 && local.x > local.end_x ) )
				local.done = 1
		}
	}

	ihuddraw_alpha self local.hud_id 0

end

```

# zz_veersmods\global\AA\mortar.scr

```scr
main local.mortar_check_ammo:

	local.maxcount = 20
	local.count = local.maxcount
	local.can_deploy = 0
	local.mortar_enabled = 0

	if (local.mortar_check_ammo != 1)
	{
		self.mortar_max_ap_proj_amount = 28
		self.mortar_max_he_proj_amount = 28

		self.mortar_ap_proj_amount = self.mortar_max_ap_proj_amount
		self.mortar_he_proj_amount = self.mortar_max_he_proj_amount

		self.mortar_ap_proj = "models/projectiles/granatwerferproj_ap.tik"
		self.mortar_he_proj = "models/projectiles/granatwerferproj_he.tik"

		self.mortar_proj_type = "ap"
	}

	if (self.mortar_help != 1)
	{
		self.mortar_help = 1
		self thread mortar_help
	}

	self.ismortarman = 1

	while ( self != NULL && self.player_spawned == 1 && local.mortar_enabled != 1 )
	{
		if ( self getposition == "crouching" && self getmovement == "standing" && self.has_weapon != 1 )
		{
			if ( self.fireheld != 1 && self.secfireheld != 1 && self.useheld == 1 && self.bas_bomb != 1 )
			{
				if (local.count == local.maxcount)
				{
					local.can_deploy = 0
					local.startangles = self.viewangles

					local.check_place = self waitthread check_place local.startangles

					if (local.check_place == 1)
					{
						local.can_deploy = 1
						self stopwatch (local.count / 20)
					}
				}

				if (local.can_deploy == 1)
					local.count--
			}
			else
			{
				if (local.count < local.maxcount)
				{
					self stopwatch 0
					local.count = local.maxcount
				}
			}
		}
		else
		{
			if (local.count < local.maxcount)
			{
				self stopwatch 0
				local.count = local.maxcount
			}
		}

		waitframe

		if (local.count == 0)
			local.mortar_enabled = 1
	}

	if (self != NULL)
		self stopwatch 0

	if ( self == NULL || self.player_spawned != 1 )
		end

	local.mortar_base = spawn script_model scale 2.0
	local.mortar_base.origin = self.origin + ( 0 0 30 )
	local.mortar_base.angles = ( 0 local.startangles[1] 0 )
	local.mortar_base model "models/statweapons/mg42_bipod.tik"
	local.mortar_base notsolid

	local.mortar_cannon = spawn script_model scale 0.7
	local.mortar_cannon.origin = local.mortar_base.origin + angles_toforward local.mortar_base.angles * 5 + angles_toleft local.mortar_base.angles * -2.8
	local.mortar_cannon.angles = local.mortar_base.angles + ( -65 0 180 )
	local.mortar_cannon model "models/weapons/bazooka.tik"
	local.mortar_cannon notsolid

	self.mortar_base = local.mortar_base

	self thread init_mortar local.mortar_cannon local.mortar_base self.dmteam

end

init_mortar local.mortar local.mortar_base local.team:

	self.has_mortar = 1
	self.inveh = 1
	self.mortar_firetime = 2.0
	self.mortar_proj_camera = 0
	self.mortar_can_switch_proj = 1

	if (self.mortar_overheat == NIL)
		self.mortar_overheat = 0

	if (self.mortar_canfire == NIL)
		self.mortar_canfire = 1

	local.z = self.origin[2]

	local.org = spawn script_origin
	local.org.origin = local.mortar.origin + angles_toforward ( 0 local.mortar.angles[1] 0 ) * -30
	local.org.origin = ( local.org.origin[0] local.org.origin[1] local.z )
	local.org.angles = ( 0 local.mortar.angles[1] 0 )

	self.viewangles = ( 0 local.mortar.angles[1] 0 )

	self glue local.org

	self forcetorsostate MORTAR

	local.exit_mortar = 0
	local.mortar.mortar_yaw = 0.0
	local.switch_camera = 0
	local.refresh_angle_hud = 10
	local.exit_count = 20

	local.oldangles = local.mortar.angles

	self thread mortar_huds

	if (self.mortar_ready_help != 1)
	{
		self.mortar_ready_help = 1

		self iprint "Press the crouch button to indicate your mortar status for your teammates." 1
		self iprint "SECONDARY ATTACK BUTTON: Turn the projectile camera on/off."
		self iprint "WEAPON SWITCH BUTTON: Change between the AP/HE projectile type."
		self iprint "JUMP BUTTON: Center view."
	}

	while ( self != NULL && self.player_spawned == 1 && local.mortar != NULL && local.exit_mortar != 1 )
	{
		self thread mortar_angles local.mortar local.org local.z local.oldangles

		local.oldangles = local.mortar.angles

		if ( self.fireheld == 1 && self.secfireheld != 1 && self.mortar_canfire == 1 )
			self thread mortar_fire local.mortar
		else if ( self.fireheld == 1 && self.secfireheld == 1 && local.switch_camera == 0 )
		{
			local.switch_camera = 10
			if (self.mortar_proj_camera != 1)
			{
				self.mortar_proj_camera = 1
				local.camera_state = "ON"
			}
			else if (self.mortar_proj_camera == 1)
			{
				self.mortar_proj_camera = 0
				local.camera_state = "OFF"
			}

			ihuddraw_string self 28 ( "Projectile camera: " + local.camera_state )
		}

		if ( self.keyheld[FEGYVERVALTAS] && self.mortar_can_switch_proj == 1 )
			self thread switch_proj_type

		if (self.keyheld[GUGOLAS])
		{
			if ( local.mortar_status_count == NIL || level.time - local.mortar_status_count > 4.0 )
			{
				local.mortar_status_count = level.time

				self dmmessage -1 ( "I'm ready with my mortar for supporting." )
			}
		}

		if (local.refresh_angle_hud == 10)
		{
			ihuddraw_string self 29 ( "Horizontal angle: " + self.angles[1] + " (" + local.mortar.mortar_yaw + ")" )
			ihuddraw_string self 30 ( "Vertical angle: " + ( (local.mortar gettagangles "tag_barrel")[0] * -1.0 ) )
		}

		if (local.refresh_angle_hud > 0)
			local.refresh_angle_hud--

		if (local.refresh_angle_hud == 0)
			local.refresh_angle_hud = 10

		if ( local.exit_count == 0 && self.useheld == 1 )
			local.exit_mortar = 1

		if (local.switch_camera > 0)
			local.switch_camera--

		if (local.exit_count > 0)
			local.exit_count--

		waitframe
	}

	if (local.org)
		local.org remove

	if (local.mortar)
		local.mortar remove

	if (local.mortar_base)
		local.mortar_base remove

	if (self == NULL)
		end

	self unglue
	self.origin += ( 0 0 32 )

	self.has_mortar = 0
	self.inveh = 0

	ihuddraw_alpha self 28 0.0
	ihuddraw_alpha self 29 0.0
	ihuddraw_alpha self 30 0.0
	ihuddraw_alpha self 31 0.0
	ihuddraw_alpha self 32 0.0

	if (self.dmteam == local.team)
	{
		self forcetorsostate STAND
		self forcelegsstate STAND
	}
	else
	{
		if (self.dmteam != "spectator")
		{
			self.disable_spawn = 1

			if (isAlive self)
				self respawn
		}
	}

	local.count = 40

	while ( self != NULL && self.player_spawned == 1 && local.count > 0 )
	{
		local.count--
		waitframe
	}

	if ( self == NULL || self.player_spawned != 1 )
		end

	self exec global/AA/mortar.scr 1

end

mortar_angles local.mortar local.org local.z local.oldangles:

	if (self.keyheld[ELORE])
	{
		local.mortar.angles += ( 0.5 0 0 )

		local.angles = local.mortar gettagangles "tag_barrel"
		if (local.angles[0] > -45.0)
			local.mortar.angles -= ( 0.5 0 0 )
	}
	else if (self.keyheld[HATRA])
	{
		local.mortar.angles -= ( 0.5 0 0 )

		local.angles = local.mortar gettagangles "tag_barrel"
		if (local.angles[0] < -89.5)
			local.mortar.angles += ( 0.5 0 0 )
	}

	if (self.keyheld[BALRA])
	{
		local.mortar.angles += ( 0 0.5 0 )
		local.mortar.mortar_yaw += 0.5

		if (local.mortar.mortar_yaw > 45.0)
		{
			local.mortar.angles -= ( 0 0.5 0 )
			local.mortar.mortar_yaw -= 0.5
		}
	}
	else if (self.keyheld[JOBBRA])
	{
		local.mortar.angles -= ( 0 0.5 0 )
		local.mortar.mortar_yaw -= 0.5

		if (local.mortar.mortar_yaw < -45.0)
		{
			local.mortar.angles += ( 0 0.5 0 )
			local.mortar.mortar_yaw += 0.5
		}
	}

	if (self.keyheld[UGRAS])
		self.viewangles = ( 0 local.mortar.angles[1] 0 )

	local.org.origin = local.mortar.origin + angles_toforward ( 0 local.mortar.angles[1] 0 ) * -30
	local.org.origin = ( local.org.origin[0] local.org.origin[1] local.z )
	local.org.angles = ( 0 local.mortar.angles[1] 0 )

	local.deltaangles = local.mortar.angles - local.oldangles
	self.viewangles = ( self.viewangles[0] (self.viewangles[1] + local.deltaangles[1]) self.viewangles[2] )

end

mortar_fire local.mortar:

	if ( ( self.mortar_proj_type == "ap" && self.mortar_ap_proj_amount <= 0 ) || ( self.mortar_proj_type == "he" && self.mortar_he_proj_amount <= 0 ) )
		end

	self.mortar_canfire = 0

	local.mortar anim fire

	local.shell = spawn script_model scale 0.02
	local.shell.origin = local.mortar gettagposition "tag_barrel"
	local.shell.angles = local.mortar gettagangles "tag_barrel" + ( -90 0 0 )
	local.shell model "models/static/v2.tik"
	local.shell.attacker = self
	local.shell notsolid

	local.shell thread shell_flying self.mortar_proj_type local.mortar

	if (self.mortar_proj_type == "ap")
		self.mortar_ap_proj_amount--
	else if (self.mortar_proj_type == "he")
		self.mortar_he_proj_amount--

	self thread check_ammo_hud

	self.mortar_overheat++
	if (self.mortar_overheat >= 5)
	{
		self thread mortar_overheated
		end
	}

	wait self.mortar_firetime

	if (local.mortar == NULL)
	{
		if (self != NULL)
			self.mortar_canfire = 1

		end
	}

	local.mortar anim idle

end

mortar_overheated:

	self iprint "Mortar overheated..."

	wait 10

	if (self != NULL)
	{
		self.mortar_overheat = 0
		self.mortar_canfire = 1
	}

end

shell_flying local.proj_type local.mortar:

	local.startorigin = self.origin
	local.startangles = self.angles

	local.alfa = (local.mortar gettagangles "tag_barrel")[0] * -1.0
	local.sinalfa = waitthread global/AA/math.scr::sin local.alfa
	local.cosalfa = waitthread global/AA/math.scr::cos local.alfa

	local.V0 = 1574.8 // 30 m/s
	local.g = 514.96 // 9.81 m/s^2
	local.lifetime = 20.0 // s
	local.incoming_sound = 0
	local.t = 0.0
	local.dt = 0.05

	self.impact = 0

	self thread mortar_proj_camera

	while ( self.impact != 1 && local.t < local.lifetime && self.attacker != NULL )
	{
		local.V0x = local.V0 * local.cosalfa
		local.V0y = local.V0 * local.sinalfa

		local.Vx = local.V0x
		local.Vy = local.V0y - (local.g * local.t)
		local.V = waitthread global/AA/math.scr::sqrt ( (local.Vx * local.Vx) + (local.Vy * local.Vy) )

		if (local.Vx != 0.0)
		{
			local.pitch = waitthread global/AA/math.scr::arctan (local.Vy / local.Vx)
			local.pitch = local.pitch * -1.0
		}
		else
			local.pitch = self.angles[0]

		self.pitch = local.pitch

		local.x = local.V0x * local.t
		local.y = local.V0y * local.t - ( (local.g / 2.0) * (local.t * local.t) )

		self.origin = local.startorigin + angles_toforward ( 0 local.startangles[1] 0 ) * local.x + angles_toup ( 0 local.startangles[1] 0 ) * local.y
		self.angles = ( (local.pitch - 90.0) self.angles[1] self.angles[2] )

		if ( self.angles[0] < 360 && self.angles[0] > 320 )
		{
			if (local.incoming_sound != 1)
			{
				local.incoming_sound = 1
				self thread incoming_sound
			}
		}

		if (local.t > 0.0)
		{
			//local.sky = self waitthread check_sky_bottom self.origin
			self waitthread shell_impact local.V local.dt local.sky
		}

		wait local.dt
		local.t += local.dt
	}

	if (self.sound_org)
	{
		self.sound_org stoploopsound
		self.sound_org remove
	}

	if ( local.t >= local.lifetime || self.attacker == NULL )
	{
		self.impact = 1

		self hide

		wait 2

		self remove

		end
	}

	self thread shell_explode local.dt local.proj_type

end

shell_impact local.speed local.dt local.bottom:

	local.speed = local.speed * local.dt

	local.trace = waitexec global/AA/trace.scr self.origin ( self.origin + angles_toforward ( self.pitch self.angles[1] self.angles[2] ) * local.speed ) self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569441
	//local.traced_pos = local.trace["endPos"]

	//if (local.traced_pos[2] >= local.bottom)
	if (local.trace["surfacetype"] == "sky")
		end

	if ( local.trace["surfaceFlags"] == 0 && local.trace["contents"] == 0 )
		end

	if (local.trace["fraction"] != 1.0)
	{
		self.impact = 1
	}

end

incoming_sound:

	self.sound_org = spawn script_model model "models/fx/dummy.tik" origin self.origin
	self.sound_org glue self
	self.sound_org playsound mortar_incoming

end

shell_explode local.dt local.proj_type:

	self.impact = 1

	self hide

	local.weapon = spawn "models/weapons/weapon.tik" origin ( 0 0 -20000 )
	local.weapon notsolid
	local.weapon hide

	local.weapon firetype heavy
	local.weapon projectile ( "models/projectiles/mortarshell_" + local.proj_type + ".tik" )
	local.weapon dmprojectile ( "models/projectiles/mortarshell_" + local.proj_type + ".tik" )

	self.attacker bindweap local.weapon
	local.weapon shoot
	self.attacker bindweap local.weapon

	local.weapon remove

	local.mortarshell = NULL
	while (local.mortarshell == NULL)
	{
		wait local.dt

		if ($mortarshell.size > 0)
		{
			for (local.i = 1;local.i <= $mortarshell.size;local.i++)
			{
				local.proj = $mortarshell[local.i]

				if ( local.proj != NULL && local.proj.attacker != NIL && local.proj.attacker != NULL && local.proj.checked != 1 )
				{
					local.proj.checked = 1
					local.mortarshell = local.proj

					break
				}
			}
		}
	}

	if (local.mortarshell != NULL)
	{
		local.mortarshell.origin = self.origin
		local.mortarshell.angles = ( (self.angles[0] + 90) self.angles[1] 0 )
		local.mortarshell solid

		if (local.proj_type == "ap")
			local.mortarshell hitdamage 800
		else if (local.proj_type == "he")
			local.mortarshell hitdamage 200

		local.mortarshell explodeontouch
		local.mortarshell.velocity = local.mortarshell.forwardvector * 20000
	}

	local.fx = spawn script_model model "models/animate/fx_mortar_dirt.tik" scale 2.0
	local.fx.origin = self.origin
	local.fx notsolid
	local.fx anim start

	local.fx2 = spawn script_model model "models/animate/fx_mortar_dirt.tik"
	local.fx2.origin = self.origin
	local.fx2 notsolid
	local.fx2 anim start

	wait 2

	self remove
	local.fx remove
	local.fx2 remove

end

mortar_proj_camera:

	if (self.attacker.mortar_proj_camera != 1)
		end

	if ( self.attacker.mortar_camera == NIL || self.attacker.mortar_camera == NULL )
	{
		local.name = "mortar_camera" + randomint 999999 + self.attacker.entnum
		local.camera = spawn func_camera targetname local.name
		local.camera.cam_trigger = spawn trigger_camerause target local.name

		self.attacker.mortar_camera = local.camera
	}

	ihuddraw_alpha self.attacker 31 0.0

	waitframe

	if ( self.attacker == NULL || self.attacker.mortar_camera == NULL )
		end

	self.attacker.mortar_camera attach self "Box01" 0 ( 0 -20 0 )
	self.attacker.mortar_camera.cam_trigger douse self.attacker
	self.attacker.mortar_camera.proj = self

	local.camera = self.attacker.mortar_camera
	local.end_camera = 0

	while ( self.impact != 1 && local.camera != NULL && local.camera.proj == self && local.end_camera != 1 )
	{
		if ( self.angles[0] < 360 && self.angles[0] >= 270 )
			local.camera.angles = ( self.pitch self.angles[1] 0 )
		else
			local.camera.angles = ( 30 self.angles[1] 0 )

		if (self.attacker.forced_cueplayer == 1)
		{
			self.attacker.forced_cueplayer = 0
			self.attacker.mortar_camera.cam_trigger douse self.attacker
		}

		if ( self.attacker == NULL || self.attacker.has_mortar != 1 || self.attacker.mortar_proj_camera != 1 )
			local.end_camera = 1

		waitframe
	}

	if ( local.end_camera == 1 || ( self.impact == 1 && local.camera.proj == self ) )
	{
		if ( self.attacker != NULL && self.attacker.has_mortar == 1 )
			ihuddraw_alpha self.attacker 31 1.0

		if (local.camera)
		{
			if (local.camera.cam_trigger)
				local.camera.cam_trigger remove

			local.camera remove
		}
	}

end

switch_proj_type:

	self.mortar_can_switch_proj = 0

	self weapnext
	self activatenewweapon righthand

	self deactivateweapon righthand

	if (self.mortar_proj_type == "ap")
		self.mortar_proj_type = "he"
	else if (self.mortar_proj_type == "he")
		self.mortar_proj_type = "ap"

	self thread check_ammo_hud

	wait .5

	if ( self != NULL && self.has_mortar == 1 )
		self.mortar_can_switch_proj = 1

end

mortar_huds:

	if (self.mortar_proj_camera == 0)
		local.camera_state = "OFF"
	else if (self.mortar_proj_camera == 1)
		local.camera_state = "ON"

	ihuddraw_align self 28 left bottom
	ihuddraw_font self 28 courier-16
	ihuddraw_rect self 28 16 -200 128 16
	ihuddraw_string self 28 ( "Projectile camera: " + local.camera_state )
	ihuddraw_color self 28 1 0.588 0
	ihuddraw_alpha self 28 1.0

	ihuddraw_align self 29 left bottom
	ihuddraw_font self 29 courier-16
	ihuddraw_rect self 29 16 -180 128 16
	ihuddraw_color self 29 1 0.588 0
	ihuddraw_alpha self 29 1.0

	ihuddraw_align self 30 left bottom
	ihuddraw_font self 30 courier-16
	ihuddraw_rect self 30 16 -160 128 16
	ihuddraw_color self 30 1 0.588 0
	ihuddraw_alpha self 30 1.0

	ihuddraw_align self 31 center center
	ihuddraw_rect self 31 0 0 4 4
	ihuddraw_shader self 31 "textures/common/white.tga"
	ihuddraw_color self 31 1 0 0
	ihuddraw_alpha self 31 1.0

	ihuddraw_align self 32 left bottom
	ihuddraw_font self 32 courier-16
	ihuddraw_rect self 32 16 -140 128 16
	ihuddraw_color self 32 0.5 1.0 0.5
	ihuddraw_alpha self 32 1.0

	self thread check_ammo_hud

end

check_ammo_hud:

	if (self.mortar_proj_type == "ap")
		local.text = ( self.mortar_ap_proj_amount + " AP" )
	else if (self.mortar_proj_type == "he")
		local.text = ( self.mortar_he_proj_amount + " HE" )

	ihuddraw_string self 32 ( "Mortar Ammo: " + local.text )

end

check_place local.angles:

	for (local.i = 1;local.i <= 3;local.i++)
	{
		local.angle = local.angles[1] + (120.0 + 30.0 * local.i)

		local.startpos = self.origin + ( 0 0 20 )
		local.endpos = self.origin + angles_toforward ( 0 local.angle 0 ) * 100 + ( 0 0 20 )
		local.trace = waitexec global/AA/trace.scr local.startpos local.endpos self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569441

		if (local.trace["fraction"] != 1.0)
			end 0
	}

end 1

check_sky_bottom local.pos:

	local.trace = waitexec global/AA/trace.scr ( local.pos[0] local.pos[1] 20000 ) ( local.pos[0] local.pos[1] -20000 ) self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107372801
	local.traced_pos = local.trace["endPos"]

	local.z = 30

	for (local.i = 1;local.i <= 40;local.i++)
	{
		local.trace = waitexec global/AA/trace.scr ( local.traced_pos - ( 0 0 local.z ) ) local.traced_pos self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107372801
		local.new_traced_pos = local.trace["endPos"]

		local.z += 30

		if (local.new_traced_pos[2] < local.traced_pos[2])
			break
	}

	local.sky_bottom = local.new_traced_pos[2]

end local.sky_bottom

mortar_target:

	local.gt = int ( getcvar "g_gametype" )
	if (local.gt == 1)
		end

	if (self.mortar_target_area != 1)
	{
		self.mortar_target_area = 1

		local.pos = self gettagposition "eyes bone"
		local.trace = waitexec global/AA/trace.scr local.pos ( local.pos + angles_toforward self.viewangles * 20000 ) self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569441

		local.mortars = 0
		for (local.i = 1;local.i <= $player.size;local.i++)
		{
			local.player = $player[local.i]

			if ( local.player != NULL && local.player.ismortarman == 1 && local.player.has_mortar == 1 && local.player.dmteam == self.dmteam )
			{
				local.mortars++

				self thread mortar_target_area local.player local.trace["endPos"]
			}
		}

		if (local.mortars == 0)
		{
			self iprint "There are no deployed mortars!"

			wait 1

			self.mortar_target_area = 0
		}
		else
		{
			if (local.mortars == 1)
				self iprint ( "There is " + local.mortars + " mortar!" )
			else
				self iprint ( "There are " + local.mortars + " mortars!" )
		}

		wait 5

		if (self != NULL)
			self.mortar_target_area = 0
	}

end

mortar_target_area local.player local.pos:

	if ( local.player.mortar_base == NIL || local.player.mortar_base == NULL )
		end

	local.name = netname self

	local.startpos = ( local.player.mortar_base.origin[0] local.player.mortar_base.origin[1] local.player.origin[2] )
	local.endpos = local.pos

	local.angles = vector_toangles ( local.endpos - local.startpos )
	local.yaw = local.angles[1]

	local.a = ( local.startpos[0] local.startpos[1] 0 )
	local.b = ( local.endpos[0] local.endpos[1] 0 )
	local.x = vector_length ( local.a - local.b )

	local.V0 = 1574.8
	local.g = 514.96

	if ( abs ( (local.x * local.g) / (local.V0 * local.V0) ) > 1.0 )
	{
		local.player iprint ( local.name + " target area is out of distance!" )
		end
	}

	local.alfa = waitthread global/AA/math.scr::arcsin ( (local.x * local.g) / (local.V0 * local.V0) )
	local.alfa = 90.0 - (local.alfa / 2.0)

	local.player iprint ( local.name + " target area || HORZ. Angle: " + local.yaw + ", VERT. Angle: " + local.alfa )

end

mortar_help:

	self iprint "Crouch, holster your weapon and hold the use button to deploy mortar!" 1

end

```

# zz_veersmods\global\AA\palyavedelem.scr

```scr
main:

	level waittill spawn

	level.palyavedelem = getcvar "undermap_fix"
	if (level.palyavedelem == "")
		setcvar "undermap_fix" "1"

	level.palyavedelem = int ( getcvar "undermap_fix" )
	if (level.palyavedelem != 1)
		end

	local.z = waitthread map_ellenorzes
	if (local.z == NULL)
		end

	local.undermap_player_trigger = spawn trigger_multipleall
	local.undermap_player_trigger.origin = ( 0 0 local.z )
	local.undermap_player_trigger setsize ( -20000 -20000 -100 ) ( 20000 20000 0 )
	local.undermap_player_trigger setthread undermap_player

	local.undermap_vehicle_trigger = spawn trigger_vehicle
	local.undermap_vehicle_trigger.origin = ( 0 0 local.z )
	local.undermap_vehicle_trigger setsize ( -20000 -20000 -100 ) ( 20000 20000 0 )
	local.undermap_vehicle_trigger setthread undermap_vehicle

end

undermap_player:

	local.player = parm.other

	if ( !isAlive local.player || local.player.inveh == 1 )
		end

	local.player respawn

	stuffsrv ( "say " + (netname local.player) + " TRIED TO GET UNDER THE MAP!!!\n" )
	local.player iprint "You were forced to respawn."

	if (local.player.start_undermap_counter != 1)
	{
		local.player.start_undermap_counter = 1
		local.player thread undermap_counter
	}

	if (local.player.undermap_count == NIL)
		local.player.undermap_count = 0

	local.player.undermap_count++

end

undermap_counter:

	local.timecount = 20

	while ( self != NULL && local.timecount > 0 )
	{
		wait 2
		local.timecount--

		if ( self != NULL && self.undermap_count >= 3 )
		{
			if ( level.account == 1 && self.logged_in == 1 )
			{
				self.cash -= 50
				if (self.cash < 0)
					self.cash = 0
			}

			local.reason = "going too many times under map."

			stuffsrv ( "say " + (netname self) + " kicked for " + local.reason + "\n" )

			wait 3

			if (self != NULL)
			{
				local.num = getclientnum self

				stuffsrv ( "clientkickr " + local.num + " " + local.reason )
			}
		}
	}

	if (self == NULL)
		end

	self.start_undermap_counter = 0
	self.undermap_count = 0

end

undermap_vehicle:

	local.vehicle = parm.other

	if ( local.vehicle.classname == "VehicleCollisionEntity" || local.vehicle.classname == "ScriptSlave" )
	{
		if (local.vehicle.vehicle)
			local.vehicle = local.vehicle.vehicle
	}

	if (local.vehicle.fakehealth <= 0)
		end

	if ( self.same_z != 0 && local.vehicle.origin[2] > self.origin[2] )
		end

	if (local.vehicle.driver != NULL)
		local.driver = local.vehicle.driver

	local.vehicle.last_attacker = $world
	local.vehicle.fakehealth = 0

	local.vehicle takedamage
	local.vehicle removeimmune none
	local.vehicle normal_damage 10000

	if (local.driver != NIL)
		stuffsrv ( "say " + (netname local.driver) + " TRIED TO GET UNDER THE MAP WITH VEHICLE!!!\n" )

end

map_ellenorzes:

	local.map = getcvar "mapname"
	local.z = NULL

	switch (local.map)
	{
		case "m1l3a":
			local.z = -191.875
		break
		case "m1l3b":
			local.z = -103.875
		break
		case "m4l0":
			local.z = -327.875
		break
		case "m4l1":
			local.z = -511.875

			local.undermap_player_trigger = spawn trigger_multipleall
			local.undermap_player_trigger.origin = ( 2711 4341 -239.875 )
			local.undermap_player_trigger setsize ( -4144 -2700 -100 ) ( 1643 2763 0 )
			local.undermap_player_trigger setthread undermap_player

			local.undermap_vehicle_trigger = spawn trigger_vehicle
			local.undermap_vehicle_trigger.origin = ( 2711 4341 -239.875 )
			local.undermap_vehicle_trigger setsize ( -4144 -2700 -100 ) ( 1643 2763 0 )
			local.undermap_vehicle_trigger.same_z = 0
			local.undermap_vehicle_trigger setthread undermap_vehicle
		break
		case "m4l3":
			local.z = -447.875

			local.undermap_player_trigger = spawn trigger_multipleall
			local.undermap_player_trigger.origin = ( -4012 3103 -12 )
			local.undermap_player_trigger setsize ( 0 0 0 ) ( 5800 200 300 )
			local.undermap_player_trigger setthread undermap_player
		break
		case "m5l2a":
			local.z = 64.125
		break
		case "m5l3":
			local.z = 128.125
		break
	}

end local.z

```

# zz_veersmods\global\AA\panceltorok.scr

```scr
main local.origin local.angles local.type:

	local.pos = trace ( local.origin + ( 0 0 10 ) ) ( ( local.origin[0] local.origin[1] -17123 ) )

	local.crate = spawn script_model
	local.crate.origin = local.pos
	local.crate.angles = local.angles
	local.crate model "models/static/indycrate.tik"
	local.crate solid
	local.crate nodamage

	if (local.type == "bazooka")
		local.model = "models/weapons/bazooka.tik"
	else
		local.model = "models/weapons/panzerschreck.tik"

	local.bazooka = spawn script_model
	local.bazooka.origin = local.crate.origin + ( 0 0 50 )

	local.trace = trace ( local.bazooka.origin + ( 0 0 10 ) ) ( ( local.bazooka.origin[0] local.bazooka.origin[1] -17123 ) )
	local.bazooka.origin = local.trace

	if (local.type == "bazooka")
		local.bazooka.angles = local.crate.angles + ( 0 270 90 )
	else
		local.bazooka.angles = local.crate.angles + ( 180 90 270 )

	local.bazooka model local.model
	local.bazooka notsolid

	local.bazooka.trigger = spawn trigger_use origin local.bazooka.origin
	local.bazooka.trigger setsize ( -10 -10 -10 ) ( 10 10 20 )

	local.bazooka thread giveme_bazooka

end

giveme_bazooka:

	self.trigger waittill trigger

	local.player = parm.other

	if (local.player.has_heatseeker == 1)
	{
		goto giveme_bazooka
		end
	}

	self hide

	local.player give self.model
	local.player ammo heavy 3

	if (self.model == "models/weapons/bazooka.tik")
		self playsound bazooka_snd_pickup
	else
		self playsound panzerschreck_snd_pickup

	local.player iprint "You picked up an anti-tank weapon."

	wait 10

	self show

	goto giveme_bazooka

end

```

# zz_veersmods\global\AA\player_inturret.scr

```scr
main local.num:

	self.inturret = int local.num

	if (self.inveh != 1)
	{
		local.team = self.dmteam

		while ( self != NULL && self.player_spawned == 1 && self.inturret == 1 )
			waitframe

		if (self == NULL)
			end

		self surface all "-nodraw"

		if (self.dmteam != local.team)
		{
			self usestuff

			if (self.dmteam != "spectator")
				self.disable_spawn = 1

			self respawn
		}

		self.inturret = 0
	}

end
```

# zz_veersmods\global\AA\portablemg.scr

```scr
main local.team:

	self.has_portablemg = 1

	self takeall

	self give models/weapons/bar.tik
	self useweaponclass mg
	self activatenewweapon righthand

	if (local.team == "allies")
	{
		self give models/weapons/colt45.tik

		local.gun_model = "models/vehicles/jeep_30cal.tik"
		local.gun_hide_surface = "mount"
		local.gun_tag_offset = ( 5 -1 62.5 )
		local.bipod_tag_offset = ( -5 -1 0 )
		local.name = "M1919"
		local.firedelay = 0.08
		local.firesound = m1919_fire
		local.dmg = 60
	}
	else if (local.team == "axis")
	{
		self give models/weapons/p38.tik

		local.gun_model = "models/statweapons/mg42_gun.tik"
		local.gun_hide_surface = NIL
		local.gun_tag_offset = ( 37.5 -1 0 )
		local.bipod_tag_offset = ( -5 -1 0 )
		local.name = "MG42"
		local.firedelay = 0.06
		local.firesound = NIL
		local.dmg = 70
	}

	local.bipod_model = "models/statweapons/mg42_bipod.tik"

	waitframe

	while ( self != NULL && self.player_spawned == 1 && self.current_weapon == NULL )
		waitframe

	if ( self == NULL || self.player_spawned != 1 )
		end

	if (self.current_weapon.model != "models/weapons/bar.tik")
		end

	local.gun = spawn Animate angles ( 0 0 180 )
	local.gun attach self.current_weapon "origin" 1 local.gun_tag_offset
	local.gun model local.gun_model
	local.gun notsolid

	if (local.gun_hide_surface != NIL)
		local.gun surface local.gun_hide_surface "+nodraw"

	local.gun.bipod = spawn Animate angles ( 0 0 0 )
	local.gun.bipod attach local.gun "tag_barrel" 1 local.bipod_tag_offset
	local.gun.bipod model local.bipod_model
	local.gun.bipod notsolid

	self.current_weapon surface all "+nodraw"

	local.gun.name = local.name
	local.gun.firedelay = local.firedelay

	if (local.firesound != NIL)
		local.gun.firesound = local.firesound

	self.current_weapon noammosound		snd_step_paper
	self.current_weapon ammotype		"fakeammo"

	self.current_weapon holstertag		"Bip01 Spine2"
	self.current_weapon holsteroffset	"8.0 -7.75 6.5"
	self.current_weapon holsterangles	"0 185 -25"		
	self.current_weapon holsterScale	1.0

	self.current_weapon bulletspread	10 10 30 30
	self.current_weapon bulletdamage	local.dmg
	self.current_weapon firespreadmult	0.0 0.0 0 0.0
	self.current_weapon movementspeed	0.55

	self.current_weapon dmbulletspread	10 10 30 30
	self.current_weapon dmbulletdamage	local.dmg
	self.current_weapon dmfirespreadmult	0.0 0.0 0 0.0
	self.current_weapon dmmovementspeed	0.55

	self.current_weapon ammo_in_clip	0
	self.current_weapon semiauto

	local.gun.maxtolteny = 300
	local.gun.tolteny = 150
	local.gun.tarhely = 75
	local.gun.tolteny_tarban = 75

	local.gun.canfire = 1

	local.gun.parent = self.current_weapon
	self.portable_mg = local.gun

	if (local.team == "allies")
	{
		local.gun.rugas_mozgas[standing] = 1.0
		local.gun.rugas_mozgas[walking] = 1.3
		local.gun.rugas_mozgas[running] = 1.7
		local.gun.rugas_mozgas[falling] = 2.3
	}
	else if (local.team == "axis")
	{
		local.gun.rugas_mozgas[standing] = 1.0
		local.gun.rugas_mozgas[walking] = 1.5
		local.gun.rugas_mozgas[running] = 2.0
		local.gun.rugas_mozgas[falling] = 2.6
	}

	self stufftext ("globalwidgetcommand weaponname itemstat -1")
	self stufftext ("globalwidgetcommand weaponname title " + local.gun.name)
	self stufftext ("globalwidgetcommand clipcount playerstat -1")
	self stufftext ("globalwidgetcommand clipcount title " + local.gun.tolteny_tarban)
	self stufftext ("globalwidgetcommand ammocount playerstat -1")
	self stufftext ("globalwidgetcommand ammocount linkcvar portablemg")
	self stufftext ("globalwidgetcommand clipbulletso playerstat -1")
	self stufftext ("globalwidgetcommand clipbulletse playerstat -1")

	self stufftext ("set portablemg " + local.gun.tolteny)

	local.heveder = self waitthread heveder

	self thread check_gun local.gun local.heveder

end

check_gun local.gun local.heveder:

	if (self.portablemg_help != 1)
	{
		self.portablemg_help = 1
		self iprint "You can reload your machinegun by the sec. attack button!" 1
	}

	while ( self != NULL && self.player_spawned == 1 )
	{
		if ( self.fireheld == 1 && self.secfireheld != 1 )
		{
			if ( self.current_weapon != NULL && self.current_weapon == local.gun.parent )
			{
				if (local.gun.canfire == 1)
				{
					local.gun thread gun_firing self
				}
			}
		}
		else if ( self.fireheld == 1 && self.secfireheld == 1 )
		{
			if ( self.current_weapon != NULL && self.current_weapon == local.gun.parent )
			{
				if ( local.gun.tolteny > 0 && local.gun.isreloading != 1 )
				{
					local.gun thread gun_reload self
				}
			}
		}

		if ( local.gun != NULL && local.gun.parent.angles[2] == 90.0 )
			break

		waitframe
	}

	if (local.gun)
	{
		local.parent_gun = local.gun.parent
		local.gun.bipod remove
		local.gun remove

		if (local.parent_gun)
			local.parent_gun remove
	}

	if (local.heveder)
	{
		local.heveder detach
		local.heveder remove
	}

	if (self != NULL)
	{
		self.has_portablemg = 0

		self stufftext ("globalwidgetcommand weaponname itemstat 1")
		self stufftext ("globalwidgetcommand clipcount playerstat 6")
		self stufftext ("globalwidgetcommand ammocount playerstat 4")
		self stufftext ("globalwidgetcommand ammocount fgcolor .7 .6 .05 1")
		self stufftext ("globalwidgetcommand clipbulletso playerstat 6")
		self stufftext ("globalwidgetcommand clipbulletse playerstat 6")
	}

end

gun_firing local.attacker:

	if (self.tolteny_tarban > 0)
	{
		self.canfire = 0

		local.attacker waitthread gun_viewkick self

		local.attacker viewmodelanim fire 1
		self.parent shoot

		self.tolteny_tarban--

		local.attacker stufftext ("globalwidgetcommand clipcount title " + self.tolteny_tarban)

		self thread fakegun_firing

		wait self.firedelay

		if (self.tolteny_tarban > 0)
			self.canfire = 1
	}

end

fakegun_firing:

	self anim fire

	if (self.firesound != NIL)
		self playsound self.firesound

	waitframe

	if (self)
		self anim idle

end

gun_reload local.attacker:

	self.canfire = 0
	self.isreloading = 1

	local.tar = self.tarhely - self.tolteny_tarban
	if (local.tar == 0)
	{
		self.canfire = 1
		self.isreloading = 0

		end
	}

	wait 1

	if (self == NULL)
		end

	self playsound bar_snd_reload

	wait 3

	if (self != NULL)
	{
		if (self.tolteny >= local.tar)
		{
			local.a = local.tar
		}
		else
			local.a = self.tolteny

		self.tolteny_tarban += local.a
		self.tolteny -= local.a

		if (self.tolteny < 0)
			self.tolteny = 0

		if (local.attacker != NULL)
		{
			local.attacker stufftext ("globalwidgetcommand clipcount title " + self.tolteny_tarban)
			local.attacker stufftext ("set portablemg " + self.tolteny)
		}

		if (self.tolteny_tarban > 0)
		{
			self.canfire = 1
			self.isreloading = 0
		}
	}

end

gun_viewkick local.gun:

	local.rugas = ( 0 0 0 )

	if ( (self getposition) == "standing")
		local.modosito = 1.10
	else
		local.modosito = 0.35

	local.modositas = local.modosito * local.gun.rugas_mozgas[(self getmovement)]

	local.felfele_rugas = randomfloat 2.0
	local.felfele_rugas = local.felfele_rugas - (local.felfele_rugas + local.felfele_rugas)

	local.oldal_rugas = randomfloat 1.0
	local.elojel = randomint 6.0
	if (local.elojel > 3.0)
		local.oldal_rugas = local.oldal_rugas - (local.oldal_rugas + local.oldal_rugas)

	local.rugas = ( (local.felfele_rugas * local.modositas) (local.oldal_rugas * local.modositas) 0 )

	self.viewangles += local.rugas

end

heveder:

	local.heveder = spawn Animate model "models/gear/heer/grenadierload.tik"
	local.heveder attach self "Bip01 Spine2" 1 ( -70 1 0 )
	local.heveder surface ammobox "+nodraw"
	local.heveder angles ( 0 90 90 )
	local.heveder notsolid

end local.heveder

```

# zz_veersmods\global\AA\projectiles.scr

```scr
main local.tname:

	if (self.already_started != 1)
	{
		self.already_started = 1

		if (self.classname != "Projectile")
			end

		if ( local.tname != NIL && local.tname != NULL )
			self.targetname = local.tname

		local.t = spawn trigger_multipleall spawnflags "20" origin self.origin angles self.angles
		local.t.targetname = ( "projectile_attacker_trigger" + randomint 999999 + self.entnum )
		local.t setsize ( -5 -5 -5 ) ( 5 5 5 )
		local.t glue self

		local.t waittill trigger

		if (self == NULL)
			end

		self.attacker = parm.owner

		if (local.t)
			local.t remove

		self thread projectile_teamkill_fix self.attacker self.attacker.dmteam

		if (self.targetname == "tankproj")
			self thread tank_proj
	}

end

projectile_teamkill_fix local.attacker local.team:

	while ( self != NULL && local.attacker != NULL && local.attacker.isplayer == 1 && local.attacker.dmteam == local.team )
		waitframe

	if (self == NULL)
		end

	if ( local.attacker == NULL || ( local.attacker != NULL && local.attacker.isplayer == 1 && local.attacker.dmteam != local.team ) )
		self immediateremove

end

tank_proj:

	if (self.attacker.isplayer == 1)
	{
		if ($vezetheto_jarmu.size > 0)
		{
			for (local.i = 1;local.i <= $vezetheto_jarmu.size;local.i++)
			{
				local.jarmu = $vezetheto_jarmu[local.i]

				if ( local.jarmu.driver != NIL && local.jarmu.driver != NULL && local.jarmu.driver == self.attacker )
				{
					self speed 0

					self.origin = local.jarmu.torony gettagposition "tag_barrel"
					self.angles = local.jarmu.torony gettagangles "tag_barrel"
					self.velocity = self.forwardvector * 6000
				}
			}
		}
	}

end

```

# zz_veersmods\global\AA\reward_market.scr

```scr
main:

	if (self.logged_in != 1)
		end

	if ( self.inveh == 1 || self.inturret == 1 )
	{
		self iprint "You can't open the market in vehicle or in turret."
		end
	}

	self.market_isopen = 1
	self.inveh = 1

	if (self.has_weapon == 1)
	{
		self deactivateweapon righthand
		self exec global/AA/check_weapons.scr "0"
	}

	self forcetorsostate JARMUBEN_DEFAULT

	local.org = spawn script_origin
	local.org.origin = self.origin
	local.org.angles = self.angles

	self glue local.org

	self waitthread market_hud
	self thread in_market local.org self.dmteam

	wait 1

	if ( self != NULL && self.player_spawned == 1 && self.already_started_market != 1 )
	{
		self.already_started_market = 1

		self iprint "PUSH THE USE BUTTON TO CLOSE THE MARKET!!!" 1
	}

end

market_hud:

	ihuddraw_align self level.rewards_background_id left top
	ihuddraw_rect self level.rewards_background_id 45 150 550 250
	ihuddraw_shader self level.rewards_background_id "textures/mohmenu/black.tga"
	ihuddraw_virtualsize self level.rewards_background_id 1
	ihuddraw_alpha self level.rewards_background_id 0.9

	local.hud_id = level.rewards_hud_id
	local.x = level.rewards_x
	local.y = level.rewards_y

	for (local.i = 1;local.i <= level.rewards_size;local.i++)
	{
		local.rew = (local.hud_id - level.rewards_hud_id) + 1

		if (self.reward[level.rewards[local.rew][3]] != 1)
		{
			local.color = level.rewards_white
			ihuddraw_string self (local.hud_id + level.rewards_size) ( level.rewards[local.i][2] + " $" )
		}
		else
		{
			local.color = level.rewards_green
			ihuddraw_string self (local.hud_id + level.rewards_size) "PURCHASED"
		}

		ihuddraw_align self local.hud_id left top
		ihuddraw_rect self local.hud_id local.x local.y 0 0
		ihuddraw_color self local.hud_id local.color[0] local.color[1] local.color[2]
		ihuddraw_font self local.hud_id "verdana-12"
		ihuddraw_string self local.hud_id ( local.i + ". " + level.rewards[local.i][1] )
		ihuddraw_virtualsize self local.hud_id 1
		ihuddraw_alpha self local.hud_id 1

		ihuddraw_align self (local.hud_id + level.rewards_size) left top
		ihuddraw_rect self (local.hud_id + level.rewards_size) (local.x + level.rewards_x2) local.y 0 0
		ihuddraw_color self (local.hud_id + level.rewards_size) local.color[0] local.color[1] local.color[2]
		ihuddraw_font self (local.hud_id + level.rewards_size) "verdana-12"
		ihuddraw_virtualsize self (local.hud_id + level.rewards_size) 1
		ihuddraw_alpha self (local.hud_id + level.rewards_size) 1

		local.y += 14
		local.hud_id++

		if (local.i == 17)
		{
			local.x += level.rewards_x2 + 100
			local.y = level.rewards_y
		}
	}

end

in_market local.org local.team:

	local.current_id = level.rewards_hud_id
	local.current_price_id = level.rewards_hud_id + level.rewards_size

	ihuddraw_color self local.current_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]
	ihuddraw_color self local.current_price_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]

	local.market_color = ( 0.96 0.87 0.10 )

	self light local.market_color[0] local.market_color[1] local.market_color[2] 150

	local.count = 0

	while ( self != NULL && self.player_spawned == 1 && self.logged_in == 1 && self.useheld != 1 && self.keyheld[GUGOLAS] != 1 && self.keyheld[UGRAS] != 1 )
	{
		local.rew = (local.current_id - level.rewards_hud_id) + 1

		if (local.count == 0)
		{
			if (self.keyheld[HATRA])
			{
				if ( local.current_id + 1 <= level.rewards_hud_id + (level.rewards_size - 1) )
				{
					if (self.reward[level.rewards[local.rew][3]] != 1)
						local.color = level.rewards_white
					else
						local.color = level.rewards_green

					ihuddraw_color self local.current_id local.color[0] local.color[1] local.color[2]
					ihuddraw_color self local.current_price_id local.color[0] local.color[1] local.color[2]

					local.current_id++
					local.current_price_id++

					ihuddraw_color self local.current_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]
					ihuddraw_color self local.current_price_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]

					local.count = 4
				}
			}
			else if (self.keyheld[ELORE])
			{
				if (local.current_id - 1 >= level.rewards_hud_id)
				{
					if (self.reward[level.rewards[local.rew][3]] != 1)
						local.color = level.rewards_white
					else
						local.color = level.rewards_green

					ihuddraw_color self local.current_id local.color[0] local.color[1] local.color[2]
					ihuddraw_color self local.current_price_id local.color[0] local.color[1] local.color[2]

					local.current_id--
					local.current_price_id--

					ihuddraw_color self local.current_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]
					ihuddraw_color self local.current_price_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]

					local.count = 4
				}
			}
		}

		if ( self.fireheld && local.count == 0 )
		{
			local.price = int level.rewards[local.rew][2]

			if (self.reward[level.rewards[local.rew][3]] != 1)
			{
				if (self.cash >= local.price)
				{
					self.cash -= local.price

					ihuddraw_string self (local.current_id + level.rewards_size) "PURCHASED"

					self.reward[level.rewards[local.rew][3]] = 1

					self waitthread global/AA/reward_store.scr::update_rewards self.rew_username self.rew_password
					self waitthread global/AA/reward_store.scr::update_cash
				}
				else
					self iprint "You don't have enough cash to buy it!" 1
			}

			local.count = 4
		}

		waitframe

		if (local.count > 0)
			local.count--
	}

	if (self == NULL)
		end

	self light 0 0 0 0

	ihuddraw_alpha self level.rewards_background_id 0

	local.hud_id = level.rewards_hud_id

	for (local.i = 1;local.i <= level.rewards_size;local.i++)
	{
		ihuddraw_alpha self local.hud_id 0
		ihuddraw_alpha self (local.hud_id + level.rewards_size) 0

		local.hud_id++
	}

	self unglue

	if (local.org)
		local.org remove

	self.keyheld[GUGOLAS] = 0
	self.keyheld[UGRAS] = 0

	self.inveh = 0
	self.market_isopen = 0

	if (self.dmteam == local.team)
		self forcetorsostate STAND
	else
	{
		if (self.dmteam != "spectator")
			self respawn
	}

end

check_rewards local.username local.password:

	local.text = waitthread global/AA/files.scr::string_lines ( "main/global/accounts/" + local.username + ".txt" )
	if ( local.text == NIL || local.text.size < 2 )
		end

	self.cash = int (waitthread global/AA/files.scr::right local.text[2] "=")

	for (local.i = 1;local.i <= level.rewards_size;local.i++)
	{
		local.rew = level.rewards[local.i][3]

		local.line = waitthread global/AA/files.scr::string_to_find local.text local.rew
		if (local.line != NIL)
		{
			local.value = int (waitthread global/AA/files.scr::right local.text[local.line] "=")

			self.reward[local.rew] = local.value
			self.reward_activated[local.i] = 0
		}
		else
		{
			self.reward[local.rew] = 0
			self.reward_activated[local.i] = 0
		}
	}

	self waitthread global/AA/reward_store.scr::update_rewards local.username local.password
	self waitthread global/AA/reward_store.scr::update_cash

end

```

# zz_veersmods\global\AA\reward_store.scr

```scr
main:

	if (self.logged_in != 1)
		end

	if ( self.inveh == 1 || self.inturret == 1 )
	{
		self iprint "You can't open the store in vehicle or in turret."
		end
	}

	self.store_isopen = 1
	self.inveh = 1

	if (self.has_weapon == 1)
	{
		self deactivateweapon righthand
		self exec global/AA/check_weapons.scr "0"
	}

	self forcetorsostate JARMUBEN_DEFAULT

	local.org = spawn script_origin
	local.org.origin = self.origin
	local.org.angles = self.angles

	self glue local.org

	self waitthread store_hud
	self thread in_store local.org self.dmteam

	wait 1

	if ( self != NULL && self.player_spawned == 1 && self.already_started_store != 1 )
	{
		self.already_started_store = 1

		self iprint "PUSH THE USE BUTTON TO CLOSE THE STORE!!!" 1
	}

end

store_hud:

	ihuddraw_align self level.rewards_background_id left top
	ihuddraw_rect self level.rewards_background_id 45 150 550 250
	ihuddraw_shader self level.rewards_background_id "textures/mohmenu/black.tga"
	ihuddraw_virtualsize self level.rewards_background_id 1
	ihuddraw_alpha self level.rewards_background_id 0.9

	local.hud_id = level.rewards_hud_id
	local.x = level.rewards_x
	local.y = level.rewards_y
	local.s = 0

	for (local.i = 1;local.i <= level.rewards_size;local.i++)
	{
		local.rew = (local.hud_id - level.rewards_hud_id) + 1

		if (self.reward_activated[local.rew] != 1)
		{
			if (self.reward[level.rewards[local.rew][3]] != 1)
			{
				local.color = level.rewards_white
				ihuddraw_string self (local.hud_id + level.rewards_size) "Not PURCHASED"
			}
			else
			{
				local.color = level.rewards_blue
				ihuddraw_string self (local.hud_id + level.rewards_size) "Not ACTIVATED"
			}
		}
		else
		{
			local.color = level.rewards_green
			ihuddraw_string self (local.hud_id + level.rewards_size) "ACTIVATED"
		}

		ihuddraw_align self local.hud_id left top
		ihuddraw_rect self local.hud_id local.x local.y 0 0
		ihuddraw_color self local.hud_id local.color[0] local.color[1] local.color[2]
		ihuddraw_font self local.hud_id "verdana-12"
		ihuddraw_string self local.hud_id ( local.i + ". " + level.rewards[local.i][1] )
		ihuddraw_virtualsize self local.hud_id 1
		ihuddraw_alpha self local.hud_id 1

		ihuddraw_align self (local.hud_id + level.rewards_size) left top
		ihuddraw_rect self (local.hud_id + level.rewards_size) (local.x + level.rewards_x2 - local.s) local.y 0 0
		ihuddraw_color self (local.hud_id + level.rewards_size) local.color[0] local.color[1] local.color[2]
		ihuddraw_font self (local.hud_id + level.rewards_size) "verdana-12"
		ihuddraw_virtualsize self (local.hud_id + level.rewards_size) 1
		ihuddraw_alpha self (local.hud_id + level.rewards_size) 1

		local.y += 14
		local.hud_id++

		if (local.i == 17)
		{
			local.x += level.rewards_x2 + 100
			local.y = level.rewards_y
			local.s = 30
		}
	}

end

in_store local.org local.team:

	local.current_id = level.rewards_hud_id
	local.current_state_id = level.rewards_hud_id + level.rewards_size

	ihuddraw_color self local.current_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]
	ihuddraw_color self local.current_state_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]

	local.store_color = ( 0.84 0.04 0.98 )

	self light local.store_color[0] local.store_color[1] local.store_color[2] 150

	local.count = 0

	while ( self != NULL && self.player_spawned == 1 && self.logged_in == 1 && self.useheld != 1 && self.keyheld[GUGOLAS] != 1 && self.keyheld[UGRAS] != 1 )
	{
		local.rew = (local.current_id - level.rewards_hud_id) + 1

		if (local.count == 0)
		{
			if (self.keyheld[HATRA])
			{
				if ( local.current_id + 1 <= level.rewards_hud_id + (level.rewards_size - 1) )
				{
					if (self.reward_activated[local.rew] != 1)
					{
						if (self.reward[level.rewards[local.rew][3]] != 1)
							local.color = level.rewards_white
						else
							local.color = level.rewards_blue
					}
					else
						local.color = level.rewards_green

					ihuddraw_color self local.current_id local.color[0] local.color[1] local.color[2]
					ihuddraw_color self local.current_state_id local.color[0] local.color[1] local.color[2]

					local.current_id++
					local.current_state_id++

					ihuddraw_color self local.current_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]
					ihuddraw_color self local.current_state_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]

					local.count = 4
				}
			}
			else if (self.keyheld[ELORE])
			{
				if (local.current_id - 1 >= level.rewards_hud_id)
				{
					if (self.reward_activated[local.rew] != 1)
					{
						if (self.reward[level.rewards[local.rew][3]] != 1)
							local.color = level.rewards_white
						else
							local.color = level.rewards_blue
					}
					else
						local.color = level.rewards_green

					ihuddraw_color self local.current_id local.color[0] local.color[1] local.color[2]
					ihuddraw_color self local.current_state_id local.color[0] local.color[1] local.color[2]

					local.current_id--
					local.current_state_id--

					ihuddraw_color self local.current_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]
					ihuddraw_color self local.current_state_id level.rewards_yellow[0] level.rewards_yellow[1] level.rewards_yellow[2]

					local.count = 4
				}
			}
		}

		if ( self.fireheld && local.count == 0 )
		{
			if (self.max_activated_rewards == NIL)
				self.max_activated_rewards = 0

			local.max_rewards = getcvar "max_rewards"
			if (local.max_rewards == "")
				setcvar "max_rewards" "5"

			local.max_rewards = int ( getcvar "max_rewards" )

			if (self.max_activated_rewards < local.max_rewards)
			{
				if ( self.reward[level.rewards[local.rew][3]] == 1 && self.reward_activated[local.rew] != 1 )
				{
					self.reward_activated[local.rew] = 1

					ihuddraw_string self local.current_state_id "ACTIVATED"

					self waitthread activate_rewards level.rewards[local.rew][3]

					self.max_activated_rewards++

					local.force_respawn = 1
				}
			}
			else
			{
				if (self.reward_activated[local.rew] != 1)
					self iprint "You have the maximum rewards activated!" 1
			}

			local.count = 4
		}

		waitframe

		if (local.count > 0)
			local.count--
	}

	if (self == NULL)
		end

	self light 0 0 0 0

	ihuddraw_alpha self level.rewards_background_id 0

	local.hud_id = level.rewards_hud_id

	for (local.i = 1;local.i <= level.rewards_size;local.i++)
	{
		ihuddraw_alpha self local.hud_id 0
		ihuddraw_alpha self (local.hud_id + level.rewards_size) 0

		local.hud_id++
	}

	self unglue

	if (local.org)
		local.org remove

	self.keyheld[GUGOLAS] = 0
	self.keyheld[UGRAS] = 0

	self.inveh = 0
	self.store_isopen = 0

	if (self.dmteam == local.team)
		self forcetorsostate STAND
	else
	{
		if (self.dmteam != "spectator")
		{
			self respawn
			end
		}
	}

	if (local.force_respawn == 1)
		self respawn

end

check_activated_rewards local.text local.line:

	if (local.line > local.text.size)
		end

	for (local.i = local.line;local.i <= local.text.size;local.i++)
	{
		if (local.text[local.i].size > 5)
		{
			if ( local.text[local.i][0] == "n" && local.text[local.i][1] == "a" && local.text[local.i][2] == "m" && local.text[local.i][3] == "e" && local.text[local.i][4] == "=" )
			{
				local.next_line = local.i
				break
			}
		}
	}

	if ( local.next_line != NIL && local.next_line == local.line )
		end

	if (local.next_line == NIL)
		local.next_line = local.text.size

	if (local.next_line > local.text.size)
		end

	for (local.i = local.line;local.i <= local.next_line;local.i++)
	{
		if (local.rewards_line == NIL)
			local.rewards_line[1] = local.text[local.i]
		else
			local.rewards_line[local.rewards_line.size + 1] = local.text[local.i]
	}

	if (local.rewards_line == NIL)
		end

	for (local.i = 1;local.i <= local.rewards_line.size;local.i++)
	{
		local.rew = waitthread global/AA/files.scr::left local.rewards_line[local.i] "="
		local.value = int (waitthread global/AA/files.scr::right local.rewards_line[local.i] "=")

		for (local.j = 1;local.j <= level.rewards_size;local.j++)
		{
			local.reward = level.rewards[local.j][3]

			if (local.reward == local.rew)
			{
				if (self.max_activated_rewards == NIL)
					self.max_activated_rewards = 0

				self.reward_activated[local.j] = local.value

				self waitthread activate_rewards local.reward

				self.max_activated_rewards++
			}
		}
	}

end

activate_rewards local.reward:

	switch (local.reward)
	{
		case "doublepoints":
			self.doublepoints = 1

			if (self.max_engineerpoint)
				self.max_engineerpoint += self.max_engineerpoint

			if (self.max_medicpoint)
				self.max_medicpoint += self.max_medicpoint
		break
		case "playerextras":
			self.playerextras = 1
		break
		case "healthpack":
			self.maxhealthpack = 1
		break
		case "reviving":
			self.instant_reviving = 1
		break
		case "fastengineer":
			self.fastengineer = 1
		break
		case "sniperextras":
			self.sniperextras = 1
		break
		case "reducedbombtime":
			self.reduced_bombtime = 1
		break
		case "rifledamage":
			self.rifledamage = 1
		break
		case "smgdamage":
			self.smgdamage = 1
		break
		case "machinegundamage":
			self.mgdamage = 1
		break
		case "doublecash":
			self.doublecash = 1
		break
		case "classworks":
			self.classworks = 1
		break
		case "tankreload":
			self.tankreload = 1
		break
		case "extra_vehiclespeed":
			self.extra_vehiclespeed = 1
		break
		case "ammodrop":
			self.ammodrop = 1
		break
		case "airstrike":
			self.airstrike = 1
		break
		case "artillery":
			self.artillery = 1
		break
		case "portablemg":
			self.portablemg = 1
		break
		case "mortar":
			self.mortar = 1
		break
	}

end

give_cash local.amount:

	if (self.logged_in != 1)
		end

	local.double = 1
	if (self.doublecash == 1)
		local.double = 2

	self.cash += ( int local.amount ) * local.double

	self waitthread update_rewards self.rew_username self.rew_password
	self waitthread update_cash

end

update_rewards local.username local.password:

	if (self.cash == NIL)
		self.cash = 0

	local.content[1] = ( "password=" + local.password + "\n" )
	local.content[2] = ( "cash=" + self.cash + "\n" )

	for (local.i = 1;local.i <= level.rewards_size;local.i++)
	{
		local.rew_value = self.reward[level.rewards[local.i][3]]
		if (local.rew_value == NIL)
			local.rew_value = 0

		local.content[local.content.size + 1] = ( level.rewards[local.i][3] + "=" + local.rew_value + "\n" )
	}

	waitthread global/AA/files.scr::save_new_file ( "main/global/accounts/" + local.username + ".txt" ) local.content

end

update_cash:

	ihuddraw_align self level.cash_id left bottom
	ihuddraw_rect self level.cash_id 16 -100 10 10
	ihuddraw_color self level.cash_id 1.0 0.59 0.06 // red, green, blue
	ihuddraw_font self level.cash_id "facfont-20"
	ihuddraw_alpha self level.cash_id 1
	ihuddraw_string self level.cash_id ( "CASH: " + self.cash + " $" )
	ihuddraw_alpha self level.cash_id 1

end

reset_rewards:

	if (self.doublepoints == 1)
	{
		if (self.max_engineerpoint)
			self.max_engineerpoint -= (self.max_engineerpoint / 2)

		if (self.max_medicpoint)
			self.max_medicpoint -= (self.max_medicpoint / 2)
	}

	ihuddraw_alpha self level.cash_id 0

	self.cash = NIL
	self.doublepoints = NIL
	self.playerextras = NIL
	self.maxhealthpack = NIL
	self.instant_reviving = NIL
	self.fastengineer = NIL
	self.sniperextras = NIL
	self.reduced_bombtime = NIL
	self.rifledamage = NIL
	self.smgdamage = NIL
	self.mgdamage = NIL
	self.doublecash = NIL
	self.classworks = NIL
	self.tankreload = NIL
	self.extra_vehiclespeed = NIL
	self.ammodrop = NIL
	self.airstrike = NIL
	self.artillery = NIL
	self.portablemg = NIL
	self.mortar = NIL

	for (local.i = 1;local.i <= level.rewards_size;local.i++)
	{
		local.rew = level.rewards[local.i][3]

		self.reward[local.rew] = 0
		self.reward_activated[local.i] = 0
	}

	self.max_activated_rewards = 0

	waitframe

	if ( self != NULL && self.player_spawned == 1 )
		self respawn

end

////----------------------------------------------------------------------------------------------////
////<<<---------------------------------->>>REWARD SCRIPTS<<<---------------------------------->>>////
////----------------------------------------------------------------------------------------------////
spawned_player_rewards:

	if (self.logged_in != 1)
		end

	if (self.playerextras == 1)
	{
		self ammo pistol 999
		self ammo rifle 999
		self ammo smg 999
		self ammo mg 999
		self ammo grenade 999
		self ammo heavy 999
		self ammo shotgun 999
	}

	if ( self.ismedic != 1 && self.isengineer != 1 && self.portablemg == 1 )
	{
		self exec global/AA/portablemg.scr self.dmteam
	}

	if (self.airstrike == 1)
	{
		self exec global/AA/airstrike.scr
	}

	if (self.artillery == 1)
	{
		self exec global/AA/artillery.scr
	}

	if (self.mortar == 1)
	{
		self exec global/AA/mortar.scr
	}

end

```

# zz_veersmods\global\AA\sniper.scr

```scr
main:

	if (self.sniperextras == 1)
	{
		local.time = 20
		while ( self != NULL && self.player_spawned == 1 && self getactiveweap 0 == NULL && local.time > 0 )
		{
			waitframe
			local.time--
		}

		if ( self == NULL || self.player_spawned != 1 || self getactiveweap 0 == NULL )
			end

		local.weap = self getactiveweap 0
		if ( local.weap.model != "models/weapons/springfield.tik" && local.weap.model != "models/weapons/kar98sniper.tik" )
			end

		local.weap zoom 8
		local.weap dmzoomspreadmult 0
		local.weap clipsize 10
		local.weap ammo_in_clip 10
	}

end

```

# zz_veersmods\global\AA\spawn_protection.scr

```scr
main local.team:

	local.protection = getcvar "spawn_protect"
	if (local.protection == "")
		setcvar "spawn_protect" "0"

	local.protection = int ( getcvar "spawn_protect" )
	if (local.protection == 0)
		end

	local.light = ( 0 0 0 )

	if (local.team == "allies")
		local.light = ( 0 0 1 )
	if (local.team == "axis")
		local.light = ( 1 0 0 )

	self.inveh = 1

	self notsolid
	self nodamage
	self light local.light[0] local.light[1] local.light[2] 100

	self.spawnprotected = 1

	local.count = local.protection * 10

	while ( self != NULL && self.player_spawned == 1 && local.count > 0 )
	{
		wait .1
		local.count--
	}

	if (self == NULL)
		end

	self solid
	self takedamage
	self light 0 0 0 0

	self.inveh = 0

	self.spawnprotected = 0

end

```

# zz_veersmods\global\AA\teambalance.scr

```scr
main:

	level waittill spawn

	local.gt = int ( getcvar "g_gametype" )
	if (local.gt == 1)
		end

	teamswitchdelay .2

	wait 1

	thread player_monitor
	thread teambalance

end
		end
player_monitor:

	level.allies_balance_number = 0
	level.axis_balance_number = 0

	while ( level.intermission_started != 1 && level.bas_roundend != 1 )
	{
		for (local.i = 1;local.i <= $player.size;local.i++)
		{
			local.player = $player[local.i]

			if ( local.player != NULL && local.player.isplayer == 1 )
			{
				if (local.player.dmteam != "spectator")
				{
					if ( local.player.dmteam == "allies" && local.player.current_dmteam != "allies" )
					{
						level.allies_balance_number++

						local.player.current_dmteam = "allies"
						local.player.allies_balance_number = level.allies_balance_number
					}
					else if ( local.player.dmteam == "axis" && local.player.current_dmteam != "axis" )
					{
						level.axis_balance_number++

						local.player.current_dmteam = "axis"
						local.player.axis_balance_number = level.axis_balance_number
					}

					if ( level.last_balanced_player != NULL && level.last_balanced_player == local.player )
					{
						if (local.player.dmteam != local.player.balanced_team)
						{
							local.unbalanced_teams = waitthread check_teams
							if ( ( local.player.balanced_team == "allies" && local.unbalanced_teams == 2 ) || ( local.player.balanced_team == "axis" && local.unbalanced_teams == 1 ) )
							{
								wait .1

								if (local.player != NULL)
								{
									local.player join_team local.player.balanced_team
									local.player iprint "Stay in your team, otherwise the teams will be unbalanced."
								}
							}
							else
								level.last_balanced_player = NULL
						}
					}
				}
				else
				{
					if (local.player.current_dmteam != "spectator")
						local.player.current_dmteam = "spectator"
				}
			}
		}

		wait .1
	}

end

teambalance:

	local.max_warning = 2
	local.warning = 0
	local.warning_time = 6

	level.last_balanced_player = NULL

	while ( level.intermission_started != 1 && level.bas_roundend != 1 )
	{
		wait 1

		level.tb = getcvar "teambalance"
		if (level.tb == "")
			setcvar "teambalance" "0"

		level.tb = int ( getcvar "teambalance" )
		if (level.tb > 0)
		{
			local.unbalanced_teams = waitthread check_teams
			if (local.unbalanced_teams > 0)
			{
				if (local.warning <= local.max_warning)
				{
					wait local.warning_time

					local.unbalanced_teams = waitthread check_teams
					if (local.unbalanced_teams > 0)
					{
						local.warning++
						if (local.warning > local.max_warning)
						{
							waitthread balance_teams

							local.warning = 0
						}
						else
						{
							if (local.unbalanced_teams == 1)
								local.team = "AXIS"
							else if (local.unbalanced_teams == 2)
								local.team = "ALLIES"

							iprintlnbold ( "Teams are unbalanced! Need more " + local.team + " players!" )
						}
					}
					else
						local.warning = 0
				}
			}
			else
			{
				if (local.warning > 0)
					local.warning = 0
			}
		}
		else
		{
			if (local.warning > 0)
				local.warning = 0
		}
	}

end

check_teams:

	local.allies_count = 0
	local.axis_count = 0

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.isplayer == 1 && local.player.dmteam != "spectator" )
		{
			if (local.player.dmteam == "allies")
				local.allies_count++
			else if (local.player.dmteam == "axis")
				local.axis_count++
		}
	}

	if (local.allies_count > local.axis_count + 1)
		end 1 // More allies players
	else if (local.axis_count > local.allies_count + 1)
		end 2 // More axis players

end 0 // Everything is ok

balance_teams:

	iprintlnbold ( "Balancing teams..." )

	wait 1

	local.unbalanced_teams = waitthread check_teams
	if (local.unbalanced_teams == 1)
	{
		local.team = "allies"
		local.join_team = "axis"
	}
	else if (local.unbalanced_teams == 2)
	{
		local.team = "axis"
		local.join_team = "allies"
	}

	if (local.team != NIL)
	{
		for (local.i = 1;local.i <= $player.size;local.i++)
		{
			local.player = $player[local.i]

			if ( local.player != NULL && local.player.isplayer == 1 && local.player.dmteam != "spectator" )
			{
				if (local.player.dmteam == local.team)
				{
					if (local.teammates == NIL)
						local.teammates[1] = local.player
					else
						local.teammates[local.teammates.size + 1] = local.player
				}
			}
		}

		if ( local.teammates != NIL && local.teammates.size > 1 )
		{
			local.pl = local.teammates[1]

			for (local.i = 2;local.i <= local.teammates.size;local.i++)
			{
				local.teammate = local.teammates[local.i]

				if (local.team == "allies")
				{
					if (local.teammate.allies_balance_number > local.pl.allies_balance_number)
						local.pl = local.teammate
				}
				else if (local.team == "axis")
				{
					if (local.teammate.axis_balance_number > local.pl.axis_balance_number)
						local.pl = local.teammate
				}
			}

			local.pl join_team local.join_team

			level.last_balanced_player = local.pl
			level.last_balanced_player.balanced_team = local.join_team

			if (local.join_team == "allies")
				local.t = "ALLIES"
			else if (local.join_team == "axis")
				local.t = "AXIS"

			local.pl iprint ( "You were forced to join the " + local.t + " team!!!" )
		}
	}

end

```

# zz_veersmods\global\AA\telefrag.scr

```scr
main:

	level waittill spawn

	while (1)
	{
		wait 5

		level.touched_players = 0

		for (local.i = 1;local.i <= $player.size;local.i++)
		{
			local.player = $player[local.i]

			if ( local.player != NULL && local.player.player_spawned == 1 )
			{
				for (local.i = 1;local.i <= $player.size;local.i++)
				{
					local.player2 = $player[local.i]

					if ( local.player2 != NULL && local.player2.player_spawned == 1 )
					{
						if ( local.player2 != local.player && local.player istouching local.player2 )
							level.touched_players++
					}
				}
			}
		}

		if (level.touched_players >= 3)
		{
			stuffsrv "say Attention! ANTI-TELEFRAG SYSTEM ACTIVATED!!!"

			for (local.i = 1;local.i <= $player.size;local.i++)
			{
				local.player = $player[local.i]

				if ( local.player != NULL && local.player.player_spawned == 1 )
				{
					local.player respawn
				}
			}
		}
	}

end

/*
telefrag:

	wait .5

	while ( self != NULL && self.spawnprotected == 1 )
		waitframe

	if ( self == NULL || self.player_spawned != 1 )
		end

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.player_spawned == 1 && local.player != self )
		{
			if (self istouching local.player)
			{
				stuffsrv "say Attention! ANTI-TELEFRAG SYSTEM ACTIVATED!!!"
				conprintf ( "ANTI-TELEFRAG SYSTEM: " + (netname self) + " spawned on " + (netname local.player) + "!\n" )

				self thread respawn_player

				end
			}
		}
	}

end

respawn_player:

	self iprint "You were respawned by the system because of the telefrag crash."
	self respawn

end
*/

```

# zz_veersmods\global\AA\trace.scr

```scr
main local.startpos local.endpos local.pass_entity local.vector_mins local.vector_maxs local.mask:

	if ( local.vector_mins == NIL || local.vector_mins == NULL )
		local.vector_mins = ( -1 -1 -1 )

	if ( local.vector_maxs == NIL || local.vector_maxs == NULL )
		local.vector_maxs = ( 1 1 1 )

	if ( local.pass_entity == NIL || local.pass_entity == NULL )
		local.pass_entity = 0

	if (local.pass_entity < 0)
		local.pass_entity = 0

	if ( local.mask == NIL || local.mask == NULL )
		local.mask = 1

	local.traced = traced local.startpos local.endpos local.pass_entity local.vector_mins local.vector_maxs local.mask
	local.traced["surfacetype"] = waitthread surfacetypes local.traced["surfaceFlags"]
	local.traced["content"] = waitthread contents local.traced["contents"]

end local.traced

surfacetypes local.surfaceflag:

	switch (local.surfaceflag)
	{
		case "1":
			end "nodamage"
		break
		case "2":
			end "slick"
		break
		case "4":
			end "sky"
		break
		case "8":
			end "ladder"
		break
		case "16":
			end "noimpact"
		break
		case "32":
			end "nomarks"
		break
		case "64":
			end "castshadow"
		break
		case "8192":
			end "paper"
		break
		case "16384":
			end "wood"
		break
		case "32768":
			end "metal"
		break
		case "65536":
			end "stone"
		break
		case "131072":
			end "dirt"
		break
		case "262144":
			end "metalgrill"
		break
		case "524288":
			end "grass"
		break
		case "1048576":
			end "mud"
		break
		case "2097152":
			end "puddle"
		break
		case "4194304":
			end "glass"
		break
		case "8388608":
			end "gravel"
		break
		case "16777216":
			end "sand"
		break
		case "33554432":
			end "foliage"
		break
		case "67108864":
			end "snow"
		break
		case "134217728":
			end "carpet"
		break
		case "268435456":
			end "backside"
		break
		case "536870912":
			end "nodlight"
		break
		case "1073741824":
			end "hint"
		break
		case "65812":
			end "sky"
		break
		case "65696":
			end "sky"
		break
	}

end "none"

contents local.content:

	switch (local.content)
	{
		case "1":
			end "solid"
		break
		case "8":
			end "lava"
		break
		case "16":
			end "slime"
		break
		case "32":
			end "water"
		break
		case "64":
			end "fog"
		break
		case "32768":
			end "areaportal"
		break
		case "65536":
			end "playerclip"
		break
		case "131072":
			end "monsterclip"
		break
		case "262144":
			end "weaponclip"
		break
		case "1048576":
			end "shootableonly"
		break
		case "16777216":
			end "origin"
		break
		case "33554432":
			end "body"
		break
		case "67108864":
			end "corpse"
		break
		case "134217728":
			end "detail"
		break
		case "268435456":
			end "structural"
		break
		case "536870912":
			end "translucent"
		break
		case "1073741824":
			end "trigger"
		break
		case "2147483648":
			end "nodrop"
		break
	}

end "none"

/*
TRACE FUNCTIONS:

local.trace["allSolid"] - Integer : it tells wheter trace was inside of a solid object
local.trace["startSolid"] - Integer : it tells wheter trace started in solid object
local.trace["fraction"] - Float
local.trace["endPos"] - Vector : position where trace finished because it may finish before it reaches end point specified by caller when it hits object with specified mask before it reaches end point
local.trace["surfaceFlags"] - Integer
local.trace["shaderNum"] - Integer
local.trace["contents"] - Integer
local.trace["entityNum"] - Integer : entity number that was hit
local.trace["location"] - Integer
local.trace["entity"] - Entity : entity that was hit by the trace

Surface Flags:

SURF_NODAMAGE          1
SURF_SLICK                  2
SURF_SKY                     4
SURF_LADDER               8
SURF_NOIMPACT           16
SURF_NOMARKS            32
SURF_CASTSHADOW     64
SURF_PAPER                 8192
SURF_WOOD                 16384
SURF_METAL                 32768
SURF_STONE                 65536
SURF_DIRT                    131072
SURF_METALGRILL         262144
SURF_GRASS                 524288
SURF_MUD                     1048576
SURF_PUDDLE                2097152
SURF_GLASS                 4194304
SURF_GRAVEL               8388608
SURF_SAND                  16777216
SURF_FOLIAGE              33554432
SURF_SNOW                 67108864
SURF_CARPET               134217728
SURF_BACKSIDE            268435456
SURF_NODLIGHT            536870912
SURF_HINT                    1073741824

Masks:

MASK_SOLID                        1 (collision)

MASK_COLLISION                    637537057 ( collision (except the m5l2a), solid )
MASK_PERMANENTMARK                1073741825
MASK_AUTOCALCLIFE                1073750049
MASK_EXPLOSION                    1074003969 (collision)
MASK_TREADMARK                    1107372801 (collision, solid)
MASK_THIRDPERSON                1107372857
MASK_FOOTSTEP                    1107437825
MASK_BEAM                        1107569409
MASK_VISIBLE                    1107569409
MASK_VEHICLE                    1107569409
MASK_BULLET                        1107569441
MASK_SHOT                        1107569569
MASK_CROSSHAIRSHADER            1107897089
MASK_TRACER                        1108618017

Contents:

CONTENTS_SOLID			1
CONTENTS_LAVA			8
CONTENTS_SLIME			16
CONTENTS_WATER			32
CONTENTS_FOG			        64
CONTENTS_AREAPORTAL		32768
CONTENTS_PLAYERCLIP		65536
CONTENTS_MONSTERCLIP	        131072
CONTENTS_WEAPONCLIP		262144
CONTENTS_SHOOTABLEONLY	1048576
CONTENTS_ORIGIN			16777216
CONTENTS_BODY			33554432
CONTENTS_CORPSE			67108864
CONTENTS_DETAIL			134217728
CONTENTS_STRUCTURAL		268435456
CONTENTS_TRANSLUCENT	        536870912
CONTENTS_TRIGGER                 1073741824
CONTENTS_NODROP                  2147483648
*/

```

# zz_veersmods\global\AA\vehicle_damage.scr

```scr
main local.target local.inflictor local.damage local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location:

	local.vehicle = self
	if ( self.classname == "VehicleCollisionEntity" || self.classname == "VehicleTurretGun" || self.classname == "ScriptSlave" )
	{
		if (self.vehicle)
			local.vehicle = self.vehicle
	}

	if (local.vehicle.nodamage == 1)
		end

	if (local.vehicle.destroyed == 1)
		end

	if (local.vehicle.istank == 1)
	{
		if ( local.meansofdeath == 14 || local.meansofdeath == 18 || local.meansofdeath == 19 || local.meansofdeath == 20 || local.meansofdeath == 27 )
			end // Default immunes
	}

	if ( local.vehicle.immunities != NIL && local.vehicle.immunities != NULL )
	{
		for (local.i = 1;local.i <= local.vehicle.immunities.size;local.i++)
		{
			local.num = NULL
			switch (local.vehicle.immunities[local.i])
			{
				case "none":
					local.num = 0
				break
				case "suicide":
					local.num = 1
				break
				case "crush":
					local.num = 2
				break
				case "crush_every_frame":
					local.num = 3
				break
				case "telefrag":
					local.num = 4
				break
				case "lava":
					local.num = 5
				break
				case "slime":
					local.num = 6
				break
				case "falling":
					local.num = 7
				break
				case "last_self_inflicted":
					local.num = 8
				break
				case "explosion":
					local.num = 9
				break
				case "explodewall":
					local.num = 10
				break
				case "electric":
					local.num = 11
				break
				case "electricwater":
					local.num = 12
				break
				case "thrownobject":
					local.num = 13
				break
				case "grenade":
					local.num = 14
				break
				case "beam":
					local.num = 15
				break
				case "rocket":
					local.num = 16
				break
				case "impact":
					local.num = 17
				break
				case "bullet":
					local.num = 18
				break
				case "fast_bullet":
					local.num = 19
				break
				case "vehicle":
					local.num = 20
				break
				case "fire":
					local.num = 21
				break
				case "flashbang":
					local.num = 22
				break
				case "on_fire":
					local.num = 23
				break
				case "gib":
					local.num = 24
				break
				case "impale":
					local.num = 25
				break
				case "bash":
					local.num = 26
				break
				case "shotgun":
					local.num = 27
				break
			}

			if ( local.num != NULL && local.meansofdeath == local.num )
				end
		}
	}

	local.damage_multiplier = 1.0
	if (local.vehicle.istank == 1)
		local.damage_multiplier = local.vehicle waitthread check_damage_location local.normal

	local.dmg = local.damage * local.damage_multiplier

	local.gt = int ( getcvar "g_gametype" )
	local.td = int ( getcvar "g_teamdamage" )

	if ( local.inflictor != NIL && local.inflictor != NULL )
	{
		local.attacker = local.inflictor

		if ( local.gt == 1 || ( local.gt > 1 && local.td == 1 ) || ( local.gt > 1 && local.td != 1 && local.vehicle.mpteam && local.vehicle.mpteam != local.attacker.dmteam ) )
		{
			if (level.vehicle_spawnkill == 1)
			{
				if ( local.gt != 1 && local.vehicle.istank == 1 && local.vehicle.mpteam == "neutral" )
				{
					if ( local.vehicle.dmteam == "allies" && local.attacker.dmteam == "allies" )
					{
						if (local.vehicle istouching level.allies_vehicle_spawnkill_trigger)
							end
					}
					else if ( local.vehicle.dmteam == "axis" && local.attacker.dmteam == "axis" )
					{
						if (local.vehicle istouching level.axis_vehicle_spawnkill_trigger)
							end
					}
				}
			}

			local.vehicle.last_attacker = local.attacker
			local.vehicle.fakehealth -= local.dmg

			if ( local.vehicle.mpteam != "neutral" && local.vehicle.mpteam != local.attacker.dmteam )
			{
				if (local.attacker.playerextras == 1)
					local.attacker playsound hitsound

				if (local.vehicle.istank == 1)
					local.attacker thread global/AA/reward_store.scr::give_cash 5
			}

			if (local.vehicle.fakehealth <= 0)
			{
				local.vehicle takedamage
				local.vehicle removeimmune none
				local.vehicle normal_damage 10000

				end
			}

			if ( local.vehicle.driver != NIL && local.vehicle.driver != NULL )
			{
				local.vehicle thread update_vehicle_health_hud local.vehicle.driver
				local.vehicle.driver damage local.vehicle.last_attacker 0 local.vehicle.last_attacker ( 0 0 0 ) ( 0 0 0 ) ( 0 0 0 ) 0 0 9 0
			}

			if ( local.vehicle.gunner != NIL && local.vehicle.gunner != NULL )
			{
				local.vehicle thread update_vehicle_health_hud local.vehicle.gunner
				local.vehicle.gunner damage local.vehicle.last_attacker 0 local.vehicle.last_attacker ( 0 0 0 ) ( 0 0 0 ) ( 0 0 0 ) 0 0 9 0
			}
		}
	}

end

check_damage_location local.normal:

	local.yaw = self.angles[1]
	local.x = local.normal[0]
	local.y = local.normal[1]
	local.location = "side"
	local.damage_multiplier = 1.0

	if ( local.yaw == 0.000 || local.yaw == 90.000 || local.yaw == 180.000 || local.yaw == 270.000 )
	{
		switch (local.yaw)
		{
			case "0.000":
				if ( local.x > 0.000 && local.y == 0.000 )
					local.location = "front"
				else if ( local.x < 0.000 && local.y == 0.000 )
					local.location = "back"
			break
			case "90.000":
				if ( local.x == -0.000 && local.y > 0.000 )
					local.location = "front"
				else if ( local.x == 0.000 && local.y < 0.000 )
					local.location = "back"
			break
			case "180.000":
				if ( local.x < 0.000 && local.y == -0.000 )
					local.location = "front"
				else if ( local.x > 0.000 && local.y == 0.000 )
					local.location = "back"
			break
			case "270.000":
				if ( local.x == 0.000 && local.y < 0.000 )
					local.location = "front"
				else if ( local.x == -0.000 && local.y > 0.000 )
					local.location = "back"
			break
		}
	}
	else
	{
		if ( local.yaw > 0.000 && local.yaw < 90.000 )
		{
			if ( local.x > 0.000 && local.y > 0.000 )
				local.location = "front"
			else if ( local.x < 0.000 && local.y < 0.000 )
				local.location = "back"
		}
		else if ( local.yaw > 90.000 && local.yaw < 180.000 )
		{
			if ( local.x < 0.000 && local.y > 0.000 )
				local.location = "front"
			else if ( local.x > 0.000 && local.y < 0.000 )
				local.location = "back"
		}
		else if ( local.yaw > 180.000 && local.yaw < 270.000 )
		{
			if ( local.x < 0.000 && local.y < 0.000 )
				local.location = "front"
			else if ( local.x > 0.000 && local.y > 0.000 )
				local.location = "back"
		}
		else if ( local.yaw > 270.000 && local.yaw < 360.000 )
		{
			if ( local.x > 0.000 && local.y < 0.000 )
				local.location = "front"
			else if ( local.x < 0.000 && local.y > 0.000 )
				local.location = "back"
		}
	}

	switch (local.location)
	{
		case "front":
			local.damage_multiplier = randomfloat 0.2
			local.damage_multiplier += 0.4
		break
		case "back":
			local.damage_multiplier = 1.5
		break
		case "side":
			local.damage_multiplier = randomfloat 0.3
			local.damage_multiplier += 0.9
		break
	}

end local.damage_multiplier

vehicle_health_hud local.player:

	if (local.player == NULL)
		end

	local.player stufftext "globalwidgetcommand dday1 menu dday1 128 283 NONE 1"
	local.player stufftext "globalwidgetcommand dday1 shader townhallwindow"
	local.player stufftext "globalwidgetcommand dday1 fgcolor 1.00 1.00 1.00 1.00"
	local.player stufftext "globalwidgetcommand dday1 bgcolor 0.50 0.50 0.50 0.00"
	local.player stufftext "globalwidgetcommand dday1 align left bottom"
	local.player stufftext "globalwidgetcommand dday1 fadein 0"

	local.player stufftext "globalwidgetcommand june6 borderstyle NONE"
	local.player stufftext "globalwidgetcommand june6 shader textures/hud/healthback"
	local.player stufftext "globalwidgetcommand june6 rect 16 283 16 64"
	local.player stufftext "globalwidgetcommand june6 fgcolor 1.00 1.00 1.00 1.00"
	local.player stufftext "globalwidgetcommand june6 bgcolor 0.00 0.00 0.00 0.00"
	local.player stufftext "globalwidgetcommand june6 linkcvar vehiclehealth"
	local.player stufftext ( "globalwidgetcommand june6 statbar vertical 0 " + self.maxhealth )
	local.player stufftext "globalwidgetcommand june6 statbar_shader textures/hud/healthmeter"
	local.player stufftext "globalwidgetcommand june6 statbar_shader_flash textures/hud/healthmeterflash"
	local.player stufftext "globalwidgetcommand june6 ordernumber 0"

	local.player stufftext "ui_addhud dday1"
	local.player stufftext ( "set vehiclehealth " + self.fakehealth )

	ihuddraw_align local.player 40 left bottom
	ihuddraw_rect local.player 40 40 -172 0 0
	ihuddraw_color local.player 40 0.70 0.60 0.05
	ihuddraw_font local.player 40 "facfont-20"
	ihuddraw_string local.player 40 "Vehicle Health"
	ihuddraw_virtualsize local.player 40 0
	ihuddraw_alpha local.player 40 1

	local.perc = int ( (self.fakehealth / self.maxhealth) * 100 )
	if (local.perc < 1)
		local.perc = 1

	ihuddraw_align local.player 41 left bottom
	ihuddraw_rect local.player 41 40 -149 0 0
	ihuddraw_color local.player 41 0.70 0.60 0.05
	ihuddraw_font local.player 41 "facfont-20"
	ihuddraw_string local.player 41 local.perc
	ihuddraw_virtualsize local.player 41 0
	ihuddraw_alpha local.player 41 1

end

update_vehicle_health_hud local.player:

	local.player stufftext ( "set vehiclehealth " + self.fakehealth )

	local.perc = int ( (self.fakehealth / self.maxhealth) * 100 )
	if (local.perc < 1)
		local.perc = 1

	ihuddraw_string local.player 41 local.perc

end

remove_vehicle_health_hud:

	self stufftext "ui_removehud dday1"

	ihuddraw_alpha self 40 0
	ihuddraw_alpha self 41 0

end

```

# zz_veersmods\global\AA\vehicle_fixes.scr

```scr
vehicle_camera:

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player != self && local.player.isplayer == 1 && local.player.player_spawned == 1 && local.player.inveh == 1 )
			local.player.forced_cueplayer = 1
	}

end

vehicle_spawnkill:

	local.mapname = getcvar "mapname"
	level.vehicle_spawnkill = 0

	switch (local.mapname)
	{
		case "m1l3a":
			local.allies_origin = ( 1788 -7715 -172 )
			local.allies_size1 = ( -1300 0 0 )
			local.allies_size2 = ( 2500 4000 410 )

			local.axis_origin = ( 3891 -1813 -276 )
			local.axis_size1 = ( 0 0 0 )
			local.axis_size2 = ( 3800 4700 1100 )

			level.vehicle_spawnkill = 1
		break
		case "m1l3b":
			local.allies_origin = ( -2715 -7565 -49 )
			local.allies_size1 = ( 0 0 0 )
			local.allies_size2 = ( 4400 3000 800 )

			local.axis_origin = ( 7670 8142 -121 )
			local.axis_size1 = ( -3000 -5100 0 )
			local.axis_size2 = ( 0 0 880 )

			level.vehicle_spawnkill = 1
		break
		case "m4l0":
			local.allies_origin = ( -1689 -4509 -286 )
			local.allies_size1 = ( -5000 0 0 )
			local.allies_size2 = ( 0 4000 1200 )

			local.axis_origin = ( -5446 1016 -350 )
			local.axis_size1 = ( 0 0 0 )
			local.axis_size2 = ( 4100 7300 1200 )

			level.vehicle_spawnkill = 1
		break
		case "m4l1":
			local.allies_origin = ( -4375 -4413 -485 )
			local.allies_size1 = ( 0 -2600 0 )
			local.allies_size2 = ( 3500 0 640 )

			local.axis_origin = ( 2745 2510 171 )
			local.axis_size1 = ( 0 0 0 )
			local.axis_size2 = ( 2300 2900 720 )

			level.vehicle_spawnkill = 1
		break
		case "m4l3":
			local.allies_origin = ( -6733 -8169 -383 )
			local.allies_size1 = ( 0 0 0 )
			local.allies_size2 = ( 5000 4300 900 )

			local.axis_origin = ( 3859 -2093 -17 )
			local.axis_size1 = ( -3550 0 0 )
			local.axis_size2 = ( 0 3330 600 )

			level.vehicle_spawnkill = 1
		break
		case "m5l2a":
			local.allies_origin = ( 1090 -5965 31 )
			local.allies_size1 = ( 0 0 0 )
			local.allies_size2 = ( 2650 4800 600 )

			local.axis_origin = ( -8394 7472 138 )
			local.axis_size1 = ( 0 -2000 0 )
			local.axis_size2 = ( 3300 0 340 )

			level.vehicle_spawnkill = 1
		break
		case "m5l3":
			local.allies_origin = ( 1970 5599 137 )
			local.allies_size1 = ( -600 -100 0 )
			local.allies_size2 = ( 2100 1000 400 )

			local.axis_origin = ( -1520 -2245 212 )
			local.axis_size1 = ( 0 0 0 )
			local.axis_size2 = ( 2400 2700 550 )

			level.vehicle_spawnkill = 1
		break
	}

	if (level.vehicle_spawnkill != 1)
		end

	level.allies_vehicle_spawnkill_trigger = spawn trigger_vehicle
	level.allies_vehicle_spawnkill_trigger.origin = local.allies_origin
	level.allies_vehicle_spawnkill_trigger setsize local.allies_size1 local.allies_size2

	level.axis_vehicle_spawnkill_trigger = spawn trigger_vehicle
	level.axis_vehicle_spawnkill_trigger.origin = local.axis_origin
	level.axis_vehicle_spawnkill_trigger setsize local.axis_size1 local.axis_size2

end

veh_coll:

	local.gt = int ( getcvar "g_gametype" )
	local.td = int ( getcvar "g_teamdamage" )

	for (local.i = 1;local.i <= $vezetheto_jarmu.size;local.i++)
	{
		local.jarmu = $vezetheto_jarmu[local.i]
		if ( local.jarmu != NULL && local.jarmu.fakehealth > 0 && local.jarmu.isturret != 1 )
		{
			local.surface = local.jarmu
			if (local.jarmu.collisionent)
				local.surface = local.jarmu.collisionent

			if ( self.inveh != 1 && vector_length ( self.origin - local.jarmu.origin ) < 300 && local.jarmu.speed != 0.0 )
			{
				if ( local.gt != 1 && local.td != 1 && self.dmteam == local.jarmu.mpteam )
				{
					if (local.jarmu.istank == 1)
						local.startpos = self.origin + ( 0 0 45 )
					else
						local.startpos = self.origin + ( 0 0 15 )

					local.angles = vector_toangles ( local.jarmu.origin - local.startpos )
					local.endpos = local.startpos + angles_toforward ( 0 local.angles[1] 0 ) * 50

					local.traced = waitexec global/AA/trace.scr local.startpos local.endpos self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107372801
					if (local.traced["entityNum"] == local.surface.entnum)
					{
						local.angles = vector_toangles ( self.origin - local.jarmu.origin )
						self.origin += ( 0 0 60 )

						local.speed = local.jarmu.speed * 2.5
						if (local.speed > 900.0)
							local.speed = 900.0

						if (local.jarmu.speed > 0.0)
							self.velocity = angles_toforward ( -30 local.angles[1] 0 ) * local.speed
						else if (local.jarmu.speed < 0.0)
							self.velocity = angles_toforward ( -150 local.angles[1] 0 ) * local.speed

						end
					}
				}
			}
		}
	}

end

```

# zz_veersmods\global\AA\vehicle_lights.scr

```scr
corona local.tag local.offset:

	local.fl = NULL
	for (local.i = 1;local.i <= 2;local.i++)
	{
		local.flare = spawn script_model
		local.flare model "models/fx/searchlight.tik"
		local.flare.scale = 1.0
		local.flare notsolid
		local.flare hide

		local.flare attach self local.tag 0 local.offset

		if ( self.headlights == NIL || self.headlights == NULL )
			self.headlights[1] = local.flare
		else
			self.headlights[self.headlights.size + 1] = local.flare

		if (local.fl == NULL)
			local.fl = local.flare
	}

	local.light = spawn script_model model "models/fx/dummy.tik"
	local.light notsolid
	local.light light ( 1.0 1.0 1.0 )
	local.light lightRadius 200
	local.light lightOff
	local.light.flare = local.fl

	if ( self.flare_light == NIL || self.flare_light == NULL )
		self.flare_light[1] = local.light
	else
		self.flare_light[self.flare_light.size + 1] = local.light

end

```

# zz_veersmods\global\AA\vehicle_physics.scr

```scr
vehicle_physics:

	local.origin = self.origin

	local.pitch = self.angles[0]
	if (local.pitch > 180.0)
	{
		local.pitch -= 360.0
		local.pitch = abs local.pitch
	}
	else
		local.pitch -= local.pitch + local.pitch

	local.sinalfa = waitthread global/AA/math.scr::sin local.pitch
	local.cosalfa = waitthread global/AA/math.scr::cos local.pitch
	local.tanalfa = waitthread global/AA/math.scr::tan local.pitch

	local.se = 0.06
	if (self.istank == 1)
		local.se = 0.09

	local.gravity = (9.81 * 100) / 1.905

	local.Fsuly = self.mass * local.gravity
	local.Fny = local.Fsuly * local.cosalfa
	local.Fsurl = local.Fny * local.se
	local.Feredo = (local.Fsuly * local.sinalfa) - local.Fsurl
	local.a = local.Feredo / self.mass

	local.stop = 0

	if (self.driver != NULL)
	{
		if (self.driver.keyheld[ELORE] == 1)
		{
			if (self.speed < self.vehiclespeed)
			{
				if (self.speed < 0.0)
					self.speed = self.speed + self.acceleration * 0.1
				else
					self.speed = self.speed + self.acceleration * 0.05

				if (self.speed > self.vehiclespeed)
					self.speed = self.vehiclespeed
			}
		}
		else if (self.driver.keyheld[HATRA] == 1)
		{
			if ( self.speed > (self.vehiclespeed / 2.0) * -1.0 )
			{
				if (self.speed > 0.0)
					self.speed = self.speed - self.acceleration * 0.1
				else
					self.speed = self.speed - self.acceleration * 0.05

				if ( self.speed < (self.vehiclespeed / 2.0) * -1.0 )
					self.speed = (self.vehiclespeed / 2.0) * -1.0
			}
		}
		else
			local.stop = 1

		if (self.istank != 1)
		{
			if (self.driver.keyheld[BALRA] == 1)
			{
				self.wheel += self.turnrate
				if (self.wheel > self.wheel_max)
					self.wheel = self.wheel_max
			}
			else if (self.driver.keyheld[JOBBRA] == 1)
			{
				self.wheel -= self.turnrate
				if (self.wheel < -self.wheel_max)
					self.wheel = -self.wheel_max
			}
			else
			{
				if (self.wheel > 0.0)
				{
					self.wheel -= self.turnrate
					if (self.wheel < 0.0)
						self.wheel = 0.0
				}
				else if (self.wheel < 0.0)
				{
					self.wheel += self.turnrate
					if (self.wheel > 0.0)
						self.wheel = 0.0
				}
			}
			
		}
	}
	else
		local.stop = 1

	if ( local.stop == 1 && self.speed != 0.0 )
	{
		if (self.speed > 0.0)
		{
			self.speed -= self.acceleration * 0.05
			if (self.speed < 0.0)
				self.speed = 0.0
		}
		else if (self.speed < 0.0)
		{
			self.speed += self.acceleration * 0.05
			if (self.speed > 0.0)
				self.speed = 0.0
		}
	}

	waitframe

	local.dist = vector_length ( local.origin - self.origin )
	local.speed_frame = abs self.speed / 20.0
	if ( local.speed_frame - local.dist > 5.0 )
	{
		self.speed -= self.speed + self.speed
		self.speed = self.speed / 2.0
	}

	if (self.istank != 1)
	{
		if (self.wheel == 0.0)
			local.r = 0.0
		else
		{
			local.alfa = abs self.wheel
			local.beta = 180.0 - (90.0 + local.alfa)
			local.sinalfa = waitthread global/AA/math.scr::sin local.alfa
			local.sinbeta = waitthread global/AA/math.scr::sin local.beta
			local.r = (self.wheel_base / 2.0) / (local.sinalfa / local.sinbeta)
			local.r += (self.track / 2.0)
		}

		if (local.r != 0.0)
		{
			local.teta = (self.speed * 0.05) / local.r
			local.alfa = (180.0 - local.teta) / 2.0
			local.alfa = (90.0 - local.alfa) * 20.0

			if (self.wheel < 0.0)
				local.alfa = local.alfa * -1.0

			local.alfa = local.alfa * 1.2
			self.angles = ( self.angles[0] (self.angles[1] + local.alfa) self.angles[2] )
		}
	}

	self.velocity = self.forwardvector * self.speed

end

```

# zz_veersmods\global\AA\vehicle_respawn.scr

```scr
main local.origin local.angles local.size1 local.size2:

	local.check_respawn = spawn script_object origin local.origin
	local.check_respawn setsize local.size1 local.size2
	local.check_respawn.angles = local.angles
	local.check_respawn notsolid

	local.respawn_done = 0

	while (local.respawn_done != 1)
	{
		wait 1

		local.respawn_done = 1

		for (local.i = 1;local.i <= $player.size;local.i++)
		{
			local.player = $player[local.i]

			if ( local.player != NULL && local.player.player_spawned == 1 )
			{
				if (local.player istouching local.check_respawn)
				{
					local.respawn_done = 0
					break
				}
			}
		}

		if (local.respawn_done == 1)
		{
			for (local.i = 1;local.i <= $vezetheto_jarmu.size;local.i++)
			{
				local.vehicle = $vezetheto_jarmu[local.i]

				if (local.vehicle != NULL)
				{
					if (local.vehicle istouching local.check_respawn)
					{
						local.respawn_done = 0
						break
					}
				}
			}
		}
	}

	local.check_respawn remove

end

```

# zz_veersmods\global\AA\vehicles_thinkers.scr

```scr
//*******************************
players_tank local.trigger:
//	self vehiclespeed 300
	self rendereffects "-shadow"
	local.parent = spawn script_origin
	local.parent.origin = self.origin
	level.playertanktarget = spawn script_origin
	level.playertanktarget.origin = (self.origin + (0 0 80))
	level.playertanktarget bind local.parent
	local.parent glue self

		
	self removeondeath 0
	if (self.target)
	{
		self.collisionent = self.target
	//	self.collisionent hide
	}	
	local.gun = self QueryTurretSlotEntity 0
	local.gun2 = self QueryTurretSlotEntity 1
	if (local.gun)
		local.gun nodamage
	if (local.gun2)
		local.gun2 nodamage

	thread player_tank_health
end

player_tank_health:
	level waittill prespawn
	
	
	if (getcvar(debug) != "1")
	{
		$player notsolid
		$player nodamage
		self attachdriverslot 0 $player
		$player perferredweapon "88mm Tank Gun"
	}

	level waittill spawn
	
	local.skill = getcvar (skill)
	println "z:       local.skill = getcvar (skill) = " local.skill   
	
	if (local.skill == "2")
	{
		println "z:         skill = 2 health = 1000"
		self.health = 1000
	}
	if (local.skill == "1")
	{
		println "z:         skill = 1 health = 3000"
		self.health = 3000
	}
	if ( (local.skill != "1") && (local.skill != "2") )
	{
		println "z:         skill != 2 and skill != 1 health = 5000"
		self.health = 5000
	}


//		if ( (int (getcvar developer)) )
//			thread playertank_health_hud
		thread playertank_pain



	self waittill death

		self LockMovement
		self playsound explode_tank
		level.missionfailed = 1
		iprintlnbold "The King Tiger Tank has been lost, you have failed."
		//wait 3
		missionfailed
	end

playertank_pain:
		local.original_health = self.health
		local.previoushealth = self.health
		local.paintime = level.time
	
		while(isAlive self)
		{
			wait .1
			if (self.health < local.previoushealth)
			{
				self playsound damage_tank
				exec global/earthquake.scr .2 4 0 0	
		
				if ( (self.health < (local.previoushealth - 150)) && (level.time > (local.paintime + 5) ) )
				{
					local.paintime = level.time
					local.health_fraction = (self.health / local.original_health)
					println "z:     local.health_fraction: " local.health_fraction
					
					if (local.health_fraction >= 0.7)
					{
						$player playsound tank_hurt1
					}
					else if (local.health_fraction >= 0.4)
					{
						$player playsound tank_hurt2
					}
					else
					{
						$player playsound tank_hurt3
					}
				}
				
				local.previoushealth = self.health
			}
		}
	end


playertank_health_hud:
		level.subtitleX = 100
		level.subtitleY = 70
		while ( 1)
		{
			locprint level.subtitleX level.subtitleY ("Health: " + self.health)
			wait 1
		}
	end


//*****************************************
PLAYER_JEEP_CONTROLLER local.trigger:
	self vehicleanim remove_surfaces
	self rendereffects "-shadow"
	self thread speed_controls
	self.driver rendereffects "-shadow"
	self AttachDriverSlot 0 $oss_man
	$oss_man exec global/disable_ai.scr
	$oss_man anim jeep_idle_drive
	$oss_man nodamage
	$oss_man notsolid
	$oss_man gun "none"
	$oss_man immune bullet
	$oss_man immune fast_bullet
	$oss_man immune explosion
	$oss_man immune rocket
	$oss_man.gren_awareness = 0
	$oss_man forceactivate
	self nodamage
	if (self.target)
	{
		self.collisionent = self.target
	//	self.collisionent hide
	}

	//local.trigger waittill trigger
	
	if (getcvar(debug) != "1")
	{
		local.vturretent = self queryturretslotentity 0
		local.vturretent unlock
		self attachturretslot 0 $player    // Attach the player to the jeep
		$player perferredweapon ".30cal Machine Gun"
		local.vturretent lock
	}
	
//level waittill spawn


//	if ( (int (getcvar developer)) )
//		thread speed_tracker
end


speed_tracker:
		level.subtitleX = 100
		level.subtitleY = 70
		while ( 1)
		{
			local.speed = vector_length(self.velocity)
			local.message = ("speed: " + local.speed)
			locprint level.subtitleX level.subtitleY local.message
			wait .5
		}
	end

speed_controls:
		for ( local.i = 1; local.i <= $slowdown.size; local.i++)
		{
			thread slowdown local.i
		}
		for ( local.i = 1; local.i <= $speedup.size; local.i++)
		{
			thread speedup local.i
		}
	end

speedup local.i:
		while (1)
		{
			if ($speedup[local.i].speed != NIL)
				local.speed = $speedup[local.i].speed
			else 
				local.speed = level.fastspeed
	
			println "z:      wait for trigger speedup: " local.i  " value " local.speed
			$speedup[local.i] waittill trigger
	
			println "z:      modify drive speedup: " local.i  " value " local.speed
			self.driver anim jeep_drive_gearchange_up
			self modifydrive local.speed 10 level.lookahead
			self.driver waittill animdone
			self.driver anim jeep_idle_drive
		}
	end

slowdown local.i:
		while (1)
		{
			if ($slowdown[local.i].speed != NIL)
				local.speed = $slowdown[local.i].speed
			else 
				local.speed = level.slowspeed

			println "z:      wait for trigger slowdown: " local.i  " value " local.speed
			$slowdown[local.i] waittill trigger
	
			println "z:      modify drive slowdown: " local.i  " value " local.speed
			self.driver anim jeep_drive_gearchange_down
			self modifydrive local.speed 40 level.lookahead
			self.driver waittill animdone
			self.driver anim jeep_idle_drive
		}
	end





//****************************************
enemy_truck_think local.hp local.passengers local.path local.trigger local.type local.guy_type local.special:
	self rendereffects "-shadow"
	if (local.hp == NIL)
		self.health = 4000
	else 
		self.health = local.hp
	println "truck health: " self.health
	thread truck_INIT
		
	if ( (local.passengers != NIL) && (local.passengers != 0) )
		waitthread truck_load local.passengers local.guy_type local.panzer
	if (local.path)
	{
		println "truck_drive thread initialized"
		thread truck_drive local.path local.trigger
	}
	
self waittill death

	self stop
	self.collisionent disconnect_paths
	thread truck_killed local.type
end

truck_drive local.path local.trigger:
if (local.trigger)
{
	println "truck waitting for trigger before driving"
	local.trigger waittill trigger
}

	local.speed = 200
	local.accel = 50
	local.lookahead = 256

	println "truck starting to drive"
	self drive local.path local.speed local.accel 200 local.lookahead
	self waitTill drive
	self.drive_done = 1
	self.collisionent disconnect_paths
	println "truck done with waittill drive"
	self stop
	
	wait 3
	println "truck starting to unload"
	thread truck_unload
end

truck_load local.passengers local.guy_type local.special:
	for (local.slot = 1; local.slot <= local.passengers; local.slot++)
	{
		if (local.guy_type == NIL)
			local.guy_type = "models/human/german_afrika_private"		
		if (randomint (3) == 1) 
			local.gun = "MP40"
		else
			local.gun = "Mauser KAR 98K"
		if ( (local.special == "panzer") && (local.slot == 1) )
			local.gun = "panzerschrek"
		local.guy = spawn local.guy_type "gun" local.gun
		local.guy.origin = self.origin
		local.guy rendereffects "-shadow"
		if (level.dontdropweapons == 1)
			local.guy dontdropweapons
		self AttachPassengerSlot local.slot local.guy
		local.guy type_attack "cover"
		local.guy leash 0
		//local.guy exec global/disable_ai.scr //temp
		local.guy fixedleash 1
		local.guy physics_off
		
		switch (local.slot)
		{
		case 1:
			local.guy exec global/setdeathanim.scr "death_headpistol"
			break
		case 2:
			local.guy exec global/setdeathanim.scr "death_crotch"
			break
		case 3:
			local.guy exec global/setdeathanim.scr "death_left"
			break
		case 4:
			local.guy exec global/setdeathanim.scr "death_run"
			break
		case 5:
			local.guy exec global/setdeathanim.scr "death_shoot"
			break
		case 6:
			local.guy exec global/setdeathanim.scr "death_right"
			break
		default:
			local.guy exec global/setdeathanim.scr "death_collapse"
			break
		}
		
		
		
	}
	//driving anim name = opel_driver	
	local.driver = spawn local.guy_type "gun" "none"
	local.driver.origin = self.origin
	local.driver rendereffects "-shadow"
	self AttachDriverSlot 0 local.driver
	local.driver exec global/disable_ai.scr
	local.driver anim opel_driver
	self.driver = local.driver
	local.driver exec global/setdeathanim.scr "opel_driver_death"
end

truck_unload:
	for (local.slot = 0; local.slot <= 6; local.slot++)
	{
		thread truck_passenger_unload local.slot
	}
	local.driver = self.driver
//	self DetachDriverSlot 0 local.driver.origin
//	local.driver.origin = self gettagposition "driver"
//	local.driver.angles = self gettagangles "driver"
//	local.driver physics_on
	local.driver exec global/bullethit.scr (0 0 250) 500 0 1
	self.done_unloading = 1
end

truck_passenger_unload local.slot:
	local.ent = self QueryPassengerSlotEntity local.slot
	if !(isAlive local.ent)
		end
	if (local.ent == NULL)
		end
	local.ent exec global/disable_ai.scr
	self DetachPassengerSlot local.slot local.ent.origin
	local.tag = ("passenger" + local.slot)
	println "z:      local.tag: " local.tag
	local.ent.origin = self gettagposition local.tag
	local.ent.angles = self gettagangles local.tag
	local.ent notsolid
	local.ent physics_on
	local.ent anim_noclip ("opel_passenger" + local.slot)
	local.ent waittill animdone
	local.ent solid
	local.ent rendereffects "+shadow"
	local.ent leash 10000
	local.ent exec global/enable_ai.scr
	local.ent exec global/setdeathanim.scr NIL
	if (level.script == "maps/m1l3b.scr")
	{
		local.ent accuracy 30
	}
end

truck_INIT:
	self takedamage
	self solid
	self removeondeath 0
	
	if (self.nolights == 1)
		self vehicleanim idlenolights
	else
		self vehicleanim idlelights
	if (self.target)
	{
		self.collisionent = self.target
		//self.collisionent hide
	}
end

truck_killed local.type:
	self show
	
	self playsound explode_truck
	exec global/earthquake.scr .2 4 0 0	
	local.explosion1 = spawn script_model model models/fx/fx_truck_explosion.tik
	local.explosion1.origin = self gettagposition "engine1"
	local.explosion1.angles = self gettagangles "engine1"
	local.explosion1 anim start
	local.explosion1 notsolid

	wait .4
	
	self playsound explode_truck
	exec global/earthquake.scr .2 4 0 0	
	local.explosion2 = spawn script_model model models/fx/fx_truck_explosion.tik
	local.explosion2.origin = self gettagposition "engine2"
	local.explosion2.angles = self gettagangles "engine2"
	local.explosion2 anim start
	local.explosion2 notsolid

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		if($player[local.i] istouching self.collisionent)
		{
			$player[local.i] normal_damage 100
		}
	}
	
	//radiusdamage self.origin level.bomb_damage level.bomb_explosion_radius
	radiusdamage self.origin 200 200

//	if (local.type == "green")
//		self.damaged = thread spawn_damaged models/vehicles/opeltruckgreen_d.tik
//	else
//		self.damaged = thread spawn_damaged models/vehicles/opeltruck_d.tik
//	self hide
//	self notsolid
	self.collisionent disconnect_paths


	local.name = self
	local.angles = self.angles
	local.origin = self.origin
	local.brushmodel = self.collisionent.brushmodel
//	self remove
	self hide
	self notsolid
//	local.collision = thread damaged_collision local.angles local.origin local.brushmodel
	if (local.type == "green")
		self.damaged = thread spawn_damaged_new models/vehicles/opeltruckgreen_d.tik local.angles local.origin
	else
		self.damaged = thread spawn_damaged_new models/vehicles/opeltruck_d.tik local.angles local.origin	
//	local.collision disconnect_paths

	local.brushmodel = local.brushmodel
	local.collision = thread damaged_collision self.angles self.origin local.brushmodel
	local.collision disconnect_paths

	if (level.script == "maps/m1l3b.scr")
	{
		println "z:   in m1l3b. making truck not solid"
		self.collisionent remove
		self.damaged notsolid
		self notsolid
		while (self.done_unloading != 1)
			wait 1
		self.origin = (1952 376 80)
	}
	
	wait 10
	local.explosion1 remove
	local.explosion2 remove
end

//*****************************************
enemy_bike_think:
	self rendereffects "-shadow"
	self solid
	self.health = 100
	self takedamage
	self removeondeath 0 
	if (self.target)
	{
		self.collisionent = self.target
		//self.collisionent hide
	}

self waittill death	

	self show
	self playsound explode_bike
	
	self thread spawn_fx models/fx/fx_truck_explosion.tik
	//radiusdamage self.origin level.bomb_damage level.bomb_explosion_radius
	radiusdamage self.origin 200 200
	local.damaged = thread spawn_damaged models/vehicles/bmwbike_d.tik
	self remove
end





//**************************************
enemy_half-trak_think:
	self.mg42 = self QueryTurretSlotEntity 0 //mg42 setup
	local.gun = self.mg42
	if ($(self.gunner))
	{
		self AttachPassengerSlot 1 self.gunner //gunner positioning
		self.gunner nodamage
	}
	self rendereffects "-shadow"
	self immune bullet
	self immune fast_bullet
	self immune grenade
	self solid
	self.health = 100
	self takedamage
	self removeondeath 0
	if (self.target)
	{
		self.collisionent = self.target
		//self.collisionent hide
	}
	
self waittill death
	
//	self.collisionent disconnect_paths
	self show
	self playsound explode_tank
	self stop
	if (local.gun)
	{
		self DetachTurretSlot 0
		local.gun stopfiring
		local.gun remove
	}
	if ($(self.gunner))
	{
		self DetachPassengerSlot 1 self.gunner.origin
		self.gunner bedead
		self.gunner hide
		self.gunner notsolid
	}
	exec global/earthquake.scr .2 4 0 0
	//radiusdamage self.origin level.bomb_damage level.bomb_explosion_radius
	radiusdamage self.origin 200 200
	self thread spawn_fx models/fx/fx_tank_explosion.tik
//	local.damaged = thread spawn_damaged models/vehicles/sdkfz_green_d.tik
//	self remove

	local.name = self
	local.angles = self.angles
	local.origin = self.origin
	local.brushmodel = self.collisionent.brushmodel
	self hide
	self notsolid
	local.collision = thread damaged_collision local.angles local.origin local.brushmodel
	local.damaged = thread spawn_damaged_new models/vehicles/sdkfz_green_d.tik local.angles local.origin
	local.collision disconnect_paths
	
	wait .5
	if (self)
		self remove
end


//**************************************
enemy_flak_think:
	self rendereffects "-shadow"
	self solid
	self.health = 100
	self takedamage
	self removeondeath 0 
	if (self.target)
	{
		self.collisionent = self.target
		//self.collisionent hide
	}

level waittill spawn

while ( (level.playertanktarget == 0) || (level.playertanktarget == NIL) )
	wait 1

	if (level.sightdistance == NIL)
		level.sightdistance = 16000
	self setaimtarget level.playertanktarget
	thread enemy_flak_attack
	local.attack_thread = parm.previousthread

self waittill death	
	//self stopFiring
	self setaimtarget NULL
	self show
	self playsound explode_flak88 
	local.attack_thread delete	
	//radiusdamage self.origin level.bomb_damage level.bomb_explosion_radius
	radiusdamage self.origin 200 200	
	self thread spawn_fx models/fx/fx_tank_explosion.tik	
	local.damaged = thread spawn_damaged models/statweapons/flak88_d.tik
	self remove
end



enemy_flak_attack:
	while (isAlive self)
	{
		if !(vector_within level.playertanktarget.origin self.origin level.sightdistance)
		{		
		//	println "z:             " self " is not firing because of range"
			wait 1
		}
		else if (!(sighttrace level.playertanktarget.origin (self.origin + (0 0 64)) 1))
		{
		//	println "z:             " self " is not firing because of sight trace"
			wait 1
		}
		else
		{
			println "z:         " self " on target, waitting 3 secs to fire"
			wait 3
			self anim fire
			wait 3
		}
	}
end



//****************************************
enemy_tank_think local.notattacking local.type:

level waittill spawn

	self.type = local.type
	self rendereffects "-shadow"
	self.start_health = (((randomint 3) + 1) * 400)
	self.health = self.start_health
	self removeondeath 0
	println "z:          self.target " self.target 
	if (self.target)
	{
		self.collisionent = self.target
	//	self.collisionent hide
	}
	self.gun = self QueryTurretSlotEntity 0
	self.gun2 = self QueryTurretSlotEntity 1
	if (self.gun)
		self.gun nodamage
	if (self.gun2)
		self.gun2 nodamage
	if (level.sightdistance == NIL)
		level.sightdistance = 16000
	if (local.notattacking != 1)
	{
		while ( (level.playertanktarget == 0) || (level.playertanktarget == NIL) )
			wait 1
		self.gun setAimTarget level.playertanktarget
		thread enemy_tank_attack_loop self.gun
		self.attack_thread = parm.previousthread
		thread tank_pain self.gun
		self.pain_thread = parm.previousthread
	}

	thread tank_stop_if_close

self waittill death
	println "z:         " self " is dead. self.start_health: " self.start_health
	thread tank_killed
end

tank_stop_if_close:
	while ( (isAlive self) && !(vector_within self.origin $player.origin 450) )
	{
		wait 1
	//	println "z:         tank stop if close: " self " is not close"	
	}
	if !(isAlive self)
		end
	if (self.driving == 1)
		self stop
		println "z:         tank stop if close: " self " is close. stopping."
end

tank_killed:
	self playsound explode_tank
	self stop
	self.driving = 0

	if (self.attack_thread)
		self.attack_thread delete
	if (self.pain_thread)
		self.pain_thread delete
	println "z:          self.type: " self.type
	switch (self.type)
	{
	case empty_turretless_tiger:
		local.model = models/vehicles/tigertank_wot_d.tik
		break
	case panzer_desert:
		local.model = models/vehicles/panzer_iv_d.tik
		break
	case panzer:
		local.model = models/vehicles/panzer_iv_eud.tik
		local.get_out = 1
		local.anims[0] = panzer_exit_1
		local.anims[1] = panzer_exit_2
		local.anims[2] = panzer_exit_3
		break
	case empty_panzer_desert:
		local.model = models/vehicles/panzer_iv_d.tik
		break
	case empty_tiger:
		local.model = models/vehicles/tigertank_d.tik
		break
	default:
		local.model = models/vehicles/tigertank_d.tik
		local.get_out = 1
		local.anims[0] = tank_exit_1
		local.anims[1] = tank_exit_2
		local.anims[2] = tank_exit_3
		local.anims[3] = tank_exit_4
		break
	}
	self thread spawn_fx models/emitters/explosion_tank.tik
	exec global/earthquake.scr .2 4 0 0
	//radiusdamage self.origin level.bomb_damage level.bomb_explosion_radius
	radiusdamage (self.origin + (0 0 200)) 800 400
	wait .4   //wait for explosion fx to cover up the model swap
	self.gun = self QueryTurretSlotEntity 0
	self.gun2 = self QueryTurretSlotEntity 1
	if (self.gun)
	{
		self DetachTurretSlot 0
		self.gun remove
	}
	if (self.gun2)
	{
		self DetachTurretSlot 1
		self.gun2 remove
	}
	local.name = self
	local.angles = self.angles
	local.origin = self.origin
	local.brushmodel = self.collisionent.brushmodel
	self remove
	local.collision = thread damaged_collision local.angles local.origin local.brushmodel
	local.damaged = thread spawn_damaged_new local.model local.angles local.origin
	local.collision disconnect_paths
	if (local.get_out == 1)
		local.damaged thread tank_guys_get_out local.anims local.name
end

tank_guys_get_out local.anims local.name:
	wait 3
	if (self.state != "open")
	self anim open
	wait 1
	//self waittill animdone
	if (self.state != "open")
	{
		self anim open_idle
		self.state = "open"
	}
	
	//insert roberts random sorter here
	exec global/randomorder.scr local.anims
	
	for (local.i = 0; local.i < 4; local.i ++)
	{
		if ((randomint 100) <= 70)
		{
			if (local.anims[local.i]) 
			{
				waitthread tank_guy_spawn local.anims[local.i] local.name
			}
		}
	}
end

tank_guy_spawn local.type local.name:
	println "z:       spawning guy to get out " local.type

		local.temp = randomint 3
		if (local.temp == 0)
			local.model_type = human/german_panzer_grenadier
		if (local.temp == 1)
			local.model_type = human/german_panzer_obershutze
		if (local.temp == 2)
			local.model_type = human/german_panzer_tankcommander

		local.ent = spawn local.model_type
		local.ent.origin = self gettagposition "tag_start"
		local.ent.angles = self gettagangles "tag_start"
		
		local.ent noticescale 1
		local.ent sight 4500
		local.ent mindist 2024
		local.ent maxdist 2448
		local.ent leash 10000
		
		if (level.dontdropweapons == 1)
			local.ent dontdropweapons
		
		local.ent exec global/disable_ai.scr
		local.ent notsolid
		
	println "z:         starting anim: " local.name " " local.type
		local.ent anim_noclip local.type
		local.ent waittill animdone
	println "z:         ending   anim: " local.name " " local.type
		
		
		if ( (local.type == "tank_exit_2") || (local.type == "panzer_exit_2") )
			local.ent.position = "crawl"
		if ( (local.type == "tank_exit_3") || (local.type == "panzer_exit_3") )
			local.ent.health = 45 
		if (local.type == "tank_exit_4")
		{
			local.ent bedead
			end
		}
		
		wait .4
	println "z:         making solid: " local.name " " local.type
		
		local.ent solid
		
		
//		wait 3
	println "z:         enabling AI: " local.name " " local.type
		
		local.ent exec global/enable_ai.scr
		local.ent attackplayer
end


tank_pain local.gun:
	local.previoushealth = self.health
	local.timer = 0
	while(isAlive self)
	{
		wait .1
		if ( (isAlive self) && (self.health < local.previoushealth) )
		{
			println "z:         " self " is damaged. self.start_health: " self.start_health
			println "z:         current health: " self.health
			println "z:         " self " is stunned"
			self playsound damage_tank
			self.stunned = 1
			local.gun setAimTarget NULL
			
			if (self.driving == 1)
				self modifydrive 5 100 256
			if (self.driving_reverse == 1)
				self modifydrive -5 100 256
			
		//	self.smoke = spawn script_model model "models/emitters/linger_smoke.tik"
			self.smoke = spawn "models/emitters/linger_smoke.tik"
			self.smoke notsolid
			self.smoke anim start
			self.smoke.origin = (self.origin + (0 0 80))
			self.smoke glue self
			local.previoushealth = self.health
			local.timer = 0
		}
		
		
		if (local.timer == 80)
		{
			local.gun setAimTarget level.playertanktarget
			if (self.driving == 1)
				self modifydrive level.enemytankspeed 30 256
			if (self.driving_reverse == 1)
				self modifydrive level.enemytankspeed_reverse 30 256
			self.stunned = 0
			println "z:         " self " is no longer stunned"
		}
		local.timer++
	}
end

enemy_tank_attack_loop local.gun:    //self is the tank
	while (IsAlive self)
	{
		if (self.stunned == 1)
		{
			println "z:             " self " is not firing because stunned"
			wait 1
		}
		else if !(vector_within level.playertanktarget.origin self.origin level.sightdistance)
		{		
		//	println "z:             " self " is not firing because range"
			wait 1
		}
		else if (!(sighttrace level.playertanktarget.origin local.gun.origin 1))
		{
		//	println "z:             " self " is not firing because sight trace"
			wait 1
		}
		else
		{
			println "z:         " self " on target, waitting 3 secs to fire"
			wait 3
			if (self.stunned != 1)
				local.gun anim fire
			wait 2
		}
	}	
end




//local.collision = thread damaged_collision local.angles local.origin local.brushmodel
//local.damaged = thread spawn_damaged_new local.model local.angles local.origin
//----------------------------------
spawn_damaged local.model:
	local.damaged = spawn script_model model local.model
	local.damaged.origin = self.origin
	local.damaged.angles = self.angles
	local.damaged notsolid
end local.damaged

spawn_damaged_new local.model local.angles local.origin:
	local.damaged = spawn script_model model local.model
	local.damaged.origin = local.origin
	local.damaged.angles = local.angles
end local.damaged

spawn_fx local.fx:
	local.temp = spawn script_model model local.fx
	local.temp notsolid
	local.temp.origin = self.origin
	local.temp anim start
	local.temp notsolid
	wait 5
	local.temp remove
end

damaged_collision local.angles local.origin local.brushmodel:
	local.collision = spawn script_object model local.brushmodel
	local.collision.origin = local.origin
	local.collision.angles = local.angles
end local.collision
```

# zz_veersmods\global\AA\vezetheto_jeepek.scr

```scr
spawn_jeep local.origin local.angles local.coll:

	if ( local.origin == NIL || local.origin == NULL )
		end

	if ( local.angles == NIL || local.angles == NULL )
		local.angles = ( 0 0 0 )

	local.pos = local.origin + ( 0 0 10 )

	local.jeep = spawn "models/vehicles/jeep.tik" origin local.pos angles local.angles
	local.mg = local.jeep queryturretslotentity 0

	local.jeep hide
	local.mg hide

	waitframe

	local.jeep.origin = local.pos

	local.jeep show
	local.mg show

	local.jeep thread init_jeep local.coll local.origin

end

init_jeep local.coll local.origin:

	if ( local.origin == NIL || local.origin == NULL )
		local.origin = self.origin

	if ( local.coll && local.coll.brushmodel )
	{
		self.collisionent = local.coll

		self.collisionent.vehicle = self
		self.collisionent.isvehicle = 1
	}

	self.targetname = "vezetheto_jarmu"
	self.mpteam = "neutral"

	self lock
	self unlockmovement
	self removeondeath 0
	self takedamage

	self.mg = self queryturretslotentity 0

	self.mg lock
	self.mg notsolid

	self waitexec global/AA/immunities.scr

	local.immunities = crush::telefrag::explosion::bullet::fast_bullet::vehicle::bash::shotgun
	for (local.i = 1;local.i <= local.immunities.size;local.i++)
	{
		self.immunities[local.i] = local.immunities[local.i]
	}

	if (self.collisionent)
		self notsolid
	else
		self solid

	self.hasdriver = 0
	self.driver = NULL

	self.hasgunner = 0
	self.gunner = NULL

	self.isvehicle = 1
	self.destroyed = 0

	self.death_exp = self thread spawn_fx "models/emitters/explosion_tank.tik"

	self.mass = 1040.087 // kg
	self.health = 350.0
	self.vehiclespeed = 700.0
	self.acceleration = 314.961 // 6 m/s^2
	self.wheel_max = 25.0
	self.turnrate = 3.0
	self.wheel_base = (2032.0 / 10.0) / 1.905 // 2032 mm
	self.track = 80.0 // ~ 1.524 m
	self.lights = 0

	if ( self.collisionent == NIL || self.collisionent == NULL )
	{
		self setsize ( -96 -48 -1 ) ( 88 48 56 )
	}

	self.respawn_time = 40

	local.respawn_size1 = ( -126 -64 0 )
	local.respawn_size2 = ( 110 64 80 )

	self.max_tolteny = 250
	self.tolteny = self.max_tolteny
	self.tarhely = 250
	self.tolteny_tarban = 250
	self.firetime = 0.1

	self thread jeep_mg_properties

	self thread global/AA/vehicle_lights.scr::corona "Box01" ( 20 53 87 )
	self thread global/AA/vehicle_lights.scr::corona "Box01" ( -20 53 87 )

	self.speed = 0.0
	self.wheel = 0.0
	self.turnspeed = 0.0
	self.tuzelhet = 1

	self vehiclespeed 200.0
	self turnrate 0.0

	self.canhorn = 1

	self.maxhealth = self.health
	self.fakehealth = self.maxhealth

	self.entered = 1

	self thread jeep_funkciok local.coll local.origin self.angles local.respawn_size1 local.respawn_size2

	wait 1

	self.stop_org = spawn script_origin
	self.stop_org.origin = local.origin
	self.stop_org.angles = self.angles
	self.stop_org.glued = 0

	self.entered = 0

end

jeep_mg_properties:

	self.mg firetype bullet
	self.mg meansofdeath bullet

	self.mg bulletdamage 75
	self.mg bulletspread 25 25

	self.mg dmbulletdamage 75
	self.mg dmbulletspread 25 25

	self.mg pitchcaps "-25 12 0"
	self.mg yawcenter self.angle

	self.mg ammotype		"Fakeammo"
	self.mg usenoammo 		0
	self.mg ammorequired		1
	self.mg startammo		0
	self.mg clipsize		1
	self.mg ammo_in_clip		0

	self.mg dmammorequired		1
	self.mg dmstartammo		0

end

jeep_funkciok local.coll local.origin local.angles local.size1 local.size2:

	local.start_pos = self.origin
	local.max_speed = self.vehiclespeed
	local.selfdestruct_count = 0

	while ( self != NULL && self.fakehealth > 0 )
	{
		if (self.entered != 1)
			self thread wait_for_activate

		if (self.driver != NULL)
		{
			if (self.driver.extra_vehiclespeed == 1)
				self.vehiclespeed = local.max_speed * 1.25

			if (self.driver_kamera)
			{
				if (self.driver.forced_cueplayer == 1)
				{
					self.driver.forced_cueplayer = 0
					self.driver_kamera.kam_trigger douse self.driver
				}

				self.driver.viewangles = self.angles
				self.driver_kamera.angles = self.angles
			}
		}
		else
			self.vehiclespeed = local.max_speed

		if (self.lights == 1)
		{
			for (local.i = 1;local.i <= self.flare_light.size;local.i++)
			{
				local.flare_light = self.flare_light[local.i]
				if ( local.flare_light && local.flare_light.flare )
				{
					local.trace = trace local.flare_light.flare.origin ( local.flare_light.flare.origin + angles_toforward self.angles * 250 )
					local.flare_light.origin = local.trace
				}
			}
		}

		self thread global/AA/vehicle_physics.scr::vehicle_physics

		if (self.stop_org)
		{
			if ( self.driver == NULL && self.speed == 0.0 )
			{
				if (self.stop_org.glued != 1)
				{
					self.stop_org.glued = 1

					self.stop_org.origin = self.origin
					self.stop_org.angles = self.angles
					self glue self.stop_org
				}
			}
		}

		if ( vector_length ( local.start_pos - self.origin ) > 3500 )
		{
			if ( self.hasdriver != 1 && self.hasgunner != 1 )
			{
				local.selfdestruct_count++
				if (local.selfdestruct_count >= 600)
				{
					local.nodestruct = 0
					for (local.i = 1;local.i <= $player.size;local.i++)
					{
						local.player = $player[local.i]
						if ( local.player != NULL && local.player.player_spawned == 1 )
						{
							if ( vector_length ( local.player.origin - self.origin ) < 500 )
							{
								local.nodestruct = 1
								break
							}
						}
					}

					if (local.nodestruct != 1)
					{
						self.fakehealth = 0
						self takedamage
						self removeimmune none
						self normal_damage 10000
					}
				}
			}
			else
			{
				if (local.selfdestruct_count > 0)
					local.selfdestruct_count = 0
			}
		}
		else
		{
			if (local.selfdestruct_count > 0)
				local.selfdestruct_count = 0
		}

		waitframe
	}

	self thread jeep_respawn local.coll local.origin local.angles local.size1 local.size2
	self thread jeep_destroyed

end

wait_for_activate:

	local.surface = self
	if (self.collisionent)
		local.surface = self.collisionent

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.player_spawned == 1 )
		{
			if ( local.surface && local.player istouching local.surface )
			{
				if ( local.player.useheld && local.player.inveh != 1 )
				{
					if ( self.mpteam == "neutral" || local.player.dmteam == self.mpteam )
					{
						if ( self.hasdriver != 1 && self.hasgunner != 1 )
						{
							self.entered = 1
							self thread jeep_driver	local.player

							wait 1

							self.entered = 0
						}
						else if ( self.hasdriver == 1 && self.hasgunner != 1 )
						{
							self.entered = 1
							self thread jeep_gunner	local.player

							wait 1

							self.entered = 0
						}
						else if ( self.hasgunner == 1 && self.hasdriver != 1 )
						{
							self.entered = 1
							self thread jeep_driver	local.player

							wait 1

							self.entered = 0
						}
					}
				}
			}
		}
	}

end

jeep_driver local.driver:

	self.hasdriver = 1
	self.driver = local.driver
	self.driver.inveh = 1

	local.team = self.driver.dmteam
	self.mpteam = local.team

	self.driver.viewangles = ( 0 self.angles[1] 0 )

	if (self.driver.has_weapon == 1)
		self.driver deactivateweapon righthand

	self unglue
	self.stop_org.glued = 0

	self unlock
	self attachdriverslot 0 self.driver
	self lock

	self.driver playsound jeep_snd_doorclose

	local.org = spawn script_origin
	local.org attach self "driver" 1 ( 0 0 -50 )
	local.org.angles = self.angles

	self.driver glue local.org

	self.driver forcetorsostate JARMUBEN

	self.driver solid
	self.driver rendereffects "-shadow"

	local.kamera = self thread kamera

	self thread global/AA/vehicle_damage.scr::vehicle_health_hud self.driver

	wait .2

	local.horn = spawn script_model model "models/fx/dummy.tik"
	local.horn glue self
	local.horn notsolid

	local.light_count = 20

	while ( self.driver != NULL && local.driver.player_spawned == 1 && !(local.driver.useheld) )
	{
		if (self.driver.keyheld[TUZ])
		{
			if (self.canhorn == 1)
			{
				self.canhorn = 0
				self thread horn
			}
		}

		if (self.driver.secfireheld)
		{
			if (local.light_count == 20)
			{
				if (self.lights == 0)
				{
					self.lights = 1
					local.light_count = 0

					for (local.i = 1;local.i <= self.headlights.size;local.i++)
					{
						if (self.headlights[local.i])
							self.headlights[local.i] show
					}

					for (local.i = 1;local.i <= self.flare_light.size;local.i++)
					{
						if (self.flare_light[local.i])
							self.flare_light[local.i] lightOn
					}
				}
				else if (self.lights == 1)
				{
					self.lights = 0
					local.light_count = 0

					for (local.i = 1;local.i <= self.headlights.size;local.i++)
					{
						if (self.headlights[local.i])
							self.headlights[local.i] hide
					}

					for (local.i = 1;local.i <= self.flare_light.size;local.i++)
					{
						if (self.flare_light[local.i])
							self.flare_light[local.i] lightOFF
					}
				}
			}
		}

		if (self.driver.keyheld[GUGOLAS])
		{
			if (self.driver.poziciot_valt == 0)
				self thread pozicio_valtas self.driver
		}

		if (local.light_count < 20)
		{
			local.light_count++
			if (local.light_count > 20)
				local.light_count = 20
			
		}

		local.org.angles = self.angles

		waitframe
	}

	if (local.org)
		local.org remove

	if (local.driver != NULL)
		local.driver unglue

	if (local.kamera != NIL)
	{
		if (local.kamera.kam_trigger)
			local.kamera.kam_trigger remove

		local.kamera remove
	}

	self.canhorn = 1

	local.horn unglue
	local.horn remove

	self thread driver_getout local.driver local.team

end

jeep_gunner local.gunner:

	self.hasgunner = 1
	self.gunner = local.gunner
	self.gunner.inveh = 1

	local.team = self.gunner.dmteam
	self.mpteam = local.team

	self.gunner.viewangles = ( 0 self.angles[1] 0 )

	if (self.gunner.has_weapon == 1)
		self.gunner deactivateweapon righthand

	self unlock
	self.mg unlock
	self attachturretslot 0 self.gunner
	self lock
	self.mg lock

	local.org = spawn script_origin
	local.org attach self.mg "connect" 1 ( -10 -30 -9 )
	local.org.angles = ( self.angles[0] self.mg.angles[1] self.angles[2] )

	self.gunner glue local.org

	self.gunner forcetorsostate JARMUBEN

	self.gunner solid
	self.gunner rendereffects "-shadow"

	self thread jeep_gunner_hud self.gunner
	self thread global/AA/vehicle_damage.scr::vehicle_health_hud self.gunner

	wait .2

	while ( self.gunner != NULL && local.gunner.player_spawned == 1 && !(local.gunner.useheld) )
	{
		if ( self.gunner.keyheld[TUZ] && self.gunner.secfireheld != 1 )
			self thread tuzeles

		if (self.gunner.keyheld[GUGOLAS])
		{
			if (self.gunner.poziciot_valt == 0)
				self thread pozicio_valtas self.gunner
		}

		if ( self.gunner != NULL && self.gunner.forced_cueplayer == 1 )
		{
			self.gunner.forced_cueplayer = 0

			local.angl = self.mg.viewangles

			self unlock
			self.mg unlock
			self.gunner usestuff
			self attachturretslot 0 self.gunner
			self lock
			self.mg lock

			self.mg.viewangles = local.angl
		}

		local.org.angles = ( self.angles[0] self.mg.angles[1] self.angles[2] )

		waitframe
	}

	if (local.org)
		local.org remove

	if (local.gunner != NULL)
		local.gunner unglue

	self thread gunner_getout local.gunner local.team

end

kamera:

	local.name = "jeep_kamera" + randomint 999999 + self.driver.entnum
	local.kamera = spawn func_camera targetname local.name
	local.kamera attach self "driver" 1 ( 0 0 35 )

	local.kam_trigger = spawn trigger_camerause target local.name
	local.kam_trigger douse self.driver
	local.kam_trigger nottriggerable

	self.driver_kamera = local.kamera
	self.driver_kamera.kam_trigger = local.kam_trigger

end local.kamera

driver_getout local.driver local.team:

	self.driver = NULL

	local.no_change = 1

	if (local.driver != NULL)
	{
		if (local.driver.poziciot_valt == 1)
			local.no_change = 0

		self unlock
		local.driver usestuff
		self lock

		local.driver.viewangles = ( 0 self.angles[1] 0 )

		if (local.driver.dmteam == local.team)
			local.driver forcetorsostate STAND

		if (local.no_change == 1)
			local.driver rendereffects "+shadow"
		else
			local.driver notsolid

		local.driver playsound jeep_snd_doorclose

		local.driver thread global/AA/vehicle_damage.scr::remove_vehicle_health_hud

		if (local.driver.dmteam != local.team)
		{
			if (local.driver.dmteam != "spectator")
				local.driver.disable_spawn = 1

			local.driver respawn
		}

		if (local.no_change == 0)
		{
			local.driver.inveh = 0
			local.driver.forced_cueplayer = 0
		}
	}

	if ( isAlive self && self.gunner == NULL && local.no_change == 1 )
		self.mpteam = "neutral"

	wait 1

	if (self)
		self.hasdriver = 0

	if ( local.driver != NULL && local.no_change == 1 )
	{
		local.driver.inveh = 0
		local.driver.forced_cueplayer = 0
	}

end

gunner_getout local.gunner local.team:

	self.gunner = NULL

	local.no_change = 1

	if (local.gunner != NULL)
	{
		if (local.gunner.poziciot_valt == 1)
			local.no_change = 0

		self unlock
		self.mg unlock

		if (local.gunner.dmteam != "spectator")
			local.gunner usestuff
		else
			self.mg douse local.gunner

		self lock
		self.mg lock

		local.gunner.viewangles = ( 0 self.angles[1] 0 )

		if (local.gunner.dmteam == local.team)
			local.gunner forcetorsostate STAND

		if (local.no_change == 1)
			local.gunner rendereffects "+shadow"
		else
			local.gunner notsolid

		ihuddraw_alpha local.gunner 42 0

		local.gunner thread global/AA/vehicle_damage.scr::remove_vehicle_health_hud

		if (local.gunner.dmteam != local.team)
		{
			if (local.gunner.dmteam != "spectator")
				local.gunner.disable_spawn = 1

			local.gunner respawn
		}

		if (local.no_change == 0)
			local.gunner.inveh = 0
	}
	else
	{
		if (self.mg)
		{
			local.model = self.mg.model

			self detachturretslot 0 self.mg.origin
			self.mg remove

			self spawnturret 0 local.model
			self.mg = self queryturretslotentity 0
			self.mg lock

			self thread jeep_mg_properties
		}
	}

	if ( isAlive self && self.driver == NULL && local.no_change == 1 )
		self.mpteam = "neutral"

	wait 1

	if (self)
		self.hasgunner = 0

	if ( local.gunner != NULL && local.no_change == 1 )
		local.gunner.inveh = 0

end

pozicio_valtas local.player:

	local.player.poziciot_valt = 1

	if (local.player == self.driver)
	{
		if (self.hasgunner != 1)
		{
			self.hasgunner = 1
			self.driver = NULL

			while ( local.player != NULL && self.fakehealth > 0 && local.player.inveh == 1 )
				waitframe

			if ( local.player != NULL && local.player.player_spawned == 1 && self.fakehealth > 0 )
			{
				local.player.poziciot_valt = 2
				self thread jeep_gunner local.player
			}
			else
			{
				self.hasgunner = 0
				local.player.inveh = 0
			}
		}
	}
	else if (local.player == self.gunner)
	{
		if (self.hasdriver != 1)
		{
			self.hasdriver = 1
			self.gunner = NULL

			while ( local.player != NULL && self.fakehealth > 0 && local.player.inveh == 1 )
				waitframe

			if ( local.player != NULL && local.player.player_spawned == 1 && self.fakehealth > 0 )
			{
				local.player.poziciot_valt = 2
				self thread jeep_driver local.player
			}
			else
			{
				self.hasdriver = 0
				local.player.inveh = 0
			}
		}
	}

	wait 1.5

	if (local.player != NULL)
		local.player.poziciot_valt = 0

end

tuzeles:

	if ( self && self.mg )
	{
		if (self.tuzelhet == 1)
		{
			if (self.tolteny_tarban > 0)
			{
				self.tuzelhet = 0

				self.mg ammo_in_clip 1
				self.tolteny_tarban--

				local.map = getcvar "mapname"

				if ( local.map != "m1l3a" && local.map != "m1l3b" )
					self.mg playsound jeep_snd_fire

				if (self.gunner != NULL)
					ihuddraw_string self.gunner 42 ( "MG: " + self.tolteny_tarban + " | " + self.tolteny )

				if (self.tolteny_tarban <= 0)
					self thread geppuska_ujratoltes
				else
				{
					wait self.firetime
					self.tuzelhet = 1
				}
			}
		}
	}

end

geppuska_ujratoltes:

	while ( self.fakehealth > 0 && self.tolteny <= 0 )
		waitframe

	if (self.fakehealth <= 0)
		end

	wait 3

	if (self != NULL)
	{
		if (self.tolteny >= self.tarhely)
		{
			local.a = self.tolteny - self.tarhely
			local.a = self.tolteny - local.a
		}
		else
			local.a = self.tolteny

		self.tolteny_tarban = local.a
		self.tolteny -= self.tolteny_tarban

		if (self.tolteny < 0)
			self.tolteny = 0

		if (self.tolteny_tarban > 0)
			self.tuzelhet = 1

		if (self.gunner != NULL)
			ihuddraw_string self.gunner 42 ( "MG: " + self.tolteny_tarban + " | " + self.tolteny )
	}

end

horn:

	self playsound truck_horn

	wait 2

	if (self)
		self.canhorn = 1

end

jeep_respawn local.coll local.origin local.angles local.size1 local.size2:

	local.respawn_time = self.respawn_time

	while (self.destroyed_model == NIL)
		wait .1

	if (self == NULL)
		end

	local.destroyed_model = self.destroyed_model

	if (local.destroyed_model.collision)
		local.collision = local.destroyed_model.collision

	if (local.destroyed_model.fust)
		local.fust = local.destroyed_model.fust

	if (local.destroyed_model.tuz)
		local.tuz = local.destroyed_model.tuz

	wait 10

	local.exp = local.destroyed_model waitthread spawn_fx "models/fx/fx_tank_explosion.tik"
	local.exp.origin = local.destroyed_model.origin + ( 0 0 10 )
	local.exp anim start
	local.exp playsound explode_truck
	local.exp thread remove_fx

	radiusdamage ( local.exp.origin + ( 0 0 200 ) ) 200 200

	wait .5

	if (local.destroyed_model)
		local.destroyed_model remove

	if (local.collision)
		local.collision remove

	if (local.fust)
		local.fust remove

	if (local.tuz)
		local.tuz remove

	wait local.respawn_time

	waitexec global/AA/vehicle_respawn.scr local.origin local.angles local.size1 local.size2

	thread spawn_jeep local.origin local.angles local.coll

end

jeep_destroyed:

	self.destroyed = 1

	self playsound explode_truck
	self stop
	self.driving = 0

	if (self.driver)
	{
		local.driver = self.driver
		self.driver = NULL
	}

	if (self.gunner)
	{
		local.gunner = self.gunner
		self.gunner = NULL
	}

	if ( self.last_attacker == NIL || self.last_attacker == NULL )
		self.last_attacker = $world

	local.origin = self.origin
	local.angles = self.angles

	if (self.collisionent)
	{
		local.brushmodel = self.collisionent.brushmodel
		self.collisionent remove
	}

	self.death_exp.origin = self.origin + ( 0 0 20 )
	waitframe

	if (local.driver)
	{
		local.driver takedamage
		local.driver damage self.last_attacker 1000 self.last_attacker ( 0 0 0 ) ( 0 0 0 ) ( 0 0 0 ) 0 0 9 0
	}

	if (local.gunner)
	{
		local.gunner takedamage
		local.gunner damage self.last_attacker 1000 self.last_attacker ( 0 0 0 ) ( 0 0 0 ) ( 0 0 0 ) 0 0 9 0
	}

	self.death_exp anim start
	self.death_exp thread remove_fx

	radiusdamage ( self.origin + ( 0 0 200 ) ) 400 400

	self hide
	self notsolid

	if (self.mg)
		self.mg hide

	self.velocity = ( 0 0 0 )

	for (local.i = 1;local.i <= self.headlights.size;local.i++)
	{
		if (self.headlights[local.i])
			self.headlights[local.i] remove
	}

	for (local.i = 1;local.i <= self.flare_light.size;local.i++)
	{
		if (self.flare_light[local.i])
			self.flare_light[local.i] remove
	}

	if (local.brushmodel)
	{
		local.collision = thread damaged_collision local.brushmodel local.origin local.angles
	}

	local.damaged = thread spawn_damaged self.model local.origin local.angles

	if (local.collision != NIL)
	{
		local.damaged notsolid
		local.collision disconnect_paths
		local.damaged.collision = local.collision
	}

	local.fust = spawn script_model model "models/emitters/linger_smoke.tik"
	local.fust.origin = local.damaged.origin + ( 0 0 40 )
	local.fust anim start
	local.fust notsolid

	local.tuz = spawn script_model model "models/emitters/fire.tik" scale 0.7
	local.tuz.origin = local.damaged.origin + angles_toforward local.damaged.angles * 60 + angles_toup local.damaged.angles * 50
	local.tuz anim start
	local.tuz notsolid

	local.tuz thread tuz_sebzes

	local.damaged.fust = local.fust
	local.damaged.tuz = local.tuz

	self.destroyed_model = local.damaged

	wait 2

	if (self.mg)
	{
		self detachturretslot 0 self.mg.origin
		self.mg remove
	}

	if (self.stop_org)
		self.stop_org remove

	self remove

end

tuz_sebzes:

	self loopsound fire_large

	while (self)
	{
		for (local.i = 1;local.i <= $player.size;local.i++)
		{
			local.player = $player[local.i]

			if ( local.player != NULL && local.player.player_spawned == 1 )
			{
				if (local.player istouching self)
					local.player hurt 5
			}
		}

		waitframe
	}

end

jeep_gunner_hud local.gunner:

	ihuddraw_align local.gunner 42 left bottom
	ihuddraw_rect local.gunner 42 540 -50 0 0
	ihuddraw_color local.gunner 42 0.0 1.0 1.0
	ihuddraw_font local.gunner 42 "facfont-20"
	ihuddraw_string local.gunner 42 ( "MG: " + self.tolteny_tarban + " | " + self.tolteny )
	ihuddraw_virtualsize local.gunner 42 1
	ihuddraw_alpha local.gunner 42 1

end

remove_fx:

	wait 5
	self remove

end

spawn_damaged local.model local.origin local.angles:
	local.damaged = spawn script_model model local.model
	local.damaged.origin = local.origin
	local.damaged.angles = local.angles
	local.damaged solid
	local.damaged nodamage
end local.damaged

spawn_fx local.fx:
	local.temp = spawn script_model model local.fx
	local.temp.origin = self.origin
	local.temp notsolid
end local.temp

damaged_collision local.brushmodel local.origin local.angles:
	local.collision = spawn script_object model local.brushmodel
	local.collision.origin = local.origin
	local.collision.angles = local.angles
	local.collision solid
end local.collision

```

# zz_veersmods\global\AA\vezetheto_tankok.scr

```scr
spawn_tank local.origin local.angles local.type local.team local.coll:

	if ( local.origin == NIL || local.origin == NULL )
		end

	if ( local.angles == NIL || local.angles == NULL )
		local.angles = ( 0 0 0 )

	local.existing_type = 0
	switch (local.type)
	{
		case "kingtiger":
			local.model = "models/vehicles/kingtank.tik"
			local.existing_type = 1
		break
		case "tiger":
			local.model = "models/vehicles/tigertank.tik"
			local.existing_type = 1
		break
		case "panzer_brown":
			local.model = "models/vehicles/panzer_tank.tik"
			local.existing_type = 1
		break
		case "panzer_euro":
			local.model = "models/vehicles/panzer_tank_europe.tik"
			local.existing_type = 1
		break
	}

	if (local.existing_type != 1)
	{
		conprintf "Not defined tank type detected!!!"
		end
	}

	local.pos = local.origin + ( 0 0 10 )

	local.tank = spawn local.model origin local.pos angles local.angles
	local.turret = local.tank queryturretslotentity 0
	local.turret2 = local.tank queryturretslotentity 1

	local.tank hide
	local.tank nodamage

	if (local.turret)
		local.turret hide

	if (local.turret2)
		local.turret2 hide

	waitframe

	local.tank.origin = local.pos

	local.tank show

	if (local.turret)
		local.turret show

	if (local.turret2)
		local.turret2 show

	local.tank thread init_tank local.type local.team local.coll local.origin

end

init_tank local.type local.team local.coll local.origin:

	local.existing_type = 0
	switch (local.type)
	{
		case "kingtiger":
		case "tiger":
		case "panzer_brown":
		case "panzer_euro":
			local.existing_type = 1
		break
	}

	if (local.existing_type != 1)
	{
		conprintf "Not defined tank type detected!!!"
		end
	}

	if ( local.origin == NIL || local.origin == NULL )
		local.origin = self.origin

	if ( local.coll && local.coll.brushmodel )
	{
		self.collisionent = local.coll

		self.collisionent.vehicle = self
		self.collisionent.isvehicle = 1
	}

	if ( local.team != "allies" && local.team != "axis" )
		local.team = "allies"

	self.targetname = "vezetheto_jarmu"
	self.type = local.type
	self.dmteam = local.team
	self.mpteam = "neutral"

	self lock
	self unlockmovement
	self removeondeath 0
	self takedamage

	self.torony = self queryturretslotentity 0
	self.torony lock
	self.torony removeondeath 0

	self waitexec global/AA/immunities.scr

	local.immunities = crush::telefrag::explosion::fire::bash
	for (local.i = 1;local.i <= local.immunities.size;local.i++)
	{
		self.immunities[local.i] = local.immunities[local.i]
	}

	if (self.collisionent)
	{
		self notsolid
		self.torony notsolid
	}
	else
	{
		self solid
		self.torony solid

		self.torony.vehicle = self
		self.torony.isvehicle = 1
	}

	self.hasdriver = 0
	self.driver = NULL

	self.hasgunner = 0
	self.gunner = NULL

	self.captured = 0
	self.capturing_time = 10 // sec
	self.istank = 1
	self.isvehicle = 1
	self.destroyed = 0

	self.death_exp = self thread spawn_fx "models/emitters/explosion_tank.tik"

	switch (self.type)
	{
		case "kingtiger":
			self.health = 1600
			self.mass = 68500.0
			self.vehiclespeed = 220.0
			self.acceleration = 130.0
			self.turnrate = 22
			self.torony_turnspeed = 32

			self turnrate self.turnrate
			self.torony turnspeed self.torony_turnspeed

			self.respawn_time = 60

			if ( self.collisionent == NIL || self.collisionent == NULL )
			{
				self setsize ( -294 -128 0 ) ( 150 128 115 )
				self.torony setsize ( -112 -72 0 ) ( 94 64 69 )
			}

			local.respawn_size1 = ( -334 -175 0 )
			local.respawn_size2 = ( 214 175 120 )
		break
		case "tiger":
			self.health = 1200
			self.mass = 56900.0
			self.vehiclespeed = 250.0
			self.acceleration = 160.0
			self.turnrate = 24
			self.torony_turnspeed = 34

			self turnrate self.turnrate
			self.torony turnspeed self.torony_turnspeed

			self.respawn_time = 60

			if ( self.collisionent == NIL || self.collisionent == NULL )
			{
				self setsize ( -180 -103 0 ) ( 180 103 104 )
				self.torony setsize ( -80 -50 0 ) ( 72 60 48 )
			}

			local.respawn_size1 = ( -214 -133 0 )
			local.respawn_size2 = ( 232 133 120 )
		break
		case "panzer_brown":
		case "panzer_euro":
			self.health = 700
			self.mass = 25000.0
			self.vehiclespeed = 300.0
			self.acceleration = 200.0
			self.turnrate = 30
			self.torony_turnspeed = 40

			self turnrate self.turnrate
			self.torony turnspeed self.torony_turnspeed

			self.respawn_time = 45

			if ( self.collisionent == NIL || self.collisionent == NULL )
			{
				self setsize ( -160 -85 0 ) ( 160 85 108 )
				self.torony setsize ( -96 -48 0 ) ( 40 48 44 )
			}

			local.respawn_size1 = ( -191 -144 0 )
			local.respawn_size2 = ( 191 144 120 )
		break
	}

	self.speed = 0.0
	self vehiclespeed 200.0

	self.maxhealth = self.health
	self.fakehealth = self.maxhealth

	self.entered = 1

	self thread tank_turretfix
	self thread tank_funkciok local.team local.coll local.origin self.angles local.respawn_size1 local.respawn_size2

	wait 1

	self.stop_org = spawn script_origin
	self.stop_org.origin = local.origin
	self.stop_org.angles = self.angles
	self.stop_org.glued = 0

	self.entered = 0

end

tank_turretfix:

	self.torony surface all "+nodraw"

	self.fake_turret = spawn self.torony.model
	self.fake_turret attach self "turret0" 1 ( 0 0 0 )
	self.fake_turret notsolid
	self.fake_turret nodamage
	self.fake_turret lock
	self.fake_turret turnspeed 9999
	self.fake_turret pitchcaps "-90 90 0"
	self.fake_turret maxyawoffset 180.0

	self.fake_turret_target = spawn script_origin
	self.fake_turret_target attach self.torony "tag_barrel" 1 ( 1000000 0 0 )
	self.fake_turret setaimtarget self.fake_turret_target

end

tank_funkciok local.team local.coll local.origin local.angles local.size1 local.size2:

	self waitthread torony_geppuska_spawn
	self waitthread test_geppuska_spawn
	self waitthread tank_municio

	local.max_speed = self.vehiclespeed
	local.oldangles = self.angles

	self.torony_geppuska setaimtarget self.fake_turret_target

	local.reduced_properties = 0

	if ( getcvar "mapname" == "m4l1" )
		self thread map_fix

	while ( self != NULL && self.fakehealth > 0 )
	{
		if (self.entered != 1)
			self thread wait_for_activate

		self.torony_geppuska_org.angles = self.torony gettagangles "tag_barrel"

		if (self.test_geppuska)
		{
			self.test_geppuska yawcenter self.angle

			local.deltaangles = self.angles - local.oldangles

			if (self.gunner != NULL)
				self.test_geppuska_org.angles = ( self.gunner.viewangles[0] self.gunner.viewangles[1] self.angles[2] )
			else
				self.test_geppuska_org.angles = self.test_geppuska_org.angles + local.deltaangles

			local.oldangles = self.angles
		}

		if (self.driver != NULL)
		{
			if (self.driver.extra_vehiclespeed == 1)
				self.vehiclespeed = local.max_speed * 1.25

			if (self.driver_kamera)
			{
				if (self.driver.forced_cueplayer == 1)
				{
					self.driver.forced_cueplayer = 0
					self.driver_kamera.kam_trigger douse self.driver
				}

				self.driver_kamera.angles = ( self.driver.viewangles[0] self.driver.viewangles[1] self.angles[2] )
			}
		}

		if ( self.gunner != NULL && self.gunner_kamera )
		{
			if (self.gunner.forced_cueplayer == 1)
			{
				self.gunner.forced_cueplayer = 0
				self.gunner_kamera.kam_trigger douse self.gunner
			}

			self.gunner_kamera.angles = ( self.gunner.viewangles[0] self.gunner.viewangles[1] self.angles[2] )
		}

		local.perc = int ( (self.fakehealth / self.maxhealth) * 100 )
		if ( local.perc < 25 && local.reduced_properties != 1 )
		{
			local.reduced_properties = 1

			self.vehiclespeed = self.vehiclespeed * 0.75
			local.turnrate = self.turnrate * 0.75
			local.torony_turnspeed = self.torony_turnspeed * 0.5

			self turnrate local.turnrate
			self.torony turnspeed local.torony_turnspeed
		}
		else if ( local.perc >= 25 && local.reduced_properties == 1 )
		{
			local.reduced_properties = 0

			self.vehiclespeed = local.max_speed

			self turnrate self.turnrate
			self.torony turnspeed self.torony_turnspeed
		}

		self thread global/AA/vehicle_physics.scr::vehicle_physics

		if (self.stop_org)
		{
			if ( self.driver == NULL && self.speed == 0.0 )
			{
				if (self.stop_org.glued != 1)
				{
					self.stop_org.glued = 1

					self.stop_org.origin = self.origin
					self.stop_org.angles = self.angles
					self glue self.stop_org
				}
			}
		}

		waitframe
	}

	self thread tank_respawn local.team local.coll local.origin local.angles local.size1 local.size2
	self thread tank_destroyed

	self.fake_turret remove
	self.fake_turret_target remove

	if (self.torony_geppuska)
		self.torony_geppuska hide

	if (self.torony_geppuska_org)
		self.torony_geppuska_org remove

	if (self.test_geppuska)
		self.test_geppuska hide

	wait 1

	if (self.torony_geppuska)
		self.torony_geppuska remove

	if (self.test_geppuska)
		self.test_geppuska remove

	if (self.test_geppuska_org)
		self.test_geppuska_org remove

	if (self.turret_fix_org)
		self.turret_fix_org remove

end

map_fix:

	while ( self != NULL && self.fakehealth > 0 )
	{
		if (self.type == "kingtiger")
		{
			local.fwd = 150
			local.bwd = -294
		}
		else if (self.type == "panzer_euro")
		{
			local.fwd = 160
			local.bwd = -160
		}

		if ( local.fwd != NIL && local.bwd != NIL && self.speed != 0.0 )
		{
			if (self.speed > 0.0)
			{
				local.startpos = self.origin + angles_toup self.angles * 80
				local.endpos = local.startpos + angles_toforward self.angles * local.fwd
				local.trace = waitexec global/AA/trace.scr local.startpos local.endpos self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569569

				if (local.trace["fraction"] != 1.0)
				{
					self.speed = -self.vehiclespeed
					self.velocity = self.forwardvector * self.speed
				}
			}
			else if (self.speed < 0.0)
			{
				local.startpos = self.origin + angles_toup self.angles * 80
				local.endpos = local.startpos + angles_toforward self.angles * local.bwd
				local.trace = waitexec global/AA/trace.scr local.startpos local.endpos self.entnum ( -1 -1 -1 ) ( 1 1 1 ) 1107569569

				if (local.trace["fraction"] != 1.0)
				{
					self.speed = self.vehiclespeed
					self.velocity = self.forwardvector * self.speed
				}
			}

			wait .3
		}

		waitframe
	}

end

torony_geppuska_spawn:

	local.angles = self.torony gettagangles "pitch"

	self.torony_geppuska_org = spawn script_origin
	self.torony_geppuska_org.origin = self.origin
	self.torony_geppuska_org.angles = local.angles

	self waitthread torony_geppuska_pozicio self.torony_geppuska_org

	self.torony_geppuska = spawn VehicleTurretGun model "models/statweapons/mg42_gun.tik"
	self.torony_geppuska.origin = self.torony_geppuska_org.origin
	self.torony_geppuska.angles = self.torony_geppuska_org.angles
	self.torony_geppuska notsolid
	self.torony_geppuska show
	self.torony_geppuska turnspeed 9999
	self.torony_geppuska lock

	self.torony_geppuska glue self.torony_geppuska_org

	self.torony_geppuska firetype bullet
	self.torony_geppuska meansofdeath bullet

	self.torony_geppuska bulletdamage 75
	self.torony_geppuska bulletspread 35 35

	self.torony_geppuska dmbulletdamage 75
	self.torony_geppuska dmbulletspread 35 35

end

test_geppuska_spawn:

	local.mg = self queryturretslotentity 1

	if (local.mg)
		local.mg remove

	switch (self.type)
	{
		case "kingtiger":
			local.hely = ( 1 0 -4 )
			local.viewoffset = "0 0 0"
			local.pitchcaps = "-17 9 0"
			local.maxyawoffset = 30

			self surface mg "+nodraw"
		break
		case "tiger":
			local.hely = ( 6 0 -1 )
			local.viewoffset = "0 0 0"
			local.pitchcaps = "-17 17 0"
			local.maxyawoffset = 30

			self surface mg "+nodraw"
		break
		case "panzer_brown":
		case "panzer_euro":
			local.hely = ( 0 0 0 )
			local.viewoffset = "0 0 0"
			local.pitchcaps = "-17 10 0"
			local.maxyawoffset = 25
		break
	}

	self.test_geppuska_org = spawn script_origin
	self.test_geppuska_org.origin = self.origin
	self.test_geppuska_org.angles = self.angles

	self.test_geppuska_org attach self "turret1" 1 local.hely

	self.test_geppuska = spawn TurretGun model "models/statweapons/mg42_gun.tik" name "TANK MG42"
	self.test_geppuska.origin = self.test_geppuska_org.origin
	self.test_geppuska.angles = self.test_geppuska_org.angles
	self.test_geppuska notsolid
	self.test_geppuska show
	self.test_geppuska turnspeed 9999
	self.test_geppuska setplayerusable 0

	self.test_geppuska glue self.test_geppuska_org

	self.test_geppuska viewoffset local.viewoffset
	self.test_geppuska pitchcaps local.pitchcaps
	self.test_geppuska maxyawoffset local.maxyawoffset

	self.test_geppuska firetype bullet
	self.test_geppuska meansofdeath bullet

	self.test_geppuska bulletdamage 75
	self.test_geppuska bulletspread 35 35

	self.test_geppuska dmbulletdamage 75
	self.test_geppuska dmbulletspread 35 35

	self.test_geppuska ammotype		"Fakeammo"
	self.test_geppuska usenoammo 		0
	self.test_geppuska ammorequired		1
	self.test_geppuska startammo		0
	self.test_geppuska clipsize		1
	self.test_geppuska ammo_in_clip		0

	self.test_geppuska dmammorequired	1
	self.test_geppuska dmstartammo		0

end

torony_geppuska_pozicio local.org:

	switch (self.type)
	{
		case "kingtiger":
			local.org attach self.torony "pitch" 1 ( 18 4 -5.5 )
		break
		case "tiger":
			local.org attach self.torony "pitch" 1 ( 28.5 5 -3 )
		break
		case "panzer_brown":
		case "panzer_euro":
			local.org attach self.torony "pitch" 1 ( -17.5 -6 -1 )
		break
	}

end

tank_municio:

	switch (self.type)
	{
		case "kingtiger":
			self.torony projectile "models/projectiles/tigercannonshell.tik"
			self.torony dmprojectile "models/projectiles/tigercannonshell.tik"
			self.torony pitchcaps "-20 15 0"

			self.firetime = 5.0
		break
		case "tiger":
			self.torony projectile "models/projectiles/tigercannonshell.tik"
			self.torony dmprojectile "models/projectiles/tigercannonshell.tik"
			self.torony pitchcaps "-20 15 0"

			self.firetime = 5.0
		break
		case "panzer_brown":
		case "panzer_euro":
			self.torony projectile "models/projectiles/panzerivshell.tik"
			self.torony dmprojectile "models/projectiles/panzerivshell.tik"
			self.torony pitchcaps "-20 15 0"

			self.firetime = 3.5
		break
	}

	self.torony ammotype		"Fakeammo"
	self.torony usenoammo 		0
	self.torony ammorequired	1
	self.torony startammo		0
	self.torony clipsize		1
	self.torony ammo_in_clip	0

	self.torony dmammorequired	1
	self.torony dmstartammo		0

	self.max_lovedek_szama = 50
	self.lovedek_szama = self.max_lovedek_szama

	self.torony_geppuska.max_tolteny = 500
	self.torony_geppuska.tolteny = self.torony_geppuska.max_tolteny
	self.torony_geppuska.tarhely = 100
	self.torony_geppuska.tolteny_tarban = 100

	self.test_geppuska.max_tolteny = 500
	self.test_geppuska.tolteny = self.test_geppuska.max_tolteny
	self.test_geppuska.tarhely = 100
	self.test_geppuska.tolteny_tarban = 100

	self.tuzelhet = 1
	self.torony_geppuska.tuzelhet = 1
	self.test_geppuska.tuzelhet = 1

end

wait_for_activate:

	local.surface = self
	if (self.collisionent)
		local.surface = self.collisionent

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.player_spawned == 1 )
		{
			if ( local.surface && ( local.player istouching local.surface || local.player istouching self.torony ) )
			{
				if ( local.player.useheld && local.player.inveh != 1 && local.player.inturret != 1 )
				{
					if (local.player.ismedic != 1)
					{
						if ( self.mpteam == "neutral" || local.player.dmteam == self.mpteam )
						{
							if ( self.hasdriver != 1 && self.hasgunner != 1 )
							{
								self.entered = 1
								self thread tank_driver	local.player

								wait 1

								self.entered = 0
							}
							else if ( self.hasdriver == 1 && self.hasgunner != 1 )
							{
								self.entered = 1
								self thread tank_gunner	local.player

								wait 1

								self.entered = 0
							}
							else if ( self.hasgunner == 1 && self.hasdriver != 1 )
							{
								self.entered = 1
								self thread tank_driver	local.player

								wait 1

								self.entered = 0
							}
						}
					}
				}
			}
		}
	}

end

tank_driver local.driver:

	self.hasdriver = 1
	self.driver = local.driver
	self.driver.inveh = 1
	self.driver.capturing_tank = 0

	local.team = self.driver.dmteam
	self.mpteam = local.team

	self.driver.viewangles = ( 0 self.angles[1] 0 )

	if (self.driver.has_weapon == 1)
		self.driver deactivateweapon righthand

	local.org = spawn script_origin
	local.org attach self "turret0" 1 ( 0 0 0 )
	local.org.angles = self.angles

	self.driver glue local.org

	local.gt = int ( getcvar "g_gametype" )
	if ( local.gt > 2 && self.captured != 1 && local.team != self.dmteam )
	{
		self.driver.capturing_tank = 1
		self thread tank_capture self.driver
	}
	else
	{
		self unglue
		self.stop_org.glued = 0

		local.pitch = waitthread global/AA/math.scr::getanglediff self.angles[0] ( (self.torony gettagangles "tag_barrel")[0] )
		local.yaw = waitthread global/AA/math.scr::getanglediff self.angles[1] ( (self.torony gettagangles "tag_barrel")[1] )
		local.roll = waitthread global/AA/math.scr::getanglediff self.angles[2] ( (self.torony gettagangles "tag_barrel")[2] )

		self attachdriverslot 0 self.driver

		self.torony.viewangles = ( local.pitch local.yaw local.roll )

		local.kamera = self thread kamera self.driver

		self thread tank_driver_hud self.driver
		self thread global/AA/vehicle_damage.scr::vehicle_health_hud self.driver
	}

	self.driver forcetorsostate JARMUBEN

	self.driver notsolid
	self.driver nodamage
	self.driver show
	self.driver rendereffects "-shadow"
	self.driver rendereffects "+dontdraw"
	self.driver surface all "+nodraw"

	if (self.driver.isengineer == 1)
	{
		if (self.driver.engineer_helmet)
			self.driver.engineer_helmet surface all "+nodraw"

		if (self.driver.wrench)
			self.driver.wrench surface all "+nodraw"
	}

	wait .2

	while ( self.driver != NULL && local.driver.player_spawned == 1 && !(local.driver.useheld) )
	{
		if (self.driver.capturing_tank != 1)
		{
			if (self.driver.keyheld[TUZ])
				self thread tank_torony_tuz
			else
			{
				if (self.driver.secfireheld == 1)
					self thread tank_geppuska_tuz self.torony_geppuska self.driver
			}

			if (self.driver.keyheld[GUGOLAS])
			{
				if (self.driver.poziciot_valt == 0)
					self thread pozicio_valtas self.driver
			}
		}

		local.org.angles = self gettagangles "turret0"

		waitframe
	}

	if (local.org)
		local.org remove

	if (local.driver != NULL)
		local.driver unglue

	if (local.kamera != NIL)
	{
		if (local.kamera.kam_trigger)
			local.kamera.kam_trigger remove

		local.kamera remove
	}

	self unlock
	self.torony unlock

	if (isAlive self)
	{
		if (local.driver == NULL)
		{
			self detachturretslot 0 self.torony.origin
			self.torony remove

			self.fakehealth = 0

			self takedamage
			self removeimmune none
			self normal_damage 10000
		}
	}

	if ( local.driver != NULL && isAlive local.driver && local.driver.dmteam != "spectator" && local.driver.capturing_tank != 1 )
	{
		local.driver usestuff
		self attachturretslot 0 local.driver
		local.driver usestuff
	}

	self thread driver_getout local.driver local.team

end

tank_gunner local.gunner:

	self.hasgunner = 1
	self.gunner = local.gunner
	self.gunner.inveh = 1

	local.team = self.gunner.dmteam
	self.mpteam = local.team

	self.gunner.viewangles = ( 0 self.angles[1] 0 )

	if (self.gunner.has_weapon == 1)
		self.gunner deactivateweapon righthand

	self.test_geppuska setplayerusable 1
	self.test_geppuska douse self.gunner
	self.test_geppuska setplayerusable 0

	local.org = spawn script_origin
	local.org attach self "turret1" 1 ( 0 0 0 )
	local.org.angles = self.angles

	self.gunner glue local.org

	self.gunner forcetorsostate JARMUBEN

	self.gunner notsolid
	self.gunner nodamage
	self.gunner show
	self.gunner rendereffects "-shadow"
	self.gunner surface all "+nodraw"

	if (self.gunner.isengineer == 1)
	{
		if (self.gunner.engineer_helmet)
			self.gunner.engineer_helmet surface all "+nodraw"

		if (self.gunner.wrench)
			self.gunner.wrench surface all "+nodraw"
	}

	local.kamera = self thread kamera self.gunner

	self thread tank_gunner_hud self.gunner
	self thread global/AA/vehicle_damage.scr::vehicle_health_hud self.gunner

	wait .2

	while ( self.gunner != NULL && local.gunner.player_spawned == 1 && !(local.gunner.useheld) )
	{
		if (self.gunner.keyheld[TUZ])
			self thread tank_geppuska_tuz self.test_geppuska self.gunner

		if (self.gunner.keyheld[GUGOLAS])
		{
			if (self.gunner.poziciot_valt == 0)
				self thread pozicio_valtas self.gunner
		}

		local.org.angles = self gettagangles "turret1"

		waitframe
	}

	if (local.org)
		local.org remove

	if (local.gunner != NULL)
		local.gunner unglue

	if (local.kamera != NIL)
	{
		if (local.kamera.kam_trigger)
			local.kamera.kam_trigger remove

		local.kamera remove
	}

	self thread gunner_getout local.gunner local.team

end

tank_capture local.driver:

	local.max_count = self.capturing_time * 10.0
	local.count = local.max_count

	self thread tank_capturing_sounds

	ihuddraw_align local.driver 40 left center
	ihuddraw_rect local.driver 40 256 80 128 16
	ihuddraw_shader local.driver 40 "textures/mohmenu/black.tga"
	ihuddraw_virtualsize local.driver 40 1
	ihuddraw_alpha local.driver 40 1.0

	ihuddraw_align local.driver 41 left center
	ihuddraw_rect local.driver 41 258 80 124 10
	ihuddraw_shader local.driver 41 "textures/common/white.tga"
	ihuddraw_color local.driver 41 1.0 1.0 1.0
	ihuddraw_virtualsize local.driver 41 1
	ihuddraw_alpha local.driver 41 2.0

	ihuddraw_align local.driver 42 left center
	ihuddraw_rect local.driver 42 260 90 0 0
	ihuddraw_color local.driver 42 0.0 1.0 1.0
	ihuddraw_font local.driver 42 "verdana-12"
	ihuddraw_string local.driver 42 ( "Capturing enemy tank..." )
	ihuddraw_virtualsize local.driver 42 1
	ihuddraw_alpha local.driver 42 1

	while ( self.driver != NULL && local.count > 0 )
	{
		wait .1
		local.count--

		local.x = int ( (local.count / local.max_count) * 124 )
		ihuddraw_rect local.driver 41 258 80 local.x 10
	}

	if (local.count <= 0)
		self.captured = 1

	if (local.driver != NULL)
	{
		local.driver.capturing_tank = 0

		ihuddraw_alpha local.driver 40 0
		ihuddraw_alpha local.driver 41 0
		ihuddraw_alpha local.driver 42 0

		if (self.captured == 1)
		{
			self unglue
			self.stop_org.glued = 0

			self attachdriverslot 0 local.driver

			local.kamera = self thread kamera local.driver

			self thread tank_driver_hud local.driver
			self thread global/AA/vehicle_damage.scr::vehicle_health_hud local.driver
		}
	}

end

tank_capturing_sounds:

	while ( self.driver != NULL && self.driver.capturing_tank == 1 )
	{
		self playsound mp_tank_capturing_sound1

		wait 0.7

		if ( self.driver != NULL && self.driver.capturing_tank == 1 )
		{
			self playsound mp_tank_capturing_sound2

			wait 1

			if ( self.driver != NULL && self.driver.capturing_tank == 1 )
				wait 1
		}
		else
			self playsound mp_tank_capturing_sound2
	}

end

kamera local.player:

	local.name = "tank_kamera" + randomint 999999 + local.player.entnum
	local.kamera = spawn func_camera targetname local.name

	switch (self.type)
	{
		case "kingtiger":
			if (local.player == self.driver)
				local.kamera attach self.torony "eyebone" 1 ( 0 0 0 )
		break
		case "tiger":
			if (local.player == self.driver)
				local.kamera attach self.torony "Object01" 1 ( -32 30 40 )
		break
		case "panzer_brown":
		case "panzer_euro":
			if (local.player == self.driver)
				local.kamera attach self.torony "Box01" 1 ( 0 0 60 )
		break
	}

	if (local.player == self.gunner)
		local.kamera attach self.test_geppuska "origin" 1 ( -25 0 5 )
	else
		local.player.viewangles = self.torony gettagangles "tag_barrel"

	local.kamera.angles = ( local.player.viewangles[0] local.player.viewangles[1] self.angles[2] )

	cueplayer

	local.player waitthread global/AA/vehicle_fixes.scr::vehicle_camera

	local.kam_trigger = spawn trigger_camerause target local.name
	local.kam_trigger douse local.player
	local.kam_trigger nottriggerable

	if (local.player == self.driver)
	{
		self.driver_kamera = local.kamera
		self.driver_kamera.kam_trigger = local.kam_trigger
	}
	else if (local.player == self.gunner)
	{
		self.gunner_kamera = local.kamera
		self.gunner_kamera.kam_trigger = local.kam_trigger
	}

end local.kamera

driver_getout local.driver local.team:

	self.driver = NULL

	local.no_change = 1

	if (local.driver != NULL)
	{
		if (local.driver.poziciot_valt == 1)
			local.no_change = 0

		if (isAlive self)
			self detachdriverslot 0 local.driver

		local.driver.origin = self.torony.origin + ( 0 0 130 )
		local.driver.viewangles = ( 0 self.angles[1] 0 )

		if (local.driver.dmteam == local.team)
			local.driver forcetorsostate STAND

		local.driver solid
		local.driver takedamage
		local.driver show
		local.driver rendereffects "+shadow"
		local.driver rendereffects "-dontdraw"
		local.driver surface all "-nodraw"

		if (local.driver.isengineer == 1)
		{
			if (local.driver.engineer_helmet)
				local.driver.engineer_helmet surface all "-nodraw"

			if (local.driver.wrench)
				local.driver.wrench surface all "-nodraw"
		}

		ihuddraw_alpha local.driver 42 0

		local.driver thread global/AA/vehicle_damage.scr::remove_vehicle_health_hud

		if (local.driver.dmteam != local.team)
		{
			if (local.driver.dmteam != "spectator")
				local.driver.disable_spawn = 1

			local.driver respawn
		}

		if (local.no_change == 0)
		{
			local.driver.inveh = 0
			local.driver.forced_cueplayer = 0
		}
	}

	if (isAlive self)
	{
		self lock
		self.torony lock
	}

	if ( isAlive self && self.gunner == NULL && local.no_change == 1 )
		self.mpteam = "neutral"

	waitframe

	if ( self.fakehealth > 0 && self.torony )
	{
		local.target = spawn script_origin origin ( self.torony gettagposition "tag_barrel" + angles_toforward (self.torony gettagangles "tag_barrel") * 10000 )
		self.torony setaimtarget local.target
	}

	wait .5

	if (local.target)
		local.target remove

	wait .5

	if (self)
		self.hasdriver = 0

	if ( local.driver != NULL && local.no_change == 1 )
	{
		local.driver.inveh = 0
		local.driver.forced_cueplayer = 0
	}

end

gunner_getout local.gunner local.team:

	self.gunner = NULL

	local.no_change = 1

	if (local.gunner != NULL)
	{
		if (local.gunner.poziciot_valt == 1)
			local.no_change = 0

		self.test_geppuska setplayerusable 1

		if (local.gunner.dmteam != "spectator")
			local.gunner usestuff
		else
			self.test_geppuska douse local.gunner

		self.test_geppuska setplayerusable 0

		local.pos = self gettagposition "turret1"
		local.ang = ( 0 self.angles[1] 0 )
		local.trace = sighttrace local.pos ( local.pos + angles_toleft local.ang * 160 )

		if (local.trace == 1)
			local.gunner.origin = local.pos + angles_toleft local.ang * 125
		else
		{
			local.trace = sighttrace local.pos ( local.pos + angles_toleft local.ang * -210 )
			if (local.trace == 1)
				local.gunner.origin = local.pos + angles_toleft local.ang * -175
			else
				local.gunner.origin = local.pos + angles_toforward local.ang * 100
		}

		local.gunner.viewangles = local.ang

		if (local.gunner.dmteam == local.team)
			local.gunner forcetorsostate STAND

		//if (local.no_change == 1)
		//{
			local.gunner solid
			local.gunner takedamage
			local.gunner show
			local.gunner rendereffects "+shadow"
			local.gunner rendereffects "-dontdraw"
			local.gunner surface all "-nodraw"
		//}

		if (local.gunner.isengineer == 1)
		{
			if (local.gunner.engineer_helmet)
				local.gunner.engineer_helmet surface all "-nodraw"

			if (local.gunner.wrench)
				local.gunner.wrench surface all "-nodraw"
		}

		ihuddraw_alpha local.gunner 42 0

		local.gunner thread global/AA/vehicle_damage.scr::remove_vehicle_health_hud

		if (local.gunner.dmteam != local.team)
		{
			if (local.gunner.dmteam != "spectator")
				local.gunner.disable_spawn = 1

			local.gunner respawn
		}

		if (local.no_change == 0)
		{
			local.gunner.inveh = 0
			local.gunner.forced_cueplayer = 0
		}
	}

	if ( isAlive self && self.driver == NULL && local.no_change == 1 )
		self.mpteam = "neutral"

	wait 1

	if (self)
		self.hasgunner = 0

	if ( local.gunner != NULL && local.no_change == 1 )
	{
		local.gunner.inveh = 0
		local.gunner.forced_cueplayer = 0
	}

end

pozicio_valtas local.player:

	local.player.poziciot_valt = 1

	if (local.player == self.driver)
	{
		if (self.hasgunner != 1)
		{
			self.hasgunner = 1
			self.driver = NULL

			while ( local.player != NULL && self.fakehealth > 0 && local.player.inveh == 1 )
				waitframe

			if ( local.player != NULL && local.player.player_spawned == 1 && self.fakehealth > 0 )
			{
				local.player.poziciot_valt = 2
				self thread tank_gunner local.player
			}
			else
			{
				self.hasgunner = 0
				local.player.inveh = 0
			}
		}
	}
	else if (local.player == self.gunner)
	{
		if (self.hasdriver != 1)
		{
			self.hasdriver = 1
			self.gunner = NULL

			while ( local.player != NULL && self.fakehealth > 0 && local.player.inveh == 1 )
				waitframe

			if ( local.player != NULL && local.player.player_spawned == 1 && self.fakehealth > 0 )
			{
				local.player.poziciot_valt = 2
				self thread tank_driver local.player
			}
			else
			{
				self.hasdriver = 0
				local.player.inveh = 0
			}
		}
	}

	wait 1.5

	if (local.player != NULL)
		local.player.poziciot_valt = 0

end

tank_torony_tuz:

	if ( self && self.torony )
	{
		if (self.tuzelhet == 1)
		{
			if (self.lovedek_szama > 0)
			{
				if ( ( self.mpteam == "allies" && level.axis_vehicle_spawnkill_trigger && self istouching level.axis_vehicle_spawnkill_trigger ) || ( self.mpteam == "axis" && level.allies_vehicle_spawnkill_trigger && self istouching level.allies_vehicle_spawnkill_trigger ) )
				{
					if (self.driver != NULL)
						self.driver iprint "You are in the enemy spawn area and not able to spawnkill with tank."

					end
				}

				local.can_fire = self waitthread check_turret
				if (local.can_fire != 1)
					end

				self.tuzelhet = 0

				self.fake_turret anim fire
				self.torony shoot

				if (self.type == "tiger")
					self thread tiger_hatch

				local.map_allj = m3l3::m5l2a::m5l2b::m5l3
				local.ertek = waitthread global/AA/weaponsoundfix.scr::palyaellenorzes local.map_allj

				if (local.ertek == 1)
					self.torony playsound tank_snd_fire

				self.torony playsound tank_fire_dist

				local.pos = self.torony gettagposition "tag_barrel"
				local.angles = self.torony gettagangles "tag_barrel"

				local.smoke = spawn script_model model "models/fx/cannonsmoke.tik" origin local.pos angles local.angles
				local.smoke notsolid
				local.smoke anim idle

				self.lovedek_szama--

				if (self.driver != NULL)
					ihuddraw_string self.driver 42 ( "Shell: " + self.lovedek_szama + " || MG: " + self.torony_geppuska.tolteny_tarban + " | " + self.torony_geppuska.tolteny )

				if (self.fakehealth > 0)
					self thread tank_agyu_ujratoltes self.firetime local.smoke
				else
					end
			}
		}
	}

end

check_turret:

	if (self.turret_fix_org == NIL)
		self.turret_fix_org = spawn script_origin origin ( self.torony gettagposition "tag_barrel" )
	else
		self.turret_fix_org.origin = self.torony gettagposition "tag_barrel"

	if (self.collisionent)
	{
		if (self.turret_fix_org cansee self.collisionent 360 2000)
			end 1
	}
	else
	{
		if ( self.turret_fix_org cansee self 360 2000 || self.turret_fix_org cansee self.torony 360 2000 )
			end 1
	}

end 0

tiger_hatch:

	wait .3

	if (self.fake_turret)
		self.fake_turret anim idle

end

tank_agyu_ujratoltes local.firetime local.smoke:

	wait 0.05

	while ( self.fakehealth > 0 && self.lovedek_szama <= 0 )
		waitframe

	if (self.fakehealth <= 0)
		end

	if ( self.driver != NULL && self.driver.tankreload == 1 )
		local.firetime -= 1

	wait (local.firetime - 0.05)

	if (self)
		self.tuzelhet = 1

	local.smoke remove

end

tank_geppuska_tuz local.geppuska local.tulaj:

	if ( self && local.geppuska )
	{
		if (local.geppuska.tuzelhet == 1)
		{
			if (local.geppuska.tolteny_tarban > 0)
			{
				if ( ( self.mpteam == "allies" && level.axis_vehicle_spawnkill_trigger && self istouching level.axis_vehicle_spawnkill_trigger ) || ( self.mpteam == "axis" && level.allies_vehicle_spawnkill_trigger && self istouching level.allies_vehicle_spawnkill_trigger ) )
				{
					if (local.tulaj != NULL)
						local.tulaj iprint "You are in the enemy spawn area and not able to spawnkill with tank."

					end
				}

				local.geppuska.tuzelhet = 0

				local.geppuska.tolteny_tarban--

				if (local.tulaj)
				{
					if (local.tulaj == self.driver)
					{
						local.tulaj bindweap local.geppuska
						local.geppuska anim fire
						local.tulaj bindweap local.geppuska

						if (local.tulaj != NULL)
							ihuddraw_string local.tulaj 42 ( "Shell: " + self.lovedek_szama + " || MG: " + self.torony_geppuska.tolteny_tarban + " | " + self.torony_geppuska.tolteny )
					}
					else if (local.tulaj == self.gunner)
					{
						local.geppuska ammo_in_clip 1

						if (local.tulaj != NULL)
							ihuddraw_string local.tulaj 42 ( "MG: " + self.test_geppuska.tolteny_tarban + " | " + self.test_geppuska.tolteny )
					}
				}

				wait 0.06

				local.geppuska anim idle

				if (local.geppuska.tolteny_tarban <= 0)
					local.geppuska thread tank_mg_reload self local.tulaj
				else
					local.geppuska.tuzelhet = 1
			}
		}
	}

end

tank_mg_reload local.vehicle local.gunner:

	while ( local.vehicle.fakehealth > 0 && self.tolteny <= 0 )
		waitframe

	if (local.vehicle.fakehealth <= 0)
		end

	wait 3

	if (self != NULL)
	{
		if (self.tolteny > 0)
		{
			if (self.tolteny >= self.tarhely)
			{
				local.a = self.tolteny - self.tarhely
				local.a = self.tolteny - local.a
			}
			else
				local.a = self.tolteny

			self.tolteny_tarban = local.a
			self.tolteny -= self.tolteny_tarban

			if (self.tolteny < 0)
				self.tolteny = 0

			if (self.tolteny_tarban > 0)
				self.tuzelhet = 1

			if ( self == local.vehicle.torony_geppuska && local.vehicle.driver != NULL && local.gunner == local.vehicle.driver )
				ihuddraw_string local.gunner 42 ( "Shell: " + local.vehicle.lovedek_szama + " || MG: " + local.vehicle.torony_geppuska.tolteny_tarban + " | " + local.vehicle.torony_geppuska.tolteny )
			else if ( self == local.vehicle.test_geppuska && local.vehicle.gunner != NULL && local.gunner == local.vehicle.gunner )
				ihuddraw_string local.gunner 42 ( "MG: " + local.vehicle.test_geppuska.tolteny_tarban + " | " + local.vehicle.test_geppuska.tolteny )
		}
	}

end

tank_respawn local.team local.coll local.origin local.angles local.size1 local.size2:

	local.type = self.type
	local.respawn_time = self.respawn_time

	while (self.destroyed_model == NIL)
		wait .1

	if (self == NULL)
		end

	local.destroyed_model = self.destroyed_model

	if (local.destroyed_model.collision)
		local.collision = local.destroyed_model.collision

	if (local.destroyed_model.fust)
		local.fust = local.destroyed_model.fust

	wait 10

	local.exp = local.destroyed_model waitthread spawn_fx "models/fx/fx_tank_explosion.tik"
	local.exp.origin = local.destroyed_model.origin + ( 0 0 10 )
	local.exp anim start
	local.exp playsound explode_tank
	local.exp thread remove_fx

	radiusdamage ( local.exp.origin + ( 0 0 200 ) ) 200 200

	wait .5

	local.destroyed_model remove

	if (local.collision)
		local.collision remove

	if (local.fust)
		local.fust remove

	wait local.respawn_time

	waitexec global/AA/vehicle_respawn.scr local.origin local.angles local.size1 local.size2

	thread spawn_tank local.origin local.angles local.type local.team local.coll

end

tank_destroyed:

	self.destroyed = 1

	self playsound explode_tank
	self stop
	self.driving = 0

	if (self.driver)
	{
		local.driver = self.driver
		self.driver = NULL
	}

	if (self.gunner)
	{
		local.gunner = self.gunner
		self.gunner = NULL
	}

	if ( self.last_attacker == NIL || self.last_attacker == NULL )
		self.last_attacker = $world

	switch (self.type)
	{
		case "kingtiger":
			local.model = "models/vehicles/kingtank_all_d.tik"
		break
		case "tiger":
			local.model = "models/vehicles/tigertank_d.tik"
		break
		case "panzer_brown":
			local.model = "models/vehicles/panzer_iv_d.tik"
		break
		case "panzer_euro":
			local.model = "models/vehicles/panzer_iv_eud.tik"
		break
	}

	local.origin = self.origin
	local.angles = self.angles

	if (self.collisionent)
	{
		local.brushmodel = self.collisionent.brushmodel
		self.collisionent remove
	}

	self.death_exp.origin = self.origin
	waitframe

	if (local.driver)
	{
		local.driver takedamage
		local.driver damage self.last_attacker 1000 self.last_attacker ( 0 0 0 ) ( 0 0 0 ) ( 0 0 0 ) 0 0 9 0
	}

	if (local.gunner)
	{
		local.gunner takedamage
		local.gunner damage self.last_attacker 1000 self.last_attacker ( 0 0 0 ) ( 0 0 0 ) ( 0 0 0 ) 0 0 9 0
	}

	self.death_exp anim start
	self.death_exp thread remove_fx

	radiusdamage ( self.origin +  ( 0 0 200 ) ) 600 300

	self hide
	self notsolid

	if (self.torony)
		self.torony hide

	self.velocity = ( 0 0 0 )

	if (local.brushmodel)
	{
		local.collision = thread damaged_collision local.brushmodel local.origin local.angles
	}

	local.damaged = thread spawn_damaged local.model local.origin local.angles

	if (local.collision != NIL)
	{
		local.damaged notsolid
		local.collision disconnect_paths
		local.damaged.collision = local.collision
	}

	local.fust = spawn script_model model "models/emitters/linger_smoke.tik"
	local.fust.origin = local.damaged.origin + ( 0 0 50 )
	local.fust notsolid
	local.fust anim start

	local.damaged.fust = local.fust

	self.destroyed_model = local.damaged

	wait 2

	if (self.torony)
	{
		self detachturretslot 0 self.torony.origin
		self.torony remove
	}

	if (self.stop_org)
		self.stop_org remove

	self remove

end

tank_driver_hud local.driver:

	ihuddraw_align local.driver 42 left bottom
	ihuddraw_rect local.driver 42 480 -50 0 0
	ihuddraw_color local.driver 42 0.0 1.0 1.0
	ihuddraw_font local.driver 42 "facfont-20"
	ihuddraw_string local.driver 42 ( "Shell: " + self.lovedek_szama + " || MG: " + self.torony_geppuska.tolteny_tarban + " | " + self.torony_geppuska.tolteny )
	ihuddraw_virtualsize local.driver 42 1
	ihuddraw_alpha local.driver 42 1

end

tank_gunner_hud local.gunner:

	ihuddraw_align local.gunner 42 left bottom
	ihuddraw_rect local.gunner 42 540 -50 0 0
	ihuddraw_color local.gunner 42 0.0 1.0 1.0
	ihuddraw_font local.gunner 42 "facfont-20"
	ihuddraw_string local.gunner 42 ( "MG: " + self.test_geppuska.tolteny_tarban + " | " + self.test_geppuska.tolteny )
	ihuddraw_virtualsize local.gunner 42 1
	ihuddraw_alpha local.gunner 42 1

end

remove_fx:

	wait 5
	self remove

end

spawn_damaged local.model local.origin local.angles:
	local.damaged = spawn script_model model local.model
	local.damaged.origin = local.origin
	local.damaged.angles = local.angles
	local.damaged solid
	local.damaged nodamage
end local.damaged

spawn_fx local.fx:
	local.temp = spawn script_model model local.fx
	local.temp.origin = self.origin
	local.temp notsolid
end local.temp

damaged_collision local.brushmodel local.origin local.angles:
	local.collision = spawn script_object model local.brushmodel
	local.collision.origin = local.origin
	local.collision.angles = local.angles
	local.collision solid
end local.collision

```

# zz_veersmods\global\AA\weaponsoundfix.scr

```scr
main local.state:

	if (self == NULL)
		end

	local.fegyver = self

	// A mapok nevei, ahol engedlyezve vannak a hangok, az ubersound.scr fjlbl vannak meghatrozva.

	switch (local.state)
	{
		// PISTOL Sounds
		case "ATTACK_PISTOL_PRIMARY":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound colt45_snd_fire
		break
		case "RELOAD_PISTOL":
			if (local.fegyver.model == "models/weapons/colt45.tik")
			{
				if (level.allies_weapon_sound[local.state] == 1)
					local.fegyver playsound colt45_snd_reload
			}
			else if (local.fegyver.model == "models/weapons/silencedpistol.tik")
			{
				if (level.axis_weapon_sound[local.state] == 1)
					local.fegyver playsound silencer_snd_reload
			}
		break

		// RIFLE Sounds
		case "ATTACK_RIFLE_PRIMARY":
			if (local.fegyver.model == "models/weapons/m1_garand.tik")
			{
				if (level.allies_weapon_sound_ind[local.state]["garand"] == 1)
					local.fegyver playsound m1_snd_fire
			}
			else if (local.fegyver.model == "models/weapons/springfield.tik")
			{
				if (level.allies_weapon_sound_ind[local.state]["springfield"] == 1)
					local.fegyver playsound springfield_snd_fire2
			}
		break
		case "ATTACK_RIFLE_PRIMARY_EMPTY":
			if (level.weapon_sound[local.state] == 1)
			{
				local.fegyver playsound m1_snd_fire
				wait 0.3
				local.fegyver playsound snd_ping
			}
		break
		case "RELOAD_RIFLE":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound m1_snd_reload
		break
		case "ATTACK_SPRINGFIELD_RECHAMBER":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound springfield_snd_bolt
		break
		case "RELOAD_SPRINGFIELD":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound springfield_snd_reload_start
		break
		case "RELOAD_SPRINGFIELD_SINGLE":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound springfield_snd_reload_single
		break
		case "RELOAD_SPRINGFIELD_END":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound springfield_snd_reload_end
		break

		// MG Sounds
		case "ATTACK_MG_PRIMARY":
			if (local.fegyver.model == "models/weapons/bar.tik")
			{
				if (level.allies_weapon_sound_ind[local.state]["bar"] == 1)
					local.fegyver playsound bar_snd_fire
			}
			else if (local.fegyver.model == "models/weapons/mp44.tik")
			{
				if (level.axis_weapon_sound_ind[local.state]["mp44"] == 1)
					local.fegyver playsound mp44_snd_fire
			}
		break
		case "RELOAD_MG":
			if (local.fegyver.model == "models/weapons/bar.tik")
			{
				if (level.allies_weapon_sound_ind[local.state]["bar"] == 1)
					local.fegyver playsound bar_snd_reload
			}
			else if (local.fegyver.model == "models/weapons/mp44.tik")
			{
				if (level.axis_weapon_sound_ind[local.state]["mp44"] == 1)
					local.fegyver playsound mp44_snd_reload
			}
		break
		case "PUTAWAY_MG_BAR":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound bar_snd_putaway
		break
		case "RAISE_MG_BAR":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound bar_snd_pullout
		break
		case "RAISE_MG_MP44":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound mp44_snd_pullout
		break

		// PNCLTR Sounds
		case "ATTACK_BAZOOKA_PRIMARY":
			if (local.fegyver.model == "models/weapons/bazooka.tik")
			{
				if (level.allies_weapon_sound_ind[local.state]["bazooka"] == 1)
					local.fegyver playsound bazooka_snd_fire
			}
			else if (local.fegyver.model == "models/weapons/panzerschreck.tik")
			{
				if (level.axis_weapon_sound_ind[local.state]["panzerschreck"] == 1)
					local.fegyver playsound panzerschreck_snd_fire
			}
		break
		case "RELOAD_HEAVY":
			if (local.fegyver.model == "models/weapons/bazooka.tik")
			{
				if (level.allies_weapon_sound_ind[local.state]["bazooka"] == 1)
					local.fegyver playsound bazooka_snd_reload
			}
			else if (local.fegyver.model == "models/weapons/panzerschreck.tik")
			{
				if (level.axis_weapon_sound_ind[local.state]["panzerschreck"] == 1)
					local.fegyver playsound panzerschreck_snd_reload
			}
		break
		case "PUTAWAY_HEAVY":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound snd_bazooka_putaway
		break
		case "RAISE_HEAVY":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound snd_bazooka_pullout
		break

		// SHOTGUN Sounds
		case "ATTACK_SHOTGUN_PRIMARY":
			if (level.weapon_sound[local.state] == 1)
			{
				local.fegyver playsound shotgun_snd_fire
				local.fegyver playsound shotgun_snd_rechamber
			}
		break
		case "RELOAD_SHOTGUN":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound shotgun_snd_reload_start
		break
		case "RELOAD_SHOTGUN_SINGLE":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound shotgun_snd_reload_single
		break
		case "RELOAD_SHOTGUN_END":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound shotgun_snd_reload_end
		break
		case "PUTAWAY_SHOTGUN":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound snd_shotgun_putaway
		break
		case "RAISE_SHOTGUN":
			if (level.weapon_sound[local.state] == 1)
				local.fegyver playsound snd_shotgun_pullout
		break
	}

end

check_sounds:

	local.map = getcvar "mapname"

	local.sound_type = ATTACK_PISTOL_PRIMARY::RELOAD_PISTOL::ATTACK_RIFLE_PRIMARY::ATTACK_RIFLE_PRIMARY_EMPTY::RELOAD_RIFLE::ATTACK_SPRINGFIELD_RECHAMBER::RELOAD_SPRINGFIELD::RELOAD_SPRINGFIELD_SINGLE::RELOAD_SPRINGFIELD_END::ATTACK_MG_PRIMARY::RELOAD_MG::PUTAWAY_MG_BAR::RAISE_MG_BAR::RAISE_MG_MP44::ATTACK_BAZOOKA_PRIMARY::RELOAD_HEAVY::PUTAWAY_HEAVY::RAISE_HEAVY::ATTACK_SHOTGUN_PRIMARY::RELOAD_SHOTGUN::RELOAD_SHOTGUN_SINGLE::RELOAD_SHOTGUN_END::PUTAWAY_SHOTGUN::RAISE_SHOTGUN

	for (local.i = 1;local.i <= local.sound_type.size;local.i++)
	{
	switch (local.sound_type[local.i])
	{
		// PISTOL Sounds
		case "ATTACK_PISTOL_PRIMARY":
			local.map_allj = m1l1::m1l2a::m1l2b::m1l3c::m3l1a::m3l1b::m3l2::m3l3::m4l1::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l3a::m6l3b::m6l3c::m6l3d::dm::moh::obj::train
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RELOAD_PISTOL":
			local.map_allj = m1l1::m1l2a::m1l2b::m1l3c::m3l1a::m3l1b::m3l2::m3l3::m4l1::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l3a::m6l3b::m6l3c::m6l3d::dm::moh::obj::train
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.allies_weapon_sound[local.sound_type[local.i]] = local.ertek

			local.map_allj = m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m2l1::m2l2a::m2l2b::m2l2c::m2l3::m4l2::m4l3::m6l1a::m6l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.axis_weapon_sound[local.sound_type[local.i]] = local.ertek
		break

		// RIFLE Sounds
		case "ATTACK_RIFLE_PRIMARY":
			local.map_allj = m1l1::m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m3l1a::m3l2::m3l3::m4l0::m4l1::m5l1a::m5l1b::m6l3a::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.allies_weapon_sound_ind[local.sound_type[local.i]]["garand"] = local.ertek

			local.map_allj = m2l2a::m2l2b::m2l2c::m6l3b::m6l3c::m6l3d::m6l3e
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.allies_weapon_sound_ind[local.sound_type[local.i]]["springfield"] = local.ertek
		break
		case "ATTACK_RIFLE_PRIMARY_EMPTY":
			local.map_allj = m1l1::m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m3l1a::m3l2::m3l3::m4l0::m4l1::m5l1a::m5l1b::m6l3a::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RELOAD_RIFLE":
			local.map_allj = m1l1::m1l2a::m1l2b::m1l3a::m1l3b::m1l3c::m3l2::m3l3::m4l0::m4l1::m5l1a::m5l1b::m6l3a::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "ATTACK_SPRINGFIELD_RECHAMBER":
			local.map_allj = m2l1::m2l2a::m2l2b::m2l2c::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj::train
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RELOAD_SPRINGFIELD":
			local.map_allj = m2l1::m2l2a::m2l2b::m2l2c::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj::train
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RELOAD_SPRINGFIELD_SINGLE":
			local.map_allj = m2l1::m2l2a::m2l2b::m2l2c::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj::train
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RELOAD_SPRINGFIELD_END":
			local.map_allj = m2l1::m2l2a::m2l2b::m2l2c::m2l3::m3l1a::m3l1b::m3l2::m3l3::m5l1a::m5l1b::m5l2a::m5l2b::m5l3::m6l1a::m6l1b::m6l1c::m6l2::m6l2b::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj::train
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break

		// MG Sounds
		case "ATTACK_MG_PRIMARY":
			local.map_allj = m2l3::m3l1a::m3l2::m3l3::m4l0::m5l1b::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.allies_weapon_sound_ind[local.sound_type[local.i]]["bar"] = local.ertek

			local.map_allj = m5l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3b::m6l3c::m6l3::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.axis_weapon_sound_ind[local.sound_type[local.i]]["mp44"] = local.ertek
		break
		case "RELOAD_MG":
			local.map_allj = m3l1a::m3l2::m3l3::m4l0::m5l1b::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.allies_weapon_sound_ind[local.sound_type[local.i]]["bar"] = local.ertek

			local.map_allj = m5l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3b::m6l3::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.axis_weapon_sound_ind[local.sound_type[local.i]]["mp44"] = local.ertek
		break
		case "PUTAWAY_MG_BAR":
			local.map_allj = m3l1a::m3l2::m3l3::m4l0::m5l1b::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RAISE_MG_BAR":
			local.map_allj = m3l1a::m3l2::m3l3::m4l0::m5l1b::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RAISE_MG_MP44":
			local.map_allj = m5l1b::m6l1c::m6l2a::m6l2b::m6l3a::m6l3b::m6l3::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break

		// PNCLTR Sounds
		case "ATTACK_BAZOOKA_PRIMARY":
			local.map_allj = m5::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.allies_weapon_sound_ind[local.sound_type[local.i]]["bazooka"] = local.ertek

			local.map_allj = m1l1::m1l3::m3l3::m5l2::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.axis_weapon_sound_ind[local.sound_type[local.i]]["panzerschreck"] = local.ertek
		break
		case "RELOAD_HEAVY":
			local.map_allj = m5::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.allies_weapon_sound_ind[local.sound_type[local.i]]["bazooka"] = local.ertek

			local.map_allj = m1l1::m1l3::m3l3::m5l2::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.axis_weapon_sound_ind[local.sound_type[local.i]]["panzerschreck"] = local.ertek
		break
		case "PUTAWAY_HEAVY":
			local.map_allj = m1l1::m5::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RAISE_HEAVY":
			local.map_allj = m1l1::m3l3::m5::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break

		// SHOTGUN Sounds
		case "ATTACK_SHOTGUN_PRIMARY":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RELOAD_SHOTGUN":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RELOAD_SHOTGUN_SINGLE":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RELOAD_SHOTGUN_END":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "PUTAWAY_SHOTGUN":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
		case "RAISE_SHOTGUN":
			local.map_allj = m4l3::m6l3a::m6l3b::m6l3c::m6l3d::m6l3e::dm::moh::obj
			local.ertek = waitthread palyaellenorzes local.map_allj

			level.weapon_sound[local.sound_type[local.i]] = local.ertek
		break
	}
	}

end

palyaellenorzes local.map_allj:

	local.map = getcvar "mapname"

	for (local.i = 1;local.i <= local.map_allj.size;local.i++)
	{
		if (local.map == local.map_allj[local.i])
			end 0
	}

end 1

```

# zz_veersmods\global\barrel.scr

```scr
////////////////////////////////////////////////////////////////////////////////////////
//
//  MoH: Allied Assault Script File  
//  Global function: Exploding and launching barrels
//  Script Written By: Benson 'elmagoo' Russell
//
////////////////////////////////////////////////////////////////////////////////////////

//**************************************************************************
//*** will setup all specified barrels in the editor for explosive barrels
//*** syntax --------------------------------
//*** explosive_barrel
//**************************************************************************
explosive_barrel:

level.damage_delay = .3

//*** setup normal explosive barrels
if ($explosive_barrel == NULL)
{
	println "^~^~^ No explosive barrels in the level!!"
	goto explosive_barrel_launch_setup
}

for (local.i = 1; local.i <= $explosive_barrel.size ; local.i ++)
{
       	$explosive_barrel[local.i] thread explosive_barrel_spawn local.i
}

explosive_barrel_launch_setup:
//*** setup explosive launching barrels
if ($explosive_barrel_launch == NULL)
{
	println "^~^~^ No explosive launch barrels in the level!!"
	goto explosive_barrel_end
}

for (local.i = 1; local.i <= $explosive_barrel_launch_dummy.size; local.i ++)
{
	local.lookup[$explosive_barrel_launch_dummy[local.i].set] = local.i
}

for (local.i = 1; local.i <= $explosive_barrel_launch.size ; local.i ++)
{
	$explosive_barrel_launch[local.i].dummy_index = local.lookup[$explosive_barrel_launch[local.i].set]
	$explosive_barrel_launch[local.i] thread explosive_barrel_launch_spawn local.i
}

local.lookup = NIL

explosive_barrel_end:
end


//**************************************************************************
//*** thread for the explosive barrel
//*** syntax --------------------------------
//*** <crate> explosive_barrel_spawn <array index>
//**************************************************************************
explosive_barrel_spawn local.index:

//*** set temp variables
local.spawn_origin = local.self.origin
local.spawn_origin[2] += 32
local.spawn_targetname = (local.self.targetname + "_explosive_" + local.index)

if (local.self.dmg != NIL)
{
	local.dmg = local.self.dmg
}
else
{
	local.dmg = 250
}

if (local.self.radius != NIL)
{
	local.radius = local.self.radius
}
else
{
	local.radius = 256
}

if (self.script_health != NIL)
{
	self.health = self.script_health
}
else
{
	self.health = 1
	//println "z:       barrel: " self " health: " self.health
}

//*** wait till the barrel is destroyed
local.self waittill death


	//*** if a thread is set, run it and wait for it's completion
	if (self.run_thread != NIL)
        {
        	self thread level.script::self.run_thread
        }

//*** spawn the explosion
spawn "models/fx/barrel_gas_destroyed" targetname local.spawn_targetname angle "-1"
local.spawn_targetname = $(local.self.targetname + "_explosive_" + local.index)

//*** reset the explosions origin
local.spawn_targetname.origin = local.spawn_origin

local.spawn_targetname anim idle
/*
//*** get the distance to the player
local.distance = vector_length (local.self.origin - $player.origin)
local.check_distance = (local.radius * 1.5)
local.outter_distance = (local.radius * 2.5)

//*** shake his view
if (local.distance <= local.check_distance)  //*** inner distance check
{
	if (local.dmg <= 150)
        {
        	thread jitter_small
        }
	else
	{
		thread jitter_normal
	}
}
else if (local.distance <= local.outter_distance)  //*** outter distance check
{
	if (local.dmg <= 150)
        {
        	thread jitter_tiny
        }
	else
	{
		thread jitter_small
	}
}
*/
wait level.damage_delay // wait a bit so barrels stagger

//*** damage the player  <origin> <damage> <radius> [consitent]
radiusdamage local.spawn_targetname.origin local.dmg local.radius

wait (randomint 3 + 4)

//*** delete the effect out of the world now that it's done
local.spawn_targetname remove

end


//**************************************************************************
//*** thread for the explosive launching barrels
//*** syntax --------------------------------
//*** <crate> explosive_barrel_launch_spawn <array index>
//**************************************************************************
explosive_barrel_launch_spawn local.index:

//*** get the dummy targetname
//println "EXPLOSIVE LAUNCH: current barrel: " local.index
//println "EXPLOSIVE LAUNCH: current barrel dummy index: " local.self.dummy_index
local.dummy = $explosive_barrel_launch_dummy[local.self.dummy_index]

//*** check to see if a dummy barrel exists for this launcher, if not, turn it into a normal exploder
if (local.dummy == NULL)
{
	println "^~^~^ No dummy barrel for launcher barrel with set number: "  local.self.set "  - converting to normal exploder!!"
	local.self thread explosive_barrel_spawn local.i
	goto explosive_barrel_launch_spawn_end
}

//*** make the dummy invisible and not solid and place it
local.dummy notsolid
local.dummy hide
local.dummy.origin = local.self.origin

//*** set temp variables
local.spawn_origin = local.self.origin
local.spawn_origin[2] += 32
local.spawn_targetname = (local.self.targetname + "_explosive_" + local.index)
local.spawn_smoke_targetname = (local.self.targetname + "_smoke_" + local.index)

if (local.self.dmg != NIL)
{
	local.dmg = local.self.dmg
}
else
{
	local.dmg = 250
}

if (local.self.radius != NIL)
{
	local.radius = local.self.radius
}
else
{
	local.radius = 256
}

if (self.script_health != NIL)
{
	self.health = self.script_health
}
else
{
	self.health = 1
}

//*** wait till the barrel is destroyed
local.self waittill death

	//*** if a thread is set, run it and wait for it's completion
	if (self.run_thread != NIL)
        {
        	self thread level.script::self.run_thread
        }

//*** spawn the explosion and smoke for the dummy
spawn "models/fx/barrel_gas_destroyed" targetname local.spawn_targetname
local.spawn_targetname = $(local.self.targetname + "_explosive_" + local.index)

spawn "models/emitters/firesmoke" targetname local.spawn_smoke_targetname angle "-2"
local.spawn_smoke_targetname = $(local.self.targetname + "_smoke_" + local.index)

//println "BARREL LAUNCH: targetname: " local.spawn_smoke_targetname

//*** reset the explosions origin
local.spawn_targetname.origin = local.spawn_origin
local.spawn_smoke_targetname.origin = local.dummy.origin

//println "BARREL LAUNCH: dummy smoke origin: " local.spawn_smoke_targetname.origin
//println "BARREL LAUNCH: dummy origin: " local.dummy.origin
//println "BARREL LAUNCH: barrel origin[2] +32: " local.spawn_origin

//*** bind the dummy smoke to the dummy
local.spawn_smoke_targetname bind local.dummy

//*** show the dummy and execute the thread to launch it into the air
local.dummy show
local.dummy thread explosive_barrel_launch_dummy_fly

local.spawn_targetname anim idle

/*
//*** get the distance to the player
local.distance = vector_length (local.self.origin - $player.origin)
local.check_distance = (local.radius * 1.5)
local.outter_distance = (local.radius * 2.5)

//*** shake his view
if (local.distance <= local.check_distance)  //*** inner distance check
{
	if (local.dmg <= 150)
        {
        	thread jitter_small
        }
	else
	{
		thread jitter_normal
	}
}
else if (local.distance <= local.outter_distance)  //*** outter distance check
{
	if (local.dmg <= 150)
        {
        	thread jitter_tiny
        }
	else
	{
		thread jitter_small
	}
}
*/

wait level.damage_delay  // wait a bit so barrels stagger

//*** damage the player  <origin> <damage> <radius> [consitent]
radiusdamage local.spawn_targetname.origin local.dmg local.radius

wait (randomint 3 + 4)

//*** delete the effect out of the world now that it's done
local.spawn_targetname remove

//added by Z. dont emit smoke forever
wait 10
local.spawn_smoke_targetname remove

explosive_barrel_launch_spawn_end:
end


//**************************************************************************
//*** thread for making the exploding luncher dummy barrels fly fly fly.....
//*** syntax --------------------------------
//*** <dummy barrel> explosive_barrel_launch_dummy_fly
//**************************************************************************
explosive_barrel_launch_dummy_fly:

//*** grab it's starting position
local.start = local.self.origin

//*** see if the scripter wants a different min height than default
if (local.self.min_height != NIL)
{
	local.fly_min_height = local.self.min_height
}
else
{
	local.fly_min_height = 500
} 

//println "BARREL LAUNCH FLY: fly min height: " local.fly_min_height

//*** see if the scripter wants a different max height than default
if (local.self.max_height != NIL)
{
	local.fly_max_height = local.self.max_height - local.fly_min_height
	local.fly_max_height ++
	if (local.fly_max_height < 0)
        {
        	println "^~^~^ Maximum desired height is lower than minimum desired height!!!  Setting to 0"
		local.fly_max_height = 1
        }
}
else
{
	local.fly_max_height = 151
}

//println "BARREL LAUNCH FLY: fly max height: " local.fly_max_height

//*** calculate the target vector for it to fly on
local.fly_vector = (0 0 0)
local.fly_vector[0] = ((randomint 96) - 48)
local.fly_vector[1] = ((randomint 96) - 48)
local.fly_vector[2] = (randomint local.fly_max_height + local.fly_min_height)

//println "BARREL LAUNCH FLY: dummy fly vector heigth: " local.fly_vector[2]

//*** rotate barrel to orient to the fly vector
//println "BARREL LAUNCH FLY: dummy start angles: " local.self.angles

local.start_angles = vector_toangles local.fly_vector
local.self.angles = (0 local.start_angles[1] 0)

//println "BARREL LAUNCH FLY: dummy adjusted angles: " local.self.angles
//println "BARREL LAUNCH FLY: dummy origin: " local.self.origin

//*** launch the barrel
local.self physics_velocity (local.fly_vector)
wait .2
local.self physics_on 1
local.self physics_velocity (local.fly_vector)

//*** make it solid and set the motion flag for rotation
local.self solid
local.inmotion = 1

//*** calculate the initial spin by first getting the top down distance moved from it's start point
local.check_start = (local.start[0] local.start[1] 0)
//println "BARREL LAUNCH FLY: check starting position, reset Z: " local.check_start
local.check_end = ((local.start[0] + local.fly_vector[0]) (local.start[1] + local.fly_vector[1]) 0)
//println "BARREL LAUNCH FLY: check fly position, reset Z: " local.check_end

local.spin_length = vector_length(local.check_start - local.check_end)
//println "BARREL LAUNCH FLY: initial spin length calculation: " local.spin_length

//*** scale the spin value up to a noticable value
local.spin_length = local.spin_length * 1.5

//*** start spinning the barrel
local.self rotatex local.spin_length

//*** check for major direction changes to adjust rotation accordingly
local.pos_prev = local.self.origin

waitframe

//*** loop to check for sharp changes in direction
while (local.inmotion == 1)
{
	//println "BARREL CHECK: pos_prev: " local.pos_prev
	//println "BARREL CHECK: pos_current: " local.self.origin 
	local.vel = local.self.origin - local.pos_prev
	//println "BARREL CHECK: velocity from past to current: " local.vel
	//println "BARREL CHECK: current angles facing: " local.self.angles
	//*** old value local.pos_next = local.self.origin + local.vel + (0 0 -1.28)
	local.pos_next = local.self.origin + local.vel + (0 0 -2)
	//println "BARREL CHECK: pos_next: " local.pos_next
	local.pos_prev = local.self.origin

	waitframe
	local.pos_diff = vector_length (local.self.origin - local.pos_next)
	//println "BARREL CHECK: pos_current after predition: " local.self.origin
	//println "BARREL CHECK: difference in prediction and actual: " local.pos_diff
	//println "BARREL CHECK: local.self.velocity: " local.self.velocity
	if (local.pos_diff > 0 && local.self.velocity != (0 0 0))
        {
        	//println "BARREL COLLISION DETECTED"
		local.vel_new = local.self.origin - local.pos_prev
		//println "BARREL COLLISION: original vel: " local.vel
		//println "BARREL COLLISION: new vel: " local.vel_new
		local.vel_diff_x = local.vel_new[0] - local.vel[0]
		//println "BARREL COLLISION: x difference: " local.vel_diff_x  
		local.vel_diff_y = local.vel_new[1] - local.vel[1]
		//println "BARREL COLLISION: y difference: " local.vel_diff_y
		local.vel_diff_z = local.vel_new[2] - local.vel[2]
		//println "BARREL COLLISION: z difference: " local.vel_diff_z
		
		//*** check for a difference on the horizontal plane
		if ((local.vel_diff_x + local.vel_diff_y) > local.vel_diff_z)
                {
                	//println "BARREL COLLISION CHECK: horizontal change detected"
                }
		
		//*** check for a difference on the vertical plane
		if (local.vel_diff_z != 0)
                {
                	//println "BARREL COLLISION CHECK: vertical change detected"
			local.spin_z = local.vel_diff_z * 5
			//*** check which direction to spin
			if ((local.self.angles[0] >= 0 && local.self.angles[0] <= 90) || (local.self.angles[0] >= 180 && local.self.angles[0] <= 270))
                        {
                        	local.self rotatex local.spin_z
                        }
			else
			{
				local.spin_z = local.spin_z * -1
				local.self rotatex local.spin_z
			}
                }
        }
	else if (local.self.velocity == (0 0 0))
	{
		//println "BARREL CHECK: the barrel has stopped moving, exiting"
		local.inmotion = 0
	}
}

//*** align the barrel with the ground
if (local.self.angles[0] >= 0 && local.self.angles[0] <= 10)
{
	local.self time .75
	local.self rotatexdownto 0
	local.self move
}
else if (local.self.angles[0] >= 350 && local.self.angles[0] < 0)
{
	local.self time .75
	local.self rotatexupto 0
	local.self move
}
else if (local.self.angles[0] >= 170 && local.self.angles[0] <= 180)
{
	local.self time .75
	local.self rotatexupto 180
	local.self move
}
else if (local.self.angles[0] >= 181 && local.self.angles[0] <= 190)
{
	local.self time .75
	local.self rotatexdownto 180
	local.self move
}
else if (local.self.angles[0] >= 11 && local.self.angles[0] <= 90)
{
	//println "BARREL ALIGN: quadrant 1 move"
	local.self physics_off
	
	//println "BARREL ALIGN: start accel"
	local.distance = 90 - local.self.angles[0]
	local.distance = local.distance / 4
	//*** accelerate the final movement
	for (local.accel = .25 ; local.accel >= .1 ; local.accel = local.accel - .05)
	{
		//println "BARREL ALIGN: rotating, local.accel: " local.accel
		local.self time local.accel
		local.self rotatexup local.distance
		local.self movedown 3
		local.self waitmove
	}
}
else if (local.self.angles[0] >= 91 && local.self.angles[0] <= 169)
{
	//println "BARREL ALIGN: quadrant 2 move"
	local.self physics_off
		
	//println "BARREL ALIGN: start accel"
	local.distance = local.self.angles[0] - 90
	local.distance = local.distance / 4
	//*** accelerate the final movement
	for (local.accel = .25 ; local.accel >= .1 ; local.accel = local.accel - .05)
	{
		//println "BARREL ALIGN: rotating, local.accel: " local.accel
		local.self time local.accel
		local.self rotatexdown local.distance
		local.self movedown 3
		local.self waitmove
	}
} 
else if (local.self.angles[0] >= 191 && local.self.angles[0] <= 269)
{
	//println "BARREL ALIGN: quadrant 3 move"
	local.self physics_off
	
	//println "BARREL ALIGN: start accel"
	local.distance = 270 - local.self.angles[0]
	local.distance = local.distance / 4
	//*** accelerate the final movement
	for (local.accel = .25 ; local.accel >= .1 ; local.accel = local.accel - .05)
	{
		//println "BARREL ALIGN: rotating, local.accel: " local.accel
		local.self time local.accel
		local.self rotatexup local.distance
		local.self movedown 3
		local.self waitmove
	}
} 
else if (local.self.angles[0] >= 270 && local.self.angles[0] <= 349)
{
	//println "BARREL ALIGN: quadrant 4 move"
	local.self physics_off
		
	//println "BARREL ALIGN: start accel"
	local.distance = local.self.angles[0] - 270
	local.distance = local.distance / 4
	//*** accelerate the final movement
	for (local.accel = .25 ; local.accel >= .1 ; local.accel = local.accel - .05)
	{
		//println "BARREL ALIGN: rotating, local.accel: " local.accel
		local.self time local.accel
		local.self rotatexdown local.distance
		local.self movedown 3
		local.self waitmove
	}
} 

end


//*******************************
// random positive / negative choice
//*******************************
random_sign:

local.choice = (randomint 3 - 1)

if (local.choice == 0)
{
	goto random_sign
}

end local.choice


//******************************
// jitter effect
// jitter_normal
//******************************
jitter_normal:

waitexec global/earthquake.scr .4 3 0 0

waitexec global/earthquake.scr .5 1 0 0

//waitexec global/earthquake.scr .5 1 0 0

end


//*********************************
// jitter effect
// jitter_small
//*********************************
jitter_small:

waitexec global/earthquake.scr .3 1.5 0 0

waitexec global/earthquake.scr .35 .75 0 0

//waitexec global/earthquake.scr .5 1 0 0

end


//*********************************
// jitter effect
// jitter_tiny
//*********************************
jitter_tiny:

waitexec global/earthquake.scr 1 .3 0 0

//waitexec global/earthquake.scr .5 1 0 0

end
```

# zz_veersmods\global\BAS\baseassault.scr

```scr
main:

	level.bas = waitthread check_gametype
	if (level.bas != 1)
	{
		waitthread change_gametypestring
		end
	}

	level waittill spawn

	local.check_map = waitthread global/BAS/maps.scr::check_map
	if (local.check_map != 1)
		end

	level.dmrespawning = 1 // 1 or 0
	level.dmroundlimit = 30 // round time limit in minutes
	level.clockside = draw // set to axis, allies, kills, or draw

	level.bas_roundstarted = 0
	level.bas_roundend = 0

	while (level.bas_roundstarted != 1)
		wait 1

	thread baseassault_setup

end

baseassault_setup:

	// Objective
	setcvar "g_obj_alliedtext1" "Destroy the Axis" 
	setcvar "g_obj_alliedtext2" "bases and"
	setcvar "g_obj_alliedtext3" "detonate them!"
	setcvar "g_obj_axistext1" "Destroy the Allied"
	setcvar "g_obj_axistext2" "bases and"
	setcvar "g_obj_axistext3" "detonate them!"

	if ( getcvar "bas_planting_time" == "" )
		setcvar "bas_planting_time" "15" // default 15s

	if ( getcvar "bas_defusing_time" == "" )
		setcvar "bas_defusing_time" "10" // default 10s

	if ( getcvar "bas_countdown" == "" )
		setcvar "bas_countdown" "60" // default 60s

	level.bomb_planting_time = ( int ( getcvar "bas_planting_time" ) ) * 10
	level.bomb_defusing_time = ( int ( getcvar "bas_defusing_time" ) ) * 10
	level.bomb_countdown = int ( getcvar "bas_countdown" )

	if (level.bomb_planting_time > 600)
		level.bomb_planting_time = 600

	if (level.bomb_defusing_time > 600)
		level.bomb_defusing_time = 600

	if (level.bomb_countdown > 600)
		level.bomb_countdown = 600

	thread global/BAS/huds.scr::init_hud
	thread round_time

end

spawn_base local.origin local.angles local.team local.z:

	if ( local.z == NIL || local.z == NULL )
		local.z = 0

	if (local.team == "allies")
	{
		if (level.allies_bas_id == NIL)
			level.allies_bas_id = 0

		if (level.allies_bases_to_destroy == NIL)
			level.allies_bases_to_destroy = 0

		level.allies_bas_id++
		level.allies_bases_to_destroy++

		if (level.allies_bas_id > 3)
		{
			level.allies_bas_id = 3
			level.allies_bases_to_destroy = 3

			end
		}

		local.bas_id = level.allies_bas_id
		local.model = "models/vehicles/shermantank.tik"
		local.d_model = "models/vehicles/shermantank_damaged.tik"
		local.size1 = ( -295 -75 0 )
		local.size2 = ( 25 75 150 )
	}
	else if (local.team == "axis")
	{
		if (level.axis_bas_id == NIL)
			level.axis_bas_id = 0

		if (level.axis_bases_to_destroy == NIL)
			level.axis_bases_to_destroy = 0

		level.axis_bas_id++
		level.axis_bases_to_destroy++

		if (level.axis_bas_id > 3)
		{
			level.axis_bas_id = 3
			level.axis_bases_to_destroy = 3

			end
		}

		local.bas_id = level.axis_bas_id
		local.model = "models/vehicles/tigertank.tik"
		local.d_model = "models/vehicles/tigertank_d.tik"
		local.size1 = ( -180 -103 0 )
		local.size2 = ( 180 103 104 )
		local.turret_size1 = ( -80 -55 0 )
		local.turret_size2 = ( 72 55 48 )
	}

	local.trace = trace ( local.origin + ( 0 0 10 ) ) ( ( local.origin[0] local.origin[1] -17123 ) )

	local.base = spawn VehicleTank model local.model
	local.base.targetname = ( local.team + "_base_" + local.bas_id )
	local.base.origin = local.trace
	local.base.angles = local.angles
	local.base.bas_id = local.bas_id
	local.base.dmteam = local.team
	local.base.d_model = local.d_model
	local.base.size1 = local.size1
	local.base.size2 = local.size2
	local.base.planting_player = NULL

	local.base setsize local.base.size1 local.base.size2

	local.base.gun = local.base queryturretslotentity 0
	local.base.gun2 = local.base queryturretslotentity 1

	if (local.base.gun)
	{
		local.base.gun setsize local.turret_size1 local.turret_size2

		local.base.gun lock
		local.base.gun removeondeath 0
		local.base.gun takedamage
		local.base.gun solid

		local.base.gun.isbase = 1
		local.base.gun.base = local.base
	}

	if (local.base.gun2)
	{
		local.base detachturretslot 1 local.base.gun2.origin
		local.base.gun2 remove
	}

	local.base.maxhealth = level.base_health
	local.base.fakehealth = local.base.maxhealth
	local.base.isbase = 1
	local.base.destroyed = 0

	local.base lock
	local.base lockmovement
	local.base removeondeath 0
	local.base takedamage
	local.base solid

	local.base thread base_org local.z
	local.base thread global/BAS/huds.scr::base_icon

	local.base exec global/AA/immunities.scr

end

base_org local.z:

	wait 1

	self.base_org = spawn script_origin origin ( self.origin + ( 0 0 local.z ) ) angles self.angles
	self glue self.base_org

end

damage_monitor local.target local.inflictor local.damage local.position local.direction local.normal local.knockback local.damageflags local.meansofdeath local.location:

	local.team = self.dmteam

	if ( level.bas_roundstarted != 1 || level.bas_roundend == 1 )
		end

	if ( local.inflictor == NIL || local.inflictor == NULL )
		end

	if ( local.inflictor.isplayer != 1 || local.inflictor.dmteam == local.team )
		end

	if ( local.meansofdeath != 14 && local.meansofdeath != 16 )
		end

	if ( local.target != NIL && local.target != NULL && ( local.target.targetname == "nebelwerfer_proj" || local.target.targetname == "mortarshell" ) )
		end

	if ( self.fakehealth <= 0 || self.destroyed == 1 )
		end

	self.fakehealth -= local.damage

	self waitthread global/BAS/huds.scr::update_health_hud

	if (self.fakehealth <= 0)
	{
		self.fakehealth = 0
		self.icon_blinking = 0

		local.inflictor addKills 8

		exec global/BAS/scores.scr local.inflictor.dmteam local.inflictor 4

		self thread damaged_base

		end
	}

	if (self.icon_blinking != 1)
		self thread global/BAS/huds.scr::blink_base_icon

end

damaged_base:

	self.exp = spawn script_model model "models/emitters/explosion_tank.tik"
	self.exp notsolid

	if (self.dmteam == "allies")
	{
		self.exp.origin = self.origin + angles_toforward self.angles * -150 + ( 0 0 50 )

		self.fire[1] = spawn script_model model "models/emitters/fire.tik"
		self.fire[1].origin = self.origin + angles_toforward self.angles * -40 + ( 0 0 60 )
		self.fire[1] notsolid

		self.fire[2] = spawn script_model model "models/emitters/fire.tik"
		self.fire[2].origin = self.origin + angles_toforward self.angles * -250 + ( 0 0 70 )
		self.fire[2] notsolid

		local.bomb_origin = self.origin + angles_toforward self.angles * 40
	}
	else
	{
		self.exp.origin = self.origin + ( 0 0 50 )

		self.fire[1] = spawn script_model model "models/emitters/fire.tik"
		self.fire[1].origin = self.origin + angles_toforward self.angles * 110 + ( 0 0 80 )
		self.fire[1] notsolid

		self.fire[2] = spawn script_model model "models/emitters/fire.tik"
		self.fire[2].origin = self.origin + angles_toforward self.angles * -95 + ( 0 0 80 )

		local.bomb_origin = self.origin + angles_toforward self.angles * 210
	}

	self.exp anim start

	radiusdamage ( self.origin + ( 0 0 150 ) ) 600 400

	self nodamage

	local.bomb_origin = trace ( local.bomb_origin + angles_toup self.angles * 200 ) ( local.bomb_origin + angles_toup self.angles * -2000 )
	local.bomb_angles = ( 0 (self.angles[1] - 90) 0 )

	self.bomb = spawn script_model model "models/items/pulse_explosive.tik" origin local.bomb_origin angles local.bomb_angles
	self.bomb notsolid
	self.bomb.planted = 0

	self.bomb.trigger = spawn trigger_use origin self.bomb.origin angles self.bomb.angles
	self.bomb.trigger setsize ( -5 -5 0 ) ( 5 5 30 )
	self.bomb.trigger.base = self
	self.bomb.trigger setthread damaged_base_bomb

end

damaged_base_bomb:

	local.player = parm.other

	if ( local.player.velocity != ( 0 0 0 ) )
		end

	self nottriggerable

	local.bomb = self.base.bomb
	local.team = self.base.dmteam

	if (local.bomb.planted != 1)
	{
		if (local.player.dmteam == local.team)
		{
			self triggerable
			end
		}

		local.count = level.bomb_planting_time
		if (local.player.isengineer == 1)
			local.count = local.count - 50 // -5s

		if ( local.player.reduced_bombtime == 1 && local.count > 30 )
			local.count = 30

		if (local.count < 10)
			local.count = 10 // minimum 1s

		local.player.bas_bomb = 1

		self.base thread global/BAS/huds.scr::bomb_planting_hud local.player local.bomb
	}
	else
	{
		if (local.player.dmteam != local.team)
		{
			self triggerable
			end
		}

		local.count = level.bomb_defusing_time
		if (local.player.isengineer == 1)
			local.count = local.count - 30 // -3s

		if ( local.player.reduced_bombtime == 1 && local.count > 30 )
			local.count = 30

		if (local.count < 10)
			local.count = 10 // minimum 1s

		local.player.bas_bomb = 1

		self.base thread global/BAS/huds.scr::bomb_defusing_hud local.player local.bomb
	}

	local.player stopwatch (local.count * .1)

	if (local.player.has_weapon == 1)
	{
		local.player deactivateweapon righthand
		local.player.has_weapon = 0
	}

	while ( self.base.destroyed != 1 && local.player != NULL && local.player.player_spawned == 1 && local.player.useheld && local.player.velocity == ( 0 0 0 ) && local.player.has_weapon != 1 && local.count > 0 && level.bas_roundend != 1 )
	{
		wait .1
		local.count--
	}

	if (local.player != NULL)
	{
		local.player.bas_bomb = 0
		local.player stopwatch 0
	}
	else
		local.count = 1

	if (level.bas_roundend == 1)
		end

	if (self.base.destroyed == 1)
		local.count = 1

	local.bas_id = self.base.bas_id

	if (local.count == 0)
	{
		if (local.bomb.planted != 1)
		{
			local.bomb.planted = 1
			self.base.planting_player = local.player

			local.bomb model "models/items/explosive.tik"

			local.bomb playsound plantbomb1

			if (self.base.dmteam == "allies")
			{
				local.bombhud_id = level.allies_bombhud_id + (local.bas_id - 1)
				level.allies_bombhud_alpha[local.bas_id] = 2.0

				huddraw_alpha local.bombhud_id level.allies_bombhud_alpha[local.bas_id]
			}
			else if (self.base.dmteam == "axis")
			{
				local.bombhud_id = level.axis_bombhud_id + (local.bas_id - 1)
				level.axis_bombhud_alpha[local.bas_id] = 2.0

				huddraw_alpha local.bombhud_id level.axis_bombhud_alpha[local.bas_id]
			}

			self.base thread global/BAS/huds.scr::bomb_countdown local.bomb local.player
		}
		else
		{
			local.bomb.planted = 0

			local.bomb model "models/items/pulse_explosive.tik"

			local.bomb playsound m1l2b_disabletruck

			if (self.base.dmteam == "allies")
			{
				local.bombhud_id = level.allies_bombhud_id + (local.bas_id - 1)
				level.allies_bombhud_alpha[local.bas_id] = 0.0

				local.wirecutterhud_id = level.allies_wirecutterhud_id + (local.bas_id - 1)
				level.allies_wirecutterhud_alpha[local.bas_id] = 0.0

				local.bombtimehud_id = level.allies_bombtimehud_id + (local.bas_id - 1)
				level.allies_bombtimehud_alpha[local.bas_id] = 0.0

				huddraw_alpha local.bombhud_id level.allies_bombhud_alpha[local.bas_id]
				huddraw_alpha local.wirecutterhud_id level.allies_wirecutterhud_alpha[local.bas_id]
				huddraw_alpha local.bombtimehud_id level.allies_bombtimehud_alpha[local.bas_id]

				local.player playsound bas_allies_defused
			}
			else if (self.base.dmteam == "axis")
			{
				local.bombhud_id = level.axis_bombhud_id + (local.bas_id - 1)
				level.axis_bombhud_alpha[local.bas_id] = 0.0

				local.wirecutterhud_id = level.axis_wirecutterhud_id + (local.bas_id - 1)
				level.axis_wirecutterhud_alpha[local.bas_id] = 0.0

				local.bombtimehud_id = level.axis_bombtimehud_id + (local.bas_id - 1)
				level.axis_bombtimehud_alpha[local.bas_id] = 0.0

				huddraw_alpha local.bombhud_id level.axis_bombhud_alpha[local.bas_id]
				huddraw_alpha local.wirecutterhud_id level.axis_wirecutterhud_alpha[local.bas_id]
				huddraw_alpha local.bombtimehud_id level.axis_bombtimehud_alpha[local.bas_id]

				local.player playsound bas_axis_defused
			}
		}

		local.player addKills 2
		local.player thread global/AA/reward_store.scr::give_cash 7
	}
	else
	{
		if (local.bomb.planted != 1)
		{
			if (self.base.dmteam == "allies")
			{
				local.bombhud_id = level.allies_bombhud_id + (local.bas_id - 1)
				level.allies_bombhud_alpha[local.bas_id] = 0.0

				huddraw_alpha local.bombhud_id level.allies_bombhud_alpha[local.bas_id]
			}
			else if (self.base.dmteam == "axis")
			{
				local.bombhud_id = level.axis_bombhud_id + (local.bas_id - 1)
				level.axis_bombhud_alpha[local.bas_id] = 0.0

				huddraw_alpha local.bombhud_id level.axis_bombhud_alpha[local.bas_id]
			}
		}
		else
		{
			if (self.base.dmteam == "allies")
			{
				local.wirecutterhud_id = level.allies_wirecutterhud_id + (local.bas_id - 1)
				level.allies_wirecutterhud_alpha[local.bas_id] = 0.0

				huddraw_alpha local.wirecutterhud_id level.allies_wirecutterhud_alpha[local.bas_id]
			}
			else if (self.base.dmteam == "axis")
			{
				local.wirecutterhud_id = level.axis_wirecutterhud_id + (local.bas_id - 1)
				level.axis_wirecutterhud_alpha[local.bas_id] = 0.0

				huddraw_alpha local.wirecutterhud_id level.axis_wirecutterhud_alpha[local.bas_id]
			}
		}
	}

	wait .5

	if (self.destroyed != 1)
		self triggerable

end

destroyed_base:

	self.destroyed = 1

	if ( self.planting_player != NULL && self.planting_player.dmteam != self.dmteam && self.planting_player.dmteam != "spectator" )
		self.planting_player addKills 10

	if (self.dmteam == "allies")
		local.team = "axis"
	else if (self.dmteam == "axis")
		local.team = "allies"

	exec global/BAS/scores.scr local.team self.planting_player 5

	thread add_base_cash local.team self.bas_id

	if (self.dmteam == "allies")
	{
		local.bombhud_id = level.allies_bombhud_id + (self.bas_id - 1)
		level.allies_bombhud_alpha[self.bas_id] = 2.0

		local.x = level.allies_x_bomb + 3
		if (self.bas_id > 1)
			local.x += 36 * (self.bas_id - 1)

		huddraw_rect local.bombhud_id local.x 153 0 0
		huddraw_color local.bombhud_id level.basehealth_color_red[0] level.basehealth_color_red[1] level.basehealth_color_red[2]
		huddraw_font local.bombhud_id "handle-23"
		huddraw_string local.bombhud_id "X"
		huddraw_alpha local.bombhud_id level.allies_bombhud_alpha[self.bas_id]
	}
	else if (self.dmteam == "axis")
	{
		local.bombhud_id = level.axis_bombhud_id + (self.bas_id - 1)
		level.axis_bombhud_alpha[self.bas_id] = 2.0

		local.x = level.axis_x_bomb + 3
		if (self.bas_id > 1)
			local.x += 36 * (self.bas_id - 1)

		huddraw_rect local.bombhud_id local.x 153 0 0
		huddraw_color local.bombhud_id level.basehealth_color_red[0] level.basehealth_color_red[1] level.basehealth_color_red[2]
		huddraw_font local.bombhud_id "handle-23"
		huddraw_string local.bombhud_id "X"
		huddraw_alpha local.bombhud_id level.axis_bombhud_alpha[self.bas_id]
	}

	thread check_win self.dmteam

	self.bomb.trigger nottriggerable
	self.bomb hide

	self.exp2 = spawn script_model model "models/animate/wall_exploder.tik" scale 3.0
	self.exp2 notsolid

	self.exp3 = spawn script_model model "models/emitters/explosion_bombmetalwall.tik" scale 1.0
	self.exp3 notsolid

	self hide
	self notsolid

	if (self.gun)
	{
		self detachturretslot 0 self.gun.origin
		self.gun remove
	}

	local.damaged = spawn script_model model self.d_model

	if (self.dmteam == "allies")
		local.damaged.origin = self.origin + angles_toforward self.angles * -155
	else if (self.dmteam == "axis")
		local.damaged.origin = self.origin

	local.damaged.angles = self.angles
	local.damaged.destroyed = 1

	if (self.dmteam == "axis")
		local.damaged setsize self.size1 self.size2

	local.damaged solid
	local.damaged nodamage

	self.base_org.origin = local.damaged.origin
	self.base_org.angles = local.damaged.angles
	local.damaged glue self.base_org

	for (local.i = 1;local.i <= self.fire.size;local.i++)
	{
		self.fire[local.i] remove
	}

	for (local.i = 1;local.i <= self.base_icon.size;local.i++)
	{
		self.base_icon[local.i] deactivate
		self.base_icon[local.i] remove
	}

	self.exp.origin = self.bomb.origin
	self.exp2.origin = local.damaged.origin + ( 0 0 50 )
	self.exp3.origin = local.damaged.origin + ( 0 0 50 )

	waitframe

	self unglue

	self.exp anim start
	self.exp2 anim start
	self.exp3 anim start

	radiusdamage ( local.damaged.origin + ( 0 0 150 ) ) 800 400

	waitexec global/earthquake.scr 1.25 0.6 0 1

	wait 3

	local.damaged.targetname = self.targetname

	self.exp remove
	self.exp2 remove
	self.exp3 remove

	self.bomb.trigger remove
	self.bomb remove
	self remove

end

base_destruction_cash local.team local.id:

	if (level.account != 1)
		end

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.player = $player[local.i]

		if ( local.player != NULL && local.player.isplayer == 1 && local.player.dmteam == local.team )
		{
			if (local.players == NIL)
				local.players[1] = local.player
			else
				local.players[local.players.size + 1] = local.player
		}
	}

	if ( local.players != NIL && local.players != NULL )
	{
		if (local.team == "allies")
		{
			switch (local.id)
			{
				case "1":
					level.allies_base_1_cash_players = local.players
				break
				case "2":
					level.allies_base_2_cash_players = local.players
				break
				case "3":
					level.allies_base_3_cash_players = local.players
				break
			}
		}
		else if (local.team == "axis")
		{
			switch (local.id)
			{
				case "1":
					level.axis_base_1_cash_players = local.players
				break
				case "2":
					level.axis_base_2_cash_players = local.players
				break
				case "3":
					level.axis_base_3_cash_players = local.players
				break
			}
		}
	}

end

add_base_cash local.team local.id:

	if (level.account != 1)
		end

	if (local.team == "allies")
	{
		switch (local.id)
		{
			case "1":
				local.players = level.allies_base_1_cash_players
			break
			case "2":
				local.players = level.allies_base_2_cash_players
			break
			case "3":
				local.players = level.allies_base_3_cash_players
			break
		}
	}
	else if (local.team == "axis")
	{
		switch (local.id)
		{
			case "1":
				local.players = level.axis_base_1_cash_players
			break
			case "2":
				local.players = level.axis_base_2_cash_players
			break
			case "3":
				local.players = level.axis_base_3_cash_players
			break
		}
	}

	if ( local.players != NIL && local.players != NULL )
	{
		for (local.i = 1;local.i <= local.players.size;local.i++)
		{
			local.player = local.players[local.i]

			if ( local.player != NULL && local.player.dmteam == local.team && local.player.logged_in == 1 )
			{
				local.player thread global/AA/reward_store.scr::give_cash 15
			}
		}
	}

end

round_time:

	local.starttime = level.time

	while (level.bas_roundend != 1)
	{
		wait 1

		local.roundlimit = level.dmroundlimit * 60
		local.time = level.time - local.starttime

		if ( local.time >= local.roundlimit - 1 )
			break
	}

	if (level.bas_roundend == 1)
		end

	level.bas_roundend = 1

	if (level.allies_bases_to_destroy < level.axis_bases_to_destroy)
		teamwin axis
	else if (level.allies_bases_to_destroy > level.axis_bases_to_destroy)
		teamwin allies

	thread global/BAS/huds.scr::remove_huds
	
end

check_win local.team:

	if (local.team == "allies")
	{
		level.allies_bases_to_destroy--
		if (level.allies_bases_to_destroy == 0)
		{
			level.bas_roundend = 1
			teamwin axis

			thread global/BAS/huds.scr::remove_huds
		}
	}
	else if (local.team == "axis")
	{
		level.axis_bases_to_destroy--
		if (level.axis_bases_to_destroy == 0)
		{
			level.bas_roundend = 1
			teamwin allies

			thread global/BAS/huds.scr::remove_huds
		}
	}

end

check_gametype:

	local.bas = getcvar "g_bas"
	if (local.bas == "")
		setcvar "g_bas" "0"

	local.bas = int ( getcvar "g_bas" )
	if (local.bas == 0)
		end 0

	local.gt = int ( getcvar "g_gametype" )
	if (local.gt < 3)
		end 0

	setcvar "g_gametypestring" "Base Assault"

	local.base_health = getcvar "base_health"
	if (local.base_health == "")
		setcvar "base_health" "10000"

	level.base_health = int ( getcvar "base_health" )

end 1

change_gametypestring:

	local.gt = getcvar "g_gametype"
	local.gts = getcvar "g_gametypestring"

	if (local.gts == "Base Assault")
	{
		local.string = "Multiplayer"

		switch (local.gt)
		{
			case "1":
				local.string = "Free-For-All"
			break
			case "2":
				local.string = "Team-Match"
			break
			case "3":
				local.string = "Round-Based-Match"
			break
			case "4":
				local.string = "Objective-Match"
			break
		}

		setcvar "g_gametypestring" local.string
	}

end

```

# zz_veersmods\global\BAS\huds.scr

```scr
init_hud:

	level.allies_iconhud_id = 220
	level.allies_stringhud_id = 223
	level.allies_healthhud_id = 226
	level.allies_bombhud_id = 229
	level.allies_wirecutterhud_id = 232
	level.allies_bombtimehud_id = 235
	level.allies_x_icon = 192
	level.allies_x_string = 202
	level.allies_x_health = 193
	level.allies_x_bomb = 195
	level.allies_x_wirecutter = 195
	level.allies_x_bombtime = 189

	level.axis_iconhud_id = 238
	level.axis_stringhud_id = 241
	level.axis_healthhud_id = 244
	level.axis_bombhud_id = 247
	level.axis_wirecutterhud_id = 250
	level.axis_bombtimehud_id = 253
	level.axis_x_icon = 350
	level.axis_x_string = 360
	level.axis_x_health = 351
	level.axis_x_bomb = 353
	level.axis_x_wirecutter = 353
	level.axis_x_bombtime = 347

	level.allies_color = ( 0.23 0.42 0.96 )
	level.axis_color = ( 1.0 0.2 0.2 )

	level.basehealth_color_green = ( 0.02 0.64 0.02 )
	level.basehealth_color_orange = ( 0.84 0.47 0.0 )
	level.basehealth_color_red = ( 1.0 0.0 0.0 )

	level.bas_huds = 1

	thread refresh_huds 2

end

refresh_huds local.wait:

	wait local.wait

	if (level.bas_roundend == 1)
		end

	// Allies Huds
	local.iconhud_id = level.allies_iconhud_id
	local.stringhud_id = level.allies_stringhud_id
	local.healthhud_id = level.allies_healthhud_id
	local.bombhud_id = level.allies_bombhud_id
	local.wirecutterhud_id = level.allies_wirecutterhud_id
	local.bombtimehud_id = level.allies_bombtimehud_id

	local.x_icon = level.allies_x_icon
	local.x_string = level.allies_x_string
	local.x_health = level.allies_x_health
	local.x_bomb = level.allies_x_bomb
	local.x_wirecutter = level.allies_x_wirecutter
	local.x_bombtime = level.allies_x_bombtime

	for (local.i = 1;local.i <= level.allies_bas_id;local.i++)
	{
		local.tname = "allies_base_" + local.i
		local.base = $(local.tname)

		if (local.base == NULL)
			continue

		if (level.allies_iconhud_alpha[local.i] == NIL)
			level.allies_iconhud_alpha[local.i] = 1.0

		huddraw_align local.iconhud_id left center
		huddraw_rect local.iconhud_id local.x_icon 165 26 26
		huddraw_color local.iconhud_id 1 1 1
		huddraw_shader local.iconhud_id "textures/hud/allies"
		huddraw_virtualsize local.iconhud_id 1
		huddraw_alpha local.iconhud_id level.allies_iconhud_alpha[local.i]

		huddraw_align local.stringhud_id left center
		huddraw_rect local.stringhud_id local.x_string 183 0 0
		huddraw_color local.stringhud_id level.allies_color[0] level.allies_color[1] level.allies_color[2]
		huddraw_font local.stringhud_id "facfont-20"
		huddraw_string local.stringhud_id local.i
		huddraw_virtualsize local.stringhud_id 1
		huddraw_alpha local.stringhud_id 1.0

		if (level.allies_healthhud_alpha[local.i] == NIL)
			level.allies_healthhud_alpha[local.i] = 1.0

		if (level.allies_healthhud_max_x[local.i] == NIL)
			level.allies_healthhud_max_x[local.i] = 24

		if (level.allies_healthhud_x[local.i] == NIL)
			level.allies_healthhud_x[local.i] = level.allies_healthhud_max_x[local.i]

		huddraw_align local.healthhud_id left center
		huddraw_shader local.healthhud_id "textures/common/white"
		huddraw_virtualsize local.healthhud_id 1
		huddraw_alpha local.healthhud_id level.allies_healthhud_alpha[local.i]

		if (level.allies_healthhud_alpha[local.i] != 0.0)
			local.base waitthread update_health_hud

		if (level.allies_bombhud_alpha[local.i] == NIL)
			level.allies_bombhud_alpha[local.i] = 0.0

		huddraw_align local.bombhud_id left center

		if (local.base.destroyed != 1)
		{
			huddraw_rect local.bombhud_id local.x_bomb 165 20 20
			huddraw_color local.bombhud_id 1 1 1
			huddraw_shader local.bombhud_id "textures/hud/explosives"
		}
		else
		{
			huddraw_rect local.bombhud_id (local.x_bomb + 3) 153 0 0
			huddraw_color local.bombhud_id level.basehealth_color_red[0] level.basehealth_color_red[1] level.basehealth_color_red[2]
			huddraw_font local.bombhud_id "handle-23"
			huddraw_string local.bombhud_id "X"
		}

		huddraw_virtualsize local.bombhud_id 1
		huddraw_alpha local.bombhud_id level.allies_bombhud_alpha[local.i]

		if (level.allies_wirecutterhud_alpha[local.i] == NIL)
			level.allies_wirecutterhud_alpha[local.i] = 0.0

		huddraw_align local.wirecutterhud_id left center
		huddraw_rect local.wirecutterhud_id local.x_wirecutter 165 20 20
		huddraw_color local.wirecutterhud_id 1 1 1
		huddraw_shader local.wirecutterhud_id "textures/hud/wirecutters"
		huddraw_virtualsize local.wirecutterhud_id 1
		huddraw_alpha local.wirecutterhud_id level.allies_wirecutterhud_alpha[local.i]

		if (level.allies_bombtimehud_alpha[local.i] == NIL)
			level.allies_bombtimehud_alpha[local.i] = 0.0

		huddraw_align local.bombtimehud_id left center
		huddraw_rect local.bombtimehud_id local.x_bombtime 138 0 0
		huddraw_color local.bombtimehud_id level.allies_color[0] level.allies_color[1] level.allies_color[2]
		huddraw_font local.bombtimehud_id "verdana-12"
		huddraw_virtualsize local.bombtimehud_id 1
		huddraw_alpha local.bombtimehud_id level.allies_bombtimehud_alpha[local.i]

		local.iconhud_id++
		local.stringhud_id++
		local.healthhud_id++
		local.bombhud_id++
		local.wirecutterhud_id++
		local.bombtimehud_id++

		local.x_icon += 36
		local.x_string += 36
		local.x_health += 36
		local.x_bomb += 36
		local.x_wirecutter += 36
		local.x_bombtime += 36
	}

	// Axis Huds
	local.iconhud_id = level.axis_iconhud_id
	local.stringhud_id = level.axis_stringhud_id
	local.healthhud_id = level.axis_healthhud_id
	local.bombhud_id = level.axis_bombhud_id
	local.wirecutterhud_id = level.axis_wirecutterhud_id
	local.bombtimehud_id = level.axis_bombtimehud_id

	local.x_icon = level.axis_x_icon
	local.x_string = level.axis_x_string
	local.x_health = level.axis_x_health
	local.x_bomb = level.axis_x_bomb
	local.x_wirecutter = level.axis_x_wirecutter
	local.x_bombtime = level.axis_x_bombtime

	for (local.i = 1;local.i <= level.axis_bas_id;local.i++)
	{
		local.tname = "axis_base_" + local.i
		local.base = $(local.tname)

		if (local.base == NULL)
			continue

		if (level.axis_iconhud_alpha[local.i] == NIL)
			level.axis_iconhud_alpha[local.i] = 1.0

		huddraw_align local.iconhud_id left center
		huddraw_rect local.iconhud_id local.x_icon 165 26 26
		huddraw_color local.iconhud_id 1 1 1
		huddraw_shader local.iconhud_id "textures/hud/axis"
		huddraw_virtualsize local.iconhud_id 1
		huddraw_alpha local.iconhud_id level.axis_iconhud_alpha[local.i]

		huddraw_align local.stringhud_id left center
		huddraw_rect local.stringhud_id local.x_string 183 0 0
		huddraw_color local.stringhud_id level.axis_color[0] level.axis_color[1] level.axis_color[2]
		huddraw_font local.stringhud_id "facfont-20"
		huddraw_string local.stringhud_id local.i
		huddraw_virtualsize local.stringhud_id 1
		huddraw_alpha local.stringhud_id 1.0

		if (level.axis_healthhud_alpha[local.i] == NIL)
			level.axis_healthhud_alpha[local.i] = 1.0

		if (level.axis_healthhud_max_x[local.i] == NIL)
			level.axis_healthhud_max_x[local.i] = 24

		if (level.axis_healthhud_x[local.i] == NIL)
			level.axis_healthhud_x[local.i] = level.axis_healthhud_max_x[local.i]

		huddraw_align local.healthhud_id left center
		huddraw_shader local.healthhud_id "textures/common/white"
		huddraw_virtualsize local.healthhud_id 1
		huddraw_alpha local.healthhud_id level.axis_healthhud_alpha[local.i]

		if (level.axis_healthhud_alpha[local.i] != 0.0)
			local.base waitthread update_health_hud

		if (level.axis_bombhud_alpha[local.i] == NIL)
			level.axis_bombhud_alpha[local.i] = 0.0

		huddraw_align local.bombhud_id left center

		if (local.base.destroyed != 1)
		{
			huddraw_rect local.bombhud_id local.x_bomb 165 20 20
			huddraw_color local.bombhud_id 1 1 1
			huddraw_shader local.bombhud_id "textures/hud/explosives"
		}
		else
		{
			huddraw_rect local.bombhud_id (local.x_bomb + 3) 153 0 0
			huddraw_color local.bombhud_id level.basehealth_color_red[0] level.basehealth_color_red[1] level.basehealth_color_red[2]
			huddraw_font local.bombhud_id "handle-23"
			huddraw_string local.bombhud_id "X"
		}

		huddraw_virtualsize local.bombhud_id 1
		huddraw_alpha local.bombhud_id level.axis_bombhud_alpha[local.i]

		if (level.axis_wirecutterhud_alpha[local.i] == NIL)
			level.axis_wirecutterhud_alpha[local.i] = 0.0

		huddraw_align local.wirecutterhud_id left center
		huddraw_rect local.wirecutterhud_id local.x_wirecutter 165 20 20
		huddraw_color local.wirecutterhud_id 1 1 1
		huddraw_shader local.wirecutterhud_id "textures/hud/wirecutters"
		huddraw_virtualsize local.wirecutterhud_id 1
		huddraw_alpha local.wirecutterhud_id level.axis_wirecutterhud_alpha[local.i]

		if (level.axis_bombtimehud_alpha[local.i] == NIL)
			level.axis_bombtimehud_alpha[local.i] = 0.0

		huddraw_align local.bombtimehud_id left center
		huddraw_rect local.bombtimehud_id local.x_bombtime 138 0 0
		huddraw_color local.bombtimehud_id level.axis_color[0] level.axis_color[1] level.axis_color[2]
		huddraw_font local.bombtimehud_id "verdana-12"
		huddraw_virtualsize local.bombtimehud_id 1
		huddraw_alpha local.bombtimehud_id level.axis_bombtimehud_alpha[local.i]

		local.iconhud_id++
		local.stringhud_id++
		local.healthhud_id++
		local.bombhud_id++
		local.wirecutterhud_id++
		local.bombtimehud_id++

		local.x_icon += 36
		local.x_string += 36
		local.x_health += 36
		local.x_bomb += 36
		local.x_wirecutter += 36
		local.x_bombtime += 36
	}

end

update_health_hud:

	local.team = self.dmteam
	if (local.team == "allies")
	{
		local.id = level.allies_healthhud_id
		if (self.bas_id > 1)
			local.id += (self.bas_id - 1)

		local.x = level.allies_x_health
		if (self.bas_id > 1)
			local.x += 36 * (self.bas_id - 1)
	}
	else if (local.team == "axis")
	{
		local.id = level.axis_healthhud_id
		if (self.bas_id > 1)
			local.id += (self.bas_id - 1)

		local.x = level.axis_x_health
		if (self.bas_id > 1)
			local.x += 36 * (self.bas_id - 1)
	}

	local.perc = int ( (self.fakehealth / self.maxhealth) * 100.0 )
	if (local.perc <= 0)
	{
		if (local.team == "allies")
		{
			if (level.allies_healthhud_alpha[self.bas_id] != 0.0)
			{
				level.allies_healthhud_alpha[self.bas_id] = 0.0
				huddraw_alpha local.id level.allies_healthhud_alpha[self.bas_id]
			}
		}
		else if (local.team == "axis")
		{
			if (level.axis_healthhud_alpha[self.bas_id] != 0.0)
			{
				level.axis_healthhud_alpha[self.bas_id] = 0.0
				huddraw_alpha local.id level.axis_healthhud_alpha[self.bas_id]
			}
		}

		end
	}

	if (local.perc > 66)
		local.color = level.basehealth_color_green
	else if ( local.perc <= 66 && local.perc > 33 )
		local.color = level.basehealth_color_orange
	else
		local.color = level.basehealth_color_red

	local.perc_count = int (local.perc / 10.0)
	local.perc_count++

	if (local.perc_count > 10)
		local.perc_count = 10
	else if (local.perc_count < 1)
		local.perc_count = 1

	if (local.team == "allies")
	{
		local.count = level.allies_healthhud_max_x[self.bas_id] / 10.0
		level.allies_healthhud_x[self.bas_id] = local.perc_count * local.count

		huddraw_rect local.id local.x 181 level.allies_healthhud_x[self.bas_id] 3
	}
	else if (local.team == "axis")
	{
		local.count = level.axis_healthhud_max_x[self.bas_id] / 10.0
		level.axis_healthhud_x[self.bas_id] = local.perc_count * local.count

		huddraw_rect local.id local.x 181 level.axis_healthhud_x[self.bas_id] 3
	}

	huddraw_color local.id local.color[0] local.color[1] local.color[2]

end

bomb_countdown local.bomb local.player:

	local.team = self.dmteam
	if (local.team == "allies")
	{
		local.id = level.allies_bombtimehud_id
		if (self.bas_id > 1)
			local.id += (self.bas_id - 1)

		level.allies_bombtimehud_alpha[self.bas_id] = 1.0
		huddraw_alpha local.id level.allies_bombtimehud_alpha[self.bas_id]

		local.player playsound bas_axis_planted

		thread global/BAS/baseassault.scr::base_destruction_cash "axis" self.bas_id
	}
	else if (local.team == "axis")
	{
		local.id = level.axis_bombtimehud_id
		if (self.bas_id > 1)
			local.id += (self.bas_id - 1)

		level.axis_bombtimehud_alpha[self.bas_id] = 1.0
		huddraw_alpha local.id level.axis_bombtimehud_alpha[self.bas_id]

		local.player playsound bas_allies_planted

		thread global/BAS/baseassault.scr::base_destruction_cash "allies" self.bas_id
	}

	local.one_min = 60
	local.time = level.bomb_countdown
	local.final_countdown = 0

	local.bomb loopsound bombtick1

	while ( local.time > 0 && local.bomb.planted == 1 && level.bas_roundend != 1 )
	{
		local.count = local.time
		local.min = 0

		while (local.count >= local.one_min)
		{
			local.count -= local.one_min
			if (local.count >= 0)
				local.min++
		}

		local.sec = local.count

		local.time_min = "0" + local.min
		if (local.min > 9)
			local.time_min = local.min

		local.time_sec = "0" + local.sec
		if (local.sec > 9)
			local.time_sec = local.sec

		local.total_time = local.time_min + ":" + local.time_sec

		huddraw_string local.id local.total_time

		if ( local.time == level.bomb_defusing_time / 10 && local.final_countdown != 1 )
		{
			local.final_countdown = 1

			local.bomb stoploopsound bombtick1
			local.bomb loopsound final_countdown
		}

		wait 1

		local.time--
	}

	local.bomb stoploopsound bombtick1
	local.bomb stoploopsound final_countdown

	if (level.bas_roundend == 1)
		end

	if (local.team == "allies")
	{
		if (local.bomb.planted == 1)
		{
			local.bombhud_id = level.allies_bombhud_id + (self.bas_id - 1)
			level.allies_bombhud_alpha[self.bas_id] = 0.0

			huddraw_alpha local.bombhud_id level.allies_bombhud_alpha[self.bas_id]
		}

		level.allies_bombtimehud_alpha[self.bas_id] = 0.0
		huddraw_alpha local.id level.allies_bombtimehud_alpha[self.bas_id]
	}
	else if (local.team == "axis")
	{
		if (local.bomb.planted == 1)
		{
			local.bombhud_id = level.axis_bombhud_id + (self.bas_id - 1)
			level.axis_bombhud_alpha[self.bas_id] = 0.0

			huddraw_alpha local.bombhud_id level.axis_bombhud_alpha[self.bas_id]
		}

		level.axis_bombtimehud_alpha[self.bas_id] = 0.0
		huddraw_alpha local.id level.axis_bombtimehud_alpha[self.bas_id]
	}

	if (local.bomb.planted == 1)
	{
		self thread global/BAS/baseassault.scr::destroyed_base
	}

end

blink_base_icon:

	self.icon_blinking = 1

	if (self.dmteam == "allies")
	{
		local.bas_id = self.bas_id
		local.iconhud_id = level.allies_iconhud_id + (local.bas_id - 1)

		local.count = 0
		while ( self.icon_blinking == 1 && local.count < 10 && level.bas_roundend != 1 )
		{
			if (level.allies_iconhud_alpha[local.bas_id] == 1.0)
				level.allies_iconhud_alpha[local.bas_id] = 0.0
			else if (level.allies_iconhud_alpha[local.bas_id] == 0.0)
				level.allies_iconhud_alpha[local.bas_id] = 1.0

			huddraw_alpha local.iconhud_id level.allies_iconhud_alpha[local.bas_id]

			wait .35

			local.count++
		}

		if (level.bas_roundend == 1)
			end

		level.allies_iconhud_alpha[local.bas_id] = 1.0
		huddraw_alpha local.iconhud_id level.allies_iconhud_alpha[local.bas_id]
	}
	else if (self.dmteam == "axis")
	{
		local.bas_id = self.bas_id
		local.iconhud_id = level.axis_iconhud_id + (local.bas_id - 1)

		local.count = 0
		while ( self.icon_blinking == 1 && local.count < 10 && level.bas_roundend != 1 )
		{
			if (level.axis_iconhud_alpha[local.bas_id] == 1.0)
				level.axis_iconhud_alpha[local.bas_id] = 0.0
			else if (level.axis_iconhud_alpha[local.bas_id] == 0.0)
				level.axis_iconhud_alpha[local.bas_id] = 1.0

			huddraw_alpha local.iconhud_id level.axis_iconhud_alpha[local.bas_id]

			wait .35

			local.count++
		}

		if (level.bas_roundend == 1)
			end

		level.axis_iconhud_alpha[local.bas_id] = 1.0
		huddraw_alpha local.iconhud_id level.axis_iconhud_alpha[local.bas_id]
	}

	self.icon_blinking = 0

end

bomb_planting_hud local.player local.bomb:

	if (self.dmteam == "allies")
	{
		local.bas_id = self.bas_id
		local.bombhud_id = level.allies_bombhud_id + (local.bas_id - 1)

		while ( local.player != NULL && local.player.bas_bomb == 1 && local.bomb.planted != 1 && level.bas_roundend != 1 )
		{
			if (level.allies_bombhud_alpha[local.bas_id] == 2.0)
				level.allies_bombhud_alpha[local.bas_id] = 0.0
			else if (level.allies_bombhud_alpha[local.bas_id] == 0.0)
				level.allies_bombhud_alpha[local.bas_id] = 2.0

			huddraw_alpha local.bombhud_id level.allies_bombhud_alpha[local.bas_id]

			wait .5
		}
	}
	else if (self.dmteam == "axis")
	{
		local.bas_id = self.bas_id
		local.bombhud_id = level.axis_bombhud_id + (local.bas_id - 1)

		while ( local.player != NULL && local.player.bas_bomb == 1 && local.bomb.planted != 1 && level.bas_roundend != 1 )
		{
			if (level.axis_bombhud_alpha[local.bas_id] == 2.0)
				level.axis_bombhud_alpha[local.bas_id] = 0.0
			else if (level.axis_bombhud_alpha[local.bas_id] == 0.0)
				level.axis_bombhud_alpha[local.bas_id] = 2.0

			huddraw_alpha local.bombhud_id level.axis_bombhud_alpha[local.bas_id]

			wait .5
		}
	}

end

bomb_defusing_hud local.player local.bomb:

	if (self.dmteam == "allies")
	{
		local.bas_id = self.bas_id
		local.wirecutterhud_id = level.allies_wirecutterhud_id + (local.bas_id - 1)

		while ( local.player != NULL && local.player.bas_bomb == 1 && local.bomb.planted == 1 && level.bas_roundend != 1 )
		{
			if (level.allies_wirecutterhud_alpha[local.bas_id] == 3.0)
				level.allies_wirecutterhud_alpha[local.bas_id] = 0.0
			else if (level.allies_wirecutterhud_alpha[local.bas_id] == 0.0)
				level.allies_wirecutterhud_alpha[local.bas_id] = 3.0

			huddraw_alpha local.wirecutterhud_id level.allies_wirecutterhud_alpha[local.bas_id]

			wait .5
		}
	}
	else if (self.dmteam == "axis")
	{
		local.bas_id = self.bas_id
		local.wirecutterhud_id = level.axis_wirecutterhud_id + (local.bas_id - 1)

		while ( local.player != NULL && local.player.bas_bomb == 1 && local.bomb.planted == 1 && level.bas_roundend != 1 )
		{
			if (level.axis_wirecutterhud_alpha[local.bas_id] == 3.0)
				level.axis_wirecutterhud_alpha[local.bas_id] = 0.0
			else if (level.axis_wirecutterhud_alpha[local.bas_id] == 0.0)
				level.axis_wirecutterhud_alpha[local.bas_id] = 3.0

			huddraw_alpha local.wirecutterhud_id level.axis_wirecutterhud_alpha[local.bas_id]

			wait .5
		}
	}

end

base_icon:

	local.z = 170

	for (local.i = 1;local.i <= self.bas_id;local.i++)
	{
		local.icon = spawn func_beam

		if (self.dmteam == "allies")
			local.icon.origin = self.origin + angles_toforward self.angles * -155 + angles_toup self.angles * local.z
		else
			local.icon.origin = self.origin + angles_toup self.angles * local.z

		local.icon endpoint ( local.icon.origin + angles_toup self.angles * 30 )
		local.icon minoffset 0.0
		local.icon maxoffset 0.0
		local.icon scale 10.0
		local.icon tileshader ( "textures/hud/" + self.dmteam )
		local.icon numsegments 1
		local.icon color ( 1 1 1 )
		local.icon alpha 1.0
		local.icon activate

		local.z += 30

		self.base_icon[local.i] = local.icon
	}

end

remove_huds:

	wait 1

	for (local.i = 0;local.i <= 255;local.i++)
	{
		huddraw_alpha local.i 0
	}

end

```

# zz_veersmods\global\BAS\maps.scr

```scr
check_map:

	local.mapname = getcvar "mapname"
	local.map = 0

	switch (local.mapname)
	{
		case "m1l3a":
		case "m1l3b":
		case "m4l0":
		case "m4l1":
		case "m4l3":
		case "m5l2a":
		case "m5l3":
			local.map = 1
		break
	}

	if (local.map == 1)
		thread spawn_bases local.mapname

end local.map

spawn_bases local.mapname:

	level waittill roundstart

	switch (local.mapname)
	{
		// Allied Assault bases
		case "m1l3a":
			waitthread global/BAS/baseassault.scr::spawn_base ( -90.00 -4633.00 284.00 ) ( 0 180 0 ) "allies"
			waitthread global/BAS/baseassault.scr::spawn_base ( -2857.00 -4093.00 207.00 ) ( 0 126 0 ) "allies"

			waitthread global/BAS/baseassault.scr::spawn_base ( 2400.00 -1070.00 200.00 ) ( 0 140 0 ) "axis"
			waitthread global/BAS/baseassault.scr::spawn_base ( -1306.00 -2115.00 50.00 ) ( 0 150 0 ) "axis"
		break
		case "m1l3b":
			waitthread global/BAS/baseassault.scr::spawn_base ( -30.00 -795.00 27.00 ) ( 0 180 0 ) "allies"
			waitthread global/BAS/baseassault.scr::spawn_base ( -4062.00 61.00 -23.00 ) ( 0 180 0 ) "allies"

			waitthread global/BAS/baseassault.scr::spawn_base ( -1708.00 2221.00 88.00 ) ( 0 180 0 ) "axis"
			waitthread global/BAS/baseassault.scr::spawn_base ( -2803.00 6183.00 60.00 ) ( 0 180 0 ) "axis"
		break
		case "m4l0":
			waitthread global/BAS/baseassault.scr::spawn_base ( -672.00 -5840.00 -88.00 ) ( 0 270 0 ) "allies"
			waitthread global/BAS/baseassault.scr::spawn_base ( 3848.00 -4656.00 312.00 ) ( 9 320 0 ) "allies"

			waitthread global/BAS/baseassault.scr::spawn_base ( -544.23 1268.00 258.35 ) ( 0 270 15 ) "axis" -20
			waitthread global/BAS/baseassault.scr::spawn_base ( 3889.67 -1154.40 438.27 ) ( 354 40 0 ) "axis"
		break
		case "m4l1":
			waitthread global/BAS/baseassault.scr::spawn_base ( -1051.00 -3456.00 -41.00 ) ( 0 337 0 ) "allies"
			waitthread global/BAS/baseassault.scr::spawn_base ( 906.00 -1564.00 181.00 ) ( 0 50 0 ) "allies"

			waitthread global/BAS/baseassault.scr::spawn_base ( 1130.00 829.00 112.00 ) ( 0 310 0 ) "axis"
			waitthread global/BAS/baseassault.scr::spawn_base ( 4800.00 -3200.00 231.00 ) ( 0 225 0 ) "axis"
		break
		case "m4l3":
			waitthread global/BAS/baseassault.scr::spawn_base ( -6242.00 -1828.00 105.00 ) ( 0 90 0 ) "allies"
			waitthread global/BAS/baseassault.scr::spawn_base ( -5607.00 -175.00 150.00 ) ( 0 0 0 ) "allies"

			waitthread global/BAS/baseassault.scr::spawn_base ( -1448.00 -2291.00 86.00 ) ( 0 270 0 ) "axis"
			waitthread global/BAS/baseassault.scr::spawn_base ( -4140.00 -115.00 195.00 ) ( 0 37 0 ) "axis"
		break
		case "m5l2a":
			waitthread global/BAS/baseassault.scr::spawn_base ( 2879.00 494.00 383.00 ) ( 0 353 0 ) "allies"
			waitthread global/BAS/baseassault.scr::spawn_base ( 3933.00 3407.00 453.00 ) ( 0 47 0 ) "allies"

			waitthread global/BAS/baseassault.scr::spawn_base ( -4861.00 1030.00 477.00 ) ( 0 322 0 ) "axis"
			waitthread global/BAS/baseassault.scr::spawn_base ( -555.00 -453.00 477.00 ) ( 0 68 0 ) "axis"
		break
		case "m5l3":
			waitthread global/BAS/baseassault.scr::spawn_base ( 769.00 3523.00 375.00 ) ( 0 180 0 ) "allies" -12

			waitthread global/BAS/baseassault.scr::spawn_base ( 566.00 2249.00 474.00 ) ( 0 180 0 ) "axis"
		break
	}

	level.bas_roundstarted = 1

end

```

# zz_veersmods\global\BAS\scores.scr

```scr
main local.team local.player local.score:

	for (local.i = 1;local.i <= $player.size;local.i++)
	{
		local.pl = $player[local.i]

		if ( local.pl != NULL && local.pl.dmteam == local.team && local.pl != local.player )
			local.pl addKills local.score
	}

end

```

# zz_veersmods\global\DMprecache.scr

```scr
if (level.already_started != 1)
{
	level.already_started = 1

	cache models/player/allied_airborne.tik
	cache models/player/allied_airborne_fps.tik
	cache models/player/allied_manon.tik
	cache models/player/allied_manon_fps.tik
	cache models/player/allied_pilot.tik
	cache models/player/allied_pilot_fps.tik
	cache models/player/allied_sas.tik
	cache models/player/allied_sas_fps.tik
	cache models/player/american_army.tik
	cache models/player/american_army_fps.tik
	cache models/player/american_ranger.tik
	cache models/player/american_ranger_fps.tik
	cache models/player/german_afrika_officer.tik
	cache models/player/german_afrika_officer_fps.tik
	cache models/player/german_afrika_private.tik
	cache models/player/german_afrika_private_fps.tik
	cache models/player/german_elite_officer.tik
	cache models/player/german_elite_officer_fps.tik
	cache models/player/german_elite_sentry.tik
	cache models/player/german_elite_sentry_fps.tik
	cache models/player/german_kradshutzen.tik
	cache models/player/german_kradshutzen_fps.tik
	cache models/player/german_panzer_grenadier.tik
	cache models/player/german_panzer_grenadier_fps.tik
	cache models/player/german_panzer_obershutze.tik
	cache models/player/german_panzer_obershutze_fps.tik
	cache models/player/german_panzer_shutze.tik
	cache models/player/german_panzer_shutze_fps.tik
	cache models/player/german_panzer_tankcommander.tik
	cache models/player/german_panzer_tankcommander_fps.tik
	cache models/player/german_scientist.tik
	cache models/player/german_scientist_fps.tik
	cache models/player/german_waffenss_officer.tik
	cache models/player/german_waffenss_officer_fps.tik
	cache models/player/german_waffenss_shutze.tik
	cache models/player/german_waffenss_shutze_fps.tik
	cache models/player/german_wehrmacht_officer.tik
	cache models/player/german_wehrmacht_officer_fps.tik
	cache models/player/german_wehrmacht_soldier.tik
	cache models/player/german_wehrmacht_soldier_fps.tik
	cache models/player/german_winter_1.tik
	cache models/player/german_winter_1_fps.tik
	cache models/player/german_winter_2.tik
	cache models/player/german_winter_2_fps.tik
	cache models/player/german_worker.tik
	cache models/player/german_worker_fps.tik

	cache models/weapons/bar.tik
	cache models/weapons/bazooka.tik
	cache models/weapons/colt45.tik
	cache models/weapons/kar98.tik
	cache models/weapons/kar98sniper.tik
	cache models/weapons/m1_garand.tik
	cache models/weapons/m2frag_grenade.tik
	cache models/weapons/mp40.tik
	cache models/weapons/mp44.tik
	cache models/weapons/p38.tik
	cache models/weapons/panzerschreck.tik
	cache models/weapons/shotgun.tik
	cache models/weapons/springfield.tik
	cache models/weapons/steilhandgranate.tik
	cache models/weapons/thompsonsmg.tik
	cache models/weapons/weapon.tik

	// Event Callback Handler
	local.connected_event = registerev "connected" global/AA/callbacksetup.scr::connected
	local.disconnected_event = registerev "disconnected" global/AA/callbacksetup.scr::disconnected
	local.spawn_event = registerev "spawn" global/AA/callbacksetup.scr::spawn
	local.damage_event = registerev "damage" global/AA/callbacksetup.scr::damage
	local.kill_event = registerev "kill" global/AA/callbacksetup.scr::kill
	local.keypress_event = registerev "keypress" global/AA/callbacksetup.scr::keypress
	local.intermission_event = registerev "intermission" global/AA/callbacksetup.scr::intermission
	local.servercommand_event = registerev "servercommand" global/AA/callbacksetup.scr::servercommand

	// Base Assault gametype
	exec global/BAS/baseassault.scr

	// Plyavdelem
	exec global/AA/palyavedelem.scr

	exec global/AA/teambalance.scr
	exec global/AA/check_cvars.scr
	exec global/AA/accounts.scr
	exec global/AA/heatseeker.scr
	exec global/AA/telefrag.scr

	thread global/AA/weaponsoundfix.scr::check_sounds
	thread global/AA/vehicle_fixes.scr::vehicle_spawnkill

	exec custom/anticham.scr
	wait 1
	exec custom/anticham2.scr
}

```

# zz_veersmods\global\exploder.scr

```scr
//	Exploding chunk system created by Mackey McCandlish.
//	
//	Before level waittill prespawn "exec global/exploder.scr".
//	
//	Used in levels where stuff blows up.
//	
//	Create a script_object that is a "undestroyed" version of the thing that is supposed to blow up and targetname it "exploder"
//
//	Create a script_object that is a "destroyed" version of the thing that is supposed to blow up and targetname it
//	"explodersmashed". They occupy the same physical space.
//
//	Create script_object chunks of geometry that are going to fly out of the destroyable object/building and place them in the
//	places they're supposed to fly from. Make them near but not touching the geometry of the explodersmashed. Targetname them
//	"exploderchunk".
//	
//	Create one script_origin for each exploderchunk and make the chunk target the origin the same way a jump pad would target
//	the jump pad destination in Quake3.
//	
//	Create script_models with targetname "exploderfire" and the "model" value of the tiki you want to use. These will be tiki
//	explosions that will go off.
//
//	Give all the chunks, smasheds, fires, and exploders the same #set value. Note you can have any number of smasheds, chunks, 
//	fires, or exploders, but typically you only have one smashed and one exploder. The reason you would want multiple of any 
//	of these is that you can give any of them a #pause value, and that will make it delay that long before occuring, so you 
//	could create a multistage explosion.
//	
//	You can create an explodertrigger (with the same #set), or just do "thread global/exploder.scr::explode #" (# being the 
//	#set value of the exploder in question).
//	


main:
//end

level.exploderrepeat = 0


	if (level.debug == NIL)
		level.debug = 0

	if ($explodersmashed == NULL)
		level.explodersmasheds = 0
		else
		level.explodersmasheds = $explodersmashed.size

	if (level.explodersmasheds > 0)
	{
		level.explodersmashed = exec global/makearray.scr $explodersmashed

		for (local.i=1;local.i<level.explodersmasheds+1;local.i++)
		{
			level.explodersmashed[local.i] hide
			level.explodersmashed[local.i] notsolid

			if (level.explodersmashed[local.i].set == NIL)
				exec global/error.scr ("Error, ExploderSmashed at " + level.explodersmashed[local.i].origin + " has no #set") 1
				//else
				//println ("Spawned ExploderSmashed " + local.i)

		}
	}

	if ($exploderchunk == NULL)
		level.exploderchunks = 0
		else
		level.exploderchunks = $exploderchunk.size

	if (level.exploderchunks > 0)
	{
		level.exploderchunks = $exploderchunk.size
		level.exploderchunk = exec global/makearray.scr $exploderchunk

		for (local.i=1;local.i<level.exploderchunks+1;local.i++)
		{
			//if (level.exploderchunk[local.i].target == NIL)
				//println "Error, ExploderChunk has no Target!!!"

			level.exploderchunk[local.i] hide
			level.exploderchunk[local.i] notsolid
			level.exploderchunk[local.i].org = level.exploderchunk[local.i].origin
			level.exploderchunk[local.i].ang = level.exploderchunk[local.i].angles

			if (level.exploderchunk[local.i].set == NIL)
				exec global/error.scr ("Error, ExploderChunk at " + level.exploderchunk[local.i].origin + " has no #set") 1
				//else
				//println ("Spawned ExploderChunk " + local.i)

			if (!(level.exploderchunk[local.i].target) || (level.exploderchunk[local.i].target == NIL))
				exec global/error.scr ("Error, ExploderChunk at " + level.exploderchunk[local.i].origin + " has no target") 1



		}
	}

	
	if ($exploderfire == NULL)
		level.exploderfires = 0
		else
		level.exploderfires = $exploderfire.size

	if (level.exploderfires > 0)
	{
		level.exploderfires = $exploderfire.size
		level.exploderfire = exec global/makearray.scr $exploderfire


		for (local.i=1;local.i<level.exploderfires+1;local.i++)
		{

			if (level.exploderfire[local.i].model == NIL)
				exec global/error.scr ("Error, ExploderFire at " + level.exploderfire[local.i].origin + " has no model") 1
			//else
			//if (getcvar(debug) == "1")
				//println ("ExploderFire has model " + level.exploderfire[local.i].model)

			level.exploderfire[local.i].mdl = level.exploderfire[local.i].model
			level.exploderfire[local.i].model = "fx/dummy.tik"
			level.exploderfire[local.i] notsolid

	/*
			level.exploderfire[local.i].mdl = level.exploderfire[local.i].model
			local.ent = spawn script_model
			local.ent2 = level.exploderfire[local.i]
			local.ent.origin = local.ent2.origin
			local.ent.set = local.ent2.set
			local.ent.mdl = local.ent2.mdl
			local.ent.pause = local.ent2.pause
			level.exploderfire[local.i] = local.ent
			local.ent2 delete
	*/
//			level.exploderfire[local.i].model = "fx/dummy.tik"

			
			 // "set" level.exploderfire[local.i].set

			if (level.exploderfire[local.i].set == NIL)
				exec global/error.scr ("Error, ExploderFire at " + level.exploderfire[local.i].origin + " has no #set") 1
				//else
				//println ("Spawned ExploderFire " + local.i)

		}
	}

	if ($exploder == NULL)
		level.exploders = 0
		else
		level.exploders = $exploder.size

	if (level.exploders > 0)
	{
		level.exploders = $exploder.size
		level.exploder = exec global/makearray.scr $exploder

		for (local.i=1;local.i<level.exploders+1;local.i++)
		{
			
			if (level.exploder[local.i].walkable == NIL)
			{
				level.exploder[local.i] notsolid
				level.exploder[local.i] thread solidify
			}

			thread fireinit level.exploder[local.i].set
//			thread fireoff level.exploder[local.i].set

			if (level.exploder[local.i].set == NIL)
				exec global/error.scr ("Error, Exploder at " + level.exploder[local.i].origin + " has no #set") 1
				//else
				//println ("Spawned Exploder " + local.i)

		}
	}


	if ($explodertrigger == NULL)
		level.explodertriggers = 0
		else
		level.explodertriggers = $explodertrigger.size

	if (level.explodertriggers > 0)
	{
		level.explodertriggers = $explodertrigger.size
		level.explodertrigger = exec global/makearray.scr $explodertrigger

		for (local.i=1;local.i<level.explodertriggers+1;local.i++)
		{
			level.explodertrigger[local.i] thread explodetrigger

			if (level.explodertrigger[local.i].set == NIL)
				exec global/error.scr ("Error, ExploderTrigger at " + level.explodertrigger[local.i].origin + " has no #set") 1
				//else
				//println ("Spawned ExploderTrigger " + local.i)

		}
	}

	if (getcvar(exploders) == "0")
		thread killexploders

end

killexploders:

	wait 3

	for (local.i=1;local.i<level.explodertriggers+1;local.i++)
		level.explodertrigger[local.i] delete

	for (local.i=1;local.i<level.exploderchunks+1;local.i++)
		level.exploderchunk[local.i] delete

	for (local.i=1;local.i<level.exploders+1;local.i++)
		level.exploder[local.i] delete

	for (local.i=1;local.i<level.exploderfires+1;local.i++)
		level.exploderfire[local.i] delete
	

end


solidify:
	level waittill spawn
	self solid
	self disconnect_paths

end


repeat:
wait 2
level.exploderrepeat = 0
end


explodetrigger:
	level.explodertimer[self.set] = level.time
	self waittill trigger
	
	if (level.time > level.explodertimer[self.set])
	{
		level.explodertimer[self.set] = level.time + 6
		thread explode self.set
	}
	
	if (level.exploderrepeat == 1)
	{
		wait 5
		goto explodetrigger
	}
end

delayplaysound local.delay local.sound:
wait local.delay
self playsound (local.sound) 0 1 512
end

firelight:
	if (self.fire == NIL)
	end

	local.r = 0.5 + randomfloat (0.8)
	local.g = 0.4 + randomfloat (0.6)
	
	self lightRed (local.r)
	self lightGreen (local.g)

	wait 0.2
	goto firelight
end



fireoff local.i:
//			level.exploderfire[local.i] hide
//			level.exploderfire[local.i] anim stop
//			level.exploderfire[local.i] model "fx/dummy.tik"


			if (level.exploderfire[local.i].fire != NIL)
			{
				level.exploderfire[local.i] lightOff
				level.exploderfire[local.i] stoploopsound
				level.exploderfire[local.i].thread delete
			}
end


fireoff2 local.name:

	for (local.i=1;local.i<level.exploderfires + 1;local.i++)
	{
		if (level.exploderfire[local.i].set == local.name)
		{
			level.exploderfire[local.i] hide
			level.exploderfire[local.i] model "fx/dummy.tik"

			if (level.exploderfire[local.i].fire != NIL)
			{
				level.exploderfire[local.i] lightOff
				level.exploderfire[local.i] stoploopsound
				level.exploderfire[local.i].thread delete
			}
		}
	}

end


fireon local.i:
			if (level.exploderfire[local.i].pause != NIL)
				wait level.exploderfire[local.i].pause

			if (level.exploderfire[local.i].damageradius != NIL)
				local.damageradius = level.exploderfire[local.i].damageradius
			else
				local.damageradius = 512

			if (level.exploderfire[local.i].damage != NIL)
				radiusdamage level.exploderfire[local.i].origin level.exploderfire[local.i].damage local.damageradius

			//if (getcvar(debug) == "1")
				//println ("Model is " + level.exploderfire[local.i].mdl)

//			level.exploderfire[local.i] model level.exploderfire[local.i].mdl
//			level.exploderfire[local.i] show
//			level.exploderfire[local.i] rendereffects "+dontdraw"
//			level.exploderfire[local.i] notsolid

//			level.exploderfire[local.i] anim start

			exec global/model.scr level.exploderfire[local.i].origin level.exploderfire[local.i].mdl
			if (level.exploderfire[local.i].fire != NIL)
			{
				level.exploderfire[local.i] lightOn	

				if (randomint(100) > 50)
					level.exploderfire[local.i] loopsound "sound/environment/fire_small.wav" 1.5 256
				else
					level.exploderfire[local.i] loopsound "sound/environment/fire_big.wav" 1.5 256	

				level.exploderfire[local.i] thread firelight
				level.exploderfire[local.i].thread = parm.previousthread
			}

end

fireinit local.name:
	for (local.i=1;local.i<level.exploderfires + 1;local.i++)
	{
		if (level.exploderfire[local.i].set == local.name)
		if (level.exploderfire[local.i].fire != NIL)
		{
			level.exploderfire[local.i] light (1.0 0.8 0.0)
		}
	}

end

explodersmashedON local.i:
	if (level.explodersmashed[local.i].pause != NIL)
		wait level.explodersmashed[local.i].pause



	level.explodersmashed[local.i] playsound ("stonecrash0" + (randomint(3) + 1))
	level.explodersmashed[local.i] show
	level.explodersmashed[local.i] solid
	waitframe
	waitframe
	level.explodersmashed[local.i] disconnect_paths
end


exploderchunkONN local.i:
	if (level.exploderchunk[local.i].pause != NIL)
		wait level.exploderchunk[local.i].pause
		level.exploderchunk[local.i] show

end


exploderOFF local.i:
	if (level.exploder[local.i].pause != NIL)
	wait level.exploder[local.i].pause


	if (level.exploder[local.i].sound != NIL)
		level.exploder[local.i] playsound level.exploder[local.i].sound


//	println ("Hid exploder " + local.i)
	level.exploder[local.i] hide
	level.exploder[local.i] notsolid
	level.exploder[local.i] connect_paths

end



explode local.name:

	if (getcvar(exploders) == "0")
		end

	//if (getcvar(debug) == "1")
		//println ("** Set off explosion with set #: " + local.name)

//	println ("explode " + local.name)
		level.explodertimer[local.name] = level.time + 6


	for (local.i=1;local.i<level.explodersmasheds+1;local.i++)
	{
		if (local.name == level.explodersmashed[local.i].set)
		{
			thread explodersmashedON local.i
		}
	}

	/*
	for (local.i=1;local.i<level.exploderchunks+1;local.i++)
	{
		if (local.name == level.exploderchunk[local.i].set)
		{
			thread exploderchunkON local.i
		}
	}
	*/

	for (local.i=1;local.i<level.exploders+1;local.i++)
	{
		if (local.name == level.exploder[local.i].set)
		{
			thread exploderOFF local.i
		}
	}


	for (local.i=1;local.i<level.exploderfires + 1;local.i++)
	{
		if (level.exploderfire[local.i].set == local.name)
		{
			level.exploderfire[local.i] thread fireon local.i
		}
	}




	for (local.i=1;local.i<level.exploderchunks+1;local.i++)
	{
		if (level.exploderchunk[local.i])
		if (local.name == level.exploderchunk[local.i].set)
		{
			level.exploderchunk[local.i] thread explodechunk
		}
	}

	for (local.i=1;local.i<level.exploderfires+1;local.i++)
	{
		if (local.name == level.exploderfire[local.i].set)
			level.exploderfire[local.i] thread fireoff local.i

//			level.exploderfire[local.i] thread fireoff level.exploderfire[local.i].set
	}


	if (level.exploderrepeat != 1)
		end

	for (local.i=1;local.i<level.exploderchunks+1;local.i++)
	{
		if (local.name == level.exploderchunk[local.i].set)
		{
			level.exploderchunk[local.i] physics_off
			level.exploderchunk[local.i].velocity = (0 0 0)
			level.exploderchunk[local.i] hide
			level.exploderchunk[local.i].origin = level.exploderchunk[local.i].org
			level.exploderchunk[local.i].angles = level.exploderchunk[local.i].ang
		}
	}


	wait 6

	for (local.i=1;local.i<level.exploders+1;local.i++)
	{
		if (local.name == level.exploder[local.i].set)
		{
			level.exploder[local.i] show
			level.exploder[local.i] solid
		}
	}

	for (local.i=1;local.i<level.explodersmasheds+1;local.i++)
		if (local.name == level.explodersmashed[local.i].set)
		{
			level.explodersmashed[local.i] hide
			level.explodersmashed[local.i] notsolid
		}


	for (local.i=1;local.i<level.exploderfires+1;local.i++)
	{
		if (local.name == level.exploderfire[local.i].set)
			level.exploderfire[local.i] thread fireoff local.i

//			level.exploderfire[local.i] thread fireoff level.exploderfire[local.i].set
	}

end

phyvel local.vec:
	self physics_velocity ( local.vec )
	wait 0.2
	self physics_on 1
	self physics_velocity ( local.vec )
	

end

rocksound:

		wait (1 + randomfloat(4))
		if (self)
			self playsound ("stonesmall0" + (randomint(5) + 1))
	

end

moveitout local.num:

	local.num = local.num / 15
	local.number = 1
	while (local.number < 20)
	{
		if (self != NULL)
		{
			local.number = local.number + 0.4
			local.o = self.origin
			if (local.num > 0)
				local.o[2] = local.o[2] - local.num
			else
				local.o[2] = local.o[2] + local.num

			self.origin = local.o
		}

		waitframe
	}

end


explodetouch:
self waittill touch

// if (parm.other == $world)
	if (self != NULL)
		thread moveitout self.velocity[2]
//	self hide
end


explodechunk:
	if (self.pause != NIL)
	wait self.pause

	if (self == NULL)
		end

	self show
	self notsolid
	local.vec = (self.origin - self.target.origin)
	local.veclength = vector_length (local.vec)
	local.vec = vector_normalize (local.vec)
	local.vecscale = local.veclength * -1
	local.vec[0] = local.vec[0] * local.vecscale
	local.vec[1] = local.vec[1] * local.vecscale
	local.vec[2] = local.vec[2] * (local.vecscale * 1.5)

	thread phyvel local.vec

	self thread explodetouch
	self thread rocksound

	if (self.anglex == NIL)
	self.anglex = 0

	if (self.angley == NIL)
	self.angley = 0

	if (self.anglez == NIL)
	self.anglez = 0

	if ((self.anglex == 0) && (self.angley == 0) && (self.anglez == 0))
	{
		if (self.origin[0] > self.target.origin[0])
		local.xnum = self.origin[0] - self.target.origin[0]
		else
		local.xnum = self.target.origin[0] - self.origin[0]

		if (self.origin[1] > self.target.origin[1])
		local.ynum = self.origin[1] - self.target.origin[1]
		else
		local.ynum = self.target.origin[1] - self.origin[1]


		self.anglex = randomfloat(local.veclength / 3) * (randomint(3) - 1)
		self.angley = randomfloat(local.veclength / 3) * (randomint(3) - 1)
		self.anglez = randomfloat(local.veclength / 3) * (randomint(3) - 1)
		
		if (local.xnum > local.ynum)
		{ // was 1.5s
			if (self.origin[0] > self.target.origin[0])
				self.anglex = local.veclength * -0.5 - (randomfloat(0.5))
			else
				self.anglex = local.veclength * 0.5 + (randomfloat(0.5))
		}
		else
		{
			if (self.origin[1] > self.target.origin[1])
				self.anglez = local.veclength * 0.5  + (randomfloat(0.5))
			else
				self.anglez = local.veclength * -0.5 - (randomfloat(0.5))
		}

	}

		local.vec[0] = self.anglex
		local.vec[1] = self.angley
		local.vec[2] = self.anglez

		self rotatex local.vec[0]
		self rotatey local.vec[1]
		self rotatez local.vec[2]

	local.break = 0
	local.breaker = 1.2

//	self thread removetouch


	wait 0.5
	local.inc = 10.0 + (randomint(15))
	local.x = local.vec[0] / local.inc
	local.y = local.vec[1] / local.inc
	local.z = local.vec[2] / local.inc

//	thread moveitdown
	
	if (self == NULL)
		end

	for (local.i = 0; local.i < local.inc; local.i++)
	{
		if (local.vec[0] > 0)
		local.vec[0] = local.vec[0] - local.x
		else
		local.vec[0] = local.vec[0] - local.x

		if (local.vec[1] > 0)
		local.vec[1] = local.vec[1] - local.y
		else
		local.vec[1] = local.vec[1] - local.y

		if (local.vec[2] > 0)
		local.vec[2] = local.vec[2] - local.z
		else
		local.vec[2] = local.vec[2] - local.z

		self rotatex local.vec[0]
		self rotatey local.vec[1]
		self rotatez local.vec[2]

		waitframe
	}
	wait 10
	
	if (self != NULL)
		self delete

	
end

removetouch:
	local.lastvelocity = self.velocity
	local.lastvelocity2 = self.velocity

	local.break = 0
	local.amount = 50
	while (local.break == 0)
	{
		local.v = self.velocity
		local.count = 0
		for (local.i=0;local.i<3;local.i++)
		{
			if ((local.v[local.i] > local.amount * -1) && (local.v[local.i] < local.amount))
				local.count++
		}
		if (local.count > 2)
			local.break = 1

		//if (self.velocity == ( 0 0 0))
			//println "NO VELOCITY"

		local.lastvelocity2 = local.lastvelocity
		local.lastvelocity = self.velocity
//		println self.velocity
		waitframe
	}
	self delete

end


moveitdown:

	wait (2 + randomfloat(1.5))
	local.number = 1
	while (local.number < 20)
	{
		local.number = local.number + 0.4
		local.o = self.origin
		local.o[2] = local.o[2] - local.number
		self.origin = local.o
		waitframe
	}

end





waitplaysound local.waiter local.sound local.chan local.vol local.range:
	wait local.waiter
	self playsound local.sound local.chan local.vol local.range
	
end


/*
	models/emitters/mortar_higgins
	models/emitters/explosion_mine.tik
	models/emitters/explosion_tank.tik
	models/emitters/explosion_bombdirt.tik

*/

```

# zz_veersmods\global\modelfix.scr

```scr
// 23/11/2005 19:11 Fixed typo in disconnect will now kick players correctly.
//
// 23/11/2005 19:08 addded cvar_restart to protect other servers

//  Fix for Fps exploit
main:
	//if((waitthread check_fps self.model ) != NIL)
	local.in = waitexec global/strings.scr::InStr "fps" self.model 
	if(local.in != NIL)
	{
	   self noclip
		self physics_off
		self stufftext "say I am trying to crash the server (FPS BUG)! Report Me to an admin!"
		wait 1
		self stufftext "cvar_restart"
		wait 1
		self stufftext "disconnect"
	}
end

check_fps local.model:

local.str = ""
for(local.i = local.model.size - 7; local.i <= local.model.size-5; local.i++)
	local.str +=  local.model[local.i]

println local.str
if(local.str == "fps")
{
	end 1
}

end NIL
```

# zz_veersmods\global\shutter.scr

```scr
//	Shutters by Mackey McCandlish.
//
//	Before level waittill spawn "exec global/shutter.scr".
//	
//	Used in m1l1, m5l1a, m5l1b, m5l3.
//
//	Create script_object shutters. Shutters on the left side of a window get targetname "lshutter" and shutters on the right
//	side get targetname "rshutter".
//
//	You can alter the frequency of shutters slamming in the wind by changing level.windtime.
//
//	You can cause certain shutters to slam (like the planes flying by in m5l1a or the player's tank shooting in m5l3) by doing
//	"thread global/shutter.scr::shuttrig #" where # is the #group value you've given the shutters in question.

main:
// main local.l local.r:
level.shuttime = level.time
level.shuttertime = 0.3
level.windtime = 5 // 1.5 // 5


	if ($lshutter == NULL)
		level.lshutters = 0
		else
		level.lshutters = $lshutter.size

	if (level.lshutters > 0)
	{
		level.lshutter = exec global/makearray.scr $lshutter

		for (local.i=1;local.i<level.lshutters+1;local.i++)
		{
			level.lshutter[local.i] thread shutterthink
			level.lshutter[local.i] thread shutter local.i "l"
		}
	}


	if ($rshutter == NULL)
		level.rshutters = 0
		else
		level.rshutters = $rshutter.size

	if (level.rshutters > 0)
	{
		level.rshutter = exec global/makearray.scr $rshutter

		for (local.i=1;local.i<level.rshutters+1;local.i++)
		{
			level.rshutter[local.i] thread shutterthink
			level.rshutter[local.i] thread shutter local.i "l"
		}
	}

	if ((level.lshutters > 0) || (level.rshutters > 0))
		thread shuttermagic
end

shuttrig local.group:
	level.shuttime = level.time + 5
	for (local.i=1;local.i<level.lshutters+1;local.i++)
	{
		if (level.lshutter[local.i].group != NIL)
			if (level.lshutter[local.i].group == local.group)
				level.lshutter[local.i].specevent = 1
	}
	for (local.i=1;local.i<level.rshutters+1;local.i++)
	{
		if (level.rshutter[local.i].group != NIL)
			if (level.rshutter[local.i].group == local.group)
				level.rshutter[local.i].specevent = 1
	}

end


shuttermagic:

	level waittill spawn
	shuttermagicplay:
	if (level.time < level.shuttime)
	{
		wait 1 
		goto shuttermagicplay
	}

	local.num = (level.windtime + randomfloat(level.windtime))
//	println local.num
	if (local.num < 2)
		local.num = 2
	wait local.num
//	wait (level.windtime + randomint(level.windtime)) // level.windtime defaults to 5
	local.num = randomint(100)

	if (local.num < 40)
	{

		for (local.i=1;local.i<level.rshutters+1;local.i++)
		{
			if ( level.rshutter[local.i] && level.rshutter[local.i].specevent == 0 )
				level.rshutter[local.i].specevent = 11
		}
	
		for (local.i=1;local.i<level.lshutters+1;local.i++)
		{
			if ( level.lshutter[local.i] && level.lshutter[local.i].specevent == 0 )
				level.lshutter[local.i].specevent = 10
		}

	}
	else
	if (local.num < 60)
	{
		for (local.i=1;local.i<level.rshutters+1;local.i++)
		{
			if ( level.rshutter[local.i] && level.rshutter[local.i].specevent == 0 )
				level.rshutter[local.i].specevent = 10
		}
	
		for (local.i=1;local.i<level.lshutters+1;local.i++)
		{
			if ( level.lshutter[local.i] && level.lshutter[local.i].specevent == 0 )
				level.lshutter[local.i].specevent = 11
		}	

	}
	else
	if (local.num < 80)
	{
		for (local.i=1;local.i<level.rshutters+1;local.i++)
		{
			if ( level.rshutter[local.i] && level.rshutter[local.i].specevent == 0 )
				level.rshutter[local.i].specevent = 11
		}
	
		for (local.i=1;local.i<level.lshutters+1;local.i++)
		{
			if ( level.lshutter[local.i] && level.lshutter[local.i].specevent == 0 )
				level.lshutter[local.i].specevent = 11
		}
		
	}
	else
	{
		for (local.i=1;local.i<level.rshutters+1;local.i++)
		{
			if ( level.rshutter[local.i] && level.rshutter[local.i].specevent == 0 )
				level.rshutter[local.i].specevent = 10
		}
	
		for (local.i=1;local.i<level.lshutters+1;local.i++)
		{
			if ( level.lshutter[local.i] && level.lshutter[local.i].specevent == 0 )
				level.lshutter[local.i].specevent = 10
		}

	}


// level.shuttertime = level.time + 3
// wait 3
goto shuttermagicplay

end

shuttate local.dir local.num:
	if (local.dir == "l")
		self rotateYup local.num
	else
	if (local.dir == "r")
		self rotateYdown local.num
end


shuttersound local.num1 local.num2:
	// self playsound (NULL) 1 1 256
	self playsound shutterhit_0 5
end

shuttersqueak local.num1 local.num2:
//	if (randomint(100) > 65)
	self playsound shuttersqueak_0 5
end

shutter local.num local.dir:
	level waittill spawn
	
	self.specevent = 0
	local.curwidth = 0
	local.mover = 0

	self time 0.3
	self thread shuttate local.dir -90
	self waitmove

	while (self != NULL)
	{
		if (self.specevent == 0)
		{
			local.random = (randomint(10) - 5)

			if (local.curwidth < 2)
				local.random = (randomint(20) - 5)

			if (local.curwidth > 178)
				local.random = (randomint(20) - 15)

			if (local.mover > 6)
				local.mover = 6
			else
			if (local.mover < -6)
				local.mover = -6


			local.mover = (local.mover + local.random)

			if ((local.curwidth + local.mover ) < 0)
			{
				local.mover = (local.curwidth * -1)
				local.curwidth = 0
			}
			else
			if ((local.curwidth + local.mover) > 180)
			{
				local.mover = (180 - local.curwidth)
				local.curwidth = 180
			}
			else
				local.curwidth = (local.curwidth + local.mover)

		// self time (0.2 + (randomfloat(0.3)))
			self time level.shuttertime // default 0.3
			self thread shuttate local.dir local.mover
			self waitmove

		}
		else
		{

			if (self.specevent == 10)
			{
				self.specevent = 0

				if (local.dir == "r")
				{
					local.timedif = (180 - local.curwidth) / 200.0
					self time local.timedif
					self thread shuttersqueak 3 local.timedif
					self thread shuttate local.dir (local.curwidth * -1)
					self waitmove
					self thread shuttersound 3 local.timedif
					local.curwidth = 0
				}
				else
				{
					local.timedif = (180 - local.curwidth) / 200.0
					self time local.timedif
					self thread shuttersqueak 3 local.timedif
					self thread shuttate local.dir (180 - local.curwidth)
					self waitmove
					self thread shuttersound 1 local.timedif
					local.curwidth = 180
				}
			}
			else
			if (self.specevent == 11)
			{
				self.specevent = 0

				if (local.dir == "l")
				{
					local.timedif = (180 - local.curwidth) / 200.0
					self time local.timedif
					self thread shuttersqueak 3 local.timedif
					self thread shuttate local.dir (local.curwidth * -1)
					self waitmove
					self thread shuttersound 3 local.timedif
					local.curwidth = 0
				}
				else
				{
					local.timedif = (180 - local.curwidth) / 200.0
					self time local.timedif
					self thread shuttersqueak 3 local.timedif
					self thread shuttate local.dir (180 - local.curwidth)
					self waitmove
					self thread shuttersound 1 local.timedif
					local.curwidth = 180
				}
			}
			else
			if (local.curwidth > 0)
			{
				self time 0.5
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir (local.curwidth * -1)
				self waitmove
				self thread shuttersound 3 0.5
				local.curwidth = 0
			}


			if (self.specevent == 1)
			{
				self.specevent = 2
				local.timedif = 0.15
				self time local.timedif
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir 180
				self waitmove
				self thread shuttersound 2 local.timedif

				local.timedif = 0.20
				self time local.timedif
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir -180
				self waitmove
				self thread shuttersound 2 local.timedif

				local.timedif = 0.25
				self time local.timedif
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir 180
				self waitmove
				self thread shuttersound 2 local.timedif

				local.timedif = 0.30
				self time local.timedif
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir -180
				self waitmove
				self thread shuttersound 2 local.timedif
			}
			else
			if (self.specevent == 2)
			{
				self.specevent = 3
				local.timedif = 0.35
				self time local.timedif
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir 180
				self waitmove
				self thread shuttersound 2 local.timedif

				local.timedif = 0.65
				self time local.timedif
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir -180
				self waitmove
				self thread shuttersound 2 local.timedif
			}
			else	
			if (self.specevent == 3)
			{
				self.specevent = 0
				local.timedif = 0.85
				self time local.timedif
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir 180
				self waitmove
				self thread shuttersound 2 local.timedif
			
				local.timedif = 2.10
				self time local.timedif
				self thread shuttersqueak 3 local.timedif
				self thread shuttate local.dir -180
				self waitmove
				self thread shuttersound 2 local.timedif
			}
		}

	}
end


shutterthink:

	self waittill damage
		if (self.specevent == 0)
		if (randomint(100) > 50)
			self.specevent = 11
			else
			self.specevent = 10

	thread shutterthink
end

```

# zz_veersmods\global\spawner.scr

```scr
//**********************************************************************************
//*** converts a specified guy into a script_origin
//*** syntax --------------------------------
//*** spawner_create <guy>:
//**********************************************************************************
spawner_create local.dude:
end local.spawner


//**********************************************************************************
//*** activates a converted spawner
//*** syntax --------------------------------
//*** spawner_activate <spawner>:
//**********************************************************************************
spawner_activate local.spawner:
end

//**********************************************************************************
//**********************************************************************************


//**********************************************************************************
//*** converts a specified guy into a script_origin
//*** syntax --------------------------------
//*** spawner_create_targetname <guy>:
//**********************************************************************************
spawner_create_targetname local.dude:
end local.spawner


//**********************************************************************************
//*** activates a converted spawner
//*** syntax --------------------------------
//*** spawner_activate_targetname <spawner>:
//**********************************************************************************
spawner_activate_targetname local.spawner:
end

```

# zzz_realism_feho\Grenades\Rayon.scr

```scr
// Rayon et dgats grenades alatoires by Feho

main:

	local.rayon = randomint(400) + 400 // 400  800
	
	local.player = parm.other
	if (local.player.rankbonus["explosion"] == 1) // Excute le script seulement si le joueur a atteint le bon rang
	{
		if (local.rayon > 450) {
			local.dommage = 256
		}
		else if (local.rayon > 500) {
			local.dommage = 222
		}
		else if (local.rayon > 550) {
			local.dommage = 188
		}
		else if (local.rayon > 600) {
			local.dommage = 170
		}
		else if (local.rayon > 650) {
			local.dommage = 148
		}
		else if (local.rayon > 700) {
			local.dommage = 130
		}
		else if (local.rayon > 750) {
			local.dommage = 110
		}
		else {
			local.dommage = 270
		}	
	}
	else
	{
		if (local.rayon > 450) {
			local.dommage = 186
		}
		else if (local.rayon > 500) {
			local.dommage = 172
		}
		else if (local.rayon > 550) {
			local.dommage = 158
		}
		else if (local.rayon > 600) {
			local.dommage = 135
		}
		else if (local.rayon > 650) {
			local.dommage = 118
		}
		else if (local.rayon > 700) {
			local.dommage = 100
		}
		else if (local.rayon > 750) {
			local.dommage = 80
		}
		else {
			local.dommage = 200
		}
	}
	
	self radiusdamage local.dommage
	self radius local.rayon
	
end
```

# zzz_realism_feho\Grenades\RayonRoquette.scr

```scr
// Rayon et dgats roquettes alatoires by Feho

main:

	local.rayon = randomint(200) + 300 // 300  500
	
	if (local.rayon > 350) {
		local.dommage = 100
	}
	else if (local.rayon > 400) {
		local.dommage = 90
	}
	else if (local.rayon > 450) {
		local.dommage = 80
	}
	else {
		local.dommage = 110
	}
	
	self radiusdamage local.dommage
	self radius local.rayon
	
end
```
